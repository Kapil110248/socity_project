
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Society
 * 
 */
export type Society = $Result.DefaultSelection<Prisma.$SocietyPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RoleModel
 * 
 */
export type RoleModel = $Result.DefaultSelection<Prisma.$RoleModelPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model ParkingSlot
 * 
 */
export type ParkingSlot = $Result.DefaultSelection<Prisma.$ParkingSlotPayload>
/**
 * Model Complaint
 * 
 */
export type Complaint = $Result.DefaultSelection<Prisma.$ComplaintPayload>
/**
 * Model ComplaintComment
 * 
 */
export type ComplaintComment = $Result.DefaultSelection<Prisma.$ComplaintCommentPayload>
/**
 * Model Visitor
 * 
 */
export type Visitor = $Result.DefaultSelection<Prisma.$VisitorPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model VendorPayout
 * 
 */
export type VendorPayout = $Result.DefaultSelection<Prisma.$VendorPayoutPayload>
/**
 * Model EmergencyLog
 * 
 */
export type EmergencyLog = $Result.DefaultSelection<Prisma.$EmergencyLogPayload>
/**
 * Model EmergencyBarcode
 * 
 */
export type EmergencyBarcode = $Result.DefaultSelection<Prisma.$EmergencyBarcodePayload>
/**
 * Model EmergencyAlert
 * 
 */
export type EmergencyAlert = $Result.DefaultSelection<Prisma.$EmergencyAlertPayload>
/**
 * Model EmergencyContact
 * 
 */
export type EmergencyContact = $Result.DefaultSelection<Prisma.$EmergencyContactPayload>
/**
 * Model Notice
 * 
 */
export type Notice = $Result.DefaultSelection<Prisma.$NoticePayload>
/**
 * Model Amenity
 * 
 */
export type Amenity = $Result.DefaultSelection<Prisma.$AmenityPayload>
/**
 * Model AmenityBooking
 * 
 */
export type AmenityBooking = $Result.DefaultSelection<Prisma.$AmenityBookingPayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>
/**
 * Model BillingPlan
 * 
 */
export type BillingPlan = $Result.DefaultSelection<Prisma.$BillingPlanPayload>
/**
 * Model PlatformInvoice
 * 
 */
export type PlatformInvoice = $Result.DefaultSelection<Prisma.$PlatformInvoicePayload>
/**
 * Model CommunityBuzz
 * 
 */
export type CommunityBuzz = $Result.DefaultSelection<Prisma.$CommunityBuzzPayload>
/**
 * Model CommunityComment
 * 
 */
export type CommunityComment = $Result.DefaultSelection<Prisma.$CommunityCommentPayload>
/**
 * Model BuzzLike
 * 
 */
export type BuzzLike = $Result.DefaultSelection<Prisma.$BuzzLikePayload>
/**
 * Model UnitMember
 * 
 */
export type UnitMember = $Result.DefaultSelection<Prisma.$UnitMemberPayload>
/**
 * Model UnitVehicle
 * 
 */
export type UnitVehicle = $Result.DefaultSelection<Prisma.$UnitVehiclePayload>
/**
 * Model UnitPet
 * 
 */
export type UnitPet = $Result.DefaultSelection<Prisma.$UnitPetPayload>
/**
 * Model SOSAlert
 * 
 */
export type SOSAlert = $Result.DefaultSelection<Prisma.$SOSAlertPayload>
/**
 * Model MarketplaceItem
 * 
 */
export type MarketplaceItem = $Result.DefaultSelection<Prisma.$MarketplaceItemPayload>
/**
 * Model Meeting
 * 
 */
export type Meeting = $Result.DefaultSelection<Prisma.$MeetingPayload>
/**
 * Model CommunityGuideline
 * 
 */
export type CommunityGuideline = $Result.DefaultSelection<Prisma.$CommunityGuidelinePayload>
/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Parcel
 * 
 */
export type Parcel = $Result.DefaultSelection<Prisma.$ParcelPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model PurchaseRequest
 * 
 */
export type PurchaseRequest = $Result.DefaultSelection<Prisma.$PurchaseRequestPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model ServiceCategory
 * 
 */
export type ServiceCategory = $Result.DefaultSelection<Prisma.$ServiceCategoryPayload>
/**
 * Model ServiceVariant
 * 
 */
export type ServiceVariant = $Result.DefaultSelection<Prisma.$ServiceVariantPayload>
/**
 * Model ServiceInquiry
 * 
 */
export type ServiceInquiry = $Result.DefaultSelection<Prisma.$ServiceInquiryPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  RESIDENT: 'RESIDENT',
  GUARD: 'GUARD',
  VENDOR: 'VENDOR',
  ACCOUNTANT: 'ACCOUNTANT',
  INDIVIDUAL: 'INDIVIDUAL',
  COMMUNITY_MANAGER: 'COMMUNITY_MANAGER',
  COMMITTEE: 'COMMITTEE'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ComplaintStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type ComplaintStatus = (typeof ComplaintStatus)[keyof typeof ComplaintStatus]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const VisitorStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  CHECKED_IN: 'CHECKED_IN',
  CHECKED_OUT: 'CHECKED_OUT',
  REJECTED: 'REJECTED'
};

export type VisitorStatus = (typeof VisitorStatus)[keyof typeof VisitorStatus]


export const TransactionType: {
  INCOME: 'INCOME',
  EXPENSE: 'EXPENSE'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const PaymentMethod: {
  CASH: 'CASH',
  ONLINE: 'ONLINE',
  UPI: 'UPI',
  CHEQUE: 'CHEQUE'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const SocietyStatus: {
  ACTIVE: 'ACTIVE',
  PENDING: 'PENDING',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type SocietyStatus = (typeof SocietyStatus)[keyof typeof SocietyStatus]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  PENDING: 'PENDING'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const VendorStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  PENDING: 'PENDING'
};

export type VendorStatus = (typeof VendorStatus)[keyof typeof VendorStatus]


export const SubscriptionPlan: {
  BASIC: 'BASIC',
  PROFESSIONAL: 'PROFESSIONAL',
  ENTERPRISE: 'ENTERPRISE'
};

export type SubscriptionPlan = (typeof SubscriptionPlan)[keyof typeof SubscriptionPlan]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ComplaintStatus = $Enums.ComplaintStatus

export const ComplaintStatus: typeof $Enums.ComplaintStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type VisitorStatus = $Enums.VisitorStatus

export const VisitorStatus: typeof $Enums.VisitorStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type SocietyStatus = $Enums.SocietyStatus

export const SocietyStatus: typeof $Enums.SocietyStatus

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type VendorStatus = $Enums.VendorStatus

export const VendorStatus: typeof $Enums.VendorStatus

export type SubscriptionPlan = $Enums.SubscriptionPlan

export const SubscriptionPlan: typeof $Enums.SubscriptionPlan

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Societies
 * const societies = await prisma.society.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Societies
   * const societies = await prisma.society.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.society`: Exposes CRUD operations for the **Society** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Societies
    * const societies = await prisma.society.findMany()
    * ```
    */
  get society(): Prisma.SocietyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roleModel`: Exposes CRUD operations for the **RoleModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleModels
    * const roleModels = await prisma.roleModel.findMany()
    * ```
    */
  get roleModel(): Prisma.RoleModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parkingSlot`: Exposes CRUD operations for the **ParkingSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParkingSlots
    * const parkingSlots = await prisma.parkingSlot.findMany()
    * ```
    */
  get parkingSlot(): Prisma.ParkingSlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complaint`: Exposes CRUD operations for the **Complaint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Complaints
    * const complaints = await prisma.complaint.findMany()
    * ```
    */
  get complaint(): Prisma.ComplaintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complaintComment`: Exposes CRUD operations for the **ComplaintComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplaintComments
    * const complaintComments = await prisma.complaintComment.findMany()
    * ```
    */
  get complaintComment(): Prisma.ComplaintCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visitor`: Exposes CRUD operations for the **Visitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visitors
    * const visitors = await prisma.visitor.findMany()
    * ```
    */
  get visitor(): Prisma.VisitorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorPayout`: Exposes CRUD operations for the **VendorPayout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorPayouts
    * const vendorPayouts = await prisma.vendorPayout.findMany()
    * ```
    */
  get vendorPayout(): Prisma.VendorPayoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emergencyLog`: Exposes CRUD operations for the **EmergencyLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmergencyLogs
    * const emergencyLogs = await prisma.emergencyLog.findMany()
    * ```
    */
  get emergencyLog(): Prisma.EmergencyLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emergencyBarcode`: Exposes CRUD operations for the **EmergencyBarcode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmergencyBarcodes
    * const emergencyBarcodes = await prisma.emergencyBarcode.findMany()
    * ```
    */
  get emergencyBarcode(): Prisma.EmergencyBarcodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emergencyAlert`: Exposes CRUD operations for the **EmergencyAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmergencyAlerts
    * const emergencyAlerts = await prisma.emergencyAlert.findMany()
    * ```
    */
  get emergencyAlert(): Prisma.EmergencyAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emergencyContact`: Exposes CRUD operations for the **EmergencyContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmergencyContacts
    * const emergencyContacts = await prisma.emergencyContact.findMany()
    * ```
    */
  get emergencyContact(): Prisma.EmergencyContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notice`: Exposes CRUD operations for the **Notice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notices
    * const notices = await prisma.notice.findMany()
    * ```
    */
  get notice(): Prisma.NoticeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amenity`: Exposes CRUD operations for the **Amenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amenities
    * const amenities = await prisma.amenity.findMany()
    * ```
    */
  get amenity(): Prisma.AmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amenityBooking`: Exposes CRUD operations for the **AmenityBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AmenityBookings
    * const amenityBookings = await prisma.amenityBooking.findMany()
    * ```
    */
  get amenityBooking(): Prisma.AmenityBookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingPlan`: Exposes CRUD operations for the **BillingPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingPlans
    * const billingPlans = await prisma.billingPlan.findMany()
    * ```
    */
  get billingPlan(): Prisma.BillingPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.platformInvoice`: Exposes CRUD operations for the **PlatformInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlatformInvoices
    * const platformInvoices = await prisma.platformInvoice.findMany()
    * ```
    */
  get platformInvoice(): Prisma.PlatformInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communityBuzz`: Exposes CRUD operations for the **CommunityBuzz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityBuzzes
    * const communityBuzzes = await prisma.communityBuzz.findMany()
    * ```
    */
  get communityBuzz(): Prisma.CommunityBuzzDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communityComment`: Exposes CRUD operations for the **CommunityComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityComments
    * const communityComments = await prisma.communityComment.findMany()
    * ```
    */
  get communityComment(): Prisma.CommunityCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.buzzLike`: Exposes CRUD operations for the **BuzzLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuzzLikes
    * const buzzLikes = await prisma.buzzLike.findMany()
    * ```
    */
  get buzzLike(): Prisma.BuzzLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitMember`: Exposes CRUD operations for the **UnitMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitMembers
    * const unitMembers = await prisma.unitMember.findMany()
    * ```
    */
  get unitMember(): Prisma.UnitMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitVehicle`: Exposes CRUD operations for the **UnitVehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitVehicles
    * const unitVehicles = await prisma.unitVehicle.findMany()
    * ```
    */
  get unitVehicle(): Prisma.UnitVehicleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitPet`: Exposes CRUD operations for the **UnitPet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitPets
    * const unitPets = await prisma.unitPet.findMany()
    * ```
    */
  get unitPet(): Prisma.UnitPetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sOSAlert`: Exposes CRUD operations for the **SOSAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SOSAlerts
    * const sOSAlerts = await prisma.sOSAlert.findMany()
    * ```
    */
  get sOSAlert(): Prisma.SOSAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketplaceItem`: Exposes CRUD operations for the **MarketplaceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketplaceItems
    * const marketplaceItems = await prisma.marketplaceItem.findMany()
    * ```
    */
  get marketplaceItem(): Prisma.MarketplaceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meeting`: Exposes CRUD operations for the **Meeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meetings
    * const meetings = await prisma.meeting.findMany()
    * ```
    */
  get meeting(): Prisma.MeetingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communityGuideline`: Exposes CRUD operations for the **CommunityGuideline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityGuidelines
    * const communityGuidelines = await prisma.communityGuideline.findMany()
    * ```
    */
  get communityGuideline(): Prisma.CommunityGuidelineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parcel`: Exposes CRUD operations for the **Parcel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parcels
    * const parcels = await prisma.parcel.findMany()
    * ```
    */
  get parcel(): Prisma.ParcelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseRequest`: Exposes CRUD operations for the **PurchaseRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseRequests
    * const purchaseRequests = await prisma.purchaseRequest.findMany()
    * ```
    */
  get purchaseRequest(): Prisma.PurchaseRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceCategory`: Exposes CRUD operations for the **ServiceCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCategories
    * const serviceCategories = await prisma.serviceCategory.findMany()
    * ```
    */
  get serviceCategory(): Prisma.ServiceCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceVariant`: Exposes CRUD operations for the **ServiceVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceVariants
    * const serviceVariants = await prisma.serviceVariant.findMany()
    * ```
    */
  get serviceVariant(): Prisma.ServiceVariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceInquiry`: Exposes CRUD operations for the **ServiceInquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceInquiries
    * const serviceInquiries = await prisma.serviceInquiry.findMany()
    * ```
    */
  get serviceInquiry(): Prisma.ServiceInquiryDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Society: 'Society',
    User: 'User',
    RoleModel: 'RoleModel',
    Permission: 'Permission',
    RolePermission: 'RolePermission',
    UserSession: 'UserSession',
    Unit: 'Unit',
    ParkingSlot: 'ParkingSlot',
    Complaint: 'Complaint',
    ComplaintComment: 'ComplaintComment',
    Visitor: 'Visitor',
    Transaction: 'Transaction',
    Vendor: 'Vendor',
    VendorPayout: 'VendorPayout',
    EmergencyLog: 'EmergencyLog',
    EmergencyBarcode: 'EmergencyBarcode',
    EmergencyAlert: 'EmergencyAlert',
    EmergencyContact: 'EmergencyContact',
    Notice: 'Notice',
    Amenity: 'Amenity',
    AmenityBooking: 'AmenityBooking',
    SystemSetting: 'SystemSetting',
    BillingPlan: 'BillingPlan',
    PlatformInvoice: 'PlatformInvoice',
    CommunityBuzz: 'CommunityBuzz',
    CommunityComment: 'CommunityComment',
    BuzzLike: 'BuzzLike',
    UnitMember: 'UnitMember',
    UnitVehicle: 'UnitVehicle',
    UnitPet: 'UnitPet',
    SOSAlert: 'SOSAlert',
    MarketplaceItem: 'MarketplaceItem',
    Meeting: 'Meeting',
    CommunityGuideline: 'CommunityGuideline',
    Asset: 'Asset',
    Document: 'Document',
    Parcel: 'Parcel',
    Event: 'Event',
    PurchaseRequest: 'PurchaseRequest',
    Conversation: 'Conversation',
    ChatMessage: 'ChatMessage',
    ServiceCategory: 'ServiceCategory',
    ServiceVariant: 'ServiceVariant',
    ServiceInquiry: 'ServiceInquiry'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "society" | "user" | "roleModel" | "permission" | "rolePermission" | "userSession" | "unit" | "parkingSlot" | "complaint" | "complaintComment" | "visitor" | "transaction" | "vendor" | "vendorPayout" | "emergencyLog" | "emergencyBarcode" | "emergencyAlert" | "emergencyContact" | "notice" | "amenity" | "amenityBooking" | "systemSetting" | "billingPlan" | "platformInvoice" | "communityBuzz" | "communityComment" | "buzzLike" | "unitMember" | "unitVehicle" | "unitPet" | "sOSAlert" | "marketplaceItem" | "meeting" | "communityGuideline" | "asset" | "document" | "parcel" | "event" | "purchaseRequest" | "conversation" | "chatMessage" | "serviceCategory" | "serviceVariant" | "serviceInquiry"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Society: {
        payload: Prisma.$SocietyPayload<ExtArgs>
        fields: Prisma.SocietyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocietyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocietyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          findFirst: {
            args: Prisma.SocietyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocietyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          findMany: {
            args: Prisma.SocietyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>[]
          }
          create: {
            args: Prisma.SocietyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          createMany: {
            args: Prisma.SocietyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SocietyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          update: {
            args: Prisma.SocietyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          deleteMany: {
            args: Prisma.SocietyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocietyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SocietyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          aggregate: {
            args: Prisma.SocietyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSociety>
          }
          groupBy: {
            args: Prisma.SocietyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocietyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocietyCountArgs<ExtArgs>
            result: $Utils.Optional<SocietyCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RoleModel: {
        payload: Prisma.$RoleModelPayload<ExtArgs>
        fields: Prisma.RoleModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleModelPayload>
          }
          findFirst: {
            args: Prisma.RoleModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleModelPayload>
          }
          findMany: {
            args: Prisma.RoleModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleModelPayload>[]
          }
          create: {
            args: Prisma.RoleModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleModelPayload>
          }
          createMany: {
            args: Prisma.RoleModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoleModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleModelPayload>
          }
          update: {
            args: Prisma.RoleModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleModelPayload>
          }
          deleteMany: {
            args: Prisma.RoleModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleModelPayload>
          }
          aggregate: {
            args: Prisma.RoleModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleModel>
          }
          groupBy: {
            args: Prisma.RoleModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleModelCountArgs<ExtArgs>
            result: $Utils.Optional<RoleModelCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      ParkingSlot: {
        payload: Prisma.$ParkingSlotPayload<ExtArgs>
        fields: Prisma.ParkingSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParkingSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParkingSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          findFirst: {
            args: Prisma.ParkingSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParkingSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          findMany: {
            args: Prisma.ParkingSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>[]
          }
          create: {
            args: Prisma.ParkingSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          createMany: {
            args: Prisma.ParkingSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ParkingSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          update: {
            args: Prisma.ParkingSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          deleteMany: {
            args: Prisma.ParkingSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParkingSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParkingSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          aggregate: {
            args: Prisma.ParkingSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParkingSlot>
          }
          groupBy: {
            args: Prisma.ParkingSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParkingSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParkingSlotCountArgs<ExtArgs>
            result: $Utils.Optional<ParkingSlotCountAggregateOutputType> | number
          }
        }
      }
      Complaint: {
        payload: Prisma.$ComplaintPayload<ExtArgs>
        fields: Prisma.ComplaintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          findFirst: {
            args: Prisma.ComplaintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          findMany: {
            args: Prisma.ComplaintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>[]
          }
          create: {
            args: Prisma.ComplaintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          createMany: {
            args: Prisma.ComplaintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComplaintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          update: {
            args: Prisma.ComplaintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          deleteMany: {
            args: Prisma.ComplaintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplaintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          aggregate: {
            args: Prisma.ComplaintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaint>
          }
          groupBy: {
            args: Prisma.ComplaintGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintCountAggregateOutputType> | number
          }
        }
      }
      ComplaintComment: {
        payload: Prisma.$ComplaintCommentPayload<ExtArgs>
        fields: Prisma.ComplaintCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          findFirst: {
            args: Prisma.ComplaintCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          findMany: {
            args: Prisma.ComplaintCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>[]
          }
          create: {
            args: Prisma.ComplaintCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          createMany: {
            args: Prisma.ComplaintCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComplaintCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          update: {
            args: Prisma.ComplaintCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          deleteMany: {
            args: Prisma.ComplaintCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplaintCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          aggregate: {
            args: Prisma.ComplaintCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaintComment>
          }
          groupBy: {
            args: Prisma.ComplaintCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintCommentCountAggregateOutputType> | number
          }
        }
      }
      Visitor: {
        payload: Prisma.$VisitorPayload<ExtArgs>
        fields: Prisma.VisitorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          findFirst: {
            args: Prisma.VisitorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          findMany: {
            args: Prisma.VisitorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>[]
          }
          create: {
            args: Prisma.VisitorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          createMany: {
            args: Prisma.VisitorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VisitorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          update: {
            args: Prisma.VisitorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          deleteMany: {
            args: Prisma.VisitorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          aggregate: {
            args: Prisma.VisitorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitor>
          }
          groupBy: {
            args: Prisma.VisitorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitorCountArgs<ExtArgs>
            result: $Utils.Optional<VisitorCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      VendorPayout: {
        payload: Prisma.$VendorPayoutPayload<ExtArgs>
        fields: Prisma.VendorPayoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorPayoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorPayoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload>
          }
          findFirst: {
            args: Prisma.VendorPayoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorPayoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload>
          }
          findMany: {
            args: Prisma.VendorPayoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload>[]
          }
          create: {
            args: Prisma.VendorPayoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload>
          }
          createMany: {
            args: Prisma.VendorPayoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VendorPayoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload>
          }
          update: {
            args: Prisma.VendorPayoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload>
          }
          deleteMany: {
            args: Prisma.VendorPayoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorPayoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorPayoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload>
          }
          aggregate: {
            args: Prisma.VendorPayoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorPayout>
          }
          groupBy: {
            args: Prisma.VendorPayoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorPayoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorPayoutCountArgs<ExtArgs>
            result: $Utils.Optional<VendorPayoutCountAggregateOutputType> | number
          }
        }
      }
      EmergencyLog: {
        payload: Prisma.$EmergencyLogPayload<ExtArgs>
        fields: Prisma.EmergencyLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmergencyLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmergencyLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload>
          }
          findFirst: {
            args: Prisma.EmergencyLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmergencyLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload>
          }
          findMany: {
            args: Prisma.EmergencyLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload>[]
          }
          create: {
            args: Prisma.EmergencyLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload>
          }
          createMany: {
            args: Prisma.EmergencyLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmergencyLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload>
          }
          update: {
            args: Prisma.EmergencyLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload>
          }
          deleteMany: {
            args: Prisma.EmergencyLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmergencyLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmergencyLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload>
          }
          aggregate: {
            args: Prisma.EmergencyLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmergencyLog>
          }
          groupBy: {
            args: Prisma.EmergencyLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmergencyLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmergencyLogCountArgs<ExtArgs>
            result: $Utils.Optional<EmergencyLogCountAggregateOutputType> | number
          }
        }
      }
      EmergencyBarcode: {
        payload: Prisma.$EmergencyBarcodePayload<ExtArgs>
        fields: Prisma.EmergencyBarcodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmergencyBarcodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmergencyBarcodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload>
          }
          findFirst: {
            args: Prisma.EmergencyBarcodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmergencyBarcodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload>
          }
          findMany: {
            args: Prisma.EmergencyBarcodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload>[]
          }
          create: {
            args: Prisma.EmergencyBarcodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload>
          }
          createMany: {
            args: Prisma.EmergencyBarcodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmergencyBarcodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload>
          }
          update: {
            args: Prisma.EmergencyBarcodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload>
          }
          deleteMany: {
            args: Prisma.EmergencyBarcodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmergencyBarcodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmergencyBarcodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload>
          }
          aggregate: {
            args: Prisma.EmergencyBarcodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmergencyBarcode>
          }
          groupBy: {
            args: Prisma.EmergencyBarcodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmergencyBarcodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmergencyBarcodeCountArgs<ExtArgs>
            result: $Utils.Optional<EmergencyBarcodeCountAggregateOutputType> | number
          }
        }
      }
      EmergencyAlert: {
        payload: Prisma.$EmergencyAlertPayload<ExtArgs>
        fields: Prisma.EmergencyAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmergencyAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmergencyAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAlertPayload>
          }
          findFirst: {
            args: Prisma.EmergencyAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmergencyAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAlertPayload>
          }
          findMany: {
            args: Prisma.EmergencyAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAlertPayload>[]
          }
          create: {
            args: Prisma.EmergencyAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAlertPayload>
          }
          createMany: {
            args: Prisma.EmergencyAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmergencyAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAlertPayload>
          }
          update: {
            args: Prisma.EmergencyAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAlertPayload>
          }
          deleteMany: {
            args: Prisma.EmergencyAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmergencyAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmergencyAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyAlertPayload>
          }
          aggregate: {
            args: Prisma.EmergencyAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmergencyAlert>
          }
          groupBy: {
            args: Prisma.EmergencyAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmergencyAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmergencyAlertCountArgs<ExtArgs>
            result: $Utils.Optional<EmergencyAlertCountAggregateOutputType> | number
          }
        }
      }
      EmergencyContact: {
        payload: Prisma.$EmergencyContactPayload<ExtArgs>
        fields: Prisma.EmergencyContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmergencyContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmergencyContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          findFirst: {
            args: Prisma.EmergencyContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmergencyContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          findMany: {
            args: Prisma.EmergencyContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>[]
          }
          create: {
            args: Prisma.EmergencyContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          createMany: {
            args: Prisma.EmergencyContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmergencyContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          update: {
            args: Prisma.EmergencyContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          deleteMany: {
            args: Prisma.EmergencyContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmergencyContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmergencyContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          aggregate: {
            args: Prisma.EmergencyContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmergencyContact>
          }
          groupBy: {
            args: Prisma.EmergencyContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmergencyContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmergencyContactCountArgs<ExtArgs>
            result: $Utils.Optional<EmergencyContactCountAggregateOutputType> | number
          }
        }
      }
      Notice: {
        payload: Prisma.$NoticePayload<ExtArgs>
        fields: Prisma.NoticeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoticeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoticeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          findFirst: {
            args: Prisma.NoticeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoticeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          findMany: {
            args: Prisma.NoticeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>[]
          }
          create: {
            args: Prisma.NoticeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          createMany: {
            args: Prisma.NoticeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NoticeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          update: {
            args: Prisma.NoticeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          deleteMany: {
            args: Prisma.NoticeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoticeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoticeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          aggregate: {
            args: Prisma.NoticeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotice>
          }
          groupBy: {
            args: Prisma.NoticeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoticeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoticeCountArgs<ExtArgs>
            result: $Utils.Optional<NoticeCountAggregateOutputType> | number
          }
        }
      }
      Amenity: {
        payload: Prisma.$AmenityPayload<ExtArgs>
        fields: Prisma.AmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findFirst: {
            args: Prisma.AmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findMany: {
            args: Prisma.AmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          create: {
            args: Prisma.AmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          createMany: {
            args: Prisma.AmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          update: {
            args: Prisma.AmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          deleteMany: {
            args: Prisma.AmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          aggregate: {
            args: Prisma.AmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmenity>
          }
          groupBy: {
            args: Prisma.AmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmenityCountArgs<ExtArgs>
            result: $Utils.Optional<AmenityCountAggregateOutputType> | number
          }
        }
      }
      AmenityBooking: {
        payload: Prisma.$AmenityBookingPayload<ExtArgs>
        fields: Prisma.AmenityBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmenityBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmenityBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          findFirst: {
            args: Prisma.AmenityBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmenityBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          findMany: {
            args: Prisma.AmenityBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>[]
          }
          create: {
            args: Prisma.AmenityBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          createMany: {
            args: Prisma.AmenityBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AmenityBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          update: {
            args: Prisma.AmenityBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          deleteMany: {
            args: Prisma.AmenityBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmenityBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AmenityBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          aggregate: {
            args: Prisma.AmenityBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmenityBooking>
          }
          groupBy: {
            args: Prisma.AmenityBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmenityBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmenityBookingCountArgs<ExtArgs>
            result: $Utils.Optional<AmenityBookingCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
      BillingPlan: {
        payload: Prisma.$BillingPlanPayload<ExtArgs>
        fields: Prisma.BillingPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          findFirst: {
            args: Prisma.BillingPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          findMany: {
            args: Prisma.BillingPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>[]
          }
          create: {
            args: Prisma.BillingPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          createMany: {
            args: Prisma.BillingPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BillingPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          update: {
            args: Prisma.BillingPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          deleteMany: {
            args: Prisma.BillingPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BillingPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          aggregate: {
            args: Prisma.BillingPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingPlan>
          }
          groupBy: {
            args: Prisma.BillingPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingPlanCountArgs<ExtArgs>
            result: $Utils.Optional<BillingPlanCountAggregateOutputType> | number
          }
        }
      }
      PlatformInvoice: {
        payload: Prisma.$PlatformInvoicePayload<ExtArgs>
        fields: Prisma.PlatformInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload>
          }
          findFirst: {
            args: Prisma.PlatformInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload>
          }
          findMany: {
            args: Prisma.PlatformInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload>[]
          }
          create: {
            args: Prisma.PlatformInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload>
          }
          createMany: {
            args: Prisma.PlatformInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlatformInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload>
          }
          update: {
            args: Prisma.PlatformInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload>
          }
          deleteMany: {
            args: Prisma.PlatformInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlatformInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload>
          }
          aggregate: {
            args: Prisma.PlatformInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatformInvoice>
          }
          groupBy: {
            args: Prisma.PlatformInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformInvoiceCountAggregateOutputType> | number
          }
        }
      }
      CommunityBuzz: {
        payload: Prisma.$CommunityBuzzPayload<ExtArgs>
        fields: Prisma.CommunityBuzzFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityBuzzFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBuzzPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityBuzzFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBuzzPayload>
          }
          findFirst: {
            args: Prisma.CommunityBuzzFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBuzzPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityBuzzFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBuzzPayload>
          }
          findMany: {
            args: Prisma.CommunityBuzzFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBuzzPayload>[]
          }
          create: {
            args: Prisma.CommunityBuzzCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBuzzPayload>
          }
          createMany: {
            args: Prisma.CommunityBuzzCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommunityBuzzDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBuzzPayload>
          }
          update: {
            args: Prisma.CommunityBuzzUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBuzzPayload>
          }
          deleteMany: {
            args: Prisma.CommunityBuzzDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityBuzzUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommunityBuzzUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBuzzPayload>
          }
          aggregate: {
            args: Prisma.CommunityBuzzAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunityBuzz>
          }
          groupBy: {
            args: Prisma.CommunityBuzzGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityBuzzGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityBuzzCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityBuzzCountAggregateOutputType> | number
          }
        }
      }
      CommunityComment: {
        payload: Prisma.$CommunityCommentPayload<ExtArgs>
        fields: Prisma.CommunityCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCommentPayload>
          }
          findFirst: {
            args: Prisma.CommunityCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCommentPayload>
          }
          findMany: {
            args: Prisma.CommunityCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCommentPayload>[]
          }
          create: {
            args: Prisma.CommunityCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCommentPayload>
          }
          createMany: {
            args: Prisma.CommunityCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommunityCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCommentPayload>
          }
          update: {
            args: Prisma.CommunityCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCommentPayload>
          }
          deleteMany: {
            args: Prisma.CommunityCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommunityCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCommentPayload>
          }
          aggregate: {
            args: Prisma.CommunityCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunityComment>
          }
          groupBy: {
            args: Prisma.CommunityCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityCommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityCommentCountAggregateOutputType> | number
          }
        }
      }
      BuzzLike: {
        payload: Prisma.$BuzzLikePayload<ExtArgs>
        fields: Prisma.BuzzLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuzzLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuzzLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzLikePayload>
          }
          findFirst: {
            args: Prisma.BuzzLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuzzLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzLikePayload>
          }
          findMany: {
            args: Prisma.BuzzLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzLikePayload>[]
          }
          create: {
            args: Prisma.BuzzLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzLikePayload>
          }
          createMany: {
            args: Prisma.BuzzLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BuzzLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzLikePayload>
          }
          update: {
            args: Prisma.BuzzLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzLikePayload>
          }
          deleteMany: {
            args: Prisma.BuzzLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuzzLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuzzLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuzzLikePayload>
          }
          aggregate: {
            args: Prisma.BuzzLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuzzLike>
          }
          groupBy: {
            args: Prisma.BuzzLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuzzLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuzzLikeCountArgs<ExtArgs>
            result: $Utils.Optional<BuzzLikeCountAggregateOutputType> | number
          }
        }
      }
      UnitMember: {
        payload: Prisma.$UnitMemberPayload<ExtArgs>
        fields: Prisma.UnitMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMemberPayload>
          }
          findFirst: {
            args: Prisma.UnitMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMemberPayload>
          }
          findMany: {
            args: Prisma.UnitMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMemberPayload>[]
          }
          create: {
            args: Prisma.UnitMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMemberPayload>
          }
          createMany: {
            args: Prisma.UnitMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UnitMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMemberPayload>
          }
          update: {
            args: Prisma.UnitMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMemberPayload>
          }
          deleteMany: {
            args: Prisma.UnitMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitMemberPayload>
          }
          aggregate: {
            args: Prisma.UnitMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitMember>
          }
          groupBy: {
            args: Prisma.UnitMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitMemberCountArgs<ExtArgs>
            result: $Utils.Optional<UnitMemberCountAggregateOutputType> | number
          }
        }
      }
      UnitVehicle: {
        payload: Prisma.$UnitVehiclePayload<ExtArgs>
        fields: Prisma.UnitVehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitVehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitVehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitVehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitVehiclePayload>
          }
          findFirst: {
            args: Prisma.UnitVehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitVehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitVehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitVehiclePayload>
          }
          findMany: {
            args: Prisma.UnitVehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitVehiclePayload>[]
          }
          create: {
            args: Prisma.UnitVehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitVehiclePayload>
          }
          createMany: {
            args: Prisma.UnitVehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UnitVehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitVehiclePayload>
          }
          update: {
            args: Prisma.UnitVehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitVehiclePayload>
          }
          deleteMany: {
            args: Prisma.UnitVehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitVehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitVehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitVehiclePayload>
          }
          aggregate: {
            args: Prisma.UnitVehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitVehicle>
          }
          groupBy: {
            args: Prisma.UnitVehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitVehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitVehicleCountArgs<ExtArgs>
            result: $Utils.Optional<UnitVehicleCountAggregateOutputType> | number
          }
        }
      }
      UnitPet: {
        payload: Prisma.$UnitPetPayload<ExtArgs>
        fields: Prisma.UnitPetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitPetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitPetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPetPayload>
          }
          findFirst: {
            args: Prisma.UnitPetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitPetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPetPayload>
          }
          findMany: {
            args: Prisma.UnitPetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPetPayload>[]
          }
          create: {
            args: Prisma.UnitPetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPetPayload>
          }
          createMany: {
            args: Prisma.UnitPetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UnitPetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPetPayload>
          }
          update: {
            args: Prisma.UnitPetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPetPayload>
          }
          deleteMany: {
            args: Prisma.UnitPetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitPetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitPetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPetPayload>
          }
          aggregate: {
            args: Prisma.UnitPetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitPet>
          }
          groupBy: {
            args: Prisma.UnitPetGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitPetGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitPetCountArgs<ExtArgs>
            result: $Utils.Optional<UnitPetCountAggregateOutputType> | number
          }
        }
      }
      SOSAlert: {
        payload: Prisma.$SOSAlertPayload<ExtArgs>
        fields: Prisma.SOSAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SOSAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SOSAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSAlertPayload>
          }
          findFirst: {
            args: Prisma.SOSAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SOSAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSAlertPayload>
          }
          findMany: {
            args: Prisma.SOSAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSAlertPayload>[]
          }
          create: {
            args: Prisma.SOSAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSAlertPayload>
          }
          createMany: {
            args: Prisma.SOSAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SOSAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSAlertPayload>
          }
          update: {
            args: Prisma.SOSAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSAlertPayload>
          }
          deleteMany: {
            args: Prisma.SOSAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SOSAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SOSAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SOSAlertPayload>
          }
          aggregate: {
            args: Prisma.SOSAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSOSAlert>
          }
          groupBy: {
            args: Prisma.SOSAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<SOSAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.SOSAlertCountArgs<ExtArgs>
            result: $Utils.Optional<SOSAlertCountAggregateOutputType> | number
          }
        }
      }
      MarketplaceItem: {
        payload: Prisma.$MarketplaceItemPayload<ExtArgs>
        fields: Prisma.MarketplaceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketplaceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketplaceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          findFirst: {
            args: Prisma.MarketplaceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketplaceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          findMany: {
            args: Prisma.MarketplaceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>[]
          }
          create: {
            args: Prisma.MarketplaceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          createMany: {
            args: Prisma.MarketplaceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MarketplaceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          update: {
            args: Prisma.MarketplaceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          deleteMany: {
            args: Prisma.MarketplaceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketplaceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketplaceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          aggregate: {
            args: Prisma.MarketplaceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketplaceItem>
          }
          groupBy: {
            args: Prisma.MarketplaceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketplaceItemCountArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceItemCountAggregateOutputType> | number
          }
        }
      }
      Meeting: {
        payload: Prisma.$MeetingPayload<ExtArgs>
        fields: Prisma.MeetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findFirst: {
            args: Prisma.MeetingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findMany: {
            args: Prisma.MeetingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          create: {
            args: Prisma.MeetingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          createMany: {
            args: Prisma.MeetingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MeetingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          update: {
            args: Prisma.MeetingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          deleteMany: {
            args: Prisma.MeetingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MeetingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          aggregate: {
            args: Prisma.MeetingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeeting>
          }
          groupBy: {
            args: Prisma.MeetingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingCountAggregateOutputType> | number
          }
        }
      }
      CommunityGuideline: {
        payload: Prisma.$CommunityGuidelinePayload<ExtArgs>
        fields: Prisma.CommunityGuidelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityGuidelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGuidelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityGuidelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGuidelinePayload>
          }
          findFirst: {
            args: Prisma.CommunityGuidelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGuidelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityGuidelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGuidelinePayload>
          }
          findMany: {
            args: Prisma.CommunityGuidelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGuidelinePayload>[]
          }
          create: {
            args: Prisma.CommunityGuidelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGuidelinePayload>
          }
          createMany: {
            args: Prisma.CommunityGuidelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommunityGuidelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGuidelinePayload>
          }
          update: {
            args: Prisma.CommunityGuidelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGuidelinePayload>
          }
          deleteMany: {
            args: Prisma.CommunityGuidelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityGuidelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommunityGuidelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityGuidelinePayload>
          }
          aggregate: {
            args: Prisma.CommunityGuidelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunityGuideline>
          }
          groupBy: {
            args: Prisma.CommunityGuidelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityGuidelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityGuidelineCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityGuidelineCountAggregateOutputType> | number
          }
        }
      }
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Parcel: {
        payload: Prisma.$ParcelPayload<ExtArgs>
        fields: Prisma.ParcelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParcelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParcelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload>
          }
          findFirst: {
            args: Prisma.ParcelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParcelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload>
          }
          findMany: {
            args: Prisma.ParcelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload>[]
          }
          create: {
            args: Prisma.ParcelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload>
          }
          createMany: {
            args: Prisma.ParcelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ParcelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload>
          }
          update: {
            args: Prisma.ParcelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload>
          }
          deleteMany: {
            args: Prisma.ParcelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParcelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParcelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParcelPayload>
          }
          aggregate: {
            args: Prisma.ParcelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParcel>
          }
          groupBy: {
            args: Prisma.ParcelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParcelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParcelCountArgs<ExtArgs>
            result: $Utils.Optional<ParcelCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      PurchaseRequest: {
        payload: Prisma.$PurchaseRequestPayload<ExtArgs>
        fields: Prisma.PurchaseRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          findFirst: {
            args: Prisma.PurchaseRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          findMany: {
            args: Prisma.PurchaseRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>[]
          }
          create: {
            args: Prisma.PurchaseRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          createMany: {
            args: Prisma.PurchaseRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PurchaseRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          update: {
            args: Prisma.PurchaseRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          aggregate: {
            args: Prisma.PurchaseRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseRequest>
          }
          groupBy: {
            args: Prisma.PurchaseRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseRequestCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseRequestCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      ServiceCategory: {
        payload: Prisma.$ServiceCategoryPayload<ExtArgs>
        fields: Prisma.ServiceCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findFirst: {
            args: Prisma.ServiceCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findMany: {
            args: Prisma.ServiceCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          create: {
            args: Prisma.ServiceCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          createMany: {
            args: Prisma.ServiceCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          update: {
            args: Prisma.ServiceCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ServiceCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          aggregate: {
            args: Prisma.ServiceCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceCategory>
          }
          groupBy: {
            args: Prisma.ServiceCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryCountAggregateOutputType> | number
          }
        }
      }
      ServiceVariant: {
        payload: Prisma.$ServiceVariantPayload<ExtArgs>
        fields: Prisma.ServiceVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>
          }
          findFirst: {
            args: Prisma.ServiceVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>
          }
          findMany: {
            args: Prisma.ServiceVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>[]
          }
          create: {
            args: Prisma.ServiceVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>
          }
          createMany: {
            args: Prisma.ServiceVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>
          }
          update: {
            args: Prisma.ServiceVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>
          }
          deleteMany: {
            args: Prisma.ServiceVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>
          }
          aggregate: {
            args: Prisma.ServiceVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceVariant>
          }
          groupBy: {
            args: Prisma.ServiceVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceVariantCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceVariantCountAggregateOutputType> | number
          }
        }
      }
      ServiceInquiry: {
        payload: Prisma.$ServiceInquiryPayload<ExtArgs>
        fields: Prisma.ServiceInquiryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceInquiryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceInquiryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload>
          }
          findFirst: {
            args: Prisma.ServiceInquiryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceInquiryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload>
          }
          findMany: {
            args: Prisma.ServiceInquiryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload>[]
          }
          create: {
            args: Prisma.ServiceInquiryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload>
          }
          createMany: {
            args: Prisma.ServiceInquiryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceInquiryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload>
          }
          update: {
            args: Prisma.ServiceInquiryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload>
          }
          deleteMany: {
            args: Prisma.ServiceInquiryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceInquiryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceInquiryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload>
          }
          aggregate: {
            args: Prisma.ServiceInquiryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceInquiry>
          }
          groupBy: {
            args: Prisma.ServiceInquiryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceInquiryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceInquiryCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceInquiryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    society?: SocietyOmit
    user?: UserOmit
    roleModel?: RoleModelOmit
    permission?: PermissionOmit
    rolePermission?: RolePermissionOmit
    userSession?: UserSessionOmit
    unit?: UnitOmit
    parkingSlot?: ParkingSlotOmit
    complaint?: ComplaintOmit
    complaintComment?: ComplaintCommentOmit
    visitor?: VisitorOmit
    transaction?: TransactionOmit
    vendor?: VendorOmit
    vendorPayout?: VendorPayoutOmit
    emergencyLog?: EmergencyLogOmit
    emergencyBarcode?: EmergencyBarcodeOmit
    emergencyAlert?: EmergencyAlertOmit
    emergencyContact?: EmergencyContactOmit
    notice?: NoticeOmit
    amenity?: AmenityOmit
    amenityBooking?: AmenityBookingOmit
    systemSetting?: SystemSettingOmit
    billingPlan?: BillingPlanOmit
    platformInvoice?: PlatformInvoiceOmit
    communityBuzz?: CommunityBuzzOmit
    communityComment?: CommunityCommentOmit
    buzzLike?: BuzzLikeOmit
    unitMember?: UnitMemberOmit
    unitVehicle?: UnitVehicleOmit
    unitPet?: UnitPetOmit
    sOSAlert?: SOSAlertOmit
    marketplaceItem?: MarketplaceItemOmit
    meeting?: MeetingOmit
    communityGuideline?: CommunityGuidelineOmit
    asset?: AssetOmit
    document?: DocumentOmit
    parcel?: ParcelOmit
    event?: EventOmit
    purchaseRequest?: PurchaseRequestOmit
    conversation?: ConversationOmit
    chatMessage?: ChatMessageOmit
    serviceCategory?: ServiceCategoryOmit
    serviceVariant?: ServiceVariantOmit
    serviceInquiry?: ServiceInquiryOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SocietyCountOutputType
   */

  export type SocietyCountOutputType = {
    users: number
    units: number
    complaints: number
    visitors: number
    transactions: number
    notices: number
    vendors: number
    amenities: number
    parkingSlots: number
    platformInvoices: number
    meetings: number
    assets: number
    documents: number
    parcels: number
    events: number
    purchaseRequests: number
    emergencyAlerts: number
    emergencyContacts: number
    serviceInquiries: number
    conversations: number
    buzzs: number
    marketplaceItems: number
    guidelines: number
    sosAlerts: number
  }

  export type SocietyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SocietyCountOutputTypeCountUsersArgs
    units?: boolean | SocietyCountOutputTypeCountUnitsArgs
    complaints?: boolean | SocietyCountOutputTypeCountComplaintsArgs
    visitors?: boolean | SocietyCountOutputTypeCountVisitorsArgs
    transactions?: boolean | SocietyCountOutputTypeCountTransactionsArgs
    notices?: boolean | SocietyCountOutputTypeCountNoticesArgs
    vendors?: boolean | SocietyCountOutputTypeCountVendorsArgs
    amenities?: boolean | SocietyCountOutputTypeCountAmenitiesArgs
    parkingSlots?: boolean | SocietyCountOutputTypeCountParkingSlotsArgs
    platformInvoices?: boolean | SocietyCountOutputTypeCountPlatformInvoicesArgs
    meetings?: boolean | SocietyCountOutputTypeCountMeetingsArgs
    assets?: boolean | SocietyCountOutputTypeCountAssetsArgs
    documents?: boolean | SocietyCountOutputTypeCountDocumentsArgs
    parcels?: boolean | SocietyCountOutputTypeCountParcelsArgs
    events?: boolean | SocietyCountOutputTypeCountEventsArgs
    purchaseRequests?: boolean | SocietyCountOutputTypeCountPurchaseRequestsArgs
    emergencyAlerts?: boolean | SocietyCountOutputTypeCountEmergencyAlertsArgs
    emergencyContacts?: boolean | SocietyCountOutputTypeCountEmergencyContactsArgs
    serviceInquiries?: boolean | SocietyCountOutputTypeCountServiceInquiriesArgs
    conversations?: boolean | SocietyCountOutputTypeCountConversationsArgs
    buzzs?: boolean | SocietyCountOutputTypeCountBuzzsArgs
    marketplaceItems?: boolean | SocietyCountOutputTypeCountMarketplaceItemsArgs
    guidelines?: boolean | SocietyCountOutputTypeCountGuidelinesArgs
    sosAlerts?: boolean | SocietyCountOutputTypeCountSosAlertsArgs
  }

  // Custom InputTypes
  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocietyCountOutputType
     */
    select?: SocietyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountNoticesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoticeWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountAmenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountParkingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingSlotWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountPlatformInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformInvoiceWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountParcelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParcelWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountPurchaseRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseRequestWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountEmergencyAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyAlertWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountEmergencyContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyContactWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountServiceInquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceInquiryWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountBuzzsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityBuzzWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountMarketplaceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceItemWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountGuidelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityGuidelineWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountSosAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SOSAlertWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    ownedUnits: number
    rentedUnits: number
    reportedComplaints: number
    assignedComplaints: number
    bookings: number
    comments: number
    purchaseRequests: number
    emergencyAlerts: number
    serviceInquiries: number
    conversations: number
    sentMessages: number
    buzzs: number
    communityComments: number
    sosAlerts: number
    emergencyContacts: number
    marketplaceItems: number
    buzzLikes: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    ownedUnits?: boolean | UserCountOutputTypeCountOwnedUnitsArgs
    rentedUnits?: boolean | UserCountOutputTypeCountRentedUnitsArgs
    reportedComplaints?: boolean | UserCountOutputTypeCountReportedComplaintsArgs
    assignedComplaints?: boolean | UserCountOutputTypeCountAssignedComplaintsArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    purchaseRequests?: boolean | UserCountOutputTypeCountPurchaseRequestsArgs
    emergencyAlerts?: boolean | UserCountOutputTypeCountEmergencyAlertsArgs
    serviceInquiries?: boolean | UserCountOutputTypeCountServiceInquiriesArgs
    conversations?: boolean | UserCountOutputTypeCountConversationsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    buzzs?: boolean | UserCountOutputTypeCountBuzzsArgs
    communityComments?: boolean | UserCountOutputTypeCountCommunityCommentsArgs
    sosAlerts?: boolean | UserCountOutputTypeCountSosAlertsArgs
    emergencyContacts?: boolean | UserCountOutputTypeCountEmergencyContactsArgs
    marketplaceItems?: boolean | UserCountOutputTypeCountMarketplaceItemsArgs
    buzzLikes?: boolean | UserCountOutputTypeCountBuzzLikesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRentedUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportedComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityBookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchaseRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmergencyAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyAlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServiceInquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceInquiryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBuzzsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityBuzzWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommunityCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSosAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SOSAlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmergencyContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMarketplaceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBuzzLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuzzLikeWhereInput
  }


  /**
   * Count Type RoleModelCountOutputType
   */

  export type RoleModelCountOutputType = {
    permissions: number
    users: number
  }

  export type RoleModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | RoleModelCountOutputTypeCountPermissionsArgs
    users?: boolean | RoleModelCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleModelCountOutputType without action
   */
  export type RoleModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleModelCountOutputType
     */
    select?: RoleModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleModelCountOutputType without action
   */
  export type RoleModelCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }

  /**
   * RoleModelCountOutputType without action
   */
  export type RoleModelCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    visitors: number
    parkingSlots: number
    parcels: number
    members: number
    vehicles: number
    petsList: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visitors?: boolean | UnitCountOutputTypeCountVisitorsArgs
    parkingSlots?: boolean | UnitCountOutputTypeCountParkingSlotsArgs
    parcels?: boolean | UnitCountOutputTypeCountParcelsArgs
    members?: boolean | UnitCountOutputTypeCountMembersArgs
    vehicles?: boolean | UnitCountOutputTypeCountVehiclesArgs
    petsList?: boolean | UnitCountOutputTypeCountPetsListArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountParkingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingSlotWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountParcelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParcelWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitMemberWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitVehicleWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountPetsListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitPetWhereInput
  }


  /**
   * Count Type ComplaintCountOutputType
   */

  export type ComplaintCountOutputType = {
    comments: number
  }

  export type ComplaintCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | ComplaintCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ComplaintCountOutputType without action
   */
  export type ComplaintCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintCountOutputType
     */
    select?: ComplaintCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComplaintCountOutputType without action
   */
  export type ComplaintCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintCommentWhereInput
  }


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    payouts: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payouts?: boolean | VendorCountOutputTypeCountPayoutsArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountPayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorPayoutWhereInput
  }


  /**
   * Count Type AmenityCountOutputType
   */

  export type AmenityCountOutputType = {
    bookings: number
  }

  export type AmenityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | AmenityCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityCountOutputType
     */
    select?: AmenityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityBookingWhereInput
  }


  /**
   * Count Type CommunityBuzzCountOutputType
   */

  export type CommunityBuzzCountOutputType = {
    comments: number
    likedBy: number
  }

  export type CommunityBuzzCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | CommunityBuzzCountOutputTypeCountCommentsArgs
    likedBy?: boolean | CommunityBuzzCountOutputTypeCountLikedByArgs
  }

  // Custom InputTypes
  /**
   * CommunityBuzzCountOutputType without action
   */
  export type CommunityBuzzCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBuzzCountOutputType
     */
    select?: CommunityBuzzCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommunityBuzzCountOutputType without action
   */
  export type CommunityBuzzCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityCommentWhereInput
  }

  /**
   * CommunityBuzzCountOutputType without action
   */
  export type CommunityBuzzCountOutputTypeCountLikedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuzzLikeWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type ServiceCategoryCountOutputType
   */

  export type ServiceCategoryCountOutputType = {
    variants: number
    inquiries: number
  }

  export type ServiceCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | ServiceCategoryCountOutputTypeCountVariantsArgs
    inquiries?: boolean | ServiceCategoryCountOutputTypeCountInquiriesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryCountOutputType
     */
    select?: ServiceCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceVariantWhereInput
  }

  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeCountInquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceInquiryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Society
   */

  export type AggregateSociety = {
    _count: SocietyCountAggregateOutputType | null
    _avg: SocietyAvgAggregateOutputType | null
    _sum: SocietySumAggregateOutputType | null
    _min: SocietyMinAggregateOutputType | null
    _max: SocietyMaxAggregateOutputType | null
  }

  export type SocietyAvgAggregateOutputType = {
    id: number | null
    expectedUnits: number | null
  }

  export type SocietySumAggregateOutputType = {
    id: number | null
    expectedUnits: number | null
  }

  export type SocietyMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    pincode: string | null
    code: string | null
    status: $Enums.SocietyStatus | null
    subscriptionPlan: $Enums.SubscriptionPlan | null
    expectedUnits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocietyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    pincode: string | null
    code: string | null
    status: $Enums.SocietyStatus | null
    subscriptionPlan: $Enums.SubscriptionPlan | null
    expectedUnits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocietyCountAggregateOutputType = {
    id: number
    name: number
    address: number
    city: number
    state: number
    pincode: number
    code: number
    status: number
    subscriptionPlan: number
    expectedUnits: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocietyAvgAggregateInputType = {
    id?: true
    expectedUnits?: true
  }

  export type SocietySumAggregateInputType = {
    id?: true
    expectedUnits?: true
  }

  export type SocietyMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    pincode?: true
    code?: true
    status?: true
    subscriptionPlan?: true
    expectedUnits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocietyMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    pincode?: true
    code?: true
    status?: true
    subscriptionPlan?: true
    expectedUnits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocietyCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    pincode?: true
    code?: true
    status?: true
    subscriptionPlan?: true
    expectedUnits?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocietyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Society to aggregate.
     */
    where?: SocietyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Societies to fetch.
     */
    orderBy?: SocietyOrderByWithRelationInput | SocietyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocietyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Societies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Societies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Societies
    **/
    _count?: true | SocietyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SocietyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SocietySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocietyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocietyMaxAggregateInputType
  }

  export type GetSocietyAggregateType<T extends SocietyAggregateArgs> = {
        [P in keyof T & keyof AggregateSociety]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSociety[P]>
      : GetScalarType<T[P], AggregateSociety[P]>
  }




  export type SocietyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocietyWhereInput
    orderBy?: SocietyOrderByWithAggregationInput | SocietyOrderByWithAggregationInput[]
    by: SocietyScalarFieldEnum[] | SocietyScalarFieldEnum
    having?: SocietyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocietyCountAggregateInputType | true
    _avg?: SocietyAvgAggregateInputType
    _sum?: SocietySumAggregateInputType
    _min?: SocietyMinAggregateInputType
    _max?: SocietyMaxAggregateInputType
  }

  export type SocietyGroupByOutputType = {
    id: number
    name: string
    address: string | null
    city: string | null
    state: string | null
    pincode: string | null
    code: string
    status: $Enums.SocietyStatus
    subscriptionPlan: $Enums.SubscriptionPlan
    expectedUnits: number
    createdAt: Date
    updatedAt: Date
    _count: SocietyCountAggregateOutputType | null
    _avg: SocietyAvgAggregateOutputType | null
    _sum: SocietySumAggregateOutputType | null
    _min: SocietyMinAggregateOutputType | null
    _max: SocietyMaxAggregateOutputType | null
  }

  type GetSocietyGroupByPayload<T extends SocietyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocietyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocietyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocietyGroupByOutputType[P]>
            : GetScalarType<T[P], SocietyGroupByOutputType[P]>
        }
      >
    >


  export type SocietySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    code?: boolean
    status?: boolean
    subscriptionPlan?: boolean
    expectedUnits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Society$usersArgs<ExtArgs>
    units?: boolean | Society$unitsArgs<ExtArgs>
    complaints?: boolean | Society$complaintsArgs<ExtArgs>
    visitors?: boolean | Society$visitorsArgs<ExtArgs>
    transactions?: boolean | Society$transactionsArgs<ExtArgs>
    notices?: boolean | Society$noticesArgs<ExtArgs>
    vendors?: boolean | Society$vendorsArgs<ExtArgs>
    amenities?: boolean | Society$amenitiesArgs<ExtArgs>
    parkingSlots?: boolean | Society$parkingSlotsArgs<ExtArgs>
    platformInvoices?: boolean | Society$platformInvoicesArgs<ExtArgs>
    meetings?: boolean | Society$meetingsArgs<ExtArgs>
    assets?: boolean | Society$assetsArgs<ExtArgs>
    documents?: boolean | Society$documentsArgs<ExtArgs>
    parcels?: boolean | Society$parcelsArgs<ExtArgs>
    events?: boolean | Society$eventsArgs<ExtArgs>
    purchaseRequests?: boolean | Society$purchaseRequestsArgs<ExtArgs>
    emergencyAlerts?: boolean | Society$emergencyAlertsArgs<ExtArgs>
    emergencyContacts?: boolean | Society$emergencyContactsArgs<ExtArgs>
    serviceInquiries?: boolean | Society$serviceInquiriesArgs<ExtArgs>
    conversations?: boolean | Society$conversationsArgs<ExtArgs>
    buzzs?: boolean | Society$buzzsArgs<ExtArgs>
    marketplaceItems?: boolean | Society$marketplaceItemsArgs<ExtArgs>
    guidelines?: boolean | Society$guidelinesArgs<ExtArgs>
    sosAlerts?: boolean | Society$sosAlertsArgs<ExtArgs>
    _count?: boolean | SocietyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["society"]>



  export type SocietySelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    code?: boolean
    status?: boolean
    subscriptionPlan?: boolean
    expectedUnits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocietyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "city" | "state" | "pincode" | "code" | "status" | "subscriptionPlan" | "expectedUnits" | "createdAt" | "updatedAt", ExtArgs["result"]["society"]>
  export type SocietyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Society$usersArgs<ExtArgs>
    units?: boolean | Society$unitsArgs<ExtArgs>
    complaints?: boolean | Society$complaintsArgs<ExtArgs>
    visitors?: boolean | Society$visitorsArgs<ExtArgs>
    transactions?: boolean | Society$transactionsArgs<ExtArgs>
    notices?: boolean | Society$noticesArgs<ExtArgs>
    vendors?: boolean | Society$vendorsArgs<ExtArgs>
    amenities?: boolean | Society$amenitiesArgs<ExtArgs>
    parkingSlots?: boolean | Society$parkingSlotsArgs<ExtArgs>
    platformInvoices?: boolean | Society$platformInvoicesArgs<ExtArgs>
    meetings?: boolean | Society$meetingsArgs<ExtArgs>
    assets?: boolean | Society$assetsArgs<ExtArgs>
    documents?: boolean | Society$documentsArgs<ExtArgs>
    parcels?: boolean | Society$parcelsArgs<ExtArgs>
    events?: boolean | Society$eventsArgs<ExtArgs>
    purchaseRequests?: boolean | Society$purchaseRequestsArgs<ExtArgs>
    emergencyAlerts?: boolean | Society$emergencyAlertsArgs<ExtArgs>
    emergencyContacts?: boolean | Society$emergencyContactsArgs<ExtArgs>
    serviceInquiries?: boolean | Society$serviceInquiriesArgs<ExtArgs>
    conversations?: boolean | Society$conversationsArgs<ExtArgs>
    buzzs?: boolean | Society$buzzsArgs<ExtArgs>
    marketplaceItems?: boolean | Society$marketplaceItemsArgs<ExtArgs>
    guidelines?: boolean | Society$guidelinesArgs<ExtArgs>
    sosAlerts?: boolean | Society$sosAlertsArgs<ExtArgs>
    _count?: boolean | SocietyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SocietyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Society"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      units: Prisma.$UnitPayload<ExtArgs>[]
      complaints: Prisma.$ComplaintPayload<ExtArgs>[]
      visitors: Prisma.$VisitorPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      notices: Prisma.$NoticePayload<ExtArgs>[]
      vendors: Prisma.$VendorPayload<ExtArgs>[]
      amenities: Prisma.$AmenityPayload<ExtArgs>[]
      parkingSlots: Prisma.$ParkingSlotPayload<ExtArgs>[]
      platformInvoices: Prisma.$PlatformInvoicePayload<ExtArgs>[]
      meetings: Prisma.$MeetingPayload<ExtArgs>[]
      assets: Prisma.$AssetPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      parcels: Prisma.$ParcelPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      purchaseRequests: Prisma.$PurchaseRequestPayload<ExtArgs>[]
      emergencyAlerts: Prisma.$EmergencyAlertPayload<ExtArgs>[]
      emergencyContacts: Prisma.$EmergencyContactPayload<ExtArgs>[]
      serviceInquiries: Prisma.$ServiceInquiryPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      buzzs: Prisma.$CommunityBuzzPayload<ExtArgs>[]
      marketplaceItems: Prisma.$MarketplaceItemPayload<ExtArgs>[]
      guidelines: Prisma.$CommunityGuidelinePayload<ExtArgs>[]
      sosAlerts: Prisma.$SOSAlertPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string | null
      city: string | null
      state: string | null
      pincode: string | null
      code: string
      status: $Enums.SocietyStatus
      subscriptionPlan: $Enums.SubscriptionPlan
      expectedUnits: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["society"]>
    composites: {}
  }

  type SocietyGetPayload<S extends boolean | null | undefined | SocietyDefaultArgs> = $Result.GetResult<Prisma.$SocietyPayload, S>

  type SocietyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocietyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocietyCountAggregateInputType | true
    }

  export interface SocietyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Society'], meta: { name: 'Society' } }
    /**
     * Find zero or one Society that matches the filter.
     * @param {SocietyFindUniqueArgs} args - Arguments to find a Society
     * @example
     * // Get one Society
     * const society = await prisma.society.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocietyFindUniqueArgs>(args: SelectSubset<T, SocietyFindUniqueArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Society that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocietyFindUniqueOrThrowArgs} args - Arguments to find a Society
     * @example
     * // Get one Society
     * const society = await prisma.society.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocietyFindUniqueOrThrowArgs>(args: SelectSubset<T, SocietyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Society that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyFindFirstArgs} args - Arguments to find a Society
     * @example
     * // Get one Society
     * const society = await prisma.society.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocietyFindFirstArgs>(args?: SelectSubset<T, SocietyFindFirstArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Society that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyFindFirstOrThrowArgs} args - Arguments to find a Society
     * @example
     * // Get one Society
     * const society = await prisma.society.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocietyFindFirstOrThrowArgs>(args?: SelectSubset<T, SocietyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Societies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Societies
     * const societies = await prisma.society.findMany()
     * 
     * // Get first 10 Societies
     * const societies = await prisma.society.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const societyWithIdOnly = await prisma.society.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocietyFindManyArgs>(args?: SelectSubset<T, SocietyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Society.
     * @param {SocietyCreateArgs} args - Arguments to create a Society.
     * @example
     * // Create one Society
     * const Society = await prisma.society.create({
     *   data: {
     *     // ... data to create a Society
     *   }
     * })
     * 
     */
    create<T extends SocietyCreateArgs>(args: SelectSubset<T, SocietyCreateArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Societies.
     * @param {SocietyCreateManyArgs} args - Arguments to create many Societies.
     * @example
     * // Create many Societies
     * const society = await prisma.society.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocietyCreateManyArgs>(args?: SelectSubset<T, SocietyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Society.
     * @param {SocietyDeleteArgs} args - Arguments to delete one Society.
     * @example
     * // Delete one Society
     * const Society = await prisma.society.delete({
     *   where: {
     *     // ... filter to delete one Society
     *   }
     * })
     * 
     */
    delete<T extends SocietyDeleteArgs>(args: SelectSubset<T, SocietyDeleteArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Society.
     * @param {SocietyUpdateArgs} args - Arguments to update one Society.
     * @example
     * // Update one Society
     * const society = await prisma.society.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocietyUpdateArgs>(args: SelectSubset<T, SocietyUpdateArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Societies.
     * @param {SocietyDeleteManyArgs} args - Arguments to filter Societies to delete.
     * @example
     * // Delete a few Societies
     * const { count } = await prisma.society.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocietyDeleteManyArgs>(args?: SelectSubset<T, SocietyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Societies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Societies
     * const society = await prisma.society.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocietyUpdateManyArgs>(args: SelectSubset<T, SocietyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Society.
     * @param {SocietyUpsertArgs} args - Arguments to update or create a Society.
     * @example
     * // Update or create a Society
     * const society = await prisma.society.upsert({
     *   create: {
     *     // ... data to create a Society
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Society we want to update
     *   }
     * })
     */
    upsert<T extends SocietyUpsertArgs>(args: SelectSubset<T, SocietyUpsertArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Societies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyCountArgs} args - Arguments to filter Societies to count.
     * @example
     * // Count the number of Societies
     * const count = await prisma.society.count({
     *   where: {
     *     // ... the filter for the Societies we want to count
     *   }
     * })
    **/
    count<T extends SocietyCountArgs>(
      args?: Subset<T, SocietyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocietyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Society.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocietyAggregateArgs>(args: Subset<T, SocietyAggregateArgs>): Prisma.PrismaPromise<GetSocietyAggregateType<T>>

    /**
     * Group by Society.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocietyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocietyGroupByArgs['orderBy'] }
        : { orderBy?: SocietyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocietyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocietyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Society model
   */
  readonly fields: SocietyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Society.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocietyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Society$usersArgs<ExtArgs> = {}>(args?: Subset<T, Society$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    units<T extends Society$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Society$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    complaints<T extends Society$complaintsArgs<ExtArgs> = {}>(args?: Subset<T, Society$complaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visitors<T extends Society$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, Society$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Society$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Society$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notices<T extends Society$noticesArgs<ExtArgs> = {}>(args?: Subset<T, Society$noticesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendors<T extends Society$vendorsArgs<ExtArgs> = {}>(args?: Subset<T, Society$vendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    amenities<T extends Society$amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Society$amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parkingSlots<T extends Society$parkingSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Society$parkingSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    platformInvoices<T extends Society$platformInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Society$platformInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    meetings<T extends Society$meetingsArgs<ExtArgs> = {}>(args?: Subset<T, Society$meetingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assets<T extends Society$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Society$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Society$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Society$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parcels<T extends Society$parcelsArgs<ExtArgs> = {}>(args?: Subset<T, Society$parcelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends Society$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Society$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseRequests<T extends Society$purchaseRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Society$purchaseRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emergencyAlerts<T extends Society$emergencyAlertsArgs<ExtArgs> = {}>(args?: Subset<T, Society$emergencyAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emergencyContacts<T extends Society$emergencyContactsArgs<ExtArgs> = {}>(args?: Subset<T, Society$emergencyContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceInquiries<T extends Society$serviceInquiriesArgs<ExtArgs> = {}>(args?: Subset<T, Society$serviceInquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends Society$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Society$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buzzs<T extends Society$buzzsArgs<ExtArgs> = {}>(args?: Subset<T, Society$buzzsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityBuzzPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    marketplaceItems<T extends Society$marketplaceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Society$marketplaceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    guidelines<T extends Society$guidelinesArgs<ExtArgs> = {}>(args?: Subset<T, Society$guidelinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityGuidelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sosAlerts<T extends Society$sosAlertsArgs<ExtArgs> = {}>(args?: Subset<T, Society$sosAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SOSAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Society model
   */
  interface SocietyFieldRefs {
    readonly id: FieldRef<"Society", 'Int'>
    readonly name: FieldRef<"Society", 'String'>
    readonly address: FieldRef<"Society", 'String'>
    readonly city: FieldRef<"Society", 'String'>
    readonly state: FieldRef<"Society", 'String'>
    readonly pincode: FieldRef<"Society", 'String'>
    readonly code: FieldRef<"Society", 'String'>
    readonly status: FieldRef<"Society", 'SocietyStatus'>
    readonly subscriptionPlan: FieldRef<"Society", 'SubscriptionPlan'>
    readonly expectedUnits: FieldRef<"Society", 'Int'>
    readonly createdAt: FieldRef<"Society", 'DateTime'>
    readonly updatedAt: FieldRef<"Society", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Society findUnique
   */
  export type SocietyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter, which Society to fetch.
     */
    where: SocietyWhereUniqueInput
  }

  /**
   * Society findUniqueOrThrow
   */
  export type SocietyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter, which Society to fetch.
     */
    where: SocietyWhereUniqueInput
  }

  /**
   * Society findFirst
   */
  export type SocietyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter, which Society to fetch.
     */
    where?: SocietyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Societies to fetch.
     */
    orderBy?: SocietyOrderByWithRelationInput | SocietyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Societies.
     */
    cursor?: SocietyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Societies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Societies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Societies.
     */
    distinct?: SocietyScalarFieldEnum | SocietyScalarFieldEnum[]
  }

  /**
   * Society findFirstOrThrow
   */
  export type SocietyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter, which Society to fetch.
     */
    where?: SocietyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Societies to fetch.
     */
    orderBy?: SocietyOrderByWithRelationInput | SocietyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Societies.
     */
    cursor?: SocietyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Societies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Societies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Societies.
     */
    distinct?: SocietyScalarFieldEnum | SocietyScalarFieldEnum[]
  }

  /**
   * Society findMany
   */
  export type SocietyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter, which Societies to fetch.
     */
    where?: SocietyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Societies to fetch.
     */
    orderBy?: SocietyOrderByWithRelationInput | SocietyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Societies.
     */
    cursor?: SocietyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Societies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Societies.
     */
    skip?: number
    distinct?: SocietyScalarFieldEnum | SocietyScalarFieldEnum[]
  }

  /**
   * Society create
   */
  export type SocietyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * The data needed to create a Society.
     */
    data: XOR<SocietyCreateInput, SocietyUncheckedCreateInput>
  }

  /**
   * Society createMany
   */
  export type SocietyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Societies.
     */
    data: SocietyCreateManyInput | SocietyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Society update
   */
  export type SocietyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * The data needed to update a Society.
     */
    data: XOR<SocietyUpdateInput, SocietyUncheckedUpdateInput>
    /**
     * Choose, which Society to update.
     */
    where: SocietyWhereUniqueInput
  }

  /**
   * Society updateMany
   */
  export type SocietyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Societies.
     */
    data: XOR<SocietyUpdateManyMutationInput, SocietyUncheckedUpdateManyInput>
    /**
     * Filter which Societies to update
     */
    where?: SocietyWhereInput
    /**
     * Limit how many Societies to update.
     */
    limit?: number
  }

  /**
   * Society upsert
   */
  export type SocietyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * The filter to search for the Society to update in case it exists.
     */
    where: SocietyWhereUniqueInput
    /**
     * In case the Society found by the `where` argument doesn't exist, create a new Society with this data.
     */
    create: XOR<SocietyCreateInput, SocietyUncheckedCreateInput>
    /**
     * In case the Society was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocietyUpdateInput, SocietyUncheckedUpdateInput>
  }

  /**
   * Society delete
   */
  export type SocietyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter which Society to delete.
     */
    where: SocietyWhereUniqueInput
  }

  /**
   * Society deleteMany
   */
  export type SocietyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Societies to delete
     */
    where?: SocietyWhereInput
    /**
     * Limit how many Societies to delete.
     */
    limit?: number
  }

  /**
   * Society.users
   */
  export type Society$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Society.units
   */
  export type Society$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Society.complaints
   */
  export type Society$complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    cursor?: ComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Society.visitors
   */
  export type Society$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    cursor?: VisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Society.transactions
   */
  export type Society$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Society.notices
   */
  export type Society$noticesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    where?: NoticeWhereInput
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    cursor?: NoticeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Society.vendors
   */
  export type Society$vendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    cursor?: VendorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Society.amenities
   */
  export type Society$amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    where?: AmenityWhereInput
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    cursor?: AmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Society.parkingSlots
   */
  export type Society$parkingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    where?: ParkingSlotWhereInput
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    cursor?: ParkingSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * Society.platformInvoices
   */
  export type Society$platformInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    where?: PlatformInvoiceWhereInput
    orderBy?: PlatformInvoiceOrderByWithRelationInput | PlatformInvoiceOrderByWithRelationInput[]
    cursor?: PlatformInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlatformInvoiceScalarFieldEnum | PlatformInvoiceScalarFieldEnum[]
  }

  /**
   * Society.meetings
   */
  export type Society$meetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    cursor?: MeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Society.assets
   */
  export type Society$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Society.documents
   */
  export type Society$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Society.parcels
   */
  export type Society$parcelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    where?: ParcelWhereInput
    orderBy?: ParcelOrderByWithRelationInput | ParcelOrderByWithRelationInput[]
    cursor?: ParcelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParcelScalarFieldEnum | ParcelScalarFieldEnum[]
  }

  /**
   * Society.events
   */
  export type Society$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Society.purchaseRequests
   */
  export type Society$purchaseRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    where?: PurchaseRequestWhereInput
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    cursor?: PurchaseRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseRequestScalarFieldEnum | PurchaseRequestScalarFieldEnum[]
  }

  /**
   * Society.emergencyAlerts
   */
  export type Society$emergencyAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAlert
     */
    select?: EmergencyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyAlert
     */
    omit?: EmergencyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAlertInclude<ExtArgs> | null
    where?: EmergencyAlertWhereInput
    orderBy?: EmergencyAlertOrderByWithRelationInput | EmergencyAlertOrderByWithRelationInput[]
    cursor?: EmergencyAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmergencyAlertScalarFieldEnum | EmergencyAlertScalarFieldEnum[]
  }

  /**
   * Society.emergencyContacts
   */
  export type Society$emergencyContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    where?: EmergencyContactWhereInput
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    cursor?: EmergencyContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * Society.serviceInquiries
   */
  export type Society$serviceInquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInquiryInclude<ExtArgs> | null
    where?: ServiceInquiryWhereInput
    orderBy?: ServiceInquiryOrderByWithRelationInput | ServiceInquiryOrderByWithRelationInput[]
    cursor?: ServiceInquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceInquiryScalarFieldEnum | ServiceInquiryScalarFieldEnum[]
  }

  /**
   * Society.conversations
   */
  export type Society$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Society.buzzs
   */
  export type Society$buzzsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBuzz
     */
    select?: CommunityBuzzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBuzz
     */
    omit?: CommunityBuzzOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityBuzzInclude<ExtArgs> | null
    where?: CommunityBuzzWhereInput
    orderBy?: CommunityBuzzOrderByWithRelationInput | CommunityBuzzOrderByWithRelationInput[]
    cursor?: CommunityBuzzWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityBuzzScalarFieldEnum | CommunityBuzzScalarFieldEnum[]
  }

  /**
   * Society.marketplaceItems
   */
  export type Society$marketplaceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceItem
     */
    omit?: MarketplaceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    where?: MarketplaceItemWhereInput
    orderBy?: MarketplaceItemOrderByWithRelationInput | MarketplaceItemOrderByWithRelationInput[]
    cursor?: MarketplaceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketplaceItemScalarFieldEnum | MarketplaceItemScalarFieldEnum[]
  }

  /**
   * Society.guidelines
   */
  export type Society$guidelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGuideline
     */
    select?: CommunityGuidelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityGuideline
     */
    omit?: CommunityGuidelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGuidelineInclude<ExtArgs> | null
    where?: CommunityGuidelineWhereInput
    orderBy?: CommunityGuidelineOrderByWithRelationInput | CommunityGuidelineOrderByWithRelationInput[]
    cursor?: CommunityGuidelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityGuidelineScalarFieldEnum | CommunityGuidelineScalarFieldEnum[]
  }

  /**
   * Society.sosAlerts
   */
  export type Society$sosAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOSAlert
     */
    select?: SOSAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOSAlert
     */
    omit?: SOSAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSAlertInclude<ExtArgs> | null
    where?: SOSAlertWhereInput
    orderBy?: SOSAlertOrderByWithRelationInput | SOSAlertOrderByWithRelationInput[]
    cursor?: SOSAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SOSAlertScalarFieldEnum | SOSAlertScalarFieldEnum[]
  }

  /**
   * Society without action
   */
  export type SocietyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
    societyId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    roleId: number | null
    societyId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    role: $Enums.Role | null
    status: $Enums.UserStatus | null
    profileImg: string | null
    roleId: number | null
    societyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    role: $Enums.Role | null
    status: $Enums.UserStatus | null
    profileImg: string | null
    roleId: number | null
    societyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    phone: number
    role: number
    status: number
    profileImg: number
    roleId: number
    societyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    roleId?: true
    societyId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    roleId?: true
    societyId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    role?: true
    status?: true
    profileImg?: true
    roleId?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    role?: true
    status?: true
    profileImg?: true
    roleId?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    role?: true
    status?: true
    profileImg?: true
    roleId?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string
    phone: string | null
    role: $Enums.Role
    status: $Enums.UserStatus
    profileImg: string | null
    roleId: number | null
    societyId: number | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    status?: boolean
    profileImg?: boolean
    roleId?: boolean
    societyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleModel?: boolean | User$roleModelArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    society?: boolean | User$societyArgs<ExtArgs>
    ownedUnits?: boolean | User$ownedUnitsArgs<ExtArgs>
    rentedUnits?: boolean | User$rentedUnitsArgs<ExtArgs>
    reportedComplaints?: boolean | User$reportedComplaintsArgs<ExtArgs>
    assignedComplaints?: boolean | User$assignedComplaintsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    purchaseRequests?: boolean | User$purchaseRequestsArgs<ExtArgs>
    emergencyAlerts?: boolean | User$emergencyAlertsArgs<ExtArgs>
    serviceInquiries?: boolean | User$serviceInquiriesArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    buzzs?: boolean | User$buzzsArgs<ExtArgs>
    communityComments?: boolean | User$communityCommentsArgs<ExtArgs>
    sosAlerts?: boolean | User$sosAlertsArgs<ExtArgs>
    emergencyContacts?: boolean | User$emergencyContactsArgs<ExtArgs>
    marketplaceItems?: boolean | User$marketplaceItemsArgs<ExtArgs>
    buzzLikes?: boolean | User$buzzLikesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    status?: boolean
    profileImg?: boolean
    roleId?: boolean
    societyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "phone" | "role" | "status" | "profileImg" | "roleId" | "societyId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleModel?: boolean | User$roleModelArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    society?: boolean | User$societyArgs<ExtArgs>
    ownedUnits?: boolean | User$ownedUnitsArgs<ExtArgs>
    rentedUnits?: boolean | User$rentedUnitsArgs<ExtArgs>
    reportedComplaints?: boolean | User$reportedComplaintsArgs<ExtArgs>
    assignedComplaints?: boolean | User$assignedComplaintsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    purchaseRequests?: boolean | User$purchaseRequestsArgs<ExtArgs>
    emergencyAlerts?: boolean | User$emergencyAlertsArgs<ExtArgs>
    serviceInquiries?: boolean | User$serviceInquiriesArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    buzzs?: boolean | User$buzzsArgs<ExtArgs>
    communityComments?: boolean | User$communityCommentsArgs<ExtArgs>
    sosAlerts?: boolean | User$sosAlertsArgs<ExtArgs>
    emergencyContacts?: boolean | User$emergencyContactsArgs<ExtArgs>
    marketplaceItems?: boolean | User$marketplaceItemsArgs<ExtArgs>
    buzzLikes?: boolean | User$buzzLikesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      roleModel: Prisma.$RoleModelPayload<ExtArgs> | null
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
      society: Prisma.$SocietyPayload<ExtArgs> | null
      ownedUnits: Prisma.$UnitPayload<ExtArgs>[]
      rentedUnits: Prisma.$UnitPayload<ExtArgs>[]
      reportedComplaints: Prisma.$ComplaintPayload<ExtArgs>[]
      assignedComplaints: Prisma.$ComplaintPayload<ExtArgs>[]
      bookings: Prisma.$AmenityBookingPayload<ExtArgs>[]
      comments: Prisma.$ComplaintCommentPayload<ExtArgs>[]
      purchaseRequests: Prisma.$PurchaseRequestPayload<ExtArgs>[]
      emergencyAlerts: Prisma.$EmergencyAlertPayload<ExtArgs>[]
      serviceInquiries: Prisma.$ServiceInquiryPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      sentMessages: Prisma.$ChatMessagePayload<ExtArgs>[]
      buzzs: Prisma.$CommunityBuzzPayload<ExtArgs>[]
      communityComments: Prisma.$CommunityCommentPayload<ExtArgs>[]
      sosAlerts: Prisma.$SOSAlertPayload<ExtArgs>[]
      emergencyContacts: Prisma.$EmergencyContactPayload<ExtArgs>[]
      marketplaceItems: Prisma.$MarketplaceItemPayload<ExtArgs>[]
      buzzLikes: Prisma.$BuzzLikePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string
      phone: string | null
      role: $Enums.Role
      status: $Enums.UserStatus
      profileImg: string | null
      roleId: number | null
      societyId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roleModel<T extends User$roleModelArgs<ExtArgs> = {}>(args?: Subset<T, User$roleModelArgs<ExtArgs>>): Prisma__RoleModelClient<$Result.GetResult<Prisma.$RoleModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    society<T extends User$societyArgs<ExtArgs> = {}>(args?: Subset<T, User$societyArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ownedUnits<T extends User$ownedUnitsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedUnitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rentedUnits<T extends User$rentedUnitsArgs<ExtArgs> = {}>(args?: Subset<T, User$rentedUnitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportedComplaints<T extends User$reportedComplaintsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportedComplaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedComplaints<T extends User$assignedComplaintsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedComplaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseRequests<T extends User$purchaseRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$purchaseRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emergencyAlerts<T extends User$emergencyAlertsArgs<ExtArgs> = {}>(args?: Subset<T, User$emergencyAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceInquiries<T extends User$serviceInquiriesArgs<ExtArgs> = {}>(args?: Subset<T, User$serviceInquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends User$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buzzs<T extends User$buzzsArgs<ExtArgs> = {}>(args?: Subset<T, User$buzzsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityBuzzPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    communityComments<T extends User$communityCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$communityCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sosAlerts<T extends User$sosAlertsArgs<ExtArgs> = {}>(args?: Subset<T, User$sosAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SOSAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emergencyContacts<T extends User$emergencyContactsArgs<ExtArgs> = {}>(args?: Subset<T, User$emergencyContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    marketplaceItems<T extends User$marketplaceItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$marketplaceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buzzLikes<T extends User$buzzLikesArgs<ExtArgs> = {}>(args?: Subset<T, User$buzzLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly profileImg: FieldRef<"User", 'String'>
    readonly roleId: FieldRef<"User", 'Int'>
    readonly societyId: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.roleModel
   */
  export type User$roleModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleModel
     */
    select?: RoleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleModel
     */
    omit?: RoleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleModelInclude<ExtArgs> | null
    where?: RoleModelWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User.society
   */
  export type User$societyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    where?: SocietyWhereInput
  }

  /**
   * User.ownedUnits
   */
  export type User$ownedUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * User.rentedUnits
   */
  export type User$rentedUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * User.reportedComplaints
   */
  export type User$reportedComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    cursor?: ComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * User.assignedComplaints
   */
  export type User$assignedComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    cursor?: ComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    where?: AmenityBookingWhereInput
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    cursor?: AmenityBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmenityBookingScalarFieldEnum | AmenityBookingScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    where?: ComplaintCommentWhereInput
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    cursor?: ComplaintCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintCommentScalarFieldEnum | ComplaintCommentScalarFieldEnum[]
  }

  /**
   * User.purchaseRequests
   */
  export type User$purchaseRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    where?: PurchaseRequestWhereInput
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    cursor?: PurchaseRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseRequestScalarFieldEnum | PurchaseRequestScalarFieldEnum[]
  }

  /**
   * User.emergencyAlerts
   */
  export type User$emergencyAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAlert
     */
    select?: EmergencyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyAlert
     */
    omit?: EmergencyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAlertInclude<ExtArgs> | null
    where?: EmergencyAlertWhereInput
    orderBy?: EmergencyAlertOrderByWithRelationInput | EmergencyAlertOrderByWithRelationInput[]
    cursor?: EmergencyAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmergencyAlertScalarFieldEnum | EmergencyAlertScalarFieldEnum[]
  }

  /**
   * User.serviceInquiries
   */
  export type User$serviceInquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInquiryInclude<ExtArgs> | null
    where?: ServiceInquiryWhereInput
    orderBy?: ServiceInquiryOrderByWithRelationInput | ServiceInquiryOrderByWithRelationInput[]
    cursor?: ServiceInquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceInquiryScalarFieldEnum | ServiceInquiryScalarFieldEnum[]
  }

  /**
   * User.conversations
   */
  export type User$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * User.buzzs
   */
  export type User$buzzsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBuzz
     */
    select?: CommunityBuzzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBuzz
     */
    omit?: CommunityBuzzOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityBuzzInclude<ExtArgs> | null
    where?: CommunityBuzzWhereInput
    orderBy?: CommunityBuzzOrderByWithRelationInput | CommunityBuzzOrderByWithRelationInput[]
    cursor?: CommunityBuzzWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityBuzzScalarFieldEnum | CommunityBuzzScalarFieldEnum[]
  }

  /**
   * User.communityComments
   */
  export type User$communityCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityComment
     */
    select?: CommunityCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityComment
     */
    omit?: CommunityCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCommentInclude<ExtArgs> | null
    where?: CommunityCommentWhereInput
    orderBy?: CommunityCommentOrderByWithRelationInput | CommunityCommentOrderByWithRelationInput[]
    cursor?: CommunityCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityCommentScalarFieldEnum | CommunityCommentScalarFieldEnum[]
  }

  /**
   * User.sosAlerts
   */
  export type User$sosAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOSAlert
     */
    select?: SOSAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOSAlert
     */
    omit?: SOSAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSAlertInclude<ExtArgs> | null
    where?: SOSAlertWhereInput
    orderBy?: SOSAlertOrderByWithRelationInput | SOSAlertOrderByWithRelationInput[]
    cursor?: SOSAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SOSAlertScalarFieldEnum | SOSAlertScalarFieldEnum[]
  }

  /**
   * User.emergencyContacts
   */
  export type User$emergencyContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    where?: EmergencyContactWhereInput
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    cursor?: EmergencyContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * User.marketplaceItems
   */
  export type User$marketplaceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceItem
     */
    omit?: MarketplaceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    where?: MarketplaceItemWhereInput
    orderBy?: MarketplaceItemOrderByWithRelationInput | MarketplaceItemOrderByWithRelationInput[]
    cursor?: MarketplaceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketplaceItemScalarFieldEnum | MarketplaceItemScalarFieldEnum[]
  }

  /**
   * User.buzzLikes
   */
  export type User$buzzLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzLike
     */
    select?: BuzzLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzLike
     */
    omit?: BuzzLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzLikeInclude<ExtArgs> | null
    where?: BuzzLikeWhereInput
    orderBy?: BuzzLikeOrderByWithRelationInput | BuzzLikeOrderByWithRelationInput[]
    cursor?: BuzzLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuzzLikeScalarFieldEnum | BuzzLikeScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RoleModel
   */

  export type AggregateRoleModel = {
    _count: RoleModelCountAggregateOutputType | null
    _avg: RoleModelAvgAggregateOutputType | null
    _sum: RoleModelSumAggregateOutputType | null
    _min: RoleModelMinAggregateOutputType | null
    _max: RoleModelMaxAggregateOutputType | null
  }

  export type RoleModelAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleModelSumAggregateOutputType = {
    id: number | null
  }

  export type RoleModelMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleModelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleModelCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleModelAvgAggregateInputType = {
    id?: true
  }

  export type RoleModelSumAggregateInputType = {
    id?: true
  }

  export type RoleModelMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleModelMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleModelCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleModel to aggregate.
     */
    where?: RoleModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleModels to fetch.
     */
    orderBy?: RoleModelOrderByWithRelationInput | RoleModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleModels
    **/
    _count?: true | RoleModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleModelMaxAggregateInputType
  }

  export type GetRoleModelAggregateType<T extends RoleModelAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleModel[P]>
      : GetScalarType<T[P], AggregateRoleModel[P]>
  }




  export type RoleModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleModelWhereInput
    orderBy?: RoleModelOrderByWithAggregationInput | RoleModelOrderByWithAggregationInput[]
    by: RoleModelScalarFieldEnum[] | RoleModelScalarFieldEnum
    having?: RoleModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleModelCountAggregateInputType | true
    _avg?: RoleModelAvgAggregateInputType
    _sum?: RoleModelSumAggregateInputType
    _min?: RoleModelMinAggregateInputType
    _max?: RoleModelMaxAggregateInputType
  }

  export type RoleModelGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleModelCountAggregateOutputType | null
    _avg: RoleModelAvgAggregateOutputType | null
    _sum: RoleModelSumAggregateOutputType | null
    _min: RoleModelMinAggregateOutputType | null
    _max: RoleModelMaxAggregateOutputType | null
  }

  type GetRoleModelGroupByPayload<T extends RoleModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleModelGroupByOutputType[P]>
            : GetScalarType<T[P], RoleModelGroupByOutputType[P]>
        }
      >
    >


  export type RoleModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean | RoleModel$permissionsArgs<ExtArgs>
    users?: boolean | RoleModel$usersArgs<ExtArgs>
    _count?: boolean | RoleModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleModel"]>



  export type RoleModelSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["roleModel"]>
  export type RoleModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | RoleModel$permissionsArgs<ExtArgs>
    users?: boolean | RoleModel$usersArgs<ExtArgs>
    _count?: boolean | RoleModelCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RoleModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleModel"
    objects: {
      permissions: Prisma.$RolePermissionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roleModel"]>
    composites: {}
  }

  type RoleModelGetPayload<S extends boolean | null | undefined | RoleModelDefaultArgs> = $Result.GetResult<Prisma.$RoleModelPayload, S>

  type RoleModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleModelCountAggregateInputType | true
    }

  export interface RoleModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleModel'], meta: { name: 'RoleModel' } }
    /**
     * Find zero or one RoleModel that matches the filter.
     * @param {RoleModelFindUniqueArgs} args - Arguments to find a RoleModel
     * @example
     * // Get one RoleModel
     * const roleModel = await prisma.roleModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleModelFindUniqueArgs>(args: SelectSubset<T, RoleModelFindUniqueArgs<ExtArgs>>): Prisma__RoleModelClient<$Result.GetResult<Prisma.$RoleModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoleModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleModelFindUniqueOrThrowArgs} args - Arguments to find a RoleModel
     * @example
     * // Get one RoleModel
     * const roleModel = await prisma.roleModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleModelFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleModelClient<$Result.GetResult<Prisma.$RoleModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleModelFindFirstArgs} args - Arguments to find a RoleModel
     * @example
     * // Get one RoleModel
     * const roleModel = await prisma.roleModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleModelFindFirstArgs>(args?: SelectSubset<T, RoleModelFindFirstArgs<ExtArgs>>): Prisma__RoleModelClient<$Result.GetResult<Prisma.$RoleModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleModelFindFirstOrThrowArgs} args - Arguments to find a RoleModel
     * @example
     * // Get one RoleModel
     * const roleModel = await prisma.roleModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleModelFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleModelClient<$Result.GetResult<Prisma.$RoleModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoleModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleModels
     * const roleModels = await prisma.roleModel.findMany()
     * 
     * // Get first 10 RoleModels
     * const roleModels = await prisma.roleModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleModelWithIdOnly = await prisma.roleModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleModelFindManyArgs>(args?: SelectSubset<T, RoleModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoleModel.
     * @param {RoleModelCreateArgs} args - Arguments to create a RoleModel.
     * @example
     * // Create one RoleModel
     * const RoleModel = await prisma.roleModel.create({
     *   data: {
     *     // ... data to create a RoleModel
     *   }
     * })
     * 
     */
    create<T extends RoleModelCreateArgs>(args: SelectSubset<T, RoleModelCreateArgs<ExtArgs>>): Prisma__RoleModelClient<$Result.GetResult<Prisma.$RoleModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoleModels.
     * @param {RoleModelCreateManyArgs} args - Arguments to create many RoleModels.
     * @example
     * // Create many RoleModels
     * const roleModel = await prisma.roleModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleModelCreateManyArgs>(args?: SelectSubset<T, RoleModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoleModel.
     * @param {RoleModelDeleteArgs} args - Arguments to delete one RoleModel.
     * @example
     * // Delete one RoleModel
     * const RoleModel = await prisma.roleModel.delete({
     *   where: {
     *     // ... filter to delete one RoleModel
     *   }
     * })
     * 
     */
    delete<T extends RoleModelDeleteArgs>(args: SelectSubset<T, RoleModelDeleteArgs<ExtArgs>>): Prisma__RoleModelClient<$Result.GetResult<Prisma.$RoleModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoleModel.
     * @param {RoleModelUpdateArgs} args - Arguments to update one RoleModel.
     * @example
     * // Update one RoleModel
     * const roleModel = await prisma.roleModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleModelUpdateArgs>(args: SelectSubset<T, RoleModelUpdateArgs<ExtArgs>>): Prisma__RoleModelClient<$Result.GetResult<Prisma.$RoleModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoleModels.
     * @param {RoleModelDeleteManyArgs} args - Arguments to filter RoleModels to delete.
     * @example
     * // Delete a few RoleModels
     * const { count } = await prisma.roleModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleModelDeleteManyArgs>(args?: SelectSubset<T, RoleModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleModels
     * const roleModel = await prisma.roleModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleModelUpdateManyArgs>(args: SelectSubset<T, RoleModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoleModel.
     * @param {RoleModelUpsertArgs} args - Arguments to update or create a RoleModel.
     * @example
     * // Update or create a RoleModel
     * const roleModel = await prisma.roleModel.upsert({
     *   create: {
     *     // ... data to create a RoleModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleModel we want to update
     *   }
     * })
     */
    upsert<T extends RoleModelUpsertArgs>(args: SelectSubset<T, RoleModelUpsertArgs<ExtArgs>>): Prisma__RoleModelClient<$Result.GetResult<Prisma.$RoleModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoleModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleModelCountArgs} args - Arguments to filter RoleModels to count.
     * @example
     * // Count the number of RoleModels
     * const count = await prisma.roleModel.count({
     *   where: {
     *     // ... the filter for the RoleModels we want to count
     *   }
     * })
    **/
    count<T extends RoleModelCountArgs>(
      args?: Subset<T, RoleModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleModelAggregateArgs>(args: Subset<T, RoleModelAggregateArgs>): Prisma.PrismaPromise<GetRoleModelAggregateType<T>>

    /**
     * Group by RoleModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleModelGroupByArgs['orderBy'] }
        : { orderBy?: RoleModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleModel model
   */
  readonly fields: RoleModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends RoleModel$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, RoleModel$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends RoleModel$usersArgs<ExtArgs> = {}>(args?: Subset<T, RoleModel$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleModel model
   */
  interface RoleModelFieldRefs {
    readonly id: FieldRef<"RoleModel", 'Int'>
    readonly name: FieldRef<"RoleModel", 'String'>
    readonly description: FieldRef<"RoleModel", 'String'>
    readonly createdAt: FieldRef<"RoleModel", 'DateTime'>
    readonly updatedAt: FieldRef<"RoleModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoleModel findUnique
   */
  export type RoleModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleModel
     */
    select?: RoleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleModel
     */
    omit?: RoleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleModelInclude<ExtArgs> | null
    /**
     * Filter, which RoleModel to fetch.
     */
    where: RoleModelWhereUniqueInput
  }

  /**
   * RoleModel findUniqueOrThrow
   */
  export type RoleModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleModel
     */
    select?: RoleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleModel
     */
    omit?: RoleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleModelInclude<ExtArgs> | null
    /**
     * Filter, which RoleModel to fetch.
     */
    where: RoleModelWhereUniqueInput
  }

  /**
   * RoleModel findFirst
   */
  export type RoleModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleModel
     */
    select?: RoleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleModel
     */
    omit?: RoleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleModelInclude<ExtArgs> | null
    /**
     * Filter, which RoleModel to fetch.
     */
    where?: RoleModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleModels to fetch.
     */
    orderBy?: RoleModelOrderByWithRelationInput | RoleModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleModels.
     */
    cursor?: RoleModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleModels.
     */
    distinct?: RoleModelScalarFieldEnum | RoleModelScalarFieldEnum[]
  }

  /**
   * RoleModel findFirstOrThrow
   */
  export type RoleModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleModel
     */
    select?: RoleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleModel
     */
    omit?: RoleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleModelInclude<ExtArgs> | null
    /**
     * Filter, which RoleModel to fetch.
     */
    where?: RoleModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleModels to fetch.
     */
    orderBy?: RoleModelOrderByWithRelationInput | RoleModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleModels.
     */
    cursor?: RoleModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleModels.
     */
    distinct?: RoleModelScalarFieldEnum | RoleModelScalarFieldEnum[]
  }

  /**
   * RoleModel findMany
   */
  export type RoleModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleModel
     */
    select?: RoleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleModel
     */
    omit?: RoleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleModelInclude<ExtArgs> | null
    /**
     * Filter, which RoleModels to fetch.
     */
    where?: RoleModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleModels to fetch.
     */
    orderBy?: RoleModelOrderByWithRelationInput | RoleModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleModels.
     */
    cursor?: RoleModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleModels.
     */
    skip?: number
    distinct?: RoleModelScalarFieldEnum | RoleModelScalarFieldEnum[]
  }

  /**
   * RoleModel create
   */
  export type RoleModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleModel
     */
    select?: RoleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleModel
     */
    omit?: RoleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleModelInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleModel.
     */
    data: XOR<RoleModelCreateInput, RoleModelUncheckedCreateInput>
  }

  /**
   * RoleModel createMany
   */
  export type RoleModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleModels.
     */
    data: RoleModelCreateManyInput | RoleModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleModel update
   */
  export type RoleModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleModel
     */
    select?: RoleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleModel
     */
    omit?: RoleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleModelInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleModel.
     */
    data: XOR<RoleModelUpdateInput, RoleModelUncheckedUpdateInput>
    /**
     * Choose, which RoleModel to update.
     */
    where: RoleModelWhereUniqueInput
  }

  /**
   * RoleModel updateMany
   */
  export type RoleModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleModels.
     */
    data: XOR<RoleModelUpdateManyMutationInput, RoleModelUncheckedUpdateManyInput>
    /**
     * Filter which RoleModels to update
     */
    where?: RoleModelWhereInput
    /**
     * Limit how many RoleModels to update.
     */
    limit?: number
  }

  /**
   * RoleModel upsert
   */
  export type RoleModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleModel
     */
    select?: RoleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleModel
     */
    omit?: RoleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleModelInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleModel to update in case it exists.
     */
    where: RoleModelWhereUniqueInput
    /**
     * In case the RoleModel found by the `where` argument doesn't exist, create a new RoleModel with this data.
     */
    create: XOR<RoleModelCreateInput, RoleModelUncheckedCreateInput>
    /**
     * In case the RoleModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleModelUpdateInput, RoleModelUncheckedUpdateInput>
  }

  /**
   * RoleModel delete
   */
  export type RoleModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleModel
     */
    select?: RoleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleModel
     */
    omit?: RoleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleModelInclude<ExtArgs> | null
    /**
     * Filter which RoleModel to delete.
     */
    where: RoleModelWhereUniqueInput
  }

  /**
   * RoleModel deleteMany
   */
  export type RoleModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleModels to delete
     */
    where?: RoleModelWhereInput
    /**
     * Limit how many RoleModels to delete.
     */
    limit?: number
  }

  /**
   * RoleModel.permissions
   */
  export type RoleModel$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RoleModel.users
   */
  export type RoleModel$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * RoleModel without action
   */
  export type RoleModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleModel
     */
    select?: RoleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleModel
     */
    omit?: RoleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleModelInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    label: string | null
    description: string | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    label: string | null
    description: string | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    label: number
    description: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    label?: true
    description?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    label?: true
    description?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    label?: true
    description?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    label: string
    description: string | null
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    description?: boolean
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>



  export type PermissionSelectScalar = {
    id?: boolean
    label?: boolean
    description?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "description", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roles: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      description: string | null
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly label: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionAvgAggregateOutputType = {
    roleId: number | null
  }

  export type RolePermissionSumAggregateOutputType = {
    roleId: number | null
  }

  export type RolePermissionMinAggregateOutputType = {
    roleId: number | null
    permissionId: string | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    roleId: number | null
    permissionId: string | null
  }

  export type RolePermissionCountAggregateOutputType = {
    roleId: number
    permissionId: number
    _all: number
  }


  export type RolePermissionAvgAggregateInputType = {
    roleId?: true
  }

  export type RolePermissionSumAggregateInputType = {
    roleId?: true
  }

  export type RolePermissionMinAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionCountAggregateInputType = {
    roleId?: true
    permissionId?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _avg?: RolePermissionAvgAggregateInputType
    _sum?: RolePermissionSumAggregateInputType
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    roleId: number
    permissionId: string
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    role?: boolean | RoleModelDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>



  export type RolePermissionSelectScalar = {
    roleId?: boolean
    permissionId?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"roleId" | "permissionId", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleModelDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RoleModelPayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roleId: number
      permissionId: string
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `roleId`
     * const rolePermissionWithRoleIdOnly = await prisma.rolePermission.findMany({ select: { roleId: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleModelDefaultArgs<ExtArgs>>): Prisma__RoleModelClient<$Result.GetResult<Prisma.$RoleModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */
  interface RolePermissionFieldRefs {
    readonly roleId: FieldRef<"RolePermission", 'Int'>
    readonly permissionId: FieldRef<"RolePermission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _avg: UserSessionAvgAggregateOutputType | null
    _sum: UserSessionSumAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserSessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    device: string | null
    ipAddress: string | null
    lastActive: Date | null
    token: string | null
    createdAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    device: string | null
    ipAddress: string | null
    lastActive: Date | null
    token: string | null
    createdAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    userId: number
    device: number
    ipAddress: number
    lastActive: number
    token: number
    createdAt: number
    _all: number
  }


  export type UserSessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserSessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserSessionMinAggregateInputType = {
    id?: true
    userId?: true
    device?: true
    ipAddress?: true
    lastActive?: true
    token?: true
    createdAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    device?: true
    ipAddress?: true
    lastActive?: true
    token?: true
    createdAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    userId?: true
    device?: true
    ipAddress?: true
    lastActive?: true
    token?: true
    createdAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _avg?: UserSessionAvgAggregateInputType
    _sum?: UserSessionSumAggregateInputType
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: number
    userId: number
    device: string | null
    ipAddress: string | null
    lastActive: Date
    token: string
    createdAt: Date
    _count: UserSessionCountAggregateOutputType | null
    _avg: UserSessionAvgAggregateOutputType | null
    _sum: UserSessionSumAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    device?: boolean
    ipAddress?: boolean
    lastActive?: boolean
    token?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>



  export type UserSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    device?: boolean
    ipAddress?: boolean
    lastActive?: boolean
    token?: boolean
    createdAt?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "device" | "ipAddress" | "lastActive" | "token" | "createdAt", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      device: string | null
      ipAddress: string | null
      lastActive: Date
      token: string
      createdAt: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'Int'>
    readonly userId: FieldRef<"UserSession", 'Int'>
    readonly device: FieldRef<"UserSession", 'String'>
    readonly ipAddress: FieldRef<"UserSession", 'String'>
    readonly lastActive: FieldRef<"UserSession", 'DateTime'>
    readonly token: FieldRef<"UserSession", 'String'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    id: number | null
    floor: number | null
    areaSqFt: number | null
    pets: number | null
    membersCount: number | null
    societyId: number | null
    ownerId: number | null
    tenantId: number | null
  }

  export type UnitSumAggregateOutputType = {
    id: number | null
    floor: number | null
    areaSqFt: number | null
    pets: number | null
    membersCount: number | null
    societyId: number | null
    ownerId: number | null
    tenantId: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: number | null
    block: string | null
    number: string | null
    floor: number | null
    type: string | null
    areaSqFt: number | null
    status: string | null
    pets: number | null
    membersCount: number | null
    societyId: number | null
    ownerId: number | null
    tenantId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    id: number | null
    block: string | null
    number: string | null
    floor: number | null
    type: string | null
    areaSqFt: number | null
    status: string | null
    pets: number | null
    membersCount: number | null
    societyId: number | null
    ownerId: number | null
    tenantId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    block: number
    number: number
    floor: number
    type: number
    areaSqFt: number
    status: number
    pets: number
    membersCount: number
    societyId: number
    ownerId: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    id?: true
    floor?: true
    areaSqFt?: true
    pets?: true
    membersCount?: true
    societyId?: true
    ownerId?: true
    tenantId?: true
  }

  export type UnitSumAggregateInputType = {
    id?: true
    floor?: true
    areaSqFt?: true
    pets?: true
    membersCount?: true
    societyId?: true
    ownerId?: true
    tenantId?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    block?: true
    number?: true
    floor?: true
    type?: true
    areaSqFt?: true
    status?: true
    pets?: true
    membersCount?: true
    societyId?: true
    ownerId?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    block?: true
    number?: true
    floor?: true
    type?: true
    areaSqFt?: true
    status?: true
    pets?: true
    membersCount?: true
    societyId?: true
    ownerId?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    block?: true
    number?: true
    floor?: true
    type?: true
    areaSqFt?: true
    status?: true
    pets?: true
    membersCount?: true
    societyId?: true
    ownerId?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status: string
    pets: number
    membersCount: number
    societyId: number
    ownerId: number | null
    tenantId: number | null
    createdAt: Date
    updatedAt: Date
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    block?: boolean
    number?: boolean
    floor?: boolean
    type?: boolean
    areaSqFt?: boolean
    status?: boolean
    pets?: boolean
    membersCount?: boolean
    societyId?: boolean
    ownerId?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    owner?: boolean | Unit$ownerArgs<ExtArgs>
    tenant?: boolean | Unit$tenantArgs<ExtArgs>
    visitors?: boolean | Unit$visitorsArgs<ExtArgs>
    parkingSlots?: boolean | Unit$parkingSlotsArgs<ExtArgs>
    parcels?: boolean | Unit$parcelsArgs<ExtArgs>
    members?: boolean | Unit$membersArgs<ExtArgs>
    vehicles?: boolean | Unit$vehiclesArgs<ExtArgs>
    petsList?: boolean | Unit$petsListArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>



  export type UnitSelectScalar = {
    id?: boolean
    block?: boolean
    number?: boolean
    floor?: boolean
    type?: boolean
    areaSqFt?: boolean
    status?: boolean
    pets?: boolean
    membersCount?: boolean
    societyId?: boolean
    ownerId?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "block" | "number" | "floor" | "type" | "areaSqFt" | "status" | "pets" | "membersCount" | "societyId" | "ownerId" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    owner?: boolean | Unit$ownerArgs<ExtArgs>
    tenant?: boolean | Unit$tenantArgs<ExtArgs>
    visitors?: boolean | Unit$visitorsArgs<ExtArgs>
    parkingSlots?: boolean | Unit$parkingSlotsArgs<ExtArgs>
    parcels?: boolean | Unit$parcelsArgs<ExtArgs>
    members?: boolean | Unit$membersArgs<ExtArgs>
    vehicles?: boolean | Unit$vehiclesArgs<ExtArgs>
    petsList?: boolean | Unit$petsListArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs> | null
      tenant: Prisma.$UserPayload<ExtArgs> | null
      visitors: Prisma.$VisitorPayload<ExtArgs>[]
      parkingSlots: Prisma.$ParkingSlotPayload<ExtArgs>[]
      parcels: Prisma.$ParcelPayload<ExtArgs>[]
      members: Prisma.$UnitMemberPayload<ExtArgs>[]
      vehicles: Prisma.$UnitVehiclePayload<ExtArgs>[]
      petsList: Prisma.$UnitPetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      block: string
      number: string
      floor: number
      type: string
      areaSqFt: number
      status: string
      pets: number
      membersCount: number
      societyId: number
      ownerId: number | null
      tenantId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends Unit$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Unit$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenant<T extends Unit$tenantArgs<ExtArgs> = {}>(args?: Subset<T, Unit$tenantArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    visitors<T extends Unit$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parkingSlots<T extends Unit$parkingSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$parkingSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parcels<T extends Unit$parcelsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$parcelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends Unit$membersArgs<ExtArgs> = {}>(args?: Subset<T, Unit$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicles<T extends Unit$vehiclesArgs<ExtArgs> = {}>(args?: Subset<T, Unit$vehiclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitVehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    petsList<T extends Unit$petsListArgs<ExtArgs> = {}>(args?: Subset<T, Unit$petsListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'Int'>
    readonly block: FieldRef<"Unit", 'String'>
    readonly number: FieldRef<"Unit", 'String'>
    readonly floor: FieldRef<"Unit", 'Int'>
    readonly type: FieldRef<"Unit", 'String'>
    readonly areaSqFt: FieldRef<"Unit", 'Float'>
    readonly status: FieldRef<"Unit", 'String'>
    readonly pets: FieldRef<"Unit", 'Int'>
    readonly membersCount: FieldRef<"Unit", 'Int'>
    readonly societyId: FieldRef<"Unit", 'Int'>
    readonly ownerId: FieldRef<"Unit", 'Int'>
    readonly tenantId: FieldRef<"Unit", 'Int'>
    readonly createdAt: FieldRef<"Unit", 'DateTime'>
    readonly updatedAt: FieldRef<"Unit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.owner
   */
  export type Unit$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Unit.tenant
   */
  export type Unit$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Unit.visitors
   */
  export type Unit$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    cursor?: VisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Unit.parkingSlots
   */
  export type Unit$parkingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    where?: ParkingSlotWhereInput
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    cursor?: ParkingSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * Unit.parcels
   */
  export type Unit$parcelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    where?: ParcelWhereInput
    orderBy?: ParcelOrderByWithRelationInput | ParcelOrderByWithRelationInput[]
    cursor?: ParcelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParcelScalarFieldEnum | ParcelScalarFieldEnum[]
  }

  /**
   * Unit.members
   */
  export type Unit$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMember
     */
    select?: UnitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMember
     */
    omit?: UnitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMemberInclude<ExtArgs> | null
    where?: UnitMemberWhereInput
    orderBy?: UnitMemberOrderByWithRelationInput | UnitMemberOrderByWithRelationInput[]
    cursor?: UnitMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitMemberScalarFieldEnum | UnitMemberScalarFieldEnum[]
  }

  /**
   * Unit.vehicles
   */
  export type Unit$vehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitVehicle
     */
    select?: UnitVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitVehicle
     */
    omit?: UnitVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitVehicleInclude<ExtArgs> | null
    where?: UnitVehicleWhereInput
    orderBy?: UnitVehicleOrderByWithRelationInput | UnitVehicleOrderByWithRelationInput[]
    cursor?: UnitVehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitVehicleScalarFieldEnum | UnitVehicleScalarFieldEnum[]
  }

  /**
   * Unit.petsList
   */
  export type Unit$petsListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPet
     */
    select?: UnitPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPet
     */
    omit?: UnitPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPetInclude<ExtArgs> | null
    where?: UnitPetWhereInput
    orderBy?: UnitPetOrderByWithRelationInput | UnitPetOrderByWithRelationInput[]
    cursor?: UnitPetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitPetScalarFieldEnum | UnitPetScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model ParkingSlot
   */

  export type AggregateParkingSlot = {
    _count: ParkingSlotCountAggregateOutputType | null
    _avg: ParkingSlotAvgAggregateOutputType | null
    _sum: ParkingSlotSumAggregateOutputType | null
    _min: ParkingSlotMinAggregateOutputType | null
    _max: ParkingSlotMaxAggregateOutputType | null
  }

  export type ParkingSlotAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
    allocatedToUnitId: number | null
  }

  export type ParkingSlotSumAggregateOutputType = {
    id: number | null
    societyId: number | null
    allocatedToUnitId: number | null
  }

  export type ParkingSlotMinAggregateOutputType = {
    id: number | null
    number: string | null
    type: string | null
    status: string | null
    societyId: number | null
    allocatedToUnitId: number | null
    vehicleNumber: string | null
    createdAt: Date | null
  }

  export type ParkingSlotMaxAggregateOutputType = {
    id: number | null
    number: string | null
    type: string | null
    status: string | null
    societyId: number | null
    allocatedToUnitId: number | null
    vehicleNumber: string | null
    createdAt: Date | null
  }

  export type ParkingSlotCountAggregateOutputType = {
    id: number
    number: number
    type: number
    status: number
    societyId: number
    allocatedToUnitId: number
    vehicleNumber: number
    createdAt: number
    _all: number
  }


  export type ParkingSlotAvgAggregateInputType = {
    id?: true
    societyId?: true
    allocatedToUnitId?: true
  }

  export type ParkingSlotSumAggregateInputType = {
    id?: true
    societyId?: true
    allocatedToUnitId?: true
  }

  export type ParkingSlotMinAggregateInputType = {
    id?: true
    number?: true
    type?: true
    status?: true
    societyId?: true
    allocatedToUnitId?: true
    vehicleNumber?: true
    createdAt?: true
  }

  export type ParkingSlotMaxAggregateInputType = {
    id?: true
    number?: true
    type?: true
    status?: true
    societyId?: true
    allocatedToUnitId?: true
    vehicleNumber?: true
    createdAt?: true
  }

  export type ParkingSlotCountAggregateInputType = {
    id?: true
    number?: true
    type?: true
    status?: true
    societyId?: true
    allocatedToUnitId?: true
    vehicleNumber?: true
    createdAt?: true
    _all?: true
  }

  export type ParkingSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParkingSlot to aggregate.
     */
    where?: ParkingSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingSlots to fetch.
     */
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParkingSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParkingSlots
    **/
    _count?: true | ParkingSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParkingSlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParkingSlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParkingSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParkingSlotMaxAggregateInputType
  }

  export type GetParkingSlotAggregateType<T extends ParkingSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateParkingSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParkingSlot[P]>
      : GetScalarType<T[P], AggregateParkingSlot[P]>
  }




  export type ParkingSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingSlotWhereInput
    orderBy?: ParkingSlotOrderByWithAggregationInput | ParkingSlotOrderByWithAggregationInput[]
    by: ParkingSlotScalarFieldEnum[] | ParkingSlotScalarFieldEnum
    having?: ParkingSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParkingSlotCountAggregateInputType | true
    _avg?: ParkingSlotAvgAggregateInputType
    _sum?: ParkingSlotSumAggregateInputType
    _min?: ParkingSlotMinAggregateInputType
    _max?: ParkingSlotMaxAggregateInputType
  }

  export type ParkingSlotGroupByOutputType = {
    id: number
    number: string
    type: string
    status: string
    societyId: number
    allocatedToUnitId: number | null
    vehicleNumber: string | null
    createdAt: Date
    _count: ParkingSlotCountAggregateOutputType | null
    _avg: ParkingSlotAvgAggregateOutputType | null
    _sum: ParkingSlotSumAggregateOutputType | null
    _min: ParkingSlotMinAggregateOutputType | null
    _max: ParkingSlotMaxAggregateOutputType | null
  }

  type GetParkingSlotGroupByPayload<T extends ParkingSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParkingSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParkingSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParkingSlotGroupByOutputType[P]>
            : GetScalarType<T[P], ParkingSlotGroupByOutputType[P]>
        }
      >
    >


  export type ParkingSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    type?: boolean
    status?: boolean
    societyId?: boolean
    allocatedToUnitId?: boolean
    vehicleNumber?: boolean
    createdAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    unit?: boolean | ParkingSlot$unitArgs<ExtArgs>
  }, ExtArgs["result"]["parkingSlot"]>



  export type ParkingSlotSelectScalar = {
    id?: boolean
    number?: boolean
    type?: boolean
    status?: boolean
    societyId?: boolean
    allocatedToUnitId?: boolean
    vehicleNumber?: boolean
    createdAt?: boolean
  }

  export type ParkingSlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "type" | "status" | "societyId" | "allocatedToUnitId" | "vehicleNumber" | "createdAt", ExtArgs["result"]["parkingSlot"]>
  export type ParkingSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    unit?: boolean | ParkingSlot$unitArgs<ExtArgs>
  }

  export type $ParkingSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParkingSlot"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: string
      type: string
      status: string
      societyId: number
      allocatedToUnitId: number | null
      vehicleNumber: string | null
      createdAt: Date
    }, ExtArgs["result"]["parkingSlot"]>
    composites: {}
  }

  type ParkingSlotGetPayload<S extends boolean | null | undefined | ParkingSlotDefaultArgs> = $Result.GetResult<Prisma.$ParkingSlotPayload, S>

  type ParkingSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParkingSlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParkingSlotCountAggregateInputType | true
    }

  export interface ParkingSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParkingSlot'], meta: { name: 'ParkingSlot' } }
    /**
     * Find zero or one ParkingSlot that matches the filter.
     * @param {ParkingSlotFindUniqueArgs} args - Arguments to find a ParkingSlot
     * @example
     * // Get one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParkingSlotFindUniqueArgs>(args: SelectSubset<T, ParkingSlotFindUniqueArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParkingSlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParkingSlotFindUniqueOrThrowArgs} args - Arguments to find a ParkingSlot
     * @example
     * // Get one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParkingSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, ParkingSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParkingSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotFindFirstArgs} args - Arguments to find a ParkingSlot
     * @example
     * // Get one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParkingSlotFindFirstArgs>(args?: SelectSubset<T, ParkingSlotFindFirstArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParkingSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotFindFirstOrThrowArgs} args - Arguments to find a ParkingSlot
     * @example
     * // Get one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParkingSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, ParkingSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParkingSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParkingSlots
     * const parkingSlots = await prisma.parkingSlot.findMany()
     * 
     * // Get first 10 ParkingSlots
     * const parkingSlots = await prisma.parkingSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parkingSlotWithIdOnly = await prisma.parkingSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParkingSlotFindManyArgs>(args?: SelectSubset<T, ParkingSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParkingSlot.
     * @param {ParkingSlotCreateArgs} args - Arguments to create a ParkingSlot.
     * @example
     * // Create one ParkingSlot
     * const ParkingSlot = await prisma.parkingSlot.create({
     *   data: {
     *     // ... data to create a ParkingSlot
     *   }
     * })
     * 
     */
    create<T extends ParkingSlotCreateArgs>(args: SelectSubset<T, ParkingSlotCreateArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParkingSlots.
     * @param {ParkingSlotCreateManyArgs} args - Arguments to create many ParkingSlots.
     * @example
     * // Create many ParkingSlots
     * const parkingSlot = await prisma.parkingSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParkingSlotCreateManyArgs>(args?: SelectSubset<T, ParkingSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ParkingSlot.
     * @param {ParkingSlotDeleteArgs} args - Arguments to delete one ParkingSlot.
     * @example
     * // Delete one ParkingSlot
     * const ParkingSlot = await prisma.parkingSlot.delete({
     *   where: {
     *     // ... filter to delete one ParkingSlot
     *   }
     * })
     * 
     */
    delete<T extends ParkingSlotDeleteArgs>(args: SelectSubset<T, ParkingSlotDeleteArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParkingSlot.
     * @param {ParkingSlotUpdateArgs} args - Arguments to update one ParkingSlot.
     * @example
     * // Update one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParkingSlotUpdateArgs>(args: SelectSubset<T, ParkingSlotUpdateArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParkingSlots.
     * @param {ParkingSlotDeleteManyArgs} args - Arguments to filter ParkingSlots to delete.
     * @example
     * // Delete a few ParkingSlots
     * const { count } = await prisma.parkingSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParkingSlotDeleteManyArgs>(args?: SelectSubset<T, ParkingSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParkingSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParkingSlots
     * const parkingSlot = await prisma.parkingSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParkingSlotUpdateManyArgs>(args: SelectSubset<T, ParkingSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ParkingSlot.
     * @param {ParkingSlotUpsertArgs} args - Arguments to update or create a ParkingSlot.
     * @example
     * // Update or create a ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.upsert({
     *   create: {
     *     // ... data to create a ParkingSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParkingSlot we want to update
     *   }
     * })
     */
    upsert<T extends ParkingSlotUpsertArgs>(args: SelectSubset<T, ParkingSlotUpsertArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParkingSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotCountArgs} args - Arguments to filter ParkingSlots to count.
     * @example
     * // Count the number of ParkingSlots
     * const count = await prisma.parkingSlot.count({
     *   where: {
     *     // ... the filter for the ParkingSlots we want to count
     *   }
     * })
    **/
    count<T extends ParkingSlotCountArgs>(
      args?: Subset<T, ParkingSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParkingSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParkingSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParkingSlotAggregateArgs>(args: Subset<T, ParkingSlotAggregateArgs>): Prisma.PrismaPromise<GetParkingSlotAggregateType<T>>

    /**
     * Group by ParkingSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParkingSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParkingSlotGroupByArgs['orderBy'] }
        : { orderBy?: ParkingSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParkingSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParkingSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParkingSlot model
   */
  readonly fields: ParkingSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParkingSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParkingSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends ParkingSlot$unitArgs<ExtArgs> = {}>(args?: Subset<T, ParkingSlot$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParkingSlot model
   */
  interface ParkingSlotFieldRefs {
    readonly id: FieldRef<"ParkingSlot", 'Int'>
    readonly number: FieldRef<"ParkingSlot", 'String'>
    readonly type: FieldRef<"ParkingSlot", 'String'>
    readonly status: FieldRef<"ParkingSlot", 'String'>
    readonly societyId: FieldRef<"ParkingSlot", 'Int'>
    readonly allocatedToUnitId: FieldRef<"ParkingSlot", 'Int'>
    readonly vehicleNumber: FieldRef<"ParkingSlot", 'String'>
    readonly createdAt: FieldRef<"ParkingSlot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParkingSlot findUnique
   */
  export type ParkingSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlot to fetch.
     */
    where: ParkingSlotWhereUniqueInput
  }

  /**
   * ParkingSlot findUniqueOrThrow
   */
  export type ParkingSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlot to fetch.
     */
    where: ParkingSlotWhereUniqueInput
  }

  /**
   * ParkingSlot findFirst
   */
  export type ParkingSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlot to fetch.
     */
    where?: ParkingSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingSlots to fetch.
     */
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParkingSlots.
     */
    cursor?: ParkingSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParkingSlots.
     */
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * ParkingSlot findFirstOrThrow
   */
  export type ParkingSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlot to fetch.
     */
    where?: ParkingSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingSlots to fetch.
     */
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParkingSlots.
     */
    cursor?: ParkingSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParkingSlots.
     */
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * ParkingSlot findMany
   */
  export type ParkingSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlots to fetch.
     */
    where?: ParkingSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingSlots to fetch.
     */
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParkingSlots.
     */
    cursor?: ParkingSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingSlots.
     */
    skip?: number
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * ParkingSlot create
   */
  export type ParkingSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a ParkingSlot.
     */
    data: XOR<ParkingSlotCreateInput, ParkingSlotUncheckedCreateInput>
  }

  /**
   * ParkingSlot createMany
   */
  export type ParkingSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParkingSlots.
     */
    data: ParkingSlotCreateManyInput | ParkingSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParkingSlot update
   */
  export type ParkingSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a ParkingSlot.
     */
    data: XOR<ParkingSlotUpdateInput, ParkingSlotUncheckedUpdateInput>
    /**
     * Choose, which ParkingSlot to update.
     */
    where: ParkingSlotWhereUniqueInput
  }

  /**
   * ParkingSlot updateMany
   */
  export type ParkingSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParkingSlots.
     */
    data: XOR<ParkingSlotUpdateManyMutationInput, ParkingSlotUncheckedUpdateManyInput>
    /**
     * Filter which ParkingSlots to update
     */
    where?: ParkingSlotWhereInput
    /**
     * Limit how many ParkingSlots to update.
     */
    limit?: number
  }

  /**
   * ParkingSlot upsert
   */
  export type ParkingSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the ParkingSlot to update in case it exists.
     */
    where: ParkingSlotWhereUniqueInput
    /**
     * In case the ParkingSlot found by the `where` argument doesn't exist, create a new ParkingSlot with this data.
     */
    create: XOR<ParkingSlotCreateInput, ParkingSlotUncheckedCreateInput>
    /**
     * In case the ParkingSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParkingSlotUpdateInput, ParkingSlotUncheckedUpdateInput>
  }

  /**
   * ParkingSlot delete
   */
  export type ParkingSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter which ParkingSlot to delete.
     */
    where: ParkingSlotWhereUniqueInput
  }

  /**
   * ParkingSlot deleteMany
   */
  export type ParkingSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParkingSlots to delete
     */
    where?: ParkingSlotWhereInput
    /**
     * Limit how many ParkingSlots to delete.
     */
    limit?: number
  }

  /**
   * ParkingSlot.unit
   */
  export type ParkingSlot$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * ParkingSlot without action
   */
  export type ParkingSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
  }


  /**
   * Model Complaint
   */

  export type AggregateComplaint = {
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  export type ComplaintAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
    reportedById: number | null
    assignedToId: number | null
  }

  export type ComplaintSumAggregateOutputType = {
    id: number | null
    societyId: number | null
    reportedById: number | null
    assignedToId: number | null
  }

  export type ComplaintMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    category: string | null
    priority: $Enums.Priority | null
    status: $Enums.ComplaintStatus | null
    isPrivate: boolean | null
    escalatedToTech: boolean | null
    societyId: number | null
    reportedById: number | null
    assignedToId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplaintMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    category: string | null
    priority: $Enums.Priority | null
    status: $Enums.ComplaintStatus | null
    isPrivate: boolean | null
    escalatedToTech: boolean | null
    societyId: number | null
    reportedById: number | null
    assignedToId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplaintCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    priority: number
    status: number
    isPrivate: number
    escalatedToTech: number
    images: number
    societyId: number
    reportedById: number
    assignedToId: number
    timeline: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComplaintAvgAggregateInputType = {
    id?: true
    societyId?: true
    reportedById?: true
    assignedToId?: true
  }

  export type ComplaintSumAggregateInputType = {
    id?: true
    societyId?: true
    reportedById?: true
    assignedToId?: true
  }

  export type ComplaintMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    isPrivate?: true
    escalatedToTech?: true
    societyId?: true
    reportedById?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplaintMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    isPrivate?: true
    escalatedToTech?: true
    societyId?: true
    reportedById?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplaintCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    isPrivate?: true
    escalatedToTech?: true
    images?: true
    societyId?: true
    reportedById?: true
    assignedToId?: true
    timeline?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComplaintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaint to aggregate.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Complaints
    **/
    _count?: true | ComplaintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintMaxAggregateInputType
  }

  export type GetComplaintAggregateType<T extends ComplaintAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaint[P]>
      : GetScalarType<T[P], AggregateComplaint[P]>
  }




  export type ComplaintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithAggregationInput | ComplaintOrderByWithAggregationInput[]
    by: ComplaintScalarFieldEnum[] | ComplaintScalarFieldEnum
    having?: ComplaintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintCountAggregateInputType | true
    _avg?: ComplaintAvgAggregateInputType
    _sum?: ComplaintSumAggregateInputType
    _min?: ComplaintMinAggregateInputType
    _max?: ComplaintMaxAggregateInputType
  }

  export type ComplaintGroupByOutputType = {
    id: number
    title: string
    description: string
    category: string
    priority: $Enums.Priority
    status: $Enums.ComplaintStatus
    isPrivate: boolean
    escalatedToTech: boolean
    images: JsonValue | null
    societyId: number
    reportedById: number
    assignedToId: number | null
    timeline: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  type GetComplaintGroupByPayload<T extends ComplaintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    isPrivate?: boolean
    escalatedToTech?: boolean
    images?: boolean
    societyId?: boolean
    reportedById?: boolean
    assignedToId?: boolean
    timeline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Complaint$assignedToArgs<ExtArgs>
    comments?: boolean | Complaint$commentsArgs<ExtArgs>
    _count?: boolean | ComplaintCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaint"]>



  export type ComplaintSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    isPrivate?: boolean
    escalatedToTech?: boolean
    images?: boolean
    societyId?: boolean
    reportedById?: boolean
    assignedToId?: boolean
    timeline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComplaintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "category" | "priority" | "status" | "isPrivate" | "escalatedToTech" | "images" | "societyId" | "reportedById" | "assignedToId" | "timeline" | "createdAt" | "updatedAt", ExtArgs["result"]["complaint"]>
  export type ComplaintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Complaint$assignedToArgs<ExtArgs>
    comments?: boolean | Complaint$commentsArgs<ExtArgs>
    _count?: boolean | ComplaintCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ComplaintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Complaint"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      reportedBy: Prisma.$UserPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      comments: Prisma.$ComplaintCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      category: string
      priority: $Enums.Priority
      status: $Enums.ComplaintStatus
      isPrivate: boolean
      escalatedToTech: boolean
      images: Prisma.JsonValue | null
      societyId: number
      reportedById: number
      assignedToId: number | null
      timeline: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["complaint"]>
    composites: {}
  }

  type ComplaintGetPayload<S extends boolean | null | undefined | ComplaintDefaultArgs> = $Result.GetResult<Prisma.$ComplaintPayload, S>

  type ComplaintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplaintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplaintCountAggregateInputType | true
    }

  export interface ComplaintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Complaint'], meta: { name: 'Complaint' } }
    /**
     * Find zero or one Complaint that matches the filter.
     * @param {ComplaintFindUniqueArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintFindUniqueArgs>(args: SelectSubset<T, ComplaintFindUniqueArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Complaint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplaintFindUniqueOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintFindFirstArgs>(args?: SelectSubset<T, ComplaintFindFirstArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complaints
     * const complaints = await prisma.complaint.findMany()
     * 
     * // Get first 10 Complaints
     * const complaints = await prisma.complaint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintWithIdOnly = await prisma.complaint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplaintFindManyArgs>(args?: SelectSubset<T, ComplaintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Complaint.
     * @param {ComplaintCreateArgs} args - Arguments to create a Complaint.
     * @example
     * // Create one Complaint
     * const Complaint = await prisma.complaint.create({
     *   data: {
     *     // ... data to create a Complaint
     *   }
     * })
     * 
     */
    create<T extends ComplaintCreateArgs>(args: SelectSubset<T, ComplaintCreateArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Complaints.
     * @param {ComplaintCreateManyArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaint = await prisma.complaint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintCreateManyArgs>(args?: SelectSubset<T, ComplaintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Complaint.
     * @param {ComplaintDeleteArgs} args - Arguments to delete one Complaint.
     * @example
     * // Delete one Complaint
     * const Complaint = await prisma.complaint.delete({
     *   where: {
     *     // ... filter to delete one Complaint
     *   }
     * })
     * 
     */
    delete<T extends ComplaintDeleteArgs>(args: SelectSubset<T, ComplaintDeleteArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Complaint.
     * @param {ComplaintUpdateArgs} args - Arguments to update one Complaint.
     * @example
     * // Update one Complaint
     * const complaint = await prisma.complaint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintUpdateArgs>(args: SelectSubset<T, ComplaintUpdateArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Complaints.
     * @param {ComplaintDeleteManyArgs} args - Arguments to filter Complaints to delete.
     * @example
     * // Delete a few Complaints
     * const { count } = await prisma.complaint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintDeleteManyArgs>(args?: SelectSubset<T, ComplaintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complaints
     * const complaint = await prisma.complaint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintUpdateManyArgs>(args: SelectSubset<T, ComplaintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Complaint.
     * @param {ComplaintUpsertArgs} args - Arguments to update or create a Complaint.
     * @example
     * // Update or create a Complaint
     * const complaint = await prisma.complaint.upsert({
     *   create: {
     *     // ... data to create a Complaint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complaint we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintUpsertArgs>(args: SelectSubset<T, ComplaintUpsertArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCountArgs} args - Arguments to filter Complaints to count.
     * @example
     * // Count the number of Complaints
     * const count = await prisma.complaint.count({
     *   where: {
     *     // ... the filter for the Complaints we want to count
     *   }
     * })
    **/
    count<T extends ComplaintCountArgs>(
      args?: Subset<T, ComplaintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintAggregateArgs>(args: Subset<T, ComplaintAggregateArgs>): Prisma.PrismaPromise<GetComplaintAggregateType<T>>

    /**
     * Group by Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Complaint model
   */
  readonly fields: ComplaintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Complaint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reportedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends Complaint$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Complaint$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comments<T extends Complaint$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Complaint$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Complaint model
   */
  interface ComplaintFieldRefs {
    readonly id: FieldRef<"Complaint", 'Int'>
    readonly title: FieldRef<"Complaint", 'String'>
    readonly description: FieldRef<"Complaint", 'String'>
    readonly category: FieldRef<"Complaint", 'String'>
    readonly priority: FieldRef<"Complaint", 'Priority'>
    readonly status: FieldRef<"Complaint", 'ComplaintStatus'>
    readonly isPrivate: FieldRef<"Complaint", 'Boolean'>
    readonly escalatedToTech: FieldRef<"Complaint", 'Boolean'>
    readonly images: FieldRef<"Complaint", 'Json'>
    readonly societyId: FieldRef<"Complaint", 'Int'>
    readonly reportedById: FieldRef<"Complaint", 'Int'>
    readonly assignedToId: FieldRef<"Complaint", 'Int'>
    readonly timeline: FieldRef<"Complaint", 'Json'>
    readonly createdAt: FieldRef<"Complaint", 'DateTime'>
    readonly updatedAt: FieldRef<"Complaint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Complaint findUnique
   */
  export type ComplaintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint findUniqueOrThrow
   */
  export type ComplaintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint findFirst
   */
  export type ComplaintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint findFirstOrThrow
   */
  export type ComplaintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint findMany
   */
  export type ComplaintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaints to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint create
   */
  export type ComplaintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The data needed to create a Complaint.
     */
    data: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>
  }

  /**
   * Complaint createMany
   */
  export type ComplaintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Complaints.
     */
    data: ComplaintCreateManyInput | ComplaintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Complaint update
   */
  export type ComplaintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The data needed to update a Complaint.
     */
    data: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>
    /**
     * Choose, which Complaint to update.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint updateMany
   */
  export type ComplaintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Complaints.
     */
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyInput>
    /**
     * Filter which Complaints to update
     */
    where?: ComplaintWhereInput
    /**
     * Limit how many Complaints to update.
     */
    limit?: number
  }

  /**
   * Complaint upsert
   */
  export type ComplaintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The filter to search for the Complaint to update in case it exists.
     */
    where: ComplaintWhereUniqueInput
    /**
     * In case the Complaint found by the `where` argument doesn't exist, create a new Complaint with this data.
     */
    create: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>
    /**
     * In case the Complaint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>
  }

  /**
   * Complaint delete
   */
  export type ComplaintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter which Complaint to delete.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint deleteMany
   */
  export type ComplaintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaints to delete
     */
    where?: ComplaintWhereInput
    /**
     * Limit how many Complaints to delete.
     */
    limit?: number
  }

  /**
   * Complaint.assignedTo
   */
  export type Complaint$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Complaint.comments
   */
  export type Complaint$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    where?: ComplaintCommentWhereInput
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    cursor?: ComplaintCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintCommentScalarFieldEnum | ComplaintCommentScalarFieldEnum[]
  }

  /**
   * Complaint without action
   */
  export type ComplaintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
  }


  /**
   * Model ComplaintComment
   */

  export type AggregateComplaintComment = {
    _count: ComplaintCommentCountAggregateOutputType | null
    _avg: ComplaintCommentAvgAggregateOutputType | null
    _sum: ComplaintCommentSumAggregateOutputType | null
    _min: ComplaintCommentMinAggregateOutputType | null
    _max: ComplaintCommentMaxAggregateOutputType | null
  }

  export type ComplaintCommentAvgAggregateOutputType = {
    id: number | null
    complaintId: number | null
    userId: number | null
  }

  export type ComplaintCommentSumAggregateOutputType = {
    id: number | null
    complaintId: number | null
    userId: number | null
  }

  export type ComplaintCommentMinAggregateOutputType = {
    id: number | null
    complaintId: number | null
    userId: number | null
    message: string | null
    createdAt: Date | null
  }

  export type ComplaintCommentMaxAggregateOutputType = {
    id: number | null
    complaintId: number | null
    userId: number | null
    message: string | null
    createdAt: Date | null
  }

  export type ComplaintCommentCountAggregateOutputType = {
    id: number
    complaintId: number
    userId: number
    message: number
    createdAt: number
    _all: number
  }


  export type ComplaintCommentAvgAggregateInputType = {
    id?: true
    complaintId?: true
    userId?: true
  }

  export type ComplaintCommentSumAggregateInputType = {
    id?: true
    complaintId?: true
    userId?: true
  }

  export type ComplaintCommentMinAggregateInputType = {
    id?: true
    complaintId?: true
    userId?: true
    message?: true
    createdAt?: true
  }

  export type ComplaintCommentMaxAggregateInputType = {
    id?: true
    complaintId?: true
    userId?: true
    message?: true
    createdAt?: true
  }

  export type ComplaintCommentCountAggregateInputType = {
    id?: true
    complaintId?: true
    userId?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type ComplaintCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplaintComment to aggregate.
     */
    where?: ComplaintCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintComments to fetch.
     */
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplaintComments
    **/
    _count?: true | ComplaintCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintCommentMaxAggregateInputType
  }

  export type GetComplaintCommentAggregateType<T extends ComplaintCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaintComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaintComment[P]>
      : GetScalarType<T[P], AggregateComplaintComment[P]>
  }




  export type ComplaintCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintCommentWhereInput
    orderBy?: ComplaintCommentOrderByWithAggregationInput | ComplaintCommentOrderByWithAggregationInput[]
    by: ComplaintCommentScalarFieldEnum[] | ComplaintCommentScalarFieldEnum
    having?: ComplaintCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintCommentCountAggregateInputType | true
    _avg?: ComplaintCommentAvgAggregateInputType
    _sum?: ComplaintCommentSumAggregateInputType
    _min?: ComplaintCommentMinAggregateInputType
    _max?: ComplaintCommentMaxAggregateInputType
  }

  export type ComplaintCommentGroupByOutputType = {
    id: number
    complaintId: number
    userId: number
    message: string
    createdAt: Date
    _count: ComplaintCommentCountAggregateOutputType | null
    _avg: ComplaintCommentAvgAggregateOutputType | null
    _sum: ComplaintCommentSumAggregateOutputType | null
    _min: ComplaintCommentMinAggregateOutputType | null
    _max: ComplaintCommentMaxAggregateOutputType | null
  }

  type GetComplaintCommentGroupByPayload<T extends ComplaintCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintCommentGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    complaintId?: boolean
    userId?: boolean
    message?: boolean
    createdAt?: boolean
    complaint?: boolean | ComplaintDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaintComment"]>



  export type ComplaintCommentSelectScalar = {
    id?: boolean
    complaintId?: boolean
    userId?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type ComplaintCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "complaintId" | "userId" | "message" | "createdAt", ExtArgs["result"]["complaintComment"]>
  export type ComplaintCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaint?: boolean | ComplaintDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ComplaintCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplaintComment"
    objects: {
      complaint: Prisma.$ComplaintPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      complaintId: number
      userId: number
      message: string
      createdAt: Date
    }, ExtArgs["result"]["complaintComment"]>
    composites: {}
  }

  type ComplaintCommentGetPayload<S extends boolean | null | undefined | ComplaintCommentDefaultArgs> = $Result.GetResult<Prisma.$ComplaintCommentPayload, S>

  type ComplaintCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplaintCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplaintCommentCountAggregateInputType | true
    }

  export interface ComplaintCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplaintComment'], meta: { name: 'ComplaintComment' } }
    /**
     * Find zero or one ComplaintComment that matches the filter.
     * @param {ComplaintCommentFindUniqueArgs} args - Arguments to find a ComplaintComment
     * @example
     * // Get one ComplaintComment
     * const complaintComment = await prisma.complaintComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintCommentFindUniqueArgs>(args: SelectSubset<T, ComplaintCommentFindUniqueArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComplaintComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplaintCommentFindUniqueOrThrowArgs} args - Arguments to find a ComplaintComment
     * @example
     * // Get one ComplaintComment
     * const complaintComment = await prisma.complaintComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplaintComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentFindFirstArgs} args - Arguments to find a ComplaintComment
     * @example
     * // Get one ComplaintComment
     * const complaintComment = await prisma.complaintComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintCommentFindFirstArgs>(args?: SelectSubset<T, ComplaintCommentFindFirstArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplaintComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentFindFirstOrThrowArgs} args - Arguments to find a ComplaintComment
     * @example
     * // Get one ComplaintComment
     * const complaintComment = await prisma.complaintComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComplaintComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplaintComments
     * const complaintComments = await prisma.complaintComment.findMany()
     * 
     * // Get first 10 ComplaintComments
     * const complaintComments = await prisma.complaintComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintCommentWithIdOnly = await prisma.complaintComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplaintCommentFindManyArgs>(args?: SelectSubset<T, ComplaintCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComplaintComment.
     * @param {ComplaintCommentCreateArgs} args - Arguments to create a ComplaintComment.
     * @example
     * // Create one ComplaintComment
     * const ComplaintComment = await prisma.complaintComment.create({
     *   data: {
     *     // ... data to create a ComplaintComment
     *   }
     * })
     * 
     */
    create<T extends ComplaintCommentCreateArgs>(args: SelectSubset<T, ComplaintCommentCreateArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComplaintComments.
     * @param {ComplaintCommentCreateManyArgs} args - Arguments to create many ComplaintComments.
     * @example
     * // Create many ComplaintComments
     * const complaintComment = await prisma.complaintComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintCommentCreateManyArgs>(args?: SelectSubset<T, ComplaintCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ComplaintComment.
     * @param {ComplaintCommentDeleteArgs} args - Arguments to delete one ComplaintComment.
     * @example
     * // Delete one ComplaintComment
     * const ComplaintComment = await prisma.complaintComment.delete({
     *   where: {
     *     // ... filter to delete one ComplaintComment
     *   }
     * })
     * 
     */
    delete<T extends ComplaintCommentDeleteArgs>(args: SelectSubset<T, ComplaintCommentDeleteArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComplaintComment.
     * @param {ComplaintCommentUpdateArgs} args - Arguments to update one ComplaintComment.
     * @example
     * // Update one ComplaintComment
     * const complaintComment = await prisma.complaintComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintCommentUpdateArgs>(args: SelectSubset<T, ComplaintCommentUpdateArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComplaintComments.
     * @param {ComplaintCommentDeleteManyArgs} args - Arguments to filter ComplaintComments to delete.
     * @example
     * // Delete a few ComplaintComments
     * const { count } = await prisma.complaintComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintCommentDeleteManyArgs>(args?: SelectSubset<T, ComplaintCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplaintComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplaintComments
     * const complaintComment = await prisma.complaintComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintCommentUpdateManyArgs>(args: SelectSubset<T, ComplaintCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComplaintComment.
     * @param {ComplaintCommentUpsertArgs} args - Arguments to update or create a ComplaintComment.
     * @example
     * // Update or create a ComplaintComment
     * const complaintComment = await prisma.complaintComment.upsert({
     *   create: {
     *     // ... data to create a ComplaintComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplaintComment we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintCommentUpsertArgs>(args: SelectSubset<T, ComplaintCommentUpsertArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComplaintComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentCountArgs} args - Arguments to filter ComplaintComments to count.
     * @example
     * // Count the number of ComplaintComments
     * const count = await prisma.complaintComment.count({
     *   where: {
     *     // ... the filter for the ComplaintComments we want to count
     *   }
     * })
    **/
    count<T extends ComplaintCommentCountArgs>(
      args?: Subset<T, ComplaintCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplaintComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintCommentAggregateArgs>(args: Subset<T, ComplaintCommentAggregateArgs>): Prisma.PrismaPromise<GetComplaintCommentAggregateType<T>>

    /**
     * Group by ComplaintComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintCommentGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplaintComment model
   */
  readonly fields: ComplaintCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplaintComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    complaint<T extends ComplaintDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComplaintDefaultArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplaintComment model
   */
  interface ComplaintCommentFieldRefs {
    readonly id: FieldRef<"ComplaintComment", 'Int'>
    readonly complaintId: FieldRef<"ComplaintComment", 'Int'>
    readonly userId: FieldRef<"ComplaintComment", 'Int'>
    readonly message: FieldRef<"ComplaintComment", 'String'>
    readonly createdAt: FieldRef<"ComplaintComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplaintComment findUnique
   */
  export type ComplaintCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintComment to fetch.
     */
    where: ComplaintCommentWhereUniqueInput
  }

  /**
   * ComplaintComment findUniqueOrThrow
   */
  export type ComplaintCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintComment to fetch.
     */
    where: ComplaintCommentWhereUniqueInput
  }

  /**
   * ComplaintComment findFirst
   */
  export type ComplaintCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintComment to fetch.
     */
    where?: ComplaintCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintComments to fetch.
     */
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplaintComments.
     */
    cursor?: ComplaintCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplaintComments.
     */
    distinct?: ComplaintCommentScalarFieldEnum | ComplaintCommentScalarFieldEnum[]
  }

  /**
   * ComplaintComment findFirstOrThrow
   */
  export type ComplaintCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintComment to fetch.
     */
    where?: ComplaintCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintComments to fetch.
     */
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplaintComments.
     */
    cursor?: ComplaintCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplaintComments.
     */
    distinct?: ComplaintCommentScalarFieldEnum | ComplaintCommentScalarFieldEnum[]
  }

  /**
   * ComplaintComment findMany
   */
  export type ComplaintCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintComments to fetch.
     */
    where?: ComplaintCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintComments to fetch.
     */
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplaintComments.
     */
    cursor?: ComplaintCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintComments.
     */
    skip?: number
    distinct?: ComplaintCommentScalarFieldEnum | ComplaintCommentScalarFieldEnum[]
  }

  /**
   * ComplaintComment create
   */
  export type ComplaintCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ComplaintComment.
     */
    data: XOR<ComplaintCommentCreateInput, ComplaintCommentUncheckedCreateInput>
  }

  /**
   * ComplaintComment createMany
   */
  export type ComplaintCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplaintComments.
     */
    data: ComplaintCommentCreateManyInput | ComplaintCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplaintComment update
   */
  export type ComplaintCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ComplaintComment.
     */
    data: XOR<ComplaintCommentUpdateInput, ComplaintCommentUncheckedUpdateInput>
    /**
     * Choose, which ComplaintComment to update.
     */
    where: ComplaintCommentWhereUniqueInput
  }

  /**
   * ComplaintComment updateMany
   */
  export type ComplaintCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplaintComments.
     */
    data: XOR<ComplaintCommentUpdateManyMutationInput, ComplaintCommentUncheckedUpdateManyInput>
    /**
     * Filter which ComplaintComments to update
     */
    where?: ComplaintCommentWhereInput
    /**
     * Limit how many ComplaintComments to update.
     */
    limit?: number
  }

  /**
   * ComplaintComment upsert
   */
  export type ComplaintCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ComplaintComment to update in case it exists.
     */
    where: ComplaintCommentWhereUniqueInput
    /**
     * In case the ComplaintComment found by the `where` argument doesn't exist, create a new ComplaintComment with this data.
     */
    create: XOR<ComplaintCommentCreateInput, ComplaintCommentUncheckedCreateInput>
    /**
     * In case the ComplaintComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintCommentUpdateInput, ComplaintCommentUncheckedUpdateInput>
  }

  /**
   * ComplaintComment delete
   */
  export type ComplaintCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter which ComplaintComment to delete.
     */
    where: ComplaintCommentWhereUniqueInput
  }

  /**
   * ComplaintComment deleteMany
   */
  export type ComplaintCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplaintComments to delete
     */
    where?: ComplaintCommentWhereInput
    /**
     * Limit how many ComplaintComments to delete.
     */
    limit?: number
  }

  /**
   * ComplaintComment without action
   */
  export type ComplaintCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
  }


  /**
   * Model Visitor
   */

  export type AggregateVisitor = {
    _count: VisitorCountAggregateOutputType | null
    _avg: VisitorAvgAggregateOutputType | null
    _sum: VisitorSumAggregateOutputType | null
    _min: VisitorMinAggregateOutputType | null
    _max: VisitorMaxAggregateOutputType | null
  }

  export type VisitorAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
    visitingUnitId: number | null
  }

  export type VisitorSumAggregateOutputType = {
    id: number | null
    societyId: number | null
    visitingUnitId: number | null
  }

  export type VisitorMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    vehicleNo: string | null
    purpose: string | null
    photo: string | null
    status: $Enums.VisitorStatus | null
    entryTime: Date | null
    exitTime: Date | null
    societyId: number | null
    visitingUnitId: number | null
    idType: string | null
    idNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    vehicleNo: string | null
    purpose: string | null
    photo: string | null
    status: $Enums.VisitorStatus | null
    entryTime: Date | null
    exitTime: Date | null
    societyId: number | null
    visitingUnitId: number | null
    idType: string | null
    idNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitorCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    vehicleNo: number
    purpose: number
    photo: number
    status: number
    entryTime: number
    exitTime: number
    societyId: number
    visitingUnitId: number
    idType: number
    idNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VisitorAvgAggregateInputType = {
    id?: true
    societyId?: true
    visitingUnitId?: true
  }

  export type VisitorSumAggregateInputType = {
    id?: true
    societyId?: true
    visitingUnitId?: true
  }

  export type VisitorMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    vehicleNo?: true
    purpose?: true
    photo?: true
    status?: true
    entryTime?: true
    exitTime?: true
    societyId?: true
    visitingUnitId?: true
    idType?: true
    idNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitorMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    vehicleNo?: true
    purpose?: true
    photo?: true
    status?: true
    entryTime?: true
    exitTime?: true
    societyId?: true
    visitingUnitId?: true
    idType?: true
    idNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitorCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    vehicleNo?: true
    purpose?: true
    photo?: true
    status?: true
    entryTime?: true
    exitTime?: true
    societyId?: true
    visitingUnitId?: true
    idType?: true
    idNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VisitorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visitor to aggregate.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Visitors
    **/
    _count?: true | VisitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitorMaxAggregateInputType
  }

  export type GetVisitorAggregateType<T extends VisitorAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitor[P]>
      : GetScalarType<T[P], AggregateVisitor[P]>
  }




  export type VisitorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithAggregationInput | VisitorOrderByWithAggregationInput[]
    by: VisitorScalarFieldEnum[] | VisitorScalarFieldEnum
    having?: VisitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitorCountAggregateInputType | true
    _avg?: VisitorAvgAggregateInputType
    _sum?: VisitorSumAggregateInputType
    _min?: VisitorMinAggregateInputType
    _max?: VisitorMaxAggregateInputType
  }

  export type VisitorGroupByOutputType = {
    id: number
    name: string
    phone: string
    vehicleNo: string | null
    purpose: string
    photo: string | null
    status: $Enums.VisitorStatus
    entryTime: Date | null
    exitTime: Date | null
    societyId: number
    visitingUnitId: number
    idType: string | null
    idNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: VisitorCountAggregateOutputType | null
    _avg: VisitorAvgAggregateOutputType | null
    _sum: VisitorSumAggregateOutputType | null
    _min: VisitorMinAggregateOutputType | null
    _max: VisitorMaxAggregateOutputType | null
  }

  type GetVisitorGroupByPayload<T extends VisitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitorGroupByOutputType[P]>
            : GetScalarType<T[P], VisitorGroupByOutputType[P]>
        }
      >
    >


  export type VisitorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    vehicleNo?: boolean
    purpose?: boolean
    photo?: boolean
    status?: boolean
    entryTime?: boolean
    exitTime?: boolean
    societyId?: boolean
    visitingUnitId?: boolean
    idType?: boolean
    idNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitor"]>



  export type VisitorSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    vehicleNo?: boolean
    purpose?: boolean
    photo?: boolean
    status?: boolean
    entryTime?: boolean
    exitTime?: boolean
    societyId?: boolean
    visitingUnitId?: boolean
    idType?: boolean
    idNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VisitorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "vehicleNo" | "purpose" | "photo" | "status" | "entryTime" | "exitTime" | "societyId" | "visitingUnitId" | "idType" | "idNumber" | "createdAt" | "updatedAt", ExtArgs["result"]["visitor"]>
  export type VisitorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $VisitorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Visitor"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string
      vehicleNo: string | null
      purpose: string
      photo: string | null
      status: $Enums.VisitorStatus
      entryTime: Date | null
      exitTime: Date | null
      societyId: number
      visitingUnitId: number
      idType: string | null
      idNumber: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["visitor"]>
    composites: {}
  }

  type VisitorGetPayload<S extends boolean | null | undefined | VisitorDefaultArgs> = $Result.GetResult<Prisma.$VisitorPayload, S>

  type VisitorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisitorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisitorCountAggregateInputType | true
    }

  export interface VisitorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Visitor'], meta: { name: 'Visitor' } }
    /**
     * Find zero or one Visitor that matches the filter.
     * @param {VisitorFindUniqueArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitorFindUniqueArgs>(args: SelectSubset<T, VisitorFindUniqueArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Visitor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisitorFindUniqueOrThrowArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitorFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindFirstArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitorFindFirstArgs>(args?: SelectSubset<T, VisitorFindFirstArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visitor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindFirstOrThrowArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitorFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Visitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visitors
     * const visitors = await prisma.visitor.findMany()
     * 
     * // Get first 10 Visitors
     * const visitors = await prisma.visitor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitorWithIdOnly = await prisma.visitor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitorFindManyArgs>(args?: SelectSubset<T, VisitorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Visitor.
     * @param {VisitorCreateArgs} args - Arguments to create a Visitor.
     * @example
     * // Create one Visitor
     * const Visitor = await prisma.visitor.create({
     *   data: {
     *     // ... data to create a Visitor
     *   }
     * })
     * 
     */
    create<T extends VisitorCreateArgs>(args: SelectSubset<T, VisitorCreateArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Visitors.
     * @param {VisitorCreateManyArgs} args - Arguments to create many Visitors.
     * @example
     * // Create many Visitors
     * const visitor = await prisma.visitor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitorCreateManyArgs>(args?: SelectSubset<T, VisitorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Visitor.
     * @param {VisitorDeleteArgs} args - Arguments to delete one Visitor.
     * @example
     * // Delete one Visitor
     * const Visitor = await prisma.visitor.delete({
     *   where: {
     *     // ... filter to delete one Visitor
     *   }
     * })
     * 
     */
    delete<T extends VisitorDeleteArgs>(args: SelectSubset<T, VisitorDeleteArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Visitor.
     * @param {VisitorUpdateArgs} args - Arguments to update one Visitor.
     * @example
     * // Update one Visitor
     * const visitor = await prisma.visitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitorUpdateArgs>(args: SelectSubset<T, VisitorUpdateArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Visitors.
     * @param {VisitorDeleteManyArgs} args - Arguments to filter Visitors to delete.
     * @example
     * // Delete a few Visitors
     * const { count } = await prisma.visitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitorDeleteManyArgs>(args?: SelectSubset<T, VisitorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visitors
     * const visitor = await prisma.visitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitorUpdateManyArgs>(args: SelectSubset<T, VisitorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Visitor.
     * @param {VisitorUpsertArgs} args - Arguments to update or create a Visitor.
     * @example
     * // Update or create a Visitor
     * const visitor = await prisma.visitor.upsert({
     *   create: {
     *     // ... data to create a Visitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visitor we want to update
     *   }
     * })
     */
    upsert<T extends VisitorUpsertArgs>(args: SelectSubset<T, VisitorUpsertArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorCountArgs} args - Arguments to filter Visitors to count.
     * @example
     * // Count the number of Visitors
     * const count = await prisma.visitor.count({
     *   where: {
     *     // ... the filter for the Visitors we want to count
     *   }
     * })
    **/
    count<T extends VisitorCountArgs>(
      args?: Subset<T, VisitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitorAggregateArgs>(args: Subset<T, VisitorAggregateArgs>): Prisma.PrismaPromise<GetVisitorAggregateType<T>>

    /**
     * Group by Visitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitorGroupByArgs['orderBy'] }
        : { orderBy?: VisitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Visitor model
   */
  readonly fields: VisitorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Visitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Visitor model
   */
  interface VisitorFieldRefs {
    readonly id: FieldRef<"Visitor", 'Int'>
    readonly name: FieldRef<"Visitor", 'String'>
    readonly phone: FieldRef<"Visitor", 'String'>
    readonly vehicleNo: FieldRef<"Visitor", 'String'>
    readonly purpose: FieldRef<"Visitor", 'String'>
    readonly photo: FieldRef<"Visitor", 'String'>
    readonly status: FieldRef<"Visitor", 'VisitorStatus'>
    readonly entryTime: FieldRef<"Visitor", 'DateTime'>
    readonly exitTime: FieldRef<"Visitor", 'DateTime'>
    readonly societyId: FieldRef<"Visitor", 'Int'>
    readonly visitingUnitId: FieldRef<"Visitor", 'Int'>
    readonly idType: FieldRef<"Visitor", 'String'>
    readonly idNumber: FieldRef<"Visitor", 'String'>
    readonly createdAt: FieldRef<"Visitor", 'DateTime'>
    readonly updatedAt: FieldRef<"Visitor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Visitor findUnique
   */
  export type VisitorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor findUniqueOrThrow
   */
  export type VisitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor findFirst
   */
  export type VisitorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visitors.
     */
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor findFirstOrThrow
   */
  export type VisitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visitors.
     */
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor findMany
   */
  export type VisitorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitors to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor create
   */
  export type VisitorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * The data needed to create a Visitor.
     */
    data: XOR<VisitorCreateInput, VisitorUncheckedCreateInput>
  }

  /**
   * Visitor createMany
   */
  export type VisitorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Visitors.
     */
    data: VisitorCreateManyInput | VisitorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Visitor update
   */
  export type VisitorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * The data needed to update a Visitor.
     */
    data: XOR<VisitorUpdateInput, VisitorUncheckedUpdateInput>
    /**
     * Choose, which Visitor to update.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor updateMany
   */
  export type VisitorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Visitors.
     */
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyInput>
    /**
     * Filter which Visitors to update
     */
    where?: VisitorWhereInput
    /**
     * Limit how many Visitors to update.
     */
    limit?: number
  }

  /**
   * Visitor upsert
   */
  export type VisitorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * The filter to search for the Visitor to update in case it exists.
     */
    where: VisitorWhereUniqueInput
    /**
     * In case the Visitor found by the `where` argument doesn't exist, create a new Visitor with this data.
     */
    create: XOR<VisitorCreateInput, VisitorUncheckedCreateInput>
    /**
     * In case the Visitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitorUpdateInput, VisitorUncheckedUpdateInput>
  }

  /**
   * Visitor delete
   */
  export type VisitorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter which Visitor to delete.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor deleteMany
   */
  export type VisitorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visitors to delete
     */
    where?: VisitorWhereInput
    /**
     * Limit how many Visitors to delete.
     */
    limit?: number
  }

  /**
   * Visitor without action
   */
  export type VisitorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    societyId: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    amount: number | null
    societyId: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    type: $Enums.TransactionType | null
    category: string | null
    amount: number | null
    date: Date | null
    description: string | null
    paymentMethod: $Enums.PaymentMethod | null
    status: string | null
    societyId: number | null
    invoiceNo: string | null
    paidTo: string | null
    receivedFrom: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    type: $Enums.TransactionType | null
    category: string | null
    amount: number | null
    date: Date | null
    description: string | null
    paymentMethod: $Enums.PaymentMethod | null
    status: string | null
    societyId: number | null
    invoiceNo: string | null
    paidTo: string | null
    receivedFrom: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    type: number
    category: number
    amount: number
    date: number
    description: number
    paymentMethod: number
    status: number
    societyId: number
    invoiceNo: number
    paidTo: number
    receivedFrom: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    amount?: true
    societyId?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    amount?: true
    societyId?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    type?: true
    category?: true
    amount?: true
    date?: true
    description?: true
    paymentMethod?: true
    status?: true
    societyId?: true
    invoiceNo?: true
    paidTo?: true
    receivedFrom?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    type?: true
    category?: true
    amount?: true
    date?: true
    description?: true
    paymentMethod?: true
    status?: true
    societyId?: true
    invoiceNo?: true
    paidTo?: true
    receivedFrom?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    type?: true
    category?: true
    amount?: true
    date?: true
    description?: true
    paymentMethod?: true
    status?: true
    societyId?: true
    invoiceNo?: true
    paidTo?: true
    receivedFrom?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date
    description: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    societyId: number
    invoiceNo: string | null
    paidTo: string | null
    receivedFrom: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    paymentMethod?: boolean
    status?: boolean
    societyId?: boolean
    invoiceNo?: boolean
    paidTo?: boolean
    receivedFrom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>



  export type TransactionSelectScalar = {
    id?: boolean
    type?: boolean
    category?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    paymentMethod?: boolean
    status?: boolean
    societyId?: boolean
    invoiceNo?: boolean
    paidTo?: boolean
    receivedFrom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "category" | "amount" | "date" | "description" | "paymentMethod" | "status" | "societyId" | "invoiceNo" | "paidTo" | "receivedFrom" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.TransactionType
      category: string
      amount: number
      date: Date
      description: string | null
      paymentMethod: $Enums.PaymentMethod
      status: string
      societyId: number
      invoiceNo: string | null
      paidTo: string | null
      receivedFrom: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly category: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly date: FieldRef<"Transaction", 'DateTime'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly paymentMethod: FieldRef<"Transaction", 'PaymentMethod'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly societyId: FieldRef<"Transaction", 'Int'>
    readonly invoiceNo: FieldRef<"Transaction", 'String'>
    readonly paidTo: FieldRef<"Transaction", 'String'>
    readonly receivedFrom: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type VendorSumAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: number | null
    name: string | null
    serviceType: string | null
    contact: string | null
    email: string | null
    address: string | null
    status: $Enums.VendorStatus | null
    societyId: number | null
    createdAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    serviceType: string | null
    contact: string | null
    email: string | null
    address: string | null
    status: $Enums.VendorStatus | null
    societyId: number | null
    createdAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    name: number
    serviceType: number
    contact: number
    email: number
    address: number
    status: number
    societyId: number
    createdAt: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type VendorSumAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    name?: true
    serviceType?: true
    contact?: true
    email?: true
    address?: true
    status?: true
    societyId?: true
    createdAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    name?: true
    serviceType?: true
    contact?: true
    email?: true
    address?: true
    status?: true
    societyId?: true
    createdAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    name?: true
    serviceType?: true
    contact?: true
    email?: true
    address?: true
    status?: true
    societyId?: true
    createdAt?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: number
    name: string
    serviceType: string
    contact: string
    email: string | null
    address: string | null
    status: $Enums.VendorStatus
    societyId: number | null
    createdAt: Date
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    serviceType?: boolean
    contact?: boolean
    email?: boolean
    address?: boolean
    status?: boolean
    societyId?: boolean
    createdAt?: boolean
    society?: boolean | Vendor$societyArgs<ExtArgs>
    payouts?: boolean | Vendor$payoutsArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>



  export type VendorSelectScalar = {
    id?: boolean
    name?: boolean
    serviceType?: boolean
    contact?: boolean
    email?: boolean
    address?: boolean
    status?: boolean
    societyId?: boolean
    createdAt?: boolean
  }

  export type VendorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "serviceType" | "contact" | "email" | "address" | "status" | "societyId" | "createdAt", ExtArgs["result"]["vendor"]>
  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | Vendor$societyArgs<ExtArgs>
    payouts?: boolean | Vendor$payoutsArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs> | null
      payouts: Prisma.$VendorPayoutPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      serviceType: string
      contact: string
      email: string | null
      address: string | null
      status: $Enums.VendorStatus
      societyId: number | null
      createdAt: Date
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends Vendor$societyArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$societyArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payouts<T extends Vendor$payoutsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$payoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'Int'>
    readonly name: FieldRef<"Vendor", 'String'>
    readonly serviceType: FieldRef<"Vendor", 'String'>
    readonly contact: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly address: FieldRef<"Vendor", 'String'>
    readonly status: FieldRef<"Vendor", 'VendorStatus'>
    readonly societyId: FieldRef<"Vendor", 'Int'>
    readonly createdAt: FieldRef<"Vendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to delete.
     */
    limit?: number
  }

  /**
   * Vendor.society
   */
  export type Vendor$societyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    where?: SocietyWhereInput
  }

  /**
   * Vendor.payouts
   */
  export type Vendor$payoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    where?: VendorPayoutWhereInput
    orderBy?: VendorPayoutOrderByWithRelationInput | VendorPayoutOrderByWithRelationInput[]
    cursor?: VendorPayoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorPayoutScalarFieldEnum | VendorPayoutScalarFieldEnum[]
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model VendorPayout
   */

  export type AggregateVendorPayout = {
    _count: VendorPayoutCountAggregateOutputType | null
    _avg: VendorPayoutAvgAggregateOutputType | null
    _sum: VendorPayoutSumAggregateOutputType | null
    _min: VendorPayoutMinAggregateOutputType | null
    _max: VendorPayoutMaxAggregateOutputType | null
  }

  export type VendorPayoutAvgAggregateOutputType = {
    id: number | null
    vendorId: number | null
    societyId: number | null
    dealValue: number | null
    commissionPercent: number | null
    payableAmount: number | null
  }

  export type VendorPayoutSumAggregateOutputType = {
    id: number | null
    vendorId: number | null
    societyId: number | null
    dealValue: number | null
    commissionPercent: number | null
    payableAmount: number | null
  }

  export type VendorPayoutMinAggregateOutputType = {
    id: number | null
    vendorId: number | null
    vendorName: string | null
    societyId: number | null
    societyName: string | null
    dealValue: number | null
    commissionPercent: number | null
    payableAmount: number | null
    status: string | null
    remarks: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorPayoutMaxAggregateOutputType = {
    id: number | null
    vendorId: number | null
    vendorName: string | null
    societyId: number | null
    societyName: string | null
    dealValue: number | null
    commissionPercent: number | null
    payableAmount: number | null
    status: string | null
    remarks: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorPayoutCountAggregateOutputType = {
    id: number
    vendorId: number
    vendorName: number
    societyId: number
    societyName: number
    dealValue: number
    commissionPercent: number
    payableAmount: number
    status: number
    remarks: number
    date: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorPayoutAvgAggregateInputType = {
    id?: true
    vendorId?: true
    societyId?: true
    dealValue?: true
    commissionPercent?: true
    payableAmount?: true
  }

  export type VendorPayoutSumAggregateInputType = {
    id?: true
    vendorId?: true
    societyId?: true
    dealValue?: true
    commissionPercent?: true
    payableAmount?: true
  }

  export type VendorPayoutMinAggregateInputType = {
    id?: true
    vendorId?: true
    vendorName?: true
    societyId?: true
    societyName?: true
    dealValue?: true
    commissionPercent?: true
    payableAmount?: true
    status?: true
    remarks?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorPayoutMaxAggregateInputType = {
    id?: true
    vendorId?: true
    vendorName?: true
    societyId?: true
    societyName?: true
    dealValue?: true
    commissionPercent?: true
    payableAmount?: true
    status?: true
    remarks?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorPayoutCountAggregateInputType = {
    id?: true
    vendorId?: true
    vendorName?: true
    societyId?: true
    societyName?: true
    dealValue?: true
    commissionPercent?: true
    payableAmount?: true
    status?: true
    remarks?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorPayoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorPayout to aggregate.
     */
    where?: VendorPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorPayouts to fetch.
     */
    orderBy?: VendorPayoutOrderByWithRelationInput | VendorPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorPayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorPayouts
    **/
    _count?: true | VendorPayoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorPayoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorPayoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorPayoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorPayoutMaxAggregateInputType
  }

  export type GetVendorPayoutAggregateType<T extends VendorPayoutAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorPayout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorPayout[P]>
      : GetScalarType<T[P], AggregateVendorPayout[P]>
  }




  export type VendorPayoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorPayoutWhereInput
    orderBy?: VendorPayoutOrderByWithAggregationInput | VendorPayoutOrderByWithAggregationInput[]
    by: VendorPayoutScalarFieldEnum[] | VendorPayoutScalarFieldEnum
    having?: VendorPayoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorPayoutCountAggregateInputType | true
    _avg?: VendorPayoutAvgAggregateInputType
    _sum?: VendorPayoutSumAggregateInputType
    _min?: VendorPayoutMinAggregateInputType
    _max?: VendorPayoutMaxAggregateInputType
  }

  export type VendorPayoutGroupByOutputType = {
    id: number
    vendorId: number
    vendorName: string
    societyId: number | null
    societyName: string | null
    dealValue: number
    commissionPercent: number
    payableAmount: number
    status: string
    remarks: string | null
    date: Date
    createdAt: Date
    updatedAt: Date
    _count: VendorPayoutCountAggregateOutputType | null
    _avg: VendorPayoutAvgAggregateOutputType | null
    _sum: VendorPayoutSumAggregateOutputType | null
    _min: VendorPayoutMinAggregateOutputType | null
    _max: VendorPayoutMaxAggregateOutputType | null
  }

  type GetVendorPayoutGroupByPayload<T extends VendorPayoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorPayoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorPayoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorPayoutGroupByOutputType[P]>
            : GetScalarType<T[P], VendorPayoutGroupByOutputType[P]>
        }
      >
    >


  export type VendorPayoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    vendorName?: boolean
    societyId?: boolean
    societyName?: boolean
    dealValue?: boolean
    commissionPercent?: boolean
    payableAmount?: boolean
    status?: boolean
    remarks?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorPayout"]>



  export type VendorPayoutSelectScalar = {
    id?: boolean
    vendorId?: boolean
    vendorName?: boolean
    societyId?: boolean
    societyName?: boolean
    dealValue?: boolean
    commissionPercent?: boolean
    payableAmount?: boolean
    status?: boolean
    remarks?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorPayoutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendorId" | "vendorName" | "societyId" | "societyName" | "dealValue" | "commissionPercent" | "payableAmount" | "status" | "remarks" | "date" | "createdAt" | "updatedAt", ExtArgs["result"]["vendorPayout"]>
  export type VendorPayoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $VendorPayoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorPayout"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      vendorId: number
      vendorName: string
      societyId: number | null
      societyName: string | null
      dealValue: number
      commissionPercent: number
      payableAmount: number
      status: string
      remarks: string | null
      date: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendorPayout"]>
    composites: {}
  }

  type VendorPayoutGetPayload<S extends boolean | null | undefined | VendorPayoutDefaultArgs> = $Result.GetResult<Prisma.$VendorPayoutPayload, S>

  type VendorPayoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorPayoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorPayoutCountAggregateInputType | true
    }

  export interface VendorPayoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorPayout'], meta: { name: 'VendorPayout' } }
    /**
     * Find zero or one VendorPayout that matches the filter.
     * @param {VendorPayoutFindUniqueArgs} args - Arguments to find a VendorPayout
     * @example
     * // Get one VendorPayout
     * const vendorPayout = await prisma.vendorPayout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorPayoutFindUniqueArgs>(args: SelectSubset<T, VendorPayoutFindUniqueArgs<ExtArgs>>): Prisma__VendorPayoutClient<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorPayout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorPayoutFindUniqueOrThrowArgs} args - Arguments to find a VendorPayout
     * @example
     * // Get one VendorPayout
     * const vendorPayout = await prisma.vendorPayout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorPayoutFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorPayoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorPayoutClient<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorPayout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPayoutFindFirstArgs} args - Arguments to find a VendorPayout
     * @example
     * // Get one VendorPayout
     * const vendorPayout = await prisma.vendorPayout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorPayoutFindFirstArgs>(args?: SelectSubset<T, VendorPayoutFindFirstArgs<ExtArgs>>): Prisma__VendorPayoutClient<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorPayout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPayoutFindFirstOrThrowArgs} args - Arguments to find a VendorPayout
     * @example
     * // Get one VendorPayout
     * const vendorPayout = await prisma.vendorPayout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorPayoutFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorPayoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorPayoutClient<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorPayouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPayoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorPayouts
     * const vendorPayouts = await prisma.vendorPayout.findMany()
     * 
     * // Get first 10 VendorPayouts
     * const vendorPayouts = await prisma.vendorPayout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorPayoutWithIdOnly = await prisma.vendorPayout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorPayoutFindManyArgs>(args?: SelectSubset<T, VendorPayoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorPayout.
     * @param {VendorPayoutCreateArgs} args - Arguments to create a VendorPayout.
     * @example
     * // Create one VendorPayout
     * const VendorPayout = await prisma.vendorPayout.create({
     *   data: {
     *     // ... data to create a VendorPayout
     *   }
     * })
     * 
     */
    create<T extends VendorPayoutCreateArgs>(args: SelectSubset<T, VendorPayoutCreateArgs<ExtArgs>>): Prisma__VendorPayoutClient<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorPayouts.
     * @param {VendorPayoutCreateManyArgs} args - Arguments to create many VendorPayouts.
     * @example
     * // Create many VendorPayouts
     * const vendorPayout = await prisma.vendorPayout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorPayoutCreateManyArgs>(args?: SelectSubset<T, VendorPayoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VendorPayout.
     * @param {VendorPayoutDeleteArgs} args - Arguments to delete one VendorPayout.
     * @example
     * // Delete one VendorPayout
     * const VendorPayout = await prisma.vendorPayout.delete({
     *   where: {
     *     // ... filter to delete one VendorPayout
     *   }
     * })
     * 
     */
    delete<T extends VendorPayoutDeleteArgs>(args: SelectSubset<T, VendorPayoutDeleteArgs<ExtArgs>>): Prisma__VendorPayoutClient<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorPayout.
     * @param {VendorPayoutUpdateArgs} args - Arguments to update one VendorPayout.
     * @example
     * // Update one VendorPayout
     * const vendorPayout = await prisma.vendorPayout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorPayoutUpdateArgs>(args: SelectSubset<T, VendorPayoutUpdateArgs<ExtArgs>>): Prisma__VendorPayoutClient<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorPayouts.
     * @param {VendorPayoutDeleteManyArgs} args - Arguments to filter VendorPayouts to delete.
     * @example
     * // Delete a few VendorPayouts
     * const { count } = await prisma.vendorPayout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorPayoutDeleteManyArgs>(args?: SelectSubset<T, VendorPayoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorPayouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPayoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorPayouts
     * const vendorPayout = await prisma.vendorPayout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorPayoutUpdateManyArgs>(args: SelectSubset<T, VendorPayoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VendorPayout.
     * @param {VendorPayoutUpsertArgs} args - Arguments to update or create a VendorPayout.
     * @example
     * // Update or create a VendorPayout
     * const vendorPayout = await prisma.vendorPayout.upsert({
     *   create: {
     *     // ... data to create a VendorPayout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorPayout we want to update
     *   }
     * })
     */
    upsert<T extends VendorPayoutUpsertArgs>(args: SelectSubset<T, VendorPayoutUpsertArgs<ExtArgs>>): Prisma__VendorPayoutClient<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorPayouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPayoutCountArgs} args - Arguments to filter VendorPayouts to count.
     * @example
     * // Count the number of VendorPayouts
     * const count = await prisma.vendorPayout.count({
     *   where: {
     *     // ... the filter for the VendorPayouts we want to count
     *   }
     * })
    **/
    count<T extends VendorPayoutCountArgs>(
      args?: Subset<T, VendorPayoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorPayoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorPayout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPayoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorPayoutAggregateArgs>(args: Subset<T, VendorPayoutAggregateArgs>): Prisma.PrismaPromise<GetVendorPayoutAggregateType<T>>

    /**
     * Group by VendorPayout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPayoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorPayoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorPayoutGroupByArgs['orderBy'] }
        : { orderBy?: VendorPayoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorPayoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorPayoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorPayout model
   */
  readonly fields: VendorPayoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorPayout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorPayoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorPayout model
   */
  interface VendorPayoutFieldRefs {
    readonly id: FieldRef<"VendorPayout", 'Int'>
    readonly vendorId: FieldRef<"VendorPayout", 'Int'>
    readonly vendorName: FieldRef<"VendorPayout", 'String'>
    readonly societyId: FieldRef<"VendorPayout", 'Int'>
    readonly societyName: FieldRef<"VendorPayout", 'String'>
    readonly dealValue: FieldRef<"VendorPayout", 'Float'>
    readonly commissionPercent: FieldRef<"VendorPayout", 'Float'>
    readonly payableAmount: FieldRef<"VendorPayout", 'Float'>
    readonly status: FieldRef<"VendorPayout", 'String'>
    readonly remarks: FieldRef<"VendorPayout", 'String'>
    readonly date: FieldRef<"VendorPayout", 'DateTime'>
    readonly createdAt: FieldRef<"VendorPayout", 'DateTime'>
    readonly updatedAt: FieldRef<"VendorPayout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorPayout findUnique
   */
  export type VendorPayoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * Filter, which VendorPayout to fetch.
     */
    where: VendorPayoutWhereUniqueInput
  }

  /**
   * VendorPayout findUniqueOrThrow
   */
  export type VendorPayoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * Filter, which VendorPayout to fetch.
     */
    where: VendorPayoutWhereUniqueInput
  }

  /**
   * VendorPayout findFirst
   */
  export type VendorPayoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * Filter, which VendorPayout to fetch.
     */
    where?: VendorPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorPayouts to fetch.
     */
    orderBy?: VendorPayoutOrderByWithRelationInput | VendorPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorPayouts.
     */
    cursor?: VendorPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorPayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorPayouts.
     */
    distinct?: VendorPayoutScalarFieldEnum | VendorPayoutScalarFieldEnum[]
  }

  /**
   * VendorPayout findFirstOrThrow
   */
  export type VendorPayoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * Filter, which VendorPayout to fetch.
     */
    where?: VendorPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorPayouts to fetch.
     */
    orderBy?: VendorPayoutOrderByWithRelationInput | VendorPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorPayouts.
     */
    cursor?: VendorPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorPayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorPayouts.
     */
    distinct?: VendorPayoutScalarFieldEnum | VendorPayoutScalarFieldEnum[]
  }

  /**
   * VendorPayout findMany
   */
  export type VendorPayoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * Filter, which VendorPayouts to fetch.
     */
    where?: VendorPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorPayouts to fetch.
     */
    orderBy?: VendorPayoutOrderByWithRelationInput | VendorPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorPayouts.
     */
    cursor?: VendorPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorPayouts.
     */
    skip?: number
    distinct?: VendorPayoutScalarFieldEnum | VendorPayoutScalarFieldEnum[]
  }

  /**
   * VendorPayout create
   */
  export type VendorPayoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorPayout.
     */
    data: XOR<VendorPayoutCreateInput, VendorPayoutUncheckedCreateInput>
  }

  /**
   * VendorPayout createMany
   */
  export type VendorPayoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorPayouts.
     */
    data: VendorPayoutCreateManyInput | VendorPayoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorPayout update
   */
  export type VendorPayoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorPayout.
     */
    data: XOR<VendorPayoutUpdateInput, VendorPayoutUncheckedUpdateInput>
    /**
     * Choose, which VendorPayout to update.
     */
    where: VendorPayoutWhereUniqueInput
  }

  /**
   * VendorPayout updateMany
   */
  export type VendorPayoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorPayouts.
     */
    data: XOR<VendorPayoutUpdateManyMutationInput, VendorPayoutUncheckedUpdateManyInput>
    /**
     * Filter which VendorPayouts to update
     */
    where?: VendorPayoutWhereInput
    /**
     * Limit how many VendorPayouts to update.
     */
    limit?: number
  }

  /**
   * VendorPayout upsert
   */
  export type VendorPayoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorPayout to update in case it exists.
     */
    where: VendorPayoutWhereUniqueInput
    /**
     * In case the VendorPayout found by the `where` argument doesn't exist, create a new VendorPayout with this data.
     */
    create: XOR<VendorPayoutCreateInput, VendorPayoutUncheckedCreateInput>
    /**
     * In case the VendorPayout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorPayoutUpdateInput, VendorPayoutUncheckedUpdateInput>
  }

  /**
   * VendorPayout delete
   */
  export type VendorPayoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * Filter which VendorPayout to delete.
     */
    where: VendorPayoutWhereUniqueInput
  }

  /**
   * VendorPayout deleteMany
   */
  export type VendorPayoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorPayouts to delete
     */
    where?: VendorPayoutWhereInput
    /**
     * Limit how many VendorPayouts to delete.
     */
    limit?: number
  }

  /**
   * VendorPayout without action
   */
  export type VendorPayoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
  }


  /**
   * Model EmergencyLog
   */

  export type AggregateEmergencyLog = {
    _count: EmergencyLogCountAggregateOutputType | null
    _avg: EmergencyLogAvgAggregateOutputType | null
    _sum: EmergencyLogSumAggregateOutputType | null
    _min: EmergencyLogMinAggregateOutputType | null
    _max: EmergencyLogMaxAggregateOutputType | null
  }

  export type EmergencyLogAvgAggregateOutputType = {
    societyId: number | null
  }

  export type EmergencyLogSumAggregateOutputType = {
    societyId: number | null
  }

  export type EmergencyLogMinAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    visitorName: string | null
    visitorPhone: string | null
    residentName: string | null
    unit: string | null
    isEmergency: boolean | null
    reason: string | null
    barcodeId: string | null
    societyId: number | null
  }

  export type EmergencyLogMaxAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    visitorName: string | null
    visitorPhone: string | null
    residentName: string | null
    unit: string | null
    isEmergency: boolean | null
    reason: string | null
    barcodeId: string | null
    societyId: number | null
  }

  export type EmergencyLogCountAggregateOutputType = {
    id: number
    timestamp: number
    visitorName: number
    visitorPhone: number
    residentName: number
    unit: number
    isEmergency: number
    reason: number
    barcodeId: number
    societyId: number
    _all: number
  }


  export type EmergencyLogAvgAggregateInputType = {
    societyId?: true
  }

  export type EmergencyLogSumAggregateInputType = {
    societyId?: true
  }

  export type EmergencyLogMinAggregateInputType = {
    id?: true
    timestamp?: true
    visitorName?: true
    visitorPhone?: true
    residentName?: true
    unit?: true
    isEmergency?: true
    reason?: true
    barcodeId?: true
    societyId?: true
  }

  export type EmergencyLogMaxAggregateInputType = {
    id?: true
    timestamp?: true
    visitorName?: true
    visitorPhone?: true
    residentName?: true
    unit?: true
    isEmergency?: true
    reason?: true
    barcodeId?: true
    societyId?: true
  }

  export type EmergencyLogCountAggregateInputType = {
    id?: true
    timestamp?: true
    visitorName?: true
    visitorPhone?: true
    residentName?: true
    unit?: true
    isEmergency?: true
    reason?: true
    barcodeId?: true
    societyId?: true
    _all?: true
  }

  export type EmergencyLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyLog to aggregate.
     */
    where?: EmergencyLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyLogs to fetch.
     */
    orderBy?: EmergencyLogOrderByWithRelationInput | EmergencyLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmergencyLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmergencyLogs
    **/
    _count?: true | EmergencyLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmergencyLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmergencyLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmergencyLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmergencyLogMaxAggregateInputType
  }

  export type GetEmergencyLogAggregateType<T extends EmergencyLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEmergencyLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmergencyLog[P]>
      : GetScalarType<T[P], AggregateEmergencyLog[P]>
  }




  export type EmergencyLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyLogWhereInput
    orderBy?: EmergencyLogOrderByWithAggregationInput | EmergencyLogOrderByWithAggregationInput[]
    by: EmergencyLogScalarFieldEnum[] | EmergencyLogScalarFieldEnum
    having?: EmergencyLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmergencyLogCountAggregateInputType | true
    _avg?: EmergencyLogAvgAggregateInputType
    _sum?: EmergencyLogSumAggregateInputType
    _min?: EmergencyLogMinAggregateInputType
    _max?: EmergencyLogMaxAggregateInputType
  }

  export type EmergencyLogGroupByOutputType = {
    id: string
    timestamp: Date
    visitorName: string
    visitorPhone: string
    residentName: string
    unit: string
    isEmergency: boolean
    reason: string | null
    barcodeId: string
    societyId: number | null
    _count: EmergencyLogCountAggregateOutputType | null
    _avg: EmergencyLogAvgAggregateOutputType | null
    _sum: EmergencyLogSumAggregateOutputType | null
    _min: EmergencyLogMinAggregateOutputType | null
    _max: EmergencyLogMaxAggregateOutputType | null
  }

  type GetEmergencyLogGroupByPayload<T extends EmergencyLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmergencyLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmergencyLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmergencyLogGroupByOutputType[P]>
            : GetScalarType<T[P], EmergencyLogGroupByOutputType[P]>
        }
      >
    >


  export type EmergencyLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    visitorName?: boolean
    visitorPhone?: boolean
    residentName?: boolean
    unit?: boolean
    isEmergency?: boolean
    reason?: boolean
    barcodeId?: boolean
    societyId?: boolean
  }, ExtArgs["result"]["emergencyLog"]>



  export type EmergencyLogSelectScalar = {
    id?: boolean
    timestamp?: boolean
    visitorName?: boolean
    visitorPhone?: boolean
    residentName?: boolean
    unit?: boolean
    isEmergency?: boolean
    reason?: boolean
    barcodeId?: boolean
    societyId?: boolean
  }

  export type EmergencyLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "visitorName" | "visitorPhone" | "residentName" | "unit" | "isEmergency" | "reason" | "barcodeId" | "societyId", ExtArgs["result"]["emergencyLog"]>

  export type $EmergencyLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmergencyLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: Date
      visitorName: string
      visitorPhone: string
      residentName: string
      unit: string
      isEmergency: boolean
      reason: string | null
      barcodeId: string
      societyId: number | null
    }, ExtArgs["result"]["emergencyLog"]>
    composites: {}
  }

  type EmergencyLogGetPayload<S extends boolean | null | undefined | EmergencyLogDefaultArgs> = $Result.GetResult<Prisma.$EmergencyLogPayload, S>

  type EmergencyLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmergencyLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmergencyLogCountAggregateInputType | true
    }

  export interface EmergencyLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmergencyLog'], meta: { name: 'EmergencyLog' } }
    /**
     * Find zero or one EmergencyLog that matches the filter.
     * @param {EmergencyLogFindUniqueArgs} args - Arguments to find a EmergencyLog
     * @example
     * // Get one EmergencyLog
     * const emergencyLog = await prisma.emergencyLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmergencyLogFindUniqueArgs>(args: SelectSubset<T, EmergencyLogFindUniqueArgs<ExtArgs>>): Prisma__EmergencyLogClient<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmergencyLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmergencyLogFindUniqueOrThrowArgs} args - Arguments to find a EmergencyLog
     * @example
     * // Get one EmergencyLog
     * const emergencyLog = await prisma.emergencyLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmergencyLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EmergencyLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmergencyLogClient<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyLogFindFirstArgs} args - Arguments to find a EmergencyLog
     * @example
     * // Get one EmergencyLog
     * const emergencyLog = await prisma.emergencyLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmergencyLogFindFirstArgs>(args?: SelectSubset<T, EmergencyLogFindFirstArgs<ExtArgs>>): Prisma__EmergencyLogClient<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyLogFindFirstOrThrowArgs} args - Arguments to find a EmergencyLog
     * @example
     * // Get one EmergencyLog
     * const emergencyLog = await prisma.emergencyLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmergencyLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EmergencyLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmergencyLogClient<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmergencyLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmergencyLogs
     * const emergencyLogs = await prisma.emergencyLog.findMany()
     * 
     * // Get first 10 EmergencyLogs
     * const emergencyLogs = await prisma.emergencyLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emergencyLogWithIdOnly = await prisma.emergencyLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmergencyLogFindManyArgs>(args?: SelectSubset<T, EmergencyLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmergencyLog.
     * @param {EmergencyLogCreateArgs} args - Arguments to create a EmergencyLog.
     * @example
     * // Create one EmergencyLog
     * const EmergencyLog = await prisma.emergencyLog.create({
     *   data: {
     *     // ... data to create a EmergencyLog
     *   }
     * })
     * 
     */
    create<T extends EmergencyLogCreateArgs>(args: SelectSubset<T, EmergencyLogCreateArgs<ExtArgs>>): Prisma__EmergencyLogClient<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmergencyLogs.
     * @param {EmergencyLogCreateManyArgs} args - Arguments to create many EmergencyLogs.
     * @example
     * // Create many EmergencyLogs
     * const emergencyLog = await prisma.emergencyLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmergencyLogCreateManyArgs>(args?: SelectSubset<T, EmergencyLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmergencyLog.
     * @param {EmergencyLogDeleteArgs} args - Arguments to delete one EmergencyLog.
     * @example
     * // Delete one EmergencyLog
     * const EmergencyLog = await prisma.emergencyLog.delete({
     *   where: {
     *     // ... filter to delete one EmergencyLog
     *   }
     * })
     * 
     */
    delete<T extends EmergencyLogDeleteArgs>(args: SelectSubset<T, EmergencyLogDeleteArgs<ExtArgs>>): Prisma__EmergencyLogClient<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmergencyLog.
     * @param {EmergencyLogUpdateArgs} args - Arguments to update one EmergencyLog.
     * @example
     * // Update one EmergencyLog
     * const emergencyLog = await prisma.emergencyLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmergencyLogUpdateArgs>(args: SelectSubset<T, EmergencyLogUpdateArgs<ExtArgs>>): Prisma__EmergencyLogClient<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmergencyLogs.
     * @param {EmergencyLogDeleteManyArgs} args - Arguments to filter EmergencyLogs to delete.
     * @example
     * // Delete a few EmergencyLogs
     * const { count } = await prisma.emergencyLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmergencyLogDeleteManyArgs>(args?: SelectSubset<T, EmergencyLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmergencyLogs
     * const emergencyLog = await prisma.emergencyLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmergencyLogUpdateManyArgs>(args: SelectSubset<T, EmergencyLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmergencyLog.
     * @param {EmergencyLogUpsertArgs} args - Arguments to update or create a EmergencyLog.
     * @example
     * // Update or create a EmergencyLog
     * const emergencyLog = await prisma.emergencyLog.upsert({
     *   create: {
     *     // ... data to create a EmergencyLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmergencyLog we want to update
     *   }
     * })
     */
    upsert<T extends EmergencyLogUpsertArgs>(args: SelectSubset<T, EmergencyLogUpsertArgs<ExtArgs>>): Prisma__EmergencyLogClient<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmergencyLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyLogCountArgs} args - Arguments to filter EmergencyLogs to count.
     * @example
     * // Count the number of EmergencyLogs
     * const count = await prisma.emergencyLog.count({
     *   where: {
     *     // ... the filter for the EmergencyLogs we want to count
     *   }
     * })
    **/
    count<T extends EmergencyLogCountArgs>(
      args?: Subset<T, EmergencyLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmergencyLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmergencyLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmergencyLogAggregateArgs>(args: Subset<T, EmergencyLogAggregateArgs>): Prisma.PrismaPromise<GetEmergencyLogAggregateType<T>>

    /**
     * Group by EmergencyLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmergencyLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmergencyLogGroupByArgs['orderBy'] }
        : { orderBy?: EmergencyLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmergencyLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmergencyLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmergencyLog model
   */
  readonly fields: EmergencyLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmergencyLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmergencyLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmergencyLog model
   */
  interface EmergencyLogFieldRefs {
    readonly id: FieldRef<"EmergencyLog", 'String'>
    readonly timestamp: FieldRef<"EmergencyLog", 'DateTime'>
    readonly visitorName: FieldRef<"EmergencyLog", 'String'>
    readonly visitorPhone: FieldRef<"EmergencyLog", 'String'>
    readonly residentName: FieldRef<"EmergencyLog", 'String'>
    readonly unit: FieldRef<"EmergencyLog", 'String'>
    readonly isEmergency: FieldRef<"EmergencyLog", 'Boolean'>
    readonly reason: FieldRef<"EmergencyLog", 'String'>
    readonly barcodeId: FieldRef<"EmergencyLog", 'String'>
    readonly societyId: FieldRef<"EmergencyLog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EmergencyLog findUnique
   */
  export type EmergencyLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyLog to fetch.
     */
    where: EmergencyLogWhereUniqueInput
  }

  /**
   * EmergencyLog findUniqueOrThrow
   */
  export type EmergencyLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyLog to fetch.
     */
    where: EmergencyLogWhereUniqueInput
  }

  /**
   * EmergencyLog findFirst
   */
  export type EmergencyLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyLog to fetch.
     */
    where?: EmergencyLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyLogs to fetch.
     */
    orderBy?: EmergencyLogOrderByWithRelationInput | EmergencyLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyLogs.
     */
    cursor?: EmergencyLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyLogs.
     */
    distinct?: EmergencyLogScalarFieldEnum | EmergencyLogScalarFieldEnum[]
  }

  /**
   * EmergencyLog findFirstOrThrow
   */
  export type EmergencyLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyLog to fetch.
     */
    where?: EmergencyLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyLogs to fetch.
     */
    orderBy?: EmergencyLogOrderByWithRelationInput | EmergencyLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyLogs.
     */
    cursor?: EmergencyLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyLogs.
     */
    distinct?: EmergencyLogScalarFieldEnum | EmergencyLogScalarFieldEnum[]
  }

  /**
   * EmergencyLog findMany
   */
  export type EmergencyLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyLogs to fetch.
     */
    where?: EmergencyLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyLogs to fetch.
     */
    orderBy?: EmergencyLogOrderByWithRelationInput | EmergencyLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmergencyLogs.
     */
    cursor?: EmergencyLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyLogs.
     */
    skip?: number
    distinct?: EmergencyLogScalarFieldEnum | EmergencyLogScalarFieldEnum[]
  }

  /**
   * EmergencyLog create
   */
  export type EmergencyLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * The data needed to create a EmergencyLog.
     */
    data: XOR<EmergencyLogCreateInput, EmergencyLogUncheckedCreateInput>
  }

  /**
   * EmergencyLog createMany
   */
  export type EmergencyLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmergencyLogs.
     */
    data: EmergencyLogCreateManyInput | EmergencyLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmergencyLog update
   */
  export type EmergencyLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * The data needed to update a EmergencyLog.
     */
    data: XOR<EmergencyLogUpdateInput, EmergencyLogUncheckedUpdateInput>
    /**
     * Choose, which EmergencyLog to update.
     */
    where: EmergencyLogWhereUniqueInput
  }

  /**
   * EmergencyLog updateMany
   */
  export type EmergencyLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmergencyLogs.
     */
    data: XOR<EmergencyLogUpdateManyMutationInput, EmergencyLogUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyLogs to update
     */
    where?: EmergencyLogWhereInput
    /**
     * Limit how many EmergencyLogs to update.
     */
    limit?: number
  }

  /**
   * EmergencyLog upsert
   */
  export type EmergencyLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * The filter to search for the EmergencyLog to update in case it exists.
     */
    where: EmergencyLogWhereUniqueInput
    /**
     * In case the EmergencyLog found by the `where` argument doesn't exist, create a new EmergencyLog with this data.
     */
    create: XOR<EmergencyLogCreateInput, EmergencyLogUncheckedCreateInput>
    /**
     * In case the EmergencyLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmergencyLogUpdateInput, EmergencyLogUncheckedUpdateInput>
  }

  /**
   * EmergencyLog delete
   */
  export type EmergencyLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * Filter which EmergencyLog to delete.
     */
    where: EmergencyLogWhereUniqueInput
  }

  /**
   * EmergencyLog deleteMany
   */
  export type EmergencyLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyLogs to delete
     */
    where?: EmergencyLogWhereInput
    /**
     * Limit how many EmergencyLogs to delete.
     */
    limit?: number
  }

  /**
   * EmergencyLog without action
   */
  export type EmergencyLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
  }


  /**
   * Model EmergencyBarcode
   */

  export type AggregateEmergencyBarcode = {
    _count: EmergencyBarcodeCountAggregateOutputType | null
    _avg: EmergencyBarcodeAvgAggregateOutputType | null
    _sum: EmergencyBarcodeSumAggregateOutputType | null
    _min: EmergencyBarcodeMinAggregateOutputType | null
    _max: EmergencyBarcodeMaxAggregateOutputType | null
  }

  export type EmergencyBarcodeAvgAggregateOutputType = {
    societyId: number | null
  }

  export type EmergencyBarcodeSumAggregateOutputType = {
    societyId: number | null
  }

  export type EmergencyBarcodeMinAggregateOutputType = {
    id: string | null
    residentName: string | null
    unit: string | null
    phone: string | null
    label: string | null
    type: string | null
    status: string | null
    qrCodeUrl: string | null
    createdAt: Date | null
    societyId: number | null
  }

  export type EmergencyBarcodeMaxAggregateOutputType = {
    id: string | null
    residentName: string | null
    unit: string | null
    phone: string | null
    label: string | null
    type: string | null
    status: string | null
    qrCodeUrl: string | null
    createdAt: Date | null
    societyId: number | null
  }

  export type EmergencyBarcodeCountAggregateOutputType = {
    id: number
    residentName: number
    unit: number
    phone: number
    label: number
    type: number
    status: number
    qrCodeUrl: number
    createdAt: number
    societyId: number
    _all: number
  }


  export type EmergencyBarcodeAvgAggregateInputType = {
    societyId?: true
  }

  export type EmergencyBarcodeSumAggregateInputType = {
    societyId?: true
  }

  export type EmergencyBarcodeMinAggregateInputType = {
    id?: true
    residentName?: true
    unit?: true
    phone?: true
    label?: true
    type?: true
    status?: true
    qrCodeUrl?: true
    createdAt?: true
    societyId?: true
  }

  export type EmergencyBarcodeMaxAggregateInputType = {
    id?: true
    residentName?: true
    unit?: true
    phone?: true
    label?: true
    type?: true
    status?: true
    qrCodeUrl?: true
    createdAt?: true
    societyId?: true
  }

  export type EmergencyBarcodeCountAggregateInputType = {
    id?: true
    residentName?: true
    unit?: true
    phone?: true
    label?: true
    type?: true
    status?: true
    qrCodeUrl?: true
    createdAt?: true
    societyId?: true
    _all?: true
  }

  export type EmergencyBarcodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyBarcode to aggregate.
     */
    where?: EmergencyBarcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyBarcodes to fetch.
     */
    orderBy?: EmergencyBarcodeOrderByWithRelationInput | EmergencyBarcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmergencyBarcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyBarcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyBarcodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmergencyBarcodes
    **/
    _count?: true | EmergencyBarcodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmergencyBarcodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmergencyBarcodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmergencyBarcodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmergencyBarcodeMaxAggregateInputType
  }

  export type GetEmergencyBarcodeAggregateType<T extends EmergencyBarcodeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmergencyBarcode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmergencyBarcode[P]>
      : GetScalarType<T[P], AggregateEmergencyBarcode[P]>
  }




  export type EmergencyBarcodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyBarcodeWhereInput
    orderBy?: EmergencyBarcodeOrderByWithAggregationInput | EmergencyBarcodeOrderByWithAggregationInput[]
    by: EmergencyBarcodeScalarFieldEnum[] | EmergencyBarcodeScalarFieldEnum
    having?: EmergencyBarcodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmergencyBarcodeCountAggregateInputType | true
    _avg?: EmergencyBarcodeAvgAggregateInputType
    _sum?: EmergencyBarcodeSumAggregateInputType
    _min?: EmergencyBarcodeMinAggregateInputType
    _max?: EmergencyBarcodeMaxAggregateInputType
  }

  export type EmergencyBarcodeGroupByOutputType = {
    id: string
    residentName: string
    unit: string
    phone: string
    label: string | null
    type: string | null
    status: string
    qrCodeUrl: string
    createdAt: Date
    societyId: number | null
    _count: EmergencyBarcodeCountAggregateOutputType | null
    _avg: EmergencyBarcodeAvgAggregateOutputType | null
    _sum: EmergencyBarcodeSumAggregateOutputType | null
    _min: EmergencyBarcodeMinAggregateOutputType | null
    _max: EmergencyBarcodeMaxAggregateOutputType | null
  }

  type GetEmergencyBarcodeGroupByPayload<T extends EmergencyBarcodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmergencyBarcodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmergencyBarcodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmergencyBarcodeGroupByOutputType[P]>
            : GetScalarType<T[P], EmergencyBarcodeGroupByOutputType[P]>
        }
      >
    >


  export type EmergencyBarcodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    residentName?: boolean
    unit?: boolean
    phone?: boolean
    label?: boolean
    type?: boolean
    status?: boolean
    qrCodeUrl?: boolean
    createdAt?: boolean
    societyId?: boolean
  }, ExtArgs["result"]["emergencyBarcode"]>



  export type EmergencyBarcodeSelectScalar = {
    id?: boolean
    residentName?: boolean
    unit?: boolean
    phone?: boolean
    label?: boolean
    type?: boolean
    status?: boolean
    qrCodeUrl?: boolean
    createdAt?: boolean
    societyId?: boolean
  }

  export type EmergencyBarcodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "residentName" | "unit" | "phone" | "label" | "type" | "status" | "qrCodeUrl" | "createdAt" | "societyId", ExtArgs["result"]["emergencyBarcode"]>

  export type $EmergencyBarcodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmergencyBarcode"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      residentName: string
      unit: string
      phone: string
      label: string | null
      type: string | null
      status: string
      qrCodeUrl: string
      createdAt: Date
      societyId: number | null
    }, ExtArgs["result"]["emergencyBarcode"]>
    composites: {}
  }

  type EmergencyBarcodeGetPayload<S extends boolean | null | undefined | EmergencyBarcodeDefaultArgs> = $Result.GetResult<Prisma.$EmergencyBarcodePayload, S>

  type EmergencyBarcodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmergencyBarcodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmergencyBarcodeCountAggregateInputType | true
    }

  export interface EmergencyBarcodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmergencyBarcode'], meta: { name: 'EmergencyBarcode' } }
    /**
     * Find zero or one EmergencyBarcode that matches the filter.
     * @param {EmergencyBarcodeFindUniqueArgs} args - Arguments to find a EmergencyBarcode
     * @example
     * // Get one EmergencyBarcode
     * const emergencyBarcode = await prisma.emergencyBarcode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmergencyBarcodeFindUniqueArgs>(args: SelectSubset<T, EmergencyBarcodeFindUniqueArgs<ExtArgs>>): Prisma__EmergencyBarcodeClient<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmergencyBarcode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmergencyBarcodeFindUniqueOrThrowArgs} args - Arguments to find a EmergencyBarcode
     * @example
     * // Get one EmergencyBarcode
     * const emergencyBarcode = await prisma.emergencyBarcode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmergencyBarcodeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmergencyBarcodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmergencyBarcodeClient<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyBarcode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyBarcodeFindFirstArgs} args - Arguments to find a EmergencyBarcode
     * @example
     * // Get one EmergencyBarcode
     * const emergencyBarcode = await prisma.emergencyBarcode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmergencyBarcodeFindFirstArgs>(args?: SelectSubset<T, EmergencyBarcodeFindFirstArgs<ExtArgs>>): Prisma__EmergencyBarcodeClient<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyBarcode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyBarcodeFindFirstOrThrowArgs} args - Arguments to find a EmergencyBarcode
     * @example
     * // Get one EmergencyBarcode
     * const emergencyBarcode = await prisma.emergencyBarcode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmergencyBarcodeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmergencyBarcodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmergencyBarcodeClient<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmergencyBarcodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyBarcodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmergencyBarcodes
     * const emergencyBarcodes = await prisma.emergencyBarcode.findMany()
     * 
     * // Get first 10 EmergencyBarcodes
     * const emergencyBarcodes = await prisma.emergencyBarcode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emergencyBarcodeWithIdOnly = await prisma.emergencyBarcode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmergencyBarcodeFindManyArgs>(args?: SelectSubset<T, EmergencyBarcodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmergencyBarcode.
     * @param {EmergencyBarcodeCreateArgs} args - Arguments to create a EmergencyBarcode.
     * @example
     * // Create one EmergencyBarcode
     * const EmergencyBarcode = await prisma.emergencyBarcode.create({
     *   data: {
     *     // ... data to create a EmergencyBarcode
     *   }
     * })
     * 
     */
    create<T extends EmergencyBarcodeCreateArgs>(args: SelectSubset<T, EmergencyBarcodeCreateArgs<ExtArgs>>): Prisma__EmergencyBarcodeClient<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmergencyBarcodes.
     * @param {EmergencyBarcodeCreateManyArgs} args - Arguments to create many EmergencyBarcodes.
     * @example
     * // Create many EmergencyBarcodes
     * const emergencyBarcode = await prisma.emergencyBarcode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmergencyBarcodeCreateManyArgs>(args?: SelectSubset<T, EmergencyBarcodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmergencyBarcode.
     * @param {EmergencyBarcodeDeleteArgs} args - Arguments to delete one EmergencyBarcode.
     * @example
     * // Delete one EmergencyBarcode
     * const EmergencyBarcode = await prisma.emergencyBarcode.delete({
     *   where: {
     *     // ... filter to delete one EmergencyBarcode
     *   }
     * })
     * 
     */
    delete<T extends EmergencyBarcodeDeleteArgs>(args: SelectSubset<T, EmergencyBarcodeDeleteArgs<ExtArgs>>): Prisma__EmergencyBarcodeClient<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmergencyBarcode.
     * @param {EmergencyBarcodeUpdateArgs} args - Arguments to update one EmergencyBarcode.
     * @example
     * // Update one EmergencyBarcode
     * const emergencyBarcode = await prisma.emergencyBarcode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmergencyBarcodeUpdateArgs>(args: SelectSubset<T, EmergencyBarcodeUpdateArgs<ExtArgs>>): Prisma__EmergencyBarcodeClient<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmergencyBarcodes.
     * @param {EmergencyBarcodeDeleteManyArgs} args - Arguments to filter EmergencyBarcodes to delete.
     * @example
     * // Delete a few EmergencyBarcodes
     * const { count } = await prisma.emergencyBarcode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmergencyBarcodeDeleteManyArgs>(args?: SelectSubset<T, EmergencyBarcodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyBarcodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyBarcodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmergencyBarcodes
     * const emergencyBarcode = await prisma.emergencyBarcode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmergencyBarcodeUpdateManyArgs>(args: SelectSubset<T, EmergencyBarcodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmergencyBarcode.
     * @param {EmergencyBarcodeUpsertArgs} args - Arguments to update or create a EmergencyBarcode.
     * @example
     * // Update or create a EmergencyBarcode
     * const emergencyBarcode = await prisma.emergencyBarcode.upsert({
     *   create: {
     *     // ... data to create a EmergencyBarcode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmergencyBarcode we want to update
     *   }
     * })
     */
    upsert<T extends EmergencyBarcodeUpsertArgs>(args: SelectSubset<T, EmergencyBarcodeUpsertArgs<ExtArgs>>): Prisma__EmergencyBarcodeClient<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmergencyBarcodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyBarcodeCountArgs} args - Arguments to filter EmergencyBarcodes to count.
     * @example
     * // Count the number of EmergencyBarcodes
     * const count = await prisma.emergencyBarcode.count({
     *   where: {
     *     // ... the filter for the EmergencyBarcodes we want to count
     *   }
     * })
    **/
    count<T extends EmergencyBarcodeCountArgs>(
      args?: Subset<T, EmergencyBarcodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmergencyBarcodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmergencyBarcode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyBarcodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmergencyBarcodeAggregateArgs>(args: Subset<T, EmergencyBarcodeAggregateArgs>): Prisma.PrismaPromise<GetEmergencyBarcodeAggregateType<T>>

    /**
     * Group by EmergencyBarcode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyBarcodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmergencyBarcodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmergencyBarcodeGroupByArgs['orderBy'] }
        : { orderBy?: EmergencyBarcodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmergencyBarcodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmergencyBarcodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmergencyBarcode model
   */
  readonly fields: EmergencyBarcodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmergencyBarcode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmergencyBarcodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmergencyBarcode model
   */
  interface EmergencyBarcodeFieldRefs {
    readonly id: FieldRef<"EmergencyBarcode", 'String'>
    readonly residentName: FieldRef<"EmergencyBarcode", 'String'>
    readonly unit: FieldRef<"EmergencyBarcode", 'String'>
    readonly phone: FieldRef<"EmergencyBarcode", 'String'>
    readonly label: FieldRef<"EmergencyBarcode", 'String'>
    readonly type: FieldRef<"EmergencyBarcode", 'String'>
    readonly status: FieldRef<"EmergencyBarcode", 'String'>
    readonly qrCodeUrl: FieldRef<"EmergencyBarcode", 'String'>
    readonly createdAt: FieldRef<"EmergencyBarcode", 'DateTime'>
    readonly societyId: FieldRef<"EmergencyBarcode", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EmergencyBarcode findUnique
   */
  export type EmergencyBarcodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyBarcode to fetch.
     */
    where: EmergencyBarcodeWhereUniqueInput
  }

  /**
   * EmergencyBarcode findUniqueOrThrow
   */
  export type EmergencyBarcodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyBarcode to fetch.
     */
    where: EmergencyBarcodeWhereUniqueInput
  }

  /**
   * EmergencyBarcode findFirst
   */
  export type EmergencyBarcodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyBarcode to fetch.
     */
    where?: EmergencyBarcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyBarcodes to fetch.
     */
    orderBy?: EmergencyBarcodeOrderByWithRelationInput | EmergencyBarcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyBarcodes.
     */
    cursor?: EmergencyBarcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyBarcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyBarcodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyBarcodes.
     */
    distinct?: EmergencyBarcodeScalarFieldEnum | EmergencyBarcodeScalarFieldEnum[]
  }

  /**
   * EmergencyBarcode findFirstOrThrow
   */
  export type EmergencyBarcodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyBarcode to fetch.
     */
    where?: EmergencyBarcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyBarcodes to fetch.
     */
    orderBy?: EmergencyBarcodeOrderByWithRelationInput | EmergencyBarcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyBarcodes.
     */
    cursor?: EmergencyBarcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyBarcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyBarcodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyBarcodes.
     */
    distinct?: EmergencyBarcodeScalarFieldEnum | EmergencyBarcodeScalarFieldEnum[]
  }

  /**
   * EmergencyBarcode findMany
   */
  export type EmergencyBarcodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyBarcodes to fetch.
     */
    where?: EmergencyBarcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyBarcodes to fetch.
     */
    orderBy?: EmergencyBarcodeOrderByWithRelationInput | EmergencyBarcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmergencyBarcodes.
     */
    cursor?: EmergencyBarcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyBarcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyBarcodes.
     */
    skip?: number
    distinct?: EmergencyBarcodeScalarFieldEnum | EmergencyBarcodeScalarFieldEnum[]
  }

  /**
   * EmergencyBarcode create
   */
  export type EmergencyBarcodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * The data needed to create a EmergencyBarcode.
     */
    data: XOR<EmergencyBarcodeCreateInput, EmergencyBarcodeUncheckedCreateInput>
  }

  /**
   * EmergencyBarcode createMany
   */
  export type EmergencyBarcodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmergencyBarcodes.
     */
    data: EmergencyBarcodeCreateManyInput | EmergencyBarcodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmergencyBarcode update
   */
  export type EmergencyBarcodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * The data needed to update a EmergencyBarcode.
     */
    data: XOR<EmergencyBarcodeUpdateInput, EmergencyBarcodeUncheckedUpdateInput>
    /**
     * Choose, which EmergencyBarcode to update.
     */
    where: EmergencyBarcodeWhereUniqueInput
  }

  /**
   * EmergencyBarcode updateMany
   */
  export type EmergencyBarcodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmergencyBarcodes.
     */
    data: XOR<EmergencyBarcodeUpdateManyMutationInput, EmergencyBarcodeUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyBarcodes to update
     */
    where?: EmergencyBarcodeWhereInput
    /**
     * Limit how many EmergencyBarcodes to update.
     */
    limit?: number
  }

  /**
   * EmergencyBarcode upsert
   */
  export type EmergencyBarcodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * The filter to search for the EmergencyBarcode to update in case it exists.
     */
    where: EmergencyBarcodeWhereUniqueInput
    /**
     * In case the EmergencyBarcode found by the `where` argument doesn't exist, create a new EmergencyBarcode with this data.
     */
    create: XOR<EmergencyBarcodeCreateInput, EmergencyBarcodeUncheckedCreateInput>
    /**
     * In case the EmergencyBarcode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmergencyBarcodeUpdateInput, EmergencyBarcodeUncheckedUpdateInput>
  }

  /**
   * EmergencyBarcode delete
   */
  export type EmergencyBarcodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * Filter which EmergencyBarcode to delete.
     */
    where: EmergencyBarcodeWhereUniqueInput
  }

  /**
   * EmergencyBarcode deleteMany
   */
  export type EmergencyBarcodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyBarcodes to delete
     */
    where?: EmergencyBarcodeWhereInput
    /**
     * Limit how many EmergencyBarcodes to delete.
     */
    limit?: number
  }

  /**
   * EmergencyBarcode without action
   */
  export type EmergencyBarcodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
  }


  /**
   * Model EmergencyAlert
   */

  export type AggregateEmergencyAlert = {
    _count: EmergencyAlertCountAggregateOutputType | null
    _avg: EmergencyAlertAvgAggregateOutputType | null
    _sum: EmergencyAlertSumAggregateOutputType | null
    _min: EmergencyAlertMinAggregateOutputType | null
    _max: EmergencyAlertMaxAggregateOutputType | null
  }

  export type EmergencyAlertAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
    userId: number | null
  }

  export type EmergencyAlertSumAggregateOutputType = {
    id: number | null
    societyId: number | null
    userId: number | null
  }

  export type EmergencyAlertMinAggregateOutputType = {
    id: number | null
    type: string | null
    unit: string | null
    description: string | null
    status: string | null
    resolution: string | null
    societyId: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmergencyAlertMaxAggregateOutputType = {
    id: number | null
    type: string | null
    unit: string | null
    description: string | null
    status: string | null
    resolution: string | null
    societyId: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmergencyAlertCountAggregateOutputType = {
    id: number
    type: number
    unit: number
    description: number
    status: number
    resolution: number
    societyId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmergencyAlertAvgAggregateInputType = {
    id?: true
    societyId?: true
    userId?: true
  }

  export type EmergencyAlertSumAggregateInputType = {
    id?: true
    societyId?: true
    userId?: true
  }

  export type EmergencyAlertMinAggregateInputType = {
    id?: true
    type?: true
    unit?: true
    description?: true
    status?: true
    resolution?: true
    societyId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmergencyAlertMaxAggregateInputType = {
    id?: true
    type?: true
    unit?: true
    description?: true
    status?: true
    resolution?: true
    societyId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmergencyAlertCountAggregateInputType = {
    id?: true
    type?: true
    unit?: true
    description?: true
    status?: true
    resolution?: true
    societyId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmergencyAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyAlert to aggregate.
     */
    where?: EmergencyAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyAlerts to fetch.
     */
    orderBy?: EmergencyAlertOrderByWithRelationInput | EmergencyAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmergencyAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmergencyAlerts
    **/
    _count?: true | EmergencyAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmergencyAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmergencyAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmergencyAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmergencyAlertMaxAggregateInputType
  }

  export type GetEmergencyAlertAggregateType<T extends EmergencyAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateEmergencyAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmergencyAlert[P]>
      : GetScalarType<T[P], AggregateEmergencyAlert[P]>
  }




  export type EmergencyAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyAlertWhereInput
    orderBy?: EmergencyAlertOrderByWithAggregationInput | EmergencyAlertOrderByWithAggregationInput[]
    by: EmergencyAlertScalarFieldEnum[] | EmergencyAlertScalarFieldEnum
    having?: EmergencyAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmergencyAlertCountAggregateInputType | true
    _avg?: EmergencyAlertAvgAggregateInputType
    _sum?: EmergencyAlertSumAggregateInputType
    _min?: EmergencyAlertMinAggregateInputType
    _max?: EmergencyAlertMaxAggregateInputType
  }

  export type EmergencyAlertGroupByOutputType = {
    id: number
    type: string
    unit: string | null
    description: string | null
    status: string
    resolution: string | null
    societyId: number
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: EmergencyAlertCountAggregateOutputType | null
    _avg: EmergencyAlertAvgAggregateOutputType | null
    _sum: EmergencyAlertSumAggregateOutputType | null
    _min: EmergencyAlertMinAggregateOutputType | null
    _max: EmergencyAlertMaxAggregateOutputType | null
  }

  type GetEmergencyAlertGroupByPayload<T extends EmergencyAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmergencyAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmergencyAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmergencyAlertGroupByOutputType[P]>
            : GetScalarType<T[P], EmergencyAlertGroupByOutputType[P]>
        }
      >
    >


  export type EmergencyAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    unit?: boolean
    description?: boolean
    status?: boolean
    resolution?: boolean
    societyId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyAlert"]>



  export type EmergencyAlertSelectScalar = {
    id?: boolean
    type?: boolean
    unit?: boolean
    description?: boolean
    status?: boolean
    resolution?: boolean
    societyId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmergencyAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "unit" | "description" | "status" | "resolution" | "societyId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["emergencyAlert"]>
  export type EmergencyAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmergencyAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmergencyAlert"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      unit: string | null
      description: string | null
      status: string
      resolution: string | null
      societyId: number
      userId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emergencyAlert"]>
    composites: {}
  }

  type EmergencyAlertGetPayload<S extends boolean | null | undefined | EmergencyAlertDefaultArgs> = $Result.GetResult<Prisma.$EmergencyAlertPayload, S>

  type EmergencyAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmergencyAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmergencyAlertCountAggregateInputType | true
    }

  export interface EmergencyAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmergencyAlert'], meta: { name: 'EmergencyAlert' } }
    /**
     * Find zero or one EmergencyAlert that matches the filter.
     * @param {EmergencyAlertFindUniqueArgs} args - Arguments to find a EmergencyAlert
     * @example
     * // Get one EmergencyAlert
     * const emergencyAlert = await prisma.emergencyAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmergencyAlertFindUniqueArgs>(args: SelectSubset<T, EmergencyAlertFindUniqueArgs<ExtArgs>>): Prisma__EmergencyAlertClient<$Result.GetResult<Prisma.$EmergencyAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmergencyAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmergencyAlertFindUniqueOrThrowArgs} args - Arguments to find a EmergencyAlert
     * @example
     * // Get one EmergencyAlert
     * const emergencyAlert = await prisma.emergencyAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmergencyAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, EmergencyAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmergencyAlertClient<$Result.GetResult<Prisma.$EmergencyAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyAlertFindFirstArgs} args - Arguments to find a EmergencyAlert
     * @example
     * // Get one EmergencyAlert
     * const emergencyAlert = await prisma.emergencyAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmergencyAlertFindFirstArgs>(args?: SelectSubset<T, EmergencyAlertFindFirstArgs<ExtArgs>>): Prisma__EmergencyAlertClient<$Result.GetResult<Prisma.$EmergencyAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyAlertFindFirstOrThrowArgs} args - Arguments to find a EmergencyAlert
     * @example
     * // Get one EmergencyAlert
     * const emergencyAlert = await prisma.emergencyAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmergencyAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, EmergencyAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmergencyAlertClient<$Result.GetResult<Prisma.$EmergencyAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmergencyAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmergencyAlerts
     * const emergencyAlerts = await prisma.emergencyAlert.findMany()
     * 
     * // Get first 10 EmergencyAlerts
     * const emergencyAlerts = await prisma.emergencyAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emergencyAlertWithIdOnly = await prisma.emergencyAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmergencyAlertFindManyArgs>(args?: SelectSubset<T, EmergencyAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmergencyAlert.
     * @param {EmergencyAlertCreateArgs} args - Arguments to create a EmergencyAlert.
     * @example
     * // Create one EmergencyAlert
     * const EmergencyAlert = await prisma.emergencyAlert.create({
     *   data: {
     *     // ... data to create a EmergencyAlert
     *   }
     * })
     * 
     */
    create<T extends EmergencyAlertCreateArgs>(args: SelectSubset<T, EmergencyAlertCreateArgs<ExtArgs>>): Prisma__EmergencyAlertClient<$Result.GetResult<Prisma.$EmergencyAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmergencyAlerts.
     * @param {EmergencyAlertCreateManyArgs} args - Arguments to create many EmergencyAlerts.
     * @example
     * // Create many EmergencyAlerts
     * const emergencyAlert = await prisma.emergencyAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmergencyAlertCreateManyArgs>(args?: SelectSubset<T, EmergencyAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmergencyAlert.
     * @param {EmergencyAlertDeleteArgs} args - Arguments to delete one EmergencyAlert.
     * @example
     * // Delete one EmergencyAlert
     * const EmergencyAlert = await prisma.emergencyAlert.delete({
     *   where: {
     *     // ... filter to delete one EmergencyAlert
     *   }
     * })
     * 
     */
    delete<T extends EmergencyAlertDeleteArgs>(args: SelectSubset<T, EmergencyAlertDeleteArgs<ExtArgs>>): Prisma__EmergencyAlertClient<$Result.GetResult<Prisma.$EmergencyAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmergencyAlert.
     * @param {EmergencyAlertUpdateArgs} args - Arguments to update one EmergencyAlert.
     * @example
     * // Update one EmergencyAlert
     * const emergencyAlert = await prisma.emergencyAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmergencyAlertUpdateArgs>(args: SelectSubset<T, EmergencyAlertUpdateArgs<ExtArgs>>): Prisma__EmergencyAlertClient<$Result.GetResult<Prisma.$EmergencyAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmergencyAlerts.
     * @param {EmergencyAlertDeleteManyArgs} args - Arguments to filter EmergencyAlerts to delete.
     * @example
     * // Delete a few EmergencyAlerts
     * const { count } = await prisma.emergencyAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmergencyAlertDeleteManyArgs>(args?: SelectSubset<T, EmergencyAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmergencyAlerts
     * const emergencyAlert = await prisma.emergencyAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmergencyAlertUpdateManyArgs>(args: SelectSubset<T, EmergencyAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmergencyAlert.
     * @param {EmergencyAlertUpsertArgs} args - Arguments to update or create a EmergencyAlert.
     * @example
     * // Update or create a EmergencyAlert
     * const emergencyAlert = await prisma.emergencyAlert.upsert({
     *   create: {
     *     // ... data to create a EmergencyAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmergencyAlert we want to update
     *   }
     * })
     */
    upsert<T extends EmergencyAlertUpsertArgs>(args: SelectSubset<T, EmergencyAlertUpsertArgs<ExtArgs>>): Prisma__EmergencyAlertClient<$Result.GetResult<Prisma.$EmergencyAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmergencyAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyAlertCountArgs} args - Arguments to filter EmergencyAlerts to count.
     * @example
     * // Count the number of EmergencyAlerts
     * const count = await prisma.emergencyAlert.count({
     *   where: {
     *     // ... the filter for the EmergencyAlerts we want to count
     *   }
     * })
    **/
    count<T extends EmergencyAlertCountArgs>(
      args?: Subset<T, EmergencyAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmergencyAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmergencyAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmergencyAlertAggregateArgs>(args: Subset<T, EmergencyAlertAggregateArgs>): Prisma.PrismaPromise<GetEmergencyAlertAggregateType<T>>

    /**
     * Group by EmergencyAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmergencyAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmergencyAlertGroupByArgs['orderBy'] }
        : { orderBy?: EmergencyAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmergencyAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmergencyAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmergencyAlert model
   */
  readonly fields: EmergencyAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmergencyAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmergencyAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmergencyAlert model
   */
  interface EmergencyAlertFieldRefs {
    readonly id: FieldRef<"EmergencyAlert", 'Int'>
    readonly type: FieldRef<"EmergencyAlert", 'String'>
    readonly unit: FieldRef<"EmergencyAlert", 'String'>
    readonly description: FieldRef<"EmergencyAlert", 'String'>
    readonly status: FieldRef<"EmergencyAlert", 'String'>
    readonly resolution: FieldRef<"EmergencyAlert", 'String'>
    readonly societyId: FieldRef<"EmergencyAlert", 'Int'>
    readonly userId: FieldRef<"EmergencyAlert", 'Int'>
    readonly createdAt: FieldRef<"EmergencyAlert", 'DateTime'>
    readonly updatedAt: FieldRef<"EmergencyAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmergencyAlert findUnique
   */
  export type EmergencyAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAlert
     */
    select?: EmergencyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyAlert
     */
    omit?: EmergencyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAlertInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyAlert to fetch.
     */
    where: EmergencyAlertWhereUniqueInput
  }

  /**
   * EmergencyAlert findUniqueOrThrow
   */
  export type EmergencyAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAlert
     */
    select?: EmergencyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyAlert
     */
    omit?: EmergencyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAlertInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyAlert to fetch.
     */
    where: EmergencyAlertWhereUniqueInput
  }

  /**
   * EmergencyAlert findFirst
   */
  export type EmergencyAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAlert
     */
    select?: EmergencyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyAlert
     */
    omit?: EmergencyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAlertInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyAlert to fetch.
     */
    where?: EmergencyAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyAlerts to fetch.
     */
    orderBy?: EmergencyAlertOrderByWithRelationInput | EmergencyAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyAlerts.
     */
    cursor?: EmergencyAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyAlerts.
     */
    distinct?: EmergencyAlertScalarFieldEnum | EmergencyAlertScalarFieldEnum[]
  }

  /**
   * EmergencyAlert findFirstOrThrow
   */
  export type EmergencyAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAlert
     */
    select?: EmergencyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyAlert
     */
    omit?: EmergencyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAlertInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyAlert to fetch.
     */
    where?: EmergencyAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyAlerts to fetch.
     */
    orderBy?: EmergencyAlertOrderByWithRelationInput | EmergencyAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyAlerts.
     */
    cursor?: EmergencyAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyAlerts.
     */
    distinct?: EmergencyAlertScalarFieldEnum | EmergencyAlertScalarFieldEnum[]
  }

  /**
   * EmergencyAlert findMany
   */
  export type EmergencyAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAlert
     */
    select?: EmergencyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyAlert
     */
    omit?: EmergencyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAlertInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyAlerts to fetch.
     */
    where?: EmergencyAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyAlerts to fetch.
     */
    orderBy?: EmergencyAlertOrderByWithRelationInput | EmergencyAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmergencyAlerts.
     */
    cursor?: EmergencyAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyAlerts.
     */
    skip?: number
    distinct?: EmergencyAlertScalarFieldEnum | EmergencyAlertScalarFieldEnum[]
  }

  /**
   * EmergencyAlert create
   */
  export type EmergencyAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAlert
     */
    select?: EmergencyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyAlert
     */
    omit?: EmergencyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a EmergencyAlert.
     */
    data: XOR<EmergencyAlertCreateInput, EmergencyAlertUncheckedCreateInput>
  }

  /**
   * EmergencyAlert createMany
   */
  export type EmergencyAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmergencyAlerts.
     */
    data: EmergencyAlertCreateManyInput | EmergencyAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmergencyAlert update
   */
  export type EmergencyAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAlert
     */
    select?: EmergencyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyAlert
     */
    omit?: EmergencyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a EmergencyAlert.
     */
    data: XOR<EmergencyAlertUpdateInput, EmergencyAlertUncheckedUpdateInput>
    /**
     * Choose, which EmergencyAlert to update.
     */
    where: EmergencyAlertWhereUniqueInput
  }

  /**
   * EmergencyAlert updateMany
   */
  export type EmergencyAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmergencyAlerts.
     */
    data: XOR<EmergencyAlertUpdateManyMutationInput, EmergencyAlertUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyAlerts to update
     */
    where?: EmergencyAlertWhereInput
    /**
     * Limit how many EmergencyAlerts to update.
     */
    limit?: number
  }

  /**
   * EmergencyAlert upsert
   */
  export type EmergencyAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAlert
     */
    select?: EmergencyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyAlert
     */
    omit?: EmergencyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the EmergencyAlert to update in case it exists.
     */
    where: EmergencyAlertWhereUniqueInput
    /**
     * In case the EmergencyAlert found by the `where` argument doesn't exist, create a new EmergencyAlert with this data.
     */
    create: XOR<EmergencyAlertCreateInput, EmergencyAlertUncheckedCreateInput>
    /**
     * In case the EmergencyAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmergencyAlertUpdateInput, EmergencyAlertUncheckedUpdateInput>
  }

  /**
   * EmergencyAlert delete
   */
  export type EmergencyAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAlert
     */
    select?: EmergencyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyAlert
     */
    omit?: EmergencyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAlertInclude<ExtArgs> | null
    /**
     * Filter which EmergencyAlert to delete.
     */
    where: EmergencyAlertWhereUniqueInput
  }

  /**
   * EmergencyAlert deleteMany
   */
  export type EmergencyAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyAlerts to delete
     */
    where?: EmergencyAlertWhereInput
    /**
     * Limit how many EmergencyAlerts to delete.
     */
    limit?: number
  }

  /**
   * EmergencyAlert without action
   */
  export type EmergencyAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyAlert
     */
    select?: EmergencyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyAlert
     */
    omit?: EmergencyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyAlertInclude<ExtArgs> | null
  }


  /**
   * Model EmergencyContact
   */

  export type AggregateEmergencyContact = {
    _count: EmergencyContactCountAggregateOutputType | null
    _avg: EmergencyContactAvgAggregateOutputType | null
    _sum: EmergencyContactSumAggregateOutputType | null
    _min: EmergencyContactMinAggregateOutputType | null
    _max: EmergencyContactMaxAggregateOutputType | null
  }

  export type EmergencyContactAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
    residentId: number | null
  }

  export type EmergencyContactSumAggregateOutputType = {
    id: number | null
    societyId: number | null
    residentId: number | null
  }

  export type EmergencyContactMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    category: string | null
    available: boolean | null
    societyId: number | null
    residentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmergencyContactMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    category: string | null
    available: boolean | null
    societyId: number | null
    residentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmergencyContactCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    category: number
    available: number
    societyId: number
    residentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmergencyContactAvgAggregateInputType = {
    id?: true
    societyId?: true
    residentId?: true
  }

  export type EmergencyContactSumAggregateInputType = {
    id?: true
    societyId?: true
    residentId?: true
  }

  export type EmergencyContactMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    category?: true
    available?: true
    societyId?: true
    residentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmergencyContactMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    category?: true
    available?: true
    societyId?: true
    residentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmergencyContactCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    category?: true
    available?: true
    societyId?: true
    residentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmergencyContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyContact to aggregate.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmergencyContacts
    **/
    _count?: true | EmergencyContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmergencyContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmergencyContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmergencyContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmergencyContactMaxAggregateInputType
  }

  export type GetEmergencyContactAggregateType<T extends EmergencyContactAggregateArgs> = {
        [P in keyof T & keyof AggregateEmergencyContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmergencyContact[P]>
      : GetScalarType<T[P], AggregateEmergencyContact[P]>
  }




  export type EmergencyContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyContactWhereInput
    orderBy?: EmergencyContactOrderByWithAggregationInput | EmergencyContactOrderByWithAggregationInput[]
    by: EmergencyContactScalarFieldEnum[] | EmergencyContactScalarFieldEnum
    having?: EmergencyContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmergencyContactCountAggregateInputType | true
    _avg?: EmergencyContactAvgAggregateInputType
    _sum?: EmergencyContactSumAggregateInputType
    _min?: EmergencyContactMinAggregateInputType
    _max?: EmergencyContactMaxAggregateInputType
  }

  export type EmergencyContactGroupByOutputType = {
    id: number
    name: string
    phone: string
    category: string
    available: boolean
    societyId: number | null
    residentId: number | null
    createdAt: Date
    updatedAt: Date
    _count: EmergencyContactCountAggregateOutputType | null
    _avg: EmergencyContactAvgAggregateOutputType | null
    _sum: EmergencyContactSumAggregateOutputType | null
    _min: EmergencyContactMinAggregateOutputType | null
    _max: EmergencyContactMaxAggregateOutputType | null
  }

  type GetEmergencyContactGroupByPayload<T extends EmergencyContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmergencyContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmergencyContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmergencyContactGroupByOutputType[P]>
            : GetScalarType<T[P], EmergencyContactGroupByOutputType[P]>
        }
      >
    >


  export type EmergencyContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    category?: boolean
    available?: boolean
    societyId?: boolean
    residentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | EmergencyContact$societyArgs<ExtArgs>
    resident?: boolean | EmergencyContact$residentArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyContact"]>



  export type EmergencyContactSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    category?: boolean
    available?: boolean
    societyId?: boolean
    residentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmergencyContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "category" | "available" | "societyId" | "residentId" | "createdAt" | "updatedAt", ExtArgs["result"]["emergencyContact"]>
  export type EmergencyContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | EmergencyContact$societyArgs<ExtArgs>
    resident?: boolean | EmergencyContact$residentArgs<ExtArgs>
  }

  export type $EmergencyContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmergencyContact"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs> | null
      resident: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string
      category: string
      available: boolean
      societyId: number | null
      residentId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emergencyContact"]>
    composites: {}
  }

  type EmergencyContactGetPayload<S extends boolean | null | undefined | EmergencyContactDefaultArgs> = $Result.GetResult<Prisma.$EmergencyContactPayload, S>

  type EmergencyContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmergencyContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmergencyContactCountAggregateInputType | true
    }

  export interface EmergencyContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmergencyContact'], meta: { name: 'EmergencyContact' } }
    /**
     * Find zero or one EmergencyContact that matches the filter.
     * @param {EmergencyContactFindUniqueArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmergencyContactFindUniqueArgs>(args: SelectSubset<T, EmergencyContactFindUniqueArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmergencyContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmergencyContactFindUniqueOrThrowArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmergencyContactFindUniqueOrThrowArgs>(args: SelectSubset<T, EmergencyContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindFirstArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmergencyContactFindFirstArgs>(args?: SelectSubset<T, EmergencyContactFindFirstArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindFirstOrThrowArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmergencyContactFindFirstOrThrowArgs>(args?: SelectSubset<T, EmergencyContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmergencyContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmergencyContacts
     * const emergencyContacts = await prisma.emergencyContact.findMany()
     * 
     * // Get first 10 EmergencyContacts
     * const emergencyContacts = await prisma.emergencyContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emergencyContactWithIdOnly = await prisma.emergencyContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmergencyContactFindManyArgs>(args?: SelectSubset<T, EmergencyContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmergencyContact.
     * @param {EmergencyContactCreateArgs} args - Arguments to create a EmergencyContact.
     * @example
     * // Create one EmergencyContact
     * const EmergencyContact = await prisma.emergencyContact.create({
     *   data: {
     *     // ... data to create a EmergencyContact
     *   }
     * })
     * 
     */
    create<T extends EmergencyContactCreateArgs>(args: SelectSubset<T, EmergencyContactCreateArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmergencyContacts.
     * @param {EmergencyContactCreateManyArgs} args - Arguments to create many EmergencyContacts.
     * @example
     * // Create many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmergencyContactCreateManyArgs>(args?: SelectSubset<T, EmergencyContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmergencyContact.
     * @param {EmergencyContactDeleteArgs} args - Arguments to delete one EmergencyContact.
     * @example
     * // Delete one EmergencyContact
     * const EmergencyContact = await prisma.emergencyContact.delete({
     *   where: {
     *     // ... filter to delete one EmergencyContact
     *   }
     * })
     * 
     */
    delete<T extends EmergencyContactDeleteArgs>(args: SelectSubset<T, EmergencyContactDeleteArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmergencyContact.
     * @param {EmergencyContactUpdateArgs} args - Arguments to update one EmergencyContact.
     * @example
     * // Update one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmergencyContactUpdateArgs>(args: SelectSubset<T, EmergencyContactUpdateArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmergencyContacts.
     * @param {EmergencyContactDeleteManyArgs} args - Arguments to filter EmergencyContacts to delete.
     * @example
     * // Delete a few EmergencyContacts
     * const { count } = await prisma.emergencyContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmergencyContactDeleteManyArgs>(args?: SelectSubset<T, EmergencyContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmergencyContactUpdateManyArgs>(args: SelectSubset<T, EmergencyContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmergencyContact.
     * @param {EmergencyContactUpsertArgs} args - Arguments to update or create a EmergencyContact.
     * @example
     * // Update or create a EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.upsert({
     *   create: {
     *     // ... data to create a EmergencyContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmergencyContact we want to update
     *   }
     * })
     */
    upsert<T extends EmergencyContactUpsertArgs>(args: SelectSubset<T, EmergencyContactUpsertArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactCountArgs} args - Arguments to filter EmergencyContacts to count.
     * @example
     * // Count the number of EmergencyContacts
     * const count = await prisma.emergencyContact.count({
     *   where: {
     *     // ... the filter for the EmergencyContacts we want to count
     *   }
     * })
    **/
    count<T extends EmergencyContactCountArgs>(
      args?: Subset<T, EmergencyContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmergencyContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmergencyContactAggregateArgs>(args: Subset<T, EmergencyContactAggregateArgs>): Prisma.PrismaPromise<GetEmergencyContactAggregateType<T>>

    /**
     * Group by EmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmergencyContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmergencyContactGroupByArgs['orderBy'] }
        : { orderBy?: EmergencyContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmergencyContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmergencyContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmergencyContact model
   */
  readonly fields: EmergencyContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmergencyContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmergencyContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends EmergencyContact$societyArgs<ExtArgs> = {}>(args?: Subset<T, EmergencyContact$societyArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    resident<T extends EmergencyContact$residentArgs<ExtArgs> = {}>(args?: Subset<T, EmergencyContact$residentArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmergencyContact model
   */
  interface EmergencyContactFieldRefs {
    readonly id: FieldRef<"EmergencyContact", 'Int'>
    readonly name: FieldRef<"EmergencyContact", 'String'>
    readonly phone: FieldRef<"EmergencyContact", 'String'>
    readonly category: FieldRef<"EmergencyContact", 'String'>
    readonly available: FieldRef<"EmergencyContact", 'Boolean'>
    readonly societyId: FieldRef<"EmergencyContact", 'Int'>
    readonly residentId: FieldRef<"EmergencyContact", 'Int'>
    readonly createdAt: FieldRef<"EmergencyContact", 'DateTime'>
    readonly updatedAt: FieldRef<"EmergencyContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmergencyContact findUnique
   */
  export type EmergencyContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact findUniqueOrThrow
   */
  export type EmergencyContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact findFirst
   */
  export type EmergencyContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyContacts.
     */
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact findFirstOrThrow
   */
  export type EmergencyContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyContacts.
     */
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact findMany
   */
  export type EmergencyContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContacts to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact create
   */
  export type EmergencyContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to create a EmergencyContact.
     */
    data: XOR<EmergencyContactCreateInput, EmergencyContactUncheckedCreateInput>
  }

  /**
   * EmergencyContact createMany
   */
  export type EmergencyContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmergencyContacts.
     */
    data: EmergencyContactCreateManyInput | EmergencyContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmergencyContact update
   */
  export type EmergencyContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to update a EmergencyContact.
     */
    data: XOR<EmergencyContactUpdateInput, EmergencyContactUncheckedUpdateInput>
    /**
     * Choose, which EmergencyContact to update.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact updateMany
   */
  export type EmergencyContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmergencyContacts.
     */
    data: XOR<EmergencyContactUpdateManyMutationInput, EmergencyContactUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyContacts to update
     */
    where?: EmergencyContactWhereInput
    /**
     * Limit how many EmergencyContacts to update.
     */
    limit?: number
  }

  /**
   * EmergencyContact upsert
   */
  export type EmergencyContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The filter to search for the EmergencyContact to update in case it exists.
     */
    where: EmergencyContactWhereUniqueInput
    /**
     * In case the EmergencyContact found by the `where` argument doesn't exist, create a new EmergencyContact with this data.
     */
    create: XOR<EmergencyContactCreateInput, EmergencyContactUncheckedCreateInput>
    /**
     * In case the EmergencyContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmergencyContactUpdateInput, EmergencyContactUncheckedUpdateInput>
  }

  /**
   * EmergencyContact delete
   */
  export type EmergencyContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter which EmergencyContact to delete.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact deleteMany
   */
  export type EmergencyContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyContacts to delete
     */
    where?: EmergencyContactWhereInput
    /**
     * Limit how many EmergencyContacts to delete.
     */
    limit?: number
  }

  /**
   * EmergencyContact.society
   */
  export type EmergencyContact$societyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    where?: SocietyWhereInput
  }

  /**
   * EmergencyContact.resident
   */
  export type EmergencyContact$residentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * EmergencyContact without action
   */
  export type EmergencyContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
  }


  /**
   * Model Notice
   */

  export type AggregateNotice = {
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  export type NoticeAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type NoticeSumAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type NoticeMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    audience: string | null
    societyId: number | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type NoticeMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    audience: string | null
    societyId: number | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type NoticeCountAggregateOutputType = {
    id: number
    title: number
    content: number
    audience: number
    societyId: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type NoticeAvgAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type NoticeSumAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type NoticeMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    audience?: true
    societyId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type NoticeMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    audience?: true
    societyId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type NoticeCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    audience?: true
    societyId?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type NoticeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notice to aggregate.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notices
    **/
    _count?: true | NoticeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoticeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoticeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoticeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoticeMaxAggregateInputType
  }

  export type GetNoticeAggregateType<T extends NoticeAggregateArgs> = {
        [P in keyof T & keyof AggregateNotice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotice[P]>
      : GetScalarType<T[P], AggregateNotice[P]>
  }




  export type NoticeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoticeWhereInput
    orderBy?: NoticeOrderByWithAggregationInput | NoticeOrderByWithAggregationInput[]
    by: NoticeScalarFieldEnum[] | NoticeScalarFieldEnum
    having?: NoticeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoticeCountAggregateInputType | true
    _avg?: NoticeAvgAggregateInputType
    _sum?: NoticeSumAggregateInputType
    _min?: NoticeMinAggregateInputType
    _max?: NoticeMaxAggregateInputType
  }

  export type NoticeGroupByOutputType = {
    id: number
    title: string
    content: string
    audience: string
    societyId: number
    createdAt: Date
    expiresAt: Date | null
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  type GetNoticeGroupByPayload<T extends NoticeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoticeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoticeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoticeGroupByOutputType[P]>
            : GetScalarType<T[P], NoticeGroupByOutputType[P]>
        }
      >
    >


  export type NoticeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    audience?: boolean
    societyId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notice"]>



  export type NoticeSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    audience?: boolean
    societyId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type NoticeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "audience" | "societyId" | "createdAt" | "expiresAt", ExtArgs["result"]["notice"]>
  export type NoticeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $NoticePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notice"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      audience: string
      societyId: number
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["notice"]>
    composites: {}
  }

  type NoticeGetPayload<S extends boolean | null | undefined | NoticeDefaultArgs> = $Result.GetResult<Prisma.$NoticePayload, S>

  type NoticeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoticeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoticeCountAggregateInputType | true
    }

  export interface NoticeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notice'], meta: { name: 'Notice' } }
    /**
     * Find zero or one Notice that matches the filter.
     * @param {NoticeFindUniqueArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoticeFindUniqueArgs>(args: SelectSubset<T, NoticeFindUniqueArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoticeFindUniqueOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoticeFindUniqueOrThrowArgs>(args: SelectSubset<T, NoticeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoticeFindFirstArgs>(args?: SelectSubset<T, NoticeFindFirstArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoticeFindFirstOrThrowArgs>(args?: SelectSubset<T, NoticeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notices
     * const notices = await prisma.notice.findMany()
     * 
     * // Get first 10 Notices
     * const notices = await prisma.notice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noticeWithIdOnly = await prisma.notice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoticeFindManyArgs>(args?: SelectSubset<T, NoticeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notice.
     * @param {NoticeCreateArgs} args - Arguments to create a Notice.
     * @example
     * // Create one Notice
     * const Notice = await prisma.notice.create({
     *   data: {
     *     // ... data to create a Notice
     *   }
     * })
     * 
     */
    create<T extends NoticeCreateArgs>(args: SelectSubset<T, NoticeCreateArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notices.
     * @param {NoticeCreateManyArgs} args - Arguments to create many Notices.
     * @example
     * // Create many Notices
     * const notice = await prisma.notice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoticeCreateManyArgs>(args?: SelectSubset<T, NoticeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notice.
     * @param {NoticeDeleteArgs} args - Arguments to delete one Notice.
     * @example
     * // Delete one Notice
     * const Notice = await prisma.notice.delete({
     *   where: {
     *     // ... filter to delete one Notice
     *   }
     * })
     * 
     */
    delete<T extends NoticeDeleteArgs>(args: SelectSubset<T, NoticeDeleteArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notice.
     * @param {NoticeUpdateArgs} args - Arguments to update one Notice.
     * @example
     * // Update one Notice
     * const notice = await prisma.notice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoticeUpdateArgs>(args: SelectSubset<T, NoticeUpdateArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notices.
     * @param {NoticeDeleteManyArgs} args - Arguments to filter Notices to delete.
     * @example
     * // Delete a few Notices
     * const { count } = await prisma.notice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoticeDeleteManyArgs>(args?: SelectSubset<T, NoticeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notices
     * const notice = await prisma.notice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoticeUpdateManyArgs>(args: SelectSubset<T, NoticeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notice.
     * @param {NoticeUpsertArgs} args - Arguments to update or create a Notice.
     * @example
     * // Update or create a Notice
     * const notice = await prisma.notice.upsert({
     *   create: {
     *     // ... data to create a Notice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notice we want to update
     *   }
     * })
     */
    upsert<T extends NoticeUpsertArgs>(args: SelectSubset<T, NoticeUpsertArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeCountArgs} args - Arguments to filter Notices to count.
     * @example
     * // Count the number of Notices
     * const count = await prisma.notice.count({
     *   where: {
     *     // ... the filter for the Notices we want to count
     *   }
     * })
    **/
    count<T extends NoticeCountArgs>(
      args?: Subset<T, NoticeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoticeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoticeAggregateArgs>(args: Subset<T, NoticeAggregateArgs>): Prisma.PrismaPromise<GetNoticeAggregateType<T>>

    /**
     * Group by Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoticeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoticeGroupByArgs['orderBy'] }
        : { orderBy?: NoticeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoticeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoticeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notice model
   */
  readonly fields: NoticeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoticeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notice model
   */
  interface NoticeFieldRefs {
    readonly id: FieldRef<"Notice", 'Int'>
    readonly title: FieldRef<"Notice", 'String'>
    readonly content: FieldRef<"Notice", 'String'>
    readonly audience: FieldRef<"Notice", 'String'>
    readonly societyId: FieldRef<"Notice", 'Int'>
    readonly createdAt: FieldRef<"Notice", 'DateTime'>
    readonly expiresAt: FieldRef<"Notice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notice findUnique
   */
  export type NoticeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice findUniqueOrThrow
   */
  export type NoticeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice findFirst
   */
  export type NoticeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     */
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice findFirstOrThrow
   */
  export type NoticeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     */
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice findMany
   */
  export type NoticeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notices to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice create
   */
  export type NoticeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The data needed to create a Notice.
     */
    data: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
  }

  /**
   * Notice createMany
   */
  export type NoticeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notices.
     */
    data: NoticeCreateManyInput | NoticeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notice update
   */
  export type NoticeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The data needed to update a Notice.
     */
    data: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
    /**
     * Choose, which Notice to update.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice updateMany
   */
  export type NoticeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notices.
     */
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyInput>
    /**
     * Filter which Notices to update
     */
    where?: NoticeWhereInput
    /**
     * Limit how many Notices to update.
     */
    limit?: number
  }

  /**
   * Notice upsert
   */
  export type NoticeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The filter to search for the Notice to update in case it exists.
     */
    where: NoticeWhereUniqueInput
    /**
     * In case the Notice found by the `where` argument doesn't exist, create a new Notice with this data.
     */
    create: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
    /**
     * In case the Notice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
  }

  /**
   * Notice delete
   */
  export type NoticeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter which Notice to delete.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice deleteMany
   */
  export type NoticeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notices to delete
     */
    where?: NoticeWhereInput
    /**
     * Limit how many Notices to delete.
     */
    limit?: number
  }

  /**
   * Notice without action
   */
  export type NoticeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
  }


  /**
   * Model Amenity
   */

  export type AggregateAmenity = {
    _count: AmenityCountAggregateOutputType | null
    _avg: AmenityAvgAggregateOutputType | null
    _sum: AmenitySumAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  export type AmenityAvgAggregateOutputType = {
    id: number | null
    capacity: number | null
    chargesPerHour: number | null
    societyId: number | null
  }

  export type AmenitySumAggregateOutputType = {
    id: number | null
    capacity: number | null
    chargesPerHour: number | null
    societyId: number | null
  }

  export type AmenityMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    description: string | null
    capacity: number | null
    chargesPerHour: number | null
    status: string | null
    societyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmenityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    description: string | null
    capacity: number | null
    chargesPerHour: number | null
    status: string | null
    societyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmenityCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    capacity: number
    chargesPerHour: number
    availableDays: number
    timings: number
    status: number
    societyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AmenityAvgAggregateInputType = {
    id?: true
    capacity?: true
    chargesPerHour?: true
    societyId?: true
  }

  export type AmenitySumAggregateInputType = {
    id?: true
    capacity?: true
    chargesPerHour?: true
    societyId?: true
  }

  export type AmenityMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    capacity?: true
    chargesPerHour?: true
    status?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmenityMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    capacity?: true
    chargesPerHour?: true
    status?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmenityCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    capacity?: true
    chargesPerHour?: true
    availableDays?: true
    timings?: true
    status?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenity to aggregate.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Amenities
    **/
    _count?: true | AmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmenityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmenitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenityMaxAggregateInputType
  }

  export type GetAmenityAggregateType<T extends AmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenity[P]>
      : GetScalarType<T[P], AggregateAmenity[P]>
  }




  export type AmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityWhereInput
    orderBy?: AmenityOrderByWithAggregationInput | AmenityOrderByWithAggregationInput[]
    by: AmenityScalarFieldEnum[] | AmenityScalarFieldEnum
    having?: AmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenityCountAggregateInputType | true
    _avg?: AmenityAvgAggregateInputType
    _sum?: AmenitySumAggregateInputType
    _min?: AmenityMinAggregateInputType
    _max?: AmenityMaxAggregateInputType
  }

  export type AmenityGroupByOutputType = {
    id: number
    name: string
    type: string
    description: string | null
    capacity: number
    chargesPerHour: number
    availableDays: JsonValue | null
    timings: JsonValue | null
    status: string
    societyId: number
    createdAt: Date
    updatedAt: Date
    _count: AmenityCountAggregateOutputType | null
    _avg: AmenityAvgAggregateOutputType | null
    _sum: AmenitySumAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  type GetAmenityGroupByPayload<T extends AmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenityGroupByOutputType[P]>
            : GetScalarType<T[P], AmenityGroupByOutputType[P]>
        }
      >
    >


  export type AmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    capacity?: boolean
    chargesPerHour?: boolean
    availableDays?: boolean
    timings?: boolean
    status?: boolean
    societyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    bookings?: boolean | Amenity$bookingsArgs<ExtArgs>
    _count?: boolean | AmenityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amenity"]>



  export type AmenitySelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    capacity?: boolean
    chargesPerHour?: boolean
    availableDays?: boolean
    timings?: boolean
    status?: boolean
    societyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "description" | "capacity" | "chargesPerHour" | "availableDays" | "timings" | "status" | "societyId" | "createdAt" | "updatedAt", ExtArgs["result"]["amenity"]>
  export type AmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    bookings?: boolean | Amenity$bookingsArgs<ExtArgs>
    _count?: boolean | AmenityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Amenity"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      bookings: Prisma.$AmenityBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      description: string | null
      capacity: number
      chargesPerHour: number
      availableDays: Prisma.JsonValue | null
      timings: Prisma.JsonValue | null
      status: string
      societyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["amenity"]>
    composites: {}
  }

  type AmenityGetPayload<S extends boolean | null | undefined | AmenityDefaultArgs> = $Result.GetResult<Prisma.$AmenityPayload, S>

  type AmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmenityCountAggregateInputType | true
    }

  export interface AmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Amenity'], meta: { name: 'Amenity' } }
    /**
     * Find zero or one Amenity that matches the filter.
     * @param {AmenityFindUniqueArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmenityFindUniqueArgs>(args: SelectSubset<T, AmenityFindUniqueArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Amenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmenityFindUniqueOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, AmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmenityFindFirstArgs>(args?: SelectSubset<T, AmenityFindFirstArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, AmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amenities
     * const amenities = await prisma.amenity.findMany()
     * 
     * // Get first 10 Amenities
     * const amenities = await prisma.amenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amenityWithIdOnly = await prisma.amenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmenityFindManyArgs>(args?: SelectSubset<T, AmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Amenity.
     * @param {AmenityCreateArgs} args - Arguments to create a Amenity.
     * @example
     * // Create one Amenity
     * const Amenity = await prisma.amenity.create({
     *   data: {
     *     // ... data to create a Amenity
     *   }
     * })
     * 
     */
    create<T extends AmenityCreateArgs>(args: SelectSubset<T, AmenityCreateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Amenities.
     * @param {AmenityCreateManyArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenity = await prisma.amenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmenityCreateManyArgs>(args?: SelectSubset<T, AmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Amenity.
     * @param {AmenityDeleteArgs} args - Arguments to delete one Amenity.
     * @example
     * // Delete one Amenity
     * const Amenity = await prisma.amenity.delete({
     *   where: {
     *     // ... filter to delete one Amenity
     *   }
     * })
     * 
     */
    delete<T extends AmenityDeleteArgs>(args: SelectSubset<T, AmenityDeleteArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Amenity.
     * @param {AmenityUpdateArgs} args - Arguments to update one Amenity.
     * @example
     * // Update one Amenity
     * const amenity = await prisma.amenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmenityUpdateArgs>(args: SelectSubset<T, AmenityUpdateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Amenities.
     * @param {AmenityDeleteManyArgs} args - Arguments to filter Amenities to delete.
     * @example
     * // Delete a few Amenities
     * const { count } = await prisma.amenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmenityDeleteManyArgs>(args?: SelectSubset<T, AmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amenities
     * const amenity = await prisma.amenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmenityUpdateManyArgs>(args: SelectSubset<T, AmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Amenity.
     * @param {AmenityUpsertArgs} args - Arguments to update or create a Amenity.
     * @example
     * // Update or create a Amenity
     * const amenity = await prisma.amenity.upsert({
     *   create: {
     *     // ... data to create a Amenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amenity we want to update
     *   }
     * })
     */
    upsert<T extends AmenityUpsertArgs>(args: SelectSubset<T, AmenityUpsertArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityCountArgs} args - Arguments to filter Amenities to count.
     * @example
     * // Count the number of Amenities
     * const count = await prisma.amenity.count({
     *   where: {
     *     // ... the filter for the Amenities we want to count
     *   }
     * })
    **/
    count<T extends AmenityCountArgs>(
      args?: Subset<T, AmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenityAggregateArgs>(args: Subset<T, AmenityAggregateArgs>): Prisma.PrismaPromise<GetAmenityAggregateType<T>>

    /**
     * Group by Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmenityGroupByArgs['orderBy'] }
        : { orderBy?: AmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Amenity model
   */
  readonly fields: AmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Amenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookings<T extends Amenity$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Amenity$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Amenity model
   */
  interface AmenityFieldRefs {
    readonly id: FieldRef<"Amenity", 'Int'>
    readonly name: FieldRef<"Amenity", 'String'>
    readonly type: FieldRef<"Amenity", 'String'>
    readonly description: FieldRef<"Amenity", 'String'>
    readonly capacity: FieldRef<"Amenity", 'Int'>
    readonly chargesPerHour: FieldRef<"Amenity", 'Float'>
    readonly availableDays: FieldRef<"Amenity", 'Json'>
    readonly timings: FieldRef<"Amenity", 'Json'>
    readonly status: FieldRef<"Amenity", 'String'>
    readonly societyId: FieldRef<"Amenity", 'Int'>
    readonly createdAt: FieldRef<"Amenity", 'DateTime'>
    readonly updatedAt: FieldRef<"Amenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Amenity findUnique
   */
  export type AmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findUniqueOrThrow
   */
  export type AmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findFirst
   */
  export type AmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findFirstOrThrow
   */
  export type AmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findMany
   */
  export type AmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity create
   */
  export type AmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a Amenity.
     */
    data: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
  }

  /**
   * Amenity createMany
   */
  export type AmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Amenities.
     */
    data: AmenityCreateManyInput | AmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenity update
   */
  export type AmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a Amenity.
     */
    data: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
    /**
     * Choose, which Amenity to update.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity updateMany
   */
  export type AmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenity upsert
   */
  export type AmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the Amenity to update in case it exists.
     */
    where: AmenityWhereUniqueInput
    /**
     * In case the Amenity found by the `where` argument doesn't exist, create a new Amenity with this data.
     */
    create: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
    /**
     * In case the Amenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
  }

  /**
   * Amenity delete
   */
  export type AmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter which Amenity to delete.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity deleteMany
   */
  export type AmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to delete
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to delete.
     */
    limit?: number
  }

  /**
   * Amenity.bookings
   */
  export type Amenity$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    where?: AmenityBookingWhereInput
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    cursor?: AmenityBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmenityBookingScalarFieldEnum | AmenityBookingScalarFieldEnum[]
  }

  /**
   * Amenity without action
   */
  export type AmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
  }


  /**
   * Model AmenityBooking
   */

  export type AggregateAmenityBooking = {
    _count: AmenityBookingCountAggregateOutputType | null
    _avg: AmenityBookingAvgAggregateOutputType | null
    _sum: AmenityBookingSumAggregateOutputType | null
    _min: AmenityBookingMinAggregateOutputType | null
    _max: AmenityBookingMaxAggregateOutputType | null
  }

  export type AmenityBookingAvgAggregateOutputType = {
    id: number | null
    amenityId: number | null
    userId: number | null
    amountPaid: number | null
  }

  export type AmenityBookingSumAggregateOutputType = {
    id: number | null
    amenityId: number | null
    userId: number | null
    amountPaid: number | null
  }

  export type AmenityBookingMinAggregateOutputType = {
    id: number | null
    amenityId: number | null
    userId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    purpose: string | null
    status: string | null
    amountPaid: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmenityBookingMaxAggregateOutputType = {
    id: number | null
    amenityId: number | null
    userId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    purpose: string | null
    status: string | null
    amountPaid: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmenityBookingCountAggregateOutputType = {
    id: number
    amenityId: number
    userId: number
    date: number
    startTime: number
    endTime: number
    purpose: number
    status: number
    amountPaid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AmenityBookingAvgAggregateInputType = {
    id?: true
    amenityId?: true
    userId?: true
    amountPaid?: true
  }

  export type AmenityBookingSumAggregateInputType = {
    id?: true
    amenityId?: true
    userId?: true
    amountPaid?: true
  }

  export type AmenityBookingMinAggregateInputType = {
    id?: true
    amenityId?: true
    userId?: true
    date?: true
    startTime?: true
    endTime?: true
    purpose?: true
    status?: true
    amountPaid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmenityBookingMaxAggregateInputType = {
    id?: true
    amenityId?: true
    userId?: true
    date?: true
    startTime?: true
    endTime?: true
    purpose?: true
    status?: true
    amountPaid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmenityBookingCountAggregateInputType = {
    id?: true
    amenityId?: true
    userId?: true
    date?: true
    startTime?: true
    endTime?: true
    purpose?: true
    status?: true
    amountPaid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AmenityBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmenityBooking to aggregate.
     */
    where?: AmenityBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmenityBookings to fetch.
     */
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmenityBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmenityBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmenityBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AmenityBookings
    **/
    _count?: true | AmenityBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmenityBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmenityBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenityBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenityBookingMaxAggregateInputType
  }

  export type GetAmenityBookingAggregateType<T extends AmenityBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenityBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenityBooking[P]>
      : GetScalarType<T[P], AggregateAmenityBooking[P]>
  }




  export type AmenityBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityBookingWhereInput
    orderBy?: AmenityBookingOrderByWithAggregationInput | AmenityBookingOrderByWithAggregationInput[]
    by: AmenityBookingScalarFieldEnum[] | AmenityBookingScalarFieldEnum
    having?: AmenityBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenityBookingCountAggregateInputType | true
    _avg?: AmenityBookingAvgAggregateInputType
    _sum?: AmenityBookingSumAggregateInputType
    _min?: AmenityBookingMinAggregateInputType
    _max?: AmenityBookingMaxAggregateInputType
  }

  export type AmenityBookingGroupByOutputType = {
    id: number
    amenityId: number
    userId: number
    date: Date
    startTime: string
    endTime: string
    purpose: string | null
    status: string
    amountPaid: number
    createdAt: Date
    updatedAt: Date
    _count: AmenityBookingCountAggregateOutputType | null
    _avg: AmenityBookingAvgAggregateOutputType | null
    _sum: AmenityBookingSumAggregateOutputType | null
    _min: AmenityBookingMinAggregateOutputType | null
    _max: AmenityBookingMaxAggregateOutputType | null
  }

  type GetAmenityBookingGroupByPayload<T extends AmenityBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenityBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenityBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenityBookingGroupByOutputType[P]>
            : GetScalarType<T[P], AmenityBookingGroupByOutputType[P]>
        }
      >
    >


  export type AmenityBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amenityId?: boolean
    userId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    purpose?: boolean
    status?: boolean
    amountPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amenityBooking"]>



  export type AmenityBookingSelectScalar = {
    id?: boolean
    amenityId?: boolean
    userId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    purpose?: boolean
    status?: boolean
    amountPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AmenityBookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amenityId" | "userId" | "date" | "startTime" | "endTime" | "purpose" | "status" | "amountPaid" | "createdAt" | "updatedAt", ExtArgs["result"]["amenityBooking"]>
  export type AmenityBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AmenityBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AmenityBooking"
    objects: {
      amenity: Prisma.$AmenityPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amenityId: number
      userId: number
      date: Date
      startTime: string
      endTime: string
      purpose: string | null
      status: string
      amountPaid: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["amenityBooking"]>
    composites: {}
  }

  type AmenityBookingGetPayload<S extends boolean | null | undefined | AmenityBookingDefaultArgs> = $Result.GetResult<Prisma.$AmenityBookingPayload, S>

  type AmenityBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmenityBookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmenityBookingCountAggregateInputType | true
    }

  export interface AmenityBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AmenityBooking'], meta: { name: 'AmenityBooking' } }
    /**
     * Find zero or one AmenityBooking that matches the filter.
     * @param {AmenityBookingFindUniqueArgs} args - Arguments to find a AmenityBooking
     * @example
     * // Get one AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmenityBookingFindUniqueArgs>(args: SelectSubset<T, AmenityBookingFindUniqueArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AmenityBooking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmenityBookingFindUniqueOrThrowArgs} args - Arguments to find a AmenityBooking
     * @example
     * // Get one AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmenityBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, AmenityBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmenityBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingFindFirstArgs} args - Arguments to find a AmenityBooking
     * @example
     * // Get one AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmenityBookingFindFirstArgs>(args?: SelectSubset<T, AmenityBookingFindFirstArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmenityBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingFindFirstOrThrowArgs} args - Arguments to find a AmenityBooking
     * @example
     * // Get one AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmenityBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, AmenityBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AmenityBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AmenityBookings
     * const amenityBookings = await prisma.amenityBooking.findMany()
     * 
     * // Get first 10 AmenityBookings
     * const amenityBookings = await prisma.amenityBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amenityBookingWithIdOnly = await prisma.amenityBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmenityBookingFindManyArgs>(args?: SelectSubset<T, AmenityBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AmenityBooking.
     * @param {AmenityBookingCreateArgs} args - Arguments to create a AmenityBooking.
     * @example
     * // Create one AmenityBooking
     * const AmenityBooking = await prisma.amenityBooking.create({
     *   data: {
     *     // ... data to create a AmenityBooking
     *   }
     * })
     * 
     */
    create<T extends AmenityBookingCreateArgs>(args: SelectSubset<T, AmenityBookingCreateArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AmenityBookings.
     * @param {AmenityBookingCreateManyArgs} args - Arguments to create many AmenityBookings.
     * @example
     * // Create many AmenityBookings
     * const amenityBooking = await prisma.amenityBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmenityBookingCreateManyArgs>(args?: SelectSubset<T, AmenityBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AmenityBooking.
     * @param {AmenityBookingDeleteArgs} args - Arguments to delete one AmenityBooking.
     * @example
     * // Delete one AmenityBooking
     * const AmenityBooking = await prisma.amenityBooking.delete({
     *   where: {
     *     // ... filter to delete one AmenityBooking
     *   }
     * })
     * 
     */
    delete<T extends AmenityBookingDeleteArgs>(args: SelectSubset<T, AmenityBookingDeleteArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AmenityBooking.
     * @param {AmenityBookingUpdateArgs} args - Arguments to update one AmenityBooking.
     * @example
     * // Update one AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmenityBookingUpdateArgs>(args: SelectSubset<T, AmenityBookingUpdateArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AmenityBookings.
     * @param {AmenityBookingDeleteManyArgs} args - Arguments to filter AmenityBookings to delete.
     * @example
     * // Delete a few AmenityBookings
     * const { count } = await prisma.amenityBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmenityBookingDeleteManyArgs>(args?: SelectSubset<T, AmenityBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmenityBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AmenityBookings
     * const amenityBooking = await prisma.amenityBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmenityBookingUpdateManyArgs>(args: SelectSubset<T, AmenityBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AmenityBooking.
     * @param {AmenityBookingUpsertArgs} args - Arguments to update or create a AmenityBooking.
     * @example
     * // Update or create a AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.upsert({
     *   create: {
     *     // ... data to create a AmenityBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AmenityBooking we want to update
     *   }
     * })
     */
    upsert<T extends AmenityBookingUpsertArgs>(args: SelectSubset<T, AmenityBookingUpsertArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AmenityBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingCountArgs} args - Arguments to filter AmenityBookings to count.
     * @example
     * // Count the number of AmenityBookings
     * const count = await prisma.amenityBooking.count({
     *   where: {
     *     // ... the filter for the AmenityBookings we want to count
     *   }
     * })
    **/
    count<T extends AmenityBookingCountArgs>(
      args?: Subset<T, AmenityBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenityBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AmenityBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenityBookingAggregateArgs>(args: Subset<T, AmenityBookingAggregateArgs>): Prisma.PrismaPromise<GetAmenityBookingAggregateType<T>>

    /**
     * Group by AmenityBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmenityBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmenityBookingGroupByArgs['orderBy'] }
        : { orderBy?: AmenityBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmenityBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenityBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AmenityBooking model
   */
  readonly fields: AmenityBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AmenityBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmenityBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    amenity<T extends AmenityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AmenityDefaultArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AmenityBooking model
   */
  interface AmenityBookingFieldRefs {
    readonly id: FieldRef<"AmenityBooking", 'Int'>
    readonly amenityId: FieldRef<"AmenityBooking", 'Int'>
    readonly userId: FieldRef<"AmenityBooking", 'Int'>
    readonly date: FieldRef<"AmenityBooking", 'DateTime'>
    readonly startTime: FieldRef<"AmenityBooking", 'String'>
    readonly endTime: FieldRef<"AmenityBooking", 'String'>
    readonly purpose: FieldRef<"AmenityBooking", 'String'>
    readonly status: FieldRef<"AmenityBooking", 'String'>
    readonly amountPaid: FieldRef<"AmenityBooking", 'Float'>
    readonly createdAt: FieldRef<"AmenityBooking", 'DateTime'>
    readonly updatedAt: FieldRef<"AmenityBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AmenityBooking findUnique
   */
  export type AmenityBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter, which AmenityBooking to fetch.
     */
    where: AmenityBookingWhereUniqueInput
  }

  /**
   * AmenityBooking findUniqueOrThrow
   */
  export type AmenityBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter, which AmenityBooking to fetch.
     */
    where: AmenityBookingWhereUniqueInput
  }

  /**
   * AmenityBooking findFirst
   */
  export type AmenityBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter, which AmenityBooking to fetch.
     */
    where?: AmenityBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmenityBookings to fetch.
     */
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmenityBookings.
     */
    cursor?: AmenityBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmenityBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmenityBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmenityBookings.
     */
    distinct?: AmenityBookingScalarFieldEnum | AmenityBookingScalarFieldEnum[]
  }

  /**
   * AmenityBooking findFirstOrThrow
   */
  export type AmenityBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter, which AmenityBooking to fetch.
     */
    where?: AmenityBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmenityBookings to fetch.
     */
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmenityBookings.
     */
    cursor?: AmenityBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmenityBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmenityBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmenityBookings.
     */
    distinct?: AmenityBookingScalarFieldEnum | AmenityBookingScalarFieldEnum[]
  }

  /**
   * AmenityBooking findMany
   */
  export type AmenityBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter, which AmenityBookings to fetch.
     */
    where?: AmenityBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmenityBookings to fetch.
     */
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AmenityBookings.
     */
    cursor?: AmenityBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmenityBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmenityBookings.
     */
    skip?: number
    distinct?: AmenityBookingScalarFieldEnum | AmenityBookingScalarFieldEnum[]
  }

  /**
   * AmenityBooking create
   */
  export type AmenityBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a AmenityBooking.
     */
    data: XOR<AmenityBookingCreateInput, AmenityBookingUncheckedCreateInput>
  }

  /**
   * AmenityBooking createMany
   */
  export type AmenityBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AmenityBookings.
     */
    data: AmenityBookingCreateManyInput | AmenityBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AmenityBooking update
   */
  export type AmenityBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a AmenityBooking.
     */
    data: XOR<AmenityBookingUpdateInput, AmenityBookingUncheckedUpdateInput>
    /**
     * Choose, which AmenityBooking to update.
     */
    where: AmenityBookingWhereUniqueInput
  }

  /**
   * AmenityBooking updateMany
   */
  export type AmenityBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AmenityBookings.
     */
    data: XOR<AmenityBookingUpdateManyMutationInput, AmenityBookingUncheckedUpdateManyInput>
    /**
     * Filter which AmenityBookings to update
     */
    where?: AmenityBookingWhereInput
    /**
     * Limit how many AmenityBookings to update.
     */
    limit?: number
  }

  /**
   * AmenityBooking upsert
   */
  export type AmenityBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the AmenityBooking to update in case it exists.
     */
    where: AmenityBookingWhereUniqueInput
    /**
     * In case the AmenityBooking found by the `where` argument doesn't exist, create a new AmenityBooking with this data.
     */
    create: XOR<AmenityBookingCreateInput, AmenityBookingUncheckedCreateInput>
    /**
     * In case the AmenityBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmenityBookingUpdateInput, AmenityBookingUncheckedUpdateInput>
  }

  /**
   * AmenityBooking delete
   */
  export type AmenityBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter which AmenityBooking to delete.
     */
    where: AmenityBookingWhereUniqueInput
  }

  /**
   * AmenityBooking deleteMany
   */
  export type AmenityBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmenityBookings to delete
     */
    where?: AmenityBookingWhereInput
    /**
     * Limit how many AmenityBookings to delete.
     */
    limit?: number
  }

  /**
   * AmenityBooking without action
   */
  export type AmenityBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _avg: SystemSettingAvgAggregateOutputType | null
    _sum: SystemSettingSumAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingAvgAggregateOutputType = {
    id: number | null
  }

  export type SystemSettingSumAggregateOutputType = {
    id: number | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    _all: number
  }


  export type SystemSettingAvgAggregateInputType = {
    id?: true
  }

  export type SystemSettingSumAggregateInputType = {
    id?: true
  }

  export type SystemSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _avg?: SystemSettingAvgAggregateInputType
    _sum?: SystemSettingSumAggregateInputType
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: number
    key: string
    value: string
    _count: SystemSettingCountAggregateOutputType | null
    _avg: SystemSettingAvgAggregateOutputType | null
    _sum: SystemSettingSumAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["systemSetting"]>



  export type SystemSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
  }

  export type SystemSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value", ExtArgs["result"]["systemSetting"]>

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: string
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'Int'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
  }


  /**
   * Model BillingPlan
   */

  export type AggregateBillingPlan = {
    _count: BillingPlanCountAggregateOutputType | null
    _avg: BillingPlanAvgAggregateOutputType | null
    _sum: BillingPlanSumAggregateOutputType | null
    _min: BillingPlanMinAggregateOutputType | null
    _max: BillingPlanMaxAggregateOutputType | null
  }

  export type BillingPlanAvgAggregateOutputType = {
    id: number | null
  }

  export type BillingPlanSumAggregateOutputType = {
    id: number | null
  }

  export type BillingPlanMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    price: string | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingPlanMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    price: string | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingPlanCountAggregateOutputType = {
    id: number
    name: number
    type: number
    price: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillingPlanAvgAggregateInputType = {
    id?: true
  }

  export type BillingPlanSumAggregateInputType = {
    id?: true
  }

  export type BillingPlanMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    price?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingPlanMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    price?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingPlanCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    price?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillingPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingPlan to aggregate.
     */
    where?: BillingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPlans to fetch.
     */
    orderBy?: BillingPlanOrderByWithRelationInput | BillingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingPlans
    **/
    _count?: true | BillingPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingPlanMaxAggregateInputType
  }

  export type GetBillingPlanAggregateType<T extends BillingPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingPlan[P]>
      : GetScalarType<T[P], AggregateBillingPlan[P]>
  }




  export type BillingPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingPlanWhereInput
    orderBy?: BillingPlanOrderByWithAggregationInput | BillingPlanOrderByWithAggregationInput[]
    by: BillingPlanScalarFieldEnum[] | BillingPlanScalarFieldEnum
    having?: BillingPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingPlanCountAggregateInputType | true
    _avg?: BillingPlanAvgAggregateInputType
    _sum?: BillingPlanSumAggregateInputType
    _min?: BillingPlanMinAggregateInputType
    _max?: BillingPlanMaxAggregateInputType
  }

  export type BillingPlanGroupByOutputType = {
    id: number
    name: string
    type: string
    price: string
    description: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: BillingPlanCountAggregateOutputType | null
    _avg: BillingPlanAvgAggregateOutputType | null
    _sum: BillingPlanSumAggregateOutputType | null
    _min: BillingPlanMinAggregateOutputType | null
    _max: BillingPlanMaxAggregateOutputType | null
  }

  type GetBillingPlanGroupByPayload<T extends BillingPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingPlanGroupByOutputType[P]>
            : GetScalarType<T[P], BillingPlanGroupByOutputType[P]>
        }
      >
    >


  export type BillingPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    price?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["billingPlan"]>



  export type BillingPlanSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    price?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillingPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "price" | "description" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["billingPlan"]>

  export type $BillingPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingPlan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      price: string
      description: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["billingPlan"]>
    composites: {}
  }

  type BillingPlanGetPayload<S extends boolean | null | undefined | BillingPlanDefaultArgs> = $Result.GetResult<Prisma.$BillingPlanPayload, S>

  type BillingPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingPlanCountAggregateInputType | true
    }

  export interface BillingPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingPlan'], meta: { name: 'BillingPlan' } }
    /**
     * Find zero or one BillingPlan that matches the filter.
     * @param {BillingPlanFindUniqueArgs} args - Arguments to find a BillingPlan
     * @example
     * // Get one BillingPlan
     * const billingPlan = await prisma.billingPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingPlanFindUniqueArgs>(args: SelectSubset<T, BillingPlanFindUniqueArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingPlanFindUniqueOrThrowArgs} args - Arguments to find a BillingPlan
     * @example
     * // Get one BillingPlan
     * const billingPlan = await prisma.billingPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanFindFirstArgs} args - Arguments to find a BillingPlan
     * @example
     * // Get one BillingPlan
     * const billingPlan = await prisma.billingPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingPlanFindFirstArgs>(args?: SelectSubset<T, BillingPlanFindFirstArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanFindFirstOrThrowArgs} args - Arguments to find a BillingPlan
     * @example
     * // Get one BillingPlan
     * const billingPlan = await prisma.billingPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingPlans
     * const billingPlans = await prisma.billingPlan.findMany()
     * 
     * // Get first 10 BillingPlans
     * const billingPlans = await prisma.billingPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingPlanWithIdOnly = await prisma.billingPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingPlanFindManyArgs>(args?: SelectSubset<T, BillingPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingPlan.
     * @param {BillingPlanCreateArgs} args - Arguments to create a BillingPlan.
     * @example
     * // Create one BillingPlan
     * const BillingPlan = await prisma.billingPlan.create({
     *   data: {
     *     // ... data to create a BillingPlan
     *   }
     * })
     * 
     */
    create<T extends BillingPlanCreateArgs>(args: SelectSubset<T, BillingPlanCreateArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingPlans.
     * @param {BillingPlanCreateManyArgs} args - Arguments to create many BillingPlans.
     * @example
     * // Create many BillingPlans
     * const billingPlan = await prisma.billingPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingPlanCreateManyArgs>(args?: SelectSubset<T, BillingPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BillingPlan.
     * @param {BillingPlanDeleteArgs} args - Arguments to delete one BillingPlan.
     * @example
     * // Delete one BillingPlan
     * const BillingPlan = await prisma.billingPlan.delete({
     *   where: {
     *     // ... filter to delete one BillingPlan
     *   }
     * })
     * 
     */
    delete<T extends BillingPlanDeleteArgs>(args: SelectSubset<T, BillingPlanDeleteArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingPlan.
     * @param {BillingPlanUpdateArgs} args - Arguments to update one BillingPlan.
     * @example
     * // Update one BillingPlan
     * const billingPlan = await prisma.billingPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingPlanUpdateArgs>(args: SelectSubset<T, BillingPlanUpdateArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingPlans.
     * @param {BillingPlanDeleteManyArgs} args - Arguments to filter BillingPlans to delete.
     * @example
     * // Delete a few BillingPlans
     * const { count } = await prisma.billingPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingPlanDeleteManyArgs>(args?: SelectSubset<T, BillingPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingPlans
     * const billingPlan = await prisma.billingPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingPlanUpdateManyArgs>(args: SelectSubset<T, BillingPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BillingPlan.
     * @param {BillingPlanUpsertArgs} args - Arguments to update or create a BillingPlan.
     * @example
     * // Update or create a BillingPlan
     * const billingPlan = await prisma.billingPlan.upsert({
     *   create: {
     *     // ... data to create a BillingPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingPlan we want to update
     *   }
     * })
     */
    upsert<T extends BillingPlanUpsertArgs>(args: SelectSubset<T, BillingPlanUpsertArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanCountArgs} args - Arguments to filter BillingPlans to count.
     * @example
     * // Count the number of BillingPlans
     * const count = await prisma.billingPlan.count({
     *   where: {
     *     // ... the filter for the BillingPlans we want to count
     *   }
     * })
    **/
    count<T extends BillingPlanCountArgs>(
      args?: Subset<T, BillingPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingPlanAggregateArgs>(args: Subset<T, BillingPlanAggregateArgs>): Prisma.PrismaPromise<GetBillingPlanAggregateType<T>>

    /**
     * Group by BillingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingPlanGroupByArgs['orderBy'] }
        : { orderBy?: BillingPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingPlan model
   */
  readonly fields: BillingPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingPlan model
   */
  interface BillingPlanFieldRefs {
    readonly id: FieldRef<"BillingPlan", 'Int'>
    readonly name: FieldRef<"BillingPlan", 'String'>
    readonly type: FieldRef<"BillingPlan", 'String'>
    readonly price: FieldRef<"BillingPlan", 'String'>
    readonly description: FieldRef<"BillingPlan", 'String'>
    readonly status: FieldRef<"BillingPlan", 'String'>
    readonly createdAt: FieldRef<"BillingPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"BillingPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillingPlan findUnique
   */
  export type BillingPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Filter, which BillingPlan to fetch.
     */
    where: BillingPlanWhereUniqueInput
  }

  /**
   * BillingPlan findUniqueOrThrow
   */
  export type BillingPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Filter, which BillingPlan to fetch.
     */
    where: BillingPlanWhereUniqueInput
  }

  /**
   * BillingPlan findFirst
   */
  export type BillingPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Filter, which BillingPlan to fetch.
     */
    where?: BillingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPlans to fetch.
     */
    orderBy?: BillingPlanOrderByWithRelationInput | BillingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingPlans.
     */
    cursor?: BillingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingPlans.
     */
    distinct?: BillingPlanScalarFieldEnum | BillingPlanScalarFieldEnum[]
  }

  /**
   * BillingPlan findFirstOrThrow
   */
  export type BillingPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Filter, which BillingPlan to fetch.
     */
    where?: BillingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPlans to fetch.
     */
    orderBy?: BillingPlanOrderByWithRelationInput | BillingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingPlans.
     */
    cursor?: BillingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingPlans.
     */
    distinct?: BillingPlanScalarFieldEnum | BillingPlanScalarFieldEnum[]
  }

  /**
   * BillingPlan findMany
   */
  export type BillingPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Filter, which BillingPlans to fetch.
     */
    where?: BillingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPlans to fetch.
     */
    orderBy?: BillingPlanOrderByWithRelationInput | BillingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingPlans.
     */
    cursor?: BillingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPlans.
     */
    skip?: number
    distinct?: BillingPlanScalarFieldEnum | BillingPlanScalarFieldEnum[]
  }

  /**
   * BillingPlan create
   */
  export type BillingPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * The data needed to create a BillingPlan.
     */
    data: XOR<BillingPlanCreateInput, BillingPlanUncheckedCreateInput>
  }

  /**
   * BillingPlan createMany
   */
  export type BillingPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingPlans.
     */
    data: BillingPlanCreateManyInput | BillingPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingPlan update
   */
  export type BillingPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * The data needed to update a BillingPlan.
     */
    data: XOR<BillingPlanUpdateInput, BillingPlanUncheckedUpdateInput>
    /**
     * Choose, which BillingPlan to update.
     */
    where: BillingPlanWhereUniqueInput
  }

  /**
   * BillingPlan updateMany
   */
  export type BillingPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingPlans.
     */
    data: XOR<BillingPlanUpdateManyMutationInput, BillingPlanUncheckedUpdateManyInput>
    /**
     * Filter which BillingPlans to update
     */
    where?: BillingPlanWhereInput
    /**
     * Limit how many BillingPlans to update.
     */
    limit?: number
  }

  /**
   * BillingPlan upsert
   */
  export type BillingPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * The filter to search for the BillingPlan to update in case it exists.
     */
    where: BillingPlanWhereUniqueInput
    /**
     * In case the BillingPlan found by the `where` argument doesn't exist, create a new BillingPlan with this data.
     */
    create: XOR<BillingPlanCreateInput, BillingPlanUncheckedCreateInput>
    /**
     * In case the BillingPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingPlanUpdateInput, BillingPlanUncheckedUpdateInput>
  }

  /**
   * BillingPlan delete
   */
  export type BillingPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Filter which BillingPlan to delete.
     */
    where: BillingPlanWhereUniqueInput
  }

  /**
   * BillingPlan deleteMany
   */
  export type BillingPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingPlans to delete
     */
    where?: BillingPlanWhereInput
    /**
     * Limit how many BillingPlans to delete.
     */
    limit?: number
  }

  /**
   * BillingPlan without action
   */
  export type BillingPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
  }


  /**
   * Model PlatformInvoice
   */

  export type AggregatePlatformInvoice = {
    _count: PlatformInvoiceCountAggregateOutputType | null
    _avg: PlatformInvoiceAvgAggregateOutputType | null
    _sum: PlatformInvoiceSumAggregateOutputType | null
    _min: PlatformInvoiceMinAggregateOutputType | null
    _max: PlatformInvoiceMaxAggregateOutputType | null
  }

  export type PlatformInvoiceAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
    amount: number | null
  }

  export type PlatformInvoiceSumAggregateOutputType = {
    id: number | null
    societyId: number | null
    amount: number | null
  }

  export type PlatformInvoiceMinAggregateOutputType = {
    id: number | null
    invoiceNo: string | null
    societyId: number | null
    amount: number | null
    status: string | null
    issueDate: Date | null
    dueDate: Date | null
    paidDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformInvoiceMaxAggregateOutputType = {
    id: number | null
    invoiceNo: string | null
    societyId: number | null
    amount: number | null
    status: string | null
    issueDate: Date | null
    dueDate: Date | null
    paidDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformInvoiceCountAggregateOutputType = {
    id: number
    invoiceNo: number
    societyId: number
    amount: number
    status: number
    issueDate: number
    dueDate: number
    paidDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlatformInvoiceAvgAggregateInputType = {
    id?: true
    societyId?: true
    amount?: true
  }

  export type PlatformInvoiceSumAggregateInputType = {
    id?: true
    societyId?: true
    amount?: true
  }

  export type PlatformInvoiceMinAggregateInputType = {
    id?: true
    invoiceNo?: true
    societyId?: true
    amount?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformInvoiceMaxAggregateInputType = {
    id?: true
    invoiceNo?: true
    societyId?: true
    amount?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformInvoiceCountAggregateInputType = {
    id?: true
    invoiceNo?: true
    societyId?: true
    amount?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlatformInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformInvoice to aggregate.
     */
    where?: PlatformInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformInvoices to fetch.
     */
    orderBy?: PlatformInvoiceOrderByWithRelationInput | PlatformInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlatformInvoices
    **/
    _count?: true | PlatformInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlatformInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlatformInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformInvoiceMaxAggregateInputType
  }

  export type GetPlatformInvoiceAggregateType<T extends PlatformInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatformInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatformInvoice[P]>
      : GetScalarType<T[P], AggregatePlatformInvoice[P]>
  }




  export type PlatformInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformInvoiceWhereInput
    orderBy?: PlatformInvoiceOrderByWithAggregationInput | PlatformInvoiceOrderByWithAggregationInput[]
    by: PlatformInvoiceScalarFieldEnum[] | PlatformInvoiceScalarFieldEnum
    having?: PlatformInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformInvoiceCountAggregateInputType | true
    _avg?: PlatformInvoiceAvgAggregateInputType
    _sum?: PlatformInvoiceSumAggregateInputType
    _min?: PlatformInvoiceMinAggregateInputType
    _max?: PlatformInvoiceMaxAggregateInputType
  }

  export type PlatformInvoiceGroupByOutputType = {
    id: number
    invoiceNo: string
    societyId: number
    amount: number
    status: string
    issueDate: Date
    dueDate: Date
    paidDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PlatformInvoiceCountAggregateOutputType | null
    _avg: PlatformInvoiceAvgAggregateOutputType | null
    _sum: PlatformInvoiceSumAggregateOutputType | null
    _min: PlatformInvoiceMinAggregateOutputType | null
    _max: PlatformInvoiceMaxAggregateOutputType | null
  }

  type GetPlatformInvoiceGroupByPayload<T extends PlatformInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type PlatformInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNo?: boolean
    societyId?: boolean
    amount?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformInvoice"]>



  export type PlatformInvoiceSelectScalar = {
    id?: boolean
    invoiceNo?: boolean
    societyId?: boolean
    amount?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlatformInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNo" | "societyId" | "amount" | "status" | "issueDate" | "dueDate" | "paidDate" | "createdAt" | "updatedAt", ExtArgs["result"]["platformInvoice"]>
  export type PlatformInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $PlatformInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlatformInvoice"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceNo: string
      societyId: number
      amount: number
      status: string
      issueDate: Date
      dueDate: Date
      paidDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["platformInvoice"]>
    composites: {}
  }

  type PlatformInvoiceGetPayload<S extends boolean | null | undefined | PlatformInvoiceDefaultArgs> = $Result.GetResult<Prisma.$PlatformInvoicePayload, S>

  type PlatformInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlatformInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlatformInvoiceCountAggregateInputType | true
    }

  export interface PlatformInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlatformInvoice'], meta: { name: 'PlatformInvoice' } }
    /**
     * Find zero or one PlatformInvoice that matches the filter.
     * @param {PlatformInvoiceFindUniqueArgs} args - Arguments to find a PlatformInvoice
     * @example
     * // Get one PlatformInvoice
     * const platformInvoice = await prisma.platformInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformInvoiceFindUniqueArgs>(args: SelectSubset<T, PlatformInvoiceFindUniqueArgs<ExtArgs>>): Prisma__PlatformInvoiceClient<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlatformInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlatformInvoiceFindUniqueOrThrowArgs} args - Arguments to find a PlatformInvoice
     * @example
     * // Get one PlatformInvoice
     * const platformInvoice = await prisma.platformInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformInvoiceClient<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformInvoiceFindFirstArgs} args - Arguments to find a PlatformInvoice
     * @example
     * // Get one PlatformInvoice
     * const platformInvoice = await prisma.platformInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformInvoiceFindFirstArgs>(args?: SelectSubset<T, PlatformInvoiceFindFirstArgs<ExtArgs>>): Prisma__PlatformInvoiceClient<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformInvoiceFindFirstOrThrowArgs} args - Arguments to find a PlatformInvoice
     * @example
     * // Get one PlatformInvoice
     * const platformInvoice = await prisma.platformInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformInvoiceClient<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlatformInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlatformInvoices
     * const platformInvoices = await prisma.platformInvoice.findMany()
     * 
     * // Get first 10 PlatformInvoices
     * const platformInvoices = await prisma.platformInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformInvoiceWithIdOnly = await prisma.platformInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformInvoiceFindManyArgs>(args?: SelectSubset<T, PlatformInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlatformInvoice.
     * @param {PlatformInvoiceCreateArgs} args - Arguments to create a PlatformInvoice.
     * @example
     * // Create one PlatformInvoice
     * const PlatformInvoice = await prisma.platformInvoice.create({
     *   data: {
     *     // ... data to create a PlatformInvoice
     *   }
     * })
     * 
     */
    create<T extends PlatformInvoiceCreateArgs>(args: SelectSubset<T, PlatformInvoiceCreateArgs<ExtArgs>>): Prisma__PlatformInvoiceClient<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlatformInvoices.
     * @param {PlatformInvoiceCreateManyArgs} args - Arguments to create many PlatformInvoices.
     * @example
     * // Create many PlatformInvoices
     * const platformInvoice = await prisma.platformInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformInvoiceCreateManyArgs>(args?: SelectSubset<T, PlatformInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlatformInvoice.
     * @param {PlatformInvoiceDeleteArgs} args - Arguments to delete one PlatformInvoice.
     * @example
     * // Delete one PlatformInvoice
     * const PlatformInvoice = await prisma.platformInvoice.delete({
     *   where: {
     *     // ... filter to delete one PlatformInvoice
     *   }
     * })
     * 
     */
    delete<T extends PlatformInvoiceDeleteArgs>(args: SelectSubset<T, PlatformInvoiceDeleteArgs<ExtArgs>>): Prisma__PlatformInvoiceClient<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlatformInvoice.
     * @param {PlatformInvoiceUpdateArgs} args - Arguments to update one PlatformInvoice.
     * @example
     * // Update one PlatformInvoice
     * const platformInvoice = await prisma.platformInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformInvoiceUpdateArgs>(args: SelectSubset<T, PlatformInvoiceUpdateArgs<ExtArgs>>): Prisma__PlatformInvoiceClient<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlatformInvoices.
     * @param {PlatformInvoiceDeleteManyArgs} args - Arguments to filter PlatformInvoices to delete.
     * @example
     * // Delete a few PlatformInvoices
     * const { count } = await prisma.platformInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformInvoiceDeleteManyArgs>(args?: SelectSubset<T, PlatformInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlatformInvoices
     * const platformInvoice = await prisma.platformInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformInvoiceUpdateManyArgs>(args: SelectSubset<T, PlatformInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlatformInvoice.
     * @param {PlatformInvoiceUpsertArgs} args - Arguments to update or create a PlatformInvoice.
     * @example
     * // Update or create a PlatformInvoice
     * const platformInvoice = await prisma.platformInvoice.upsert({
     *   create: {
     *     // ... data to create a PlatformInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlatformInvoice we want to update
     *   }
     * })
     */
    upsert<T extends PlatformInvoiceUpsertArgs>(args: SelectSubset<T, PlatformInvoiceUpsertArgs<ExtArgs>>): Prisma__PlatformInvoiceClient<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlatformInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformInvoiceCountArgs} args - Arguments to filter PlatformInvoices to count.
     * @example
     * // Count the number of PlatformInvoices
     * const count = await prisma.platformInvoice.count({
     *   where: {
     *     // ... the filter for the PlatformInvoices we want to count
     *   }
     * })
    **/
    count<T extends PlatformInvoiceCountArgs>(
      args?: Subset<T, PlatformInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlatformInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformInvoiceAggregateArgs>(args: Subset<T, PlatformInvoiceAggregateArgs>): Prisma.PrismaPromise<GetPlatformInvoiceAggregateType<T>>

    /**
     * Group by PlatformInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: PlatformInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlatformInvoice model
   */
  readonly fields: PlatformInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlatformInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlatformInvoice model
   */
  interface PlatformInvoiceFieldRefs {
    readonly id: FieldRef<"PlatformInvoice", 'Int'>
    readonly invoiceNo: FieldRef<"PlatformInvoice", 'String'>
    readonly societyId: FieldRef<"PlatformInvoice", 'Int'>
    readonly amount: FieldRef<"PlatformInvoice", 'Float'>
    readonly status: FieldRef<"PlatformInvoice", 'String'>
    readonly issueDate: FieldRef<"PlatformInvoice", 'DateTime'>
    readonly dueDate: FieldRef<"PlatformInvoice", 'DateTime'>
    readonly paidDate: FieldRef<"PlatformInvoice", 'DateTime'>
    readonly createdAt: FieldRef<"PlatformInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"PlatformInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlatformInvoice findUnique
   */
  export type PlatformInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PlatformInvoice to fetch.
     */
    where: PlatformInvoiceWhereUniqueInput
  }

  /**
   * PlatformInvoice findUniqueOrThrow
   */
  export type PlatformInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PlatformInvoice to fetch.
     */
    where: PlatformInvoiceWhereUniqueInput
  }

  /**
   * PlatformInvoice findFirst
   */
  export type PlatformInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PlatformInvoice to fetch.
     */
    where?: PlatformInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformInvoices to fetch.
     */
    orderBy?: PlatformInvoiceOrderByWithRelationInput | PlatformInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformInvoices.
     */
    cursor?: PlatformInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformInvoices.
     */
    distinct?: PlatformInvoiceScalarFieldEnum | PlatformInvoiceScalarFieldEnum[]
  }

  /**
   * PlatformInvoice findFirstOrThrow
   */
  export type PlatformInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PlatformInvoice to fetch.
     */
    where?: PlatformInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformInvoices to fetch.
     */
    orderBy?: PlatformInvoiceOrderByWithRelationInput | PlatformInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformInvoices.
     */
    cursor?: PlatformInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformInvoices.
     */
    distinct?: PlatformInvoiceScalarFieldEnum | PlatformInvoiceScalarFieldEnum[]
  }

  /**
   * PlatformInvoice findMany
   */
  export type PlatformInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PlatformInvoices to fetch.
     */
    where?: PlatformInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformInvoices to fetch.
     */
    orderBy?: PlatformInvoiceOrderByWithRelationInput | PlatformInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlatformInvoices.
     */
    cursor?: PlatformInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformInvoices.
     */
    skip?: number
    distinct?: PlatformInvoiceScalarFieldEnum | PlatformInvoiceScalarFieldEnum[]
  }

  /**
   * PlatformInvoice create
   */
  export type PlatformInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a PlatformInvoice.
     */
    data: XOR<PlatformInvoiceCreateInput, PlatformInvoiceUncheckedCreateInput>
  }

  /**
   * PlatformInvoice createMany
   */
  export type PlatformInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlatformInvoices.
     */
    data: PlatformInvoiceCreateManyInput | PlatformInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformInvoice update
   */
  export type PlatformInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a PlatformInvoice.
     */
    data: XOR<PlatformInvoiceUpdateInput, PlatformInvoiceUncheckedUpdateInput>
    /**
     * Choose, which PlatformInvoice to update.
     */
    where: PlatformInvoiceWhereUniqueInput
  }

  /**
   * PlatformInvoice updateMany
   */
  export type PlatformInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlatformInvoices.
     */
    data: XOR<PlatformInvoiceUpdateManyMutationInput, PlatformInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which PlatformInvoices to update
     */
    where?: PlatformInvoiceWhereInput
    /**
     * Limit how many PlatformInvoices to update.
     */
    limit?: number
  }

  /**
   * PlatformInvoice upsert
   */
  export type PlatformInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the PlatformInvoice to update in case it exists.
     */
    where: PlatformInvoiceWhereUniqueInput
    /**
     * In case the PlatformInvoice found by the `where` argument doesn't exist, create a new PlatformInvoice with this data.
     */
    create: XOR<PlatformInvoiceCreateInput, PlatformInvoiceUncheckedCreateInput>
    /**
     * In case the PlatformInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformInvoiceUpdateInput, PlatformInvoiceUncheckedUpdateInput>
  }

  /**
   * PlatformInvoice delete
   */
  export type PlatformInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * Filter which PlatformInvoice to delete.
     */
    where: PlatformInvoiceWhereUniqueInput
  }

  /**
   * PlatformInvoice deleteMany
   */
  export type PlatformInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformInvoices to delete
     */
    where?: PlatformInvoiceWhereInput
    /**
     * Limit how many PlatformInvoices to delete.
     */
    limit?: number
  }

  /**
   * PlatformInvoice without action
   */
  export type PlatformInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model CommunityBuzz
   */

  export type AggregateCommunityBuzz = {
    _count: CommunityBuzzCountAggregateOutputType | null
    _avg: CommunityBuzzAvgAggregateOutputType | null
    _sum: CommunityBuzzSumAggregateOutputType | null
    _min: CommunityBuzzMinAggregateOutputType | null
    _max: CommunityBuzzMaxAggregateOutputType | null
  }

  export type CommunityBuzzAvgAggregateOutputType = {
    id: number | null
    authorId: number | null
    societyId: number | null
    likes: number | null
  }

  export type CommunityBuzzSumAggregateOutputType = {
    id: number | null
    authorId: number | null
    societyId: number | null
    likes: number | null
  }

  export type CommunityBuzzMinAggregateOutputType = {
    id: number | null
    type: string | null
    title: string | null
    content: string | null
    authorId: number | null
    societyId: number | null
    hasResult: boolean | null
    likes: number | null
    createdAt: Date | null
  }

  export type CommunityBuzzMaxAggregateOutputType = {
    id: number | null
    type: string | null
    title: string | null
    content: string | null
    authorId: number | null
    societyId: number | null
    hasResult: boolean | null
    likes: number | null
    createdAt: Date | null
  }

  export type CommunityBuzzCountAggregateOutputType = {
    id: number
    type: number
    title: number
    content: number
    authorId: number
    societyId: number
    hasResult: number
    imageUrls: number
    likes: number
    createdAt: number
    _all: number
  }


  export type CommunityBuzzAvgAggregateInputType = {
    id?: true
    authorId?: true
    societyId?: true
    likes?: true
  }

  export type CommunityBuzzSumAggregateInputType = {
    id?: true
    authorId?: true
    societyId?: true
    likes?: true
  }

  export type CommunityBuzzMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    authorId?: true
    societyId?: true
    hasResult?: true
    likes?: true
    createdAt?: true
  }

  export type CommunityBuzzMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    authorId?: true
    societyId?: true
    hasResult?: true
    likes?: true
    createdAt?: true
  }

  export type CommunityBuzzCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    authorId?: true
    societyId?: true
    hasResult?: true
    imageUrls?: true
    likes?: true
    createdAt?: true
    _all?: true
  }

  export type CommunityBuzzAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityBuzz to aggregate.
     */
    where?: CommunityBuzzWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBuzzes to fetch.
     */
    orderBy?: CommunityBuzzOrderByWithRelationInput | CommunityBuzzOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityBuzzWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBuzzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBuzzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityBuzzes
    **/
    _count?: true | CommunityBuzzCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityBuzzAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityBuzzSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityBuzzMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityBuzzMaxAggregateInputType
  }

  export type GetCommunityBuzzAggregateType<T extends CommunityBuzzAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityBuzz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityBuzz[P]>
      : GetScalarType<T[P], AggregateCommunityBuzz[P]>
  }




  export type CommunityBuzzGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityBuzzWhereInput
    orderBy?: CommunityBuzzOrderByWithAggregationInput | CommunityBuzzOrderByWithAggregationInput[]
    by: CommunityBuzzScalarFieldEnum[] | CommunityBuzzScalarFieldEnum
    having?: CommunityBuzzScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityBuzzCountAggregateInputType | true
    _avg?: CommunityBuzzAvgAggregateInputType
    _sum?: CommunityBuzzSumAggregateInputType
    _min?: CommunityBuzzMinAggregateInputType
    _max?: CommunityBuzzMaxAggregateInputType
  }

  export type CommunityBuzzGroupByOutputType = {
    id: number
    type: string
    title: string
    content: string | null
    authorId: number
    societyId: number
    hasResult: boolean
    imageUrls: JsonValue | null
    likes: number
    createdAt: Date
    _count: CommunityBuzzCountAggregateOutputType | null
    _avg: CommunityBuzzAvgAggregateOutputType | null
    _sum: CommunityBuzzSumAggregateOutputType | null
    _min: CommunityBuzzMinAggregateOutputType | null
    _max: CommunityBuzzMaxAggregateOutputType | null
  }

  type GetCommunityBuzzGroupByPayload<T extends CommunityBuzzGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityBuzzGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityBuzzGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityBuzzGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityBuzzGroupByOutputType[P]>
        }
      >
    >


  export type CommunityBuzzSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    authorId?: boolean
    societyId?: boolean
    hasResult?: boolean
    imageUrls?: boolean
    likes?: boolean
    createdAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    comments?: boolean | CommunityBuzz$commentsArgs<ExtArgs>
    likedBy?: boolean | CommunityBuzz$likedByArgs<ExtArgs>
    _count?: boolean | CommunityBuzzCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityBuzz"]>



  export type CommunityBuzzSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    authorId?: boolean
    societyId?: boolean
    hasResult?: boolean
    imageUrls?: boolean
    likes?: boolean
    createdAt?: boolean
  }

  export type CommunityBuzzOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "content" | "authorId" | "societyId" | "hasResult" | "imageUrls" | "likes" | "createdAt", ExtArgs["result"]["communityBuzz"]>
  export type CommunityBuzzInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    comments?: boolean | CommunityBuzz$commentsArgs<ExtArgs>
    likedBy?: boolean | CommunityBuzz$likedByArgs<ExtArgs>
    _count?: boolean | CommunityBuzzCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CommunityBuzzPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityBuzz"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      society: Prisma.$SocietyPayload<ExtArgs>
      comments: Prisma.$CommunityCommentPayload<ExtArgs>[]
      likedBy: Prisma.$BuzzLikePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      title: string
      content: string | null
      authorId: number
      societyId: number
      hasResult: boolean
      imageUrls: Prisma.JsonValue | null
      likes: number
      createdAt: Date
    }, ExtArgs["result"]["communityBuzz"]>
    composites: {}
  }

  type CommunityBuzzGetPayload<S extends boolean | null | undefined | CommunityBuzzDefaultArgs> = $Result.GetResult<Prisma.$CommunityBuzzPayload, S>

  type CommunityBuzzCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunityBuzzFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunityBuzzCountAggregateInputType | true
    }

  export interface CommunityBuzzDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityBuzz'], meta: { name: 'CommunityBuzz' } }
    /**
     * Find zero or one CommunityBuzz that matches the filter.
     * @param {CommunityBuzzFindUniqueArgs} args - Arguments to find a CommunityBuzz
     * @example
     * // Get one CommunityBuzz
     * const communityBuzz = await prisma.communityBuzz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityBuzzFindUniqueArgs>(args: SelectSubset<T, CommunityBuzzFindUniqueArgs<ExtArgs>>): Prisma__CommunityBuzzClient<$Result.GetResult<Prisma.$CommunityBuzzPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommunityBuzz that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunityBuzzFindUniqueOrThrowArgs} args - Arguments to find a CommunityBuzz
     * @example
     * // Get one CommunityBuzz
     * const communityBuzz = await prisma.communityBuzz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityBuzzFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityBuzzFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityBuzzClient<$Result.GetResult<Prisma.$CommunityBuzzPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityBuzz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBuzzFindFirstArgs} args - Arguments to find a CommunityBuzz
     * @example
     * // Get one CommunityBuzz
     * const communityBuzz = await prisma.communityBuzz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityBuzzFindFirstArgs>(args?: SelectSubset<T, CommunityBuzzFindFirstArgs<ExtArgs>>): Prisma__CommunityBuzzClient<$Result.GetResult<Prisma.$CommunityBuzzPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityBuzz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBuzzFindFirstOrThrowArgs} args - Arguments to find a CommunityBuzz
     * @example
     * // Get one CommunityBuzz
     * const communityBuzz = await prisma.communityBuzz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityBuzzFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityBuzzFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityBuzzClient<$Result.GetResult<Prisma.$CommunityBuzzPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommunityBuzzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBuzzFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityBuzzes
     * const communityBuzzes = await prisma.communityBuzz.findMany()
     * 
     * // Get first 10 CommunityBuzzes
     * const communityBuzzes = await prisma.communityBuzz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityBuzzWithIdOnly = await prisma.communityBuzz.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityBuzzFindManyArgs>(args?: SelectSubset<T, CommunityBuzzFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityBuzzPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommunityBuzz.
     * @param {CommunityBuzzCreateArgs} args - Arguments to create a CommunityBuzz.
     * @example
     * // Create one CommunityBuzz
     * const CommunityBuzz = await prisma.communityBuzz.create({
     *   data: {
     *     // ... data to create a CommunityBuzz
     *   }
     * })
     * 
     */
    create<T extends CommunityBuzzCreateArgs>(args: SelectSubset<T, CommunityBuzzCreateArgs<ExtArgs>>): Prisma__CommunityBuzzClient<$Result.GetResult<Prisma.$CommunityBuzzPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommunityBuzzes.
     * @param {CommunityBuzzCreateManyArgs} args - Arguments to create many CommunityBuzzes.
     * @example
     * // Create many CommunityBuzzes
     * const communityBuzz = await prisma.communityBuzz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityBuzzCreateManyArgs>(args?: SelectSubset<T, CommunityBuzzCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityBuzz.
     * @param {CommunityBuzzDeleteArgs} args - Arguments to delete one CommunityBuzz.
     * @example
     * // Delete one CommunityBuzz
     * const CommunityBuzz = await prisma.communityBuzz.delete({
     *   where: {
     *     // ... filter to delete one CommunityBuzz
     *   }
     * })
     * 
     */
    delete<T extends CommunityBuzzDeleteArgs>(args: SelectSubset<T, CommunityBuzzDeleteArgs<ExtArgs>>): Prisma__CommunityBuzzClient<$Result.GetResult<Prisma.$CommunityBuzzPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommunityBuzz.
     * @param {CommunityBuzzUpdateArgs} args - Arguments to update one CommunityBuzz.
     * @example
     * // Update one CommunityBuzz
     * const communityBuzz = await prisma.communityBuzz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityBuzzUpdateArgs>(args: SelectSubset<T, CommunityBuzzUpdateArgs<ExtArgs>>): Prisma__CommunityBuzzClient<$Result.GetResult<Prisma.$CommunityBuzzPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommunityBuzzes.
     * @param {CommunityBuzzDeleteManyArgs} args - Arguments to filter CommunityBuzzes to delete.
     * @example
     * // Delete a few CommunityBuzzes
     * const { count } = await prisma.communityBuzz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityBuzzDeleteManyArgs>(args?: SelectSubset<T, CommunityBuzzDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityBuzzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBuzzUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityBuzzes
     * const communityBuzz = await prisma.communityBuzz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityBuzzUpdateManyArgs>(args: SelectSubset<T, CommunityBuzzUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityBuzz.
     * @param {CommunityBuzzUpsertArgs} args - Arguments to update or create a CommunityBuzz.
     * @example
     * // Update or create a CommunityBuzz
     * const communityBuzz = await prisma.communityBuzz.upsert({
     *   create: {
     *     // ... data to create a CommunityBuzz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityBuzz we want to update
     *   }
     * })
     */
    upsert<T extends CommunityBuzzUpsertArgs>(args: SelectSubset<T, CommunityBuzzUpsertArgs<ExtArgs>>): Prisma__CommunityBuzzClient<$Result.GetResult<Prisma.$CommunityBuzzPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommunityBuzzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBuzzCountArgs} args - Arguments to filter CommunityBuzzes to count.
     * @example
     * // Count the number of CommunityBuzzes
     * const count = await prisma.communityBuzz.count({
     *   where: {
     *     // ... the filter for the CommunityBuzzes we want to count
     *   }
     * })
    **/
    count<T extends CommunityBuzzCountArgs>(
      args?: Subset<T, CommunityBuzzCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityBuzzCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityBuzz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBuzzAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityBuzzAggregateArgs>(args: Subset<T, CommunityBuzzAggregateArgs>): Prisma.PrismaPromise<GetCommunityBuzzAggregateType<T>>

    /**
     * Group by CommunityBuzz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBuzzGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityBuzzGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityBuzzGroupByArgs['orderBy'] }
        : { orderBy?: CommunityBuzzGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityBuzzGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityBuzzGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityBuzz model
   */
  readonly fields: CommunityBuzzFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityBuzz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityBuzzClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comments<T extends CommunityBuzz$commentsArgs<ExtArgs> = {}>(args?: Subset<T, CommunityBuzz$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedBy<T extends CommunityBuzz$likedByArgs<ExtArgs> = {}>(args?: Subset<T, CommunityBuzz$likedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunityBuzz model
   */
  interface CommunityBuzzFieldRefs {
    readonly id: FieldRef<"CommunityBuzz", 'Int'>
    readonly type: FieldRef<"CommunityBuzz", 'String'>
    readonly title: FieldRef<"CommunityBuzz", 'String'>
    readonly content: FieldRef<"CommunityBuzz", 'String'>
    readonly authorId: FieldRef<"CommunityBuzz", 'Int'>
    readonly societyId: FieldRef<"CommunityBuzz", 'Int'>
    readonly hasResult: FieldRef<"CommunityBuzz", 'Boolean'>
    readonly imageUrls: FieldRef<"CommunityBuzz", 'Json'>
    readonly likes: FieldRef<"CommunityBuzz", 'Int'>
    readonly createdAt: FieldRef<"CommunityBuzz", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommunityBuzz findUnique
   */
  export type CommunityBuzzFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBuzz
     */
    select?: CommunityBuzzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBuzz
     */
    omit?: CommunityBuzzOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityBuzzInclude<ExtArgs> | null
    /**
     * Filter, which CommunityBuzz to fetch.
     */
    where: CommunityBuzzWhereUniqueInput
  }

  /**
   * CommunityBuzz findUniqueOrThrow
   */
  export type CommunityBuzzFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBuzz
     */
    select?: CommunityBuzzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBuzz
     */
    omit?: CommunityBuzzOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityBuzzInclude<ExtArgs> | null
    /**
     * Filter, which CommunityBuzz to fetch.
     */
    where: CommunityBuzzWhereUniqueInput
  }

  /**
   * CommunityBuzz findFirst
   */
  export type CommunityBuzzFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBuzz
     */
    select?: CommunityBuzzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBuzz
     */
    omit?: CommunityBuzzOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityBuzzInclude<ExtArgs> | null
    /**
     * Filter, which CommunityBuzz to fetch.
     */
    where?: CommunityBuzzWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBuzzes to fetch.
     */
    orderBy?: CommunityBuzzOrderByWithRelationInput | CommunityBuzzOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityBuzzes.
     */
    cursor?: CommunityBuzzWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBuzzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBuzzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityBuzzes.
     */
    distinct?: CommunityBuzzScalarFieldEnum | CommunityBuzzScalarFieldEnum[]
  }

  /**
   * CommunityBuzz findFirstOrThrow
   */
  export type CommunityBuzzFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBuzz
     */
    select?: CommunityBuzzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBuzz
     */
    omit?: CommunityBuzzOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityBuzzInclude<ExtArgs> | null
    /**
     * Filter, which CommunityBuzz to fetch.
     */
    where?: CommunityBuzzWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBuzzes to fetch.
     */
    orderBy?: CommunityBuzzOrderByWithRelationInput | CommunityBuzzOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityBuzzes.
     */
    cursor?: CommunityBuzzWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBuzzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBuzzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityBuzzes.
     */
    distinct?: CommunityBuzzScalarFieldEnum | CommunityBuzzScalarFieldEnum[]
  }

  /**
   * CommunityBuzz findMany
   */
  export type CommunityBuzzFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBuzz
     */
    select?: CommunityBuzzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBuzz
     */
    omit?: CommunityBuzzOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityBuzzInclude<ExtArgs> | null
    /**
     * Filter, which CommunityBuzzes to fetch.
     */
    where?: CommunityBuzzWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBuzzes to fetch.
     */
    orderBy?: CommunityBuzzOrderByWithRelationInput | CommunityBuzzOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityBuzzes.
     */
    cursor?: CommunityBuzzWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBuzzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBuzzes.
     */
    skip?: number
    distinct?: CommunityBuzzScalarFieldEnum | CommunityBuzzScalarFieldEnum[]
  }

  /**
   * CommunityBuzz create
   */
  export type CommunityBuzzCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBuzz
     */
    select?: CommunityBuzzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBuzz
     */
    omit?: CommunityBuzzOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityBuzzInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityBuzz.
     */
    data: XOR<CommunityBuzzCreateInput, CommunityBuzzUncheckedCreateInput>
  }

  /**
   * CommunityBuzz createMany
   */
  export type CommunityBuzzCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityBuzzes.
     */
    data: CommunityBuzzCreateManyInput | CommunityBuzzCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityBuzz update
   */
  export type CommunityBuzzUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBuzz
     */
    select?: CommunityBuzzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBuzz
     */
    omit?: CommunityBuzzOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityBuzzInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityBuzz.
     */
    data: XOR<CommunityBuzzUpdateInput, CommunityBuzzUncheckedUpdateInput>
    /**
     * Choose, which CommunityBuzz to update.
     */
    where: CommunityBuzzWhereUniqueInput
  }

  /**
   * CommunityBuzz updateMany
   */
  export type CommunityBuzzUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityBuzzes.
     */
    data: XOR<CommunityBuzzUpdateManyMutationInput, CommunityBuzzUncheckedUpdateManyInput>
    /**
     * Filter which CommunityBuzzes to update
     */
    where?: CommunityBuzzWhereInput
    /**
     * Limit how many CommunityBuzzes to update.
     */
    limit?: number
  }

  /**
   * CommunityBuzz upsert
   */
  export type CommunityBuzzUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBuzz
     */
    select?: CommunityBuzzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBuzz
     */
    omit?: CommunityBuzzOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityBuzzInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityBuzz to update in case it exists.
     */
    where: CommunityBuzzWhereUniqueInput
    /**
     * In case the CommunityBuzz found by the `where` argument doesn't exist, create a new CommunityBuzz with this data.
     */
    create: XOR<CommunityBuzzCreateInput, CommunityBuzzUncheckedCreateInput>
    /**
     * In case the CommunityBuzz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityBuzzUpdateInput, CommunityBuzzUncheckedUpdateInput>
  }

  /**
   * CommunityBuzz delete
   */
  export type CommunityBuzzDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBuzz
     */
    select?: CommunityBuzzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBuzz
     */
    omit?: CommunityBuzzOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityBuzzInclude<ExtArgs> | null
    /**
     * Filter which CommunityBuzz to delete.
     */
    where: CommunityBuzzWhereUniqueInput
  }

  /**
   * CommunityBuzz deleteMany
   */
  export type CommunityBuzzDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityBuzzes to delete
     */
    where?: CommunityBuzzWhereInput
    /**
     * Limit how many CommunityBuzzes to delete.
     */
    limit?: number
  }

  /**
   * CommunityBuzz.comments
   */
  export type CommunityBuzz$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityComment
     */
    select?: CommunityCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityComment
     */
    omit?: CommunityCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCommentInclude<ExtArgs> | null
    where?: CommunityCommentWhereInput
    orderBy?: CommunityCommentOrderByWithRelationInput | CommunityCommentOrderByWithRelationInput[]
    cursor?: CommunityCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityCommentScalarFieldEnum | CommunityCommentScalarFieldEnum[]
  }

  /**
   * CommunityBuzz.likedBy
   */
  export type CommunityBuzz$likedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzLike
     */
    select?: BuzzLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzLike
     */
    omit?: BuzzLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzLikeInclude<ExtArgs> | null
    where?: BuzzLikeWhereInput
    orderBy?: BuzzLikeOrderByWithRelationInput | BuzzLikeOrderByWithRelationInput[]
    cursor?: BuzzLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuzzLikeScalarFieldEnum | BuzzLikeScalarFieldEnum[]
  }

  /**
   * CommunityBuzz without action
   */
  export type CommunityBuzzDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBuzz
     */
    select?: CommunityBuzzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBuzz
     */
    omit?: CommunityBuzzOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityBuzzInclude<ExtArgs> | null
  }


  /**
   * Model CommunityComment
   */

  export type AggregateCommunityComment = {
    _count: CommunityCommentCountAggregateOutputType | null
    _avg: CommunityCommentAvgAggregateOutputType | null
    _sum: CommunityCommentSumAggregateOutputType | null
    _min: CommunityCommentMinAggregateOutputType | null
    _max: CommunityCommentMaxAggregateOutputType | null
  }

  export type CommunityCommentAvgAggregateOutputType = {
    id: number | null
    buzzId: number | null
    authorId: number | null
  }

  export type CommunityCommentSumAggregateOutputType = {
    id: number | null
    buzzId: number | null
    authorId: number | null
  }

  export type CommunityCommentMinAggregateOutputType = {
    id: number | null
    buzzId: number | null
    authorId: number | null
    content: string | null
    createdAt: Date | null
  }

  export type CommunityCommentMaxAggregateOutputType = {
    id: number | null
    buzzId: number | null
    authorId: number | null
    content: string | null
    createdAt: Date | null
  }

  export type CommunityCommentCountAggregateOutputType = {
    id: number
    buzzId: number
    authorId: number
    content: number
    createdAt: number
    _all: number
  }


  export type CommunityCommentAvgAggregateInputType = {
    id?: true
    buzzId?: true
    authorId?: true
  }

  export type CommunityCommentSumAggregateInputType = {
    id?: true
    buzzId?: true
    authorId?: true
  }

  export type CommunityCommentMinAggregateInputType = {
    id?: true
    buzzId?: true
    authorId?: true
    content?: true
    createdAt?: true
  }

  export type CommunityCommentMaxAggregateInputType = {
    id?: true
    buzzId?: true
    authorId?: true
    content?: true
    createdAt?: true
  }

  export type CommunityCommentCountAggregateInputType = {
    id?: true
    buzzId?: true
    authorId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type CommunityCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityComment to aggregate.
     */
    where?: CommunityCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityComments to fetch.
     */
    orderBy?: CommunityCommentOrderByWithRelationInput | CommunityCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityComments
    **/
    _count?: true | CommunityCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityCommentMaxAggregateInputType
  }

  export type GetCommunityCommentAggregateType<T extends CommunityCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityComment[P]>
      : GetScalarType<T[P], AggregateCommunityComment[P]>
  }




  export type CommunityCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityCommentWhereInput
    orderBy?: CommunityCommentOrderByWithAggregationInput | CommunityCommentOrderByWithAggregationInput[]
    by: CommunityCommentScalarFieldEnum[] | CommunityCommentScalarFieldEnum
    having?: CommunityCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityCommentCountAggregateInputType | true
    _avg?: CommunityCommentAvgAggregateInputType
    _sum?: CommunityCommentSumAggregateInputType
    _min?: CommunityCommentMinAggregateInputType
    _max?: CommunityCommentMaxAggregateInputType
  }

  export type CommunityCommentGroupByOutputType = {
    id: number
    buzzId: number
    authorId: number
    content: string
    createdAt: Date
    _count: CommunityCommentCountAggregateOutputType | null
    _avg: CommunityCommentAvgAggregateOutputType | null
    _sum: CommunityCommentSumAggregateOutputType | null
    _min: CommunityCommentMinAggregateOutputType | null
    _max: CommunityCommentMaxAggregateOutputType | null
  }

  type GetCommunityCommentGroupByPayload<T extends CommunityCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityCommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityCommentGroupByOutputType[P]>
        }
      >
    >


  export type CommunityCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buzzId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    buzz?: boolean | CommunityBuzzDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityComment"]>



  export type CommunityCommentSelectScalar = {
    id?: boolean
    buzzId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type CommunityCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "buzzId" | "authorId" | "content" | "createdAt", ExtArgs["result"]["communityComment"]>
  export type CommunityCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buzz?: boolean | CommunityBuzzDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommunityCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityComment"
    objects: {
      buzz: Prisma.$CommunityBuzzPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      buzzId: number
      authorId: number
      content: string
      createdAt: Date
    }, ExtArgs["result"]["communityComment"]>
    composites: {}
  }

  type CommunityCommentGetPayload<S extends boolean | null | undefined | CommunityCommentDefaultArgs> = $Result.GetResult<Prisma.$CommunityCommentPayload, S>

  type CommunityCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunityCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunityCommentCountAggregateInputType | true
    }

  export interface CommunityCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityComment'], meta: { name: 'CommunityComment' } }
    /**
     * Find zero or one CommunityComment that matches the filter.
     * @param {CommunityCommentFindUniqueArgs} args - Arguments to find a CommunityComment
     * @example
     * // Get one CommunityComment
     * const communityComment = await prisma.communityComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityCommentFindUniqueArgs>(args: SelectSubset<T, CommunityCommentFindUniqueArgs<ExtArgs>>): Prisma__CommunityCommentClient<$Result.GetResult<Prisma.$CommunityCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommunityComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunityCommentFindUniqueOrThrowArgs} args - Arguments to find a CommunityComment
     * @example
     * // Get one CommunityComment
     * const communityComment = await prisma.communityComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityCommentClient<$Result.GetResult<Prisma.$CommunityCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCommentFindFirstArgs} args - Arguments to find a CommunityComment
     * @example
     * // Get one CommunityComment
     * const communityComment = await prisma.communityComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityCommentFindFirstArgs>(args?: SelectSubset<T, CommunityCommentFindFirstArgs<ExtArgs>>): Prisma__CommunityCommentClient<$Result.GetResult<Prisma.$CommunityCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCommentFindFirstOrThrowArgs} args - Arguments to find a CommunityComment
     * @example
     * // Get one CommunityComment
     * const communityComment = await prisma.communityComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityCommentClient<$Result.GetResult<Prisma.$CommunityCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommunityComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityComments
     * const communityComments = await prisma.communityComment.findMany()
     * 
     * // Get first 10 CommunityComments
     * const communityComments = await prisma.communityComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityCommentWithIdOnly = await prisma.communityComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityCommentFindManyArgs>(args?: SelectSubset<T, CommunityCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommunityComment.
     * @param {CommunityCommentCreateArgs} args - Arguments to create a CommunityComment.
     * @example
     * // Create one CommunityComment
     * const CommunityComment = await prisma.communityComment.create({
     *   data: {
     *     // ... data to create a CommunityComment
     *   }
     * })
     * 
     */
    create<T extends CommunityCommentCreateArgs>(args: SelectSubset<T, CommunityCommentCreateArgs<ExtArgs>>): Prisma__CommunityCommentClient<$Result.GetResult<Prisma.$CommunityCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommunityComments.
     * @param {CommunityCommentCreateManyArgs} args - Arguments to create many CommunityComments.
     * @example
     * // Create many CommunityComments
     * const communityComment = await prisma.communityComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityCommentCreateManyArgs>(args?: SelectSubset<T, CommunityCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityComment.
     * @param {CommunityCommentDeleteArgs} args - Arguments to delete one CommunityComment.
     * @example
     * // Delete one CommunityComment
     * const CommunityComment = await prisma.communityComment.delete({
     *   where: {
     *     // ... filter to delete one CommunityComment
     *   }
     * })
     * 
     */
    delete<T extends CommunityCommentDeleteArgs>(args: SelectSubset<T, CommunityCommentDeleteArgs<ExtArgs>>): Prisma__CommunityCommentClient<$Result.GetResult<Prisma.$CommunityCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommunityComment.
     * @param {CommunityCommentUpdateArgs} args - Arguments to update one CommunityComment.
     * @example
     * // Update one CommunityComment
     * const communityComment = await prisma.communityComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityCommentUpdateArgs>(args: SelectSubset<T, CommunityCommentUpdateArgs<ExtArgs>>): Prisma__CommunityCommentClient<$Result.GetResult<Prisma.$CommunityCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommunityComments.
     * @param {CommunityCommentDeleteManyArgs} args - Arguments to filter CommunityComments to delete.
     * @example
     * // Delete a few CommunityComments
     * const { count } = await prisma.communityComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityCommentDeleteManyArgs>(args?: SelectSubset<T, CommunityCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityComments
     * const communityComment = await prisma.communityComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityCommentUpdateManyArgs>(args: SelectSubset<T, CommunityCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityComment.
     * @param {CommunityCommentUpsertArgs} args - Arguments to update or create a CommunityComment.
     * @example
     * // Update or create a CommunityComment
     * const communityComment = await prisma.communityComment.upsert({
     *   create: {
     *     // ... data to create a CommunityComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityComment we want to update
     *   }
     * })
     */
    upsert<T extends CommunityCommentUpsertArgs>(args: SelectSubset<T, CommunityCommentUpsertArgs<ExtArgs>>): Prisma__CommunityCommentClient<$Result.GetResult<Prisma.$CommunityCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommunityComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCommentCountArgs} args - Arguments to filter CommunityComments to count.
     * @example
     * // Count the number of CommunityComments
     * const count = await prisma.communityComment.count({
     *   where: {
     *     // ... the filter for the CommunityComments we want to count
     *   }
     * })
    **/
    count<T extends CommunityCommentCountArgs>(
      args?: Subset<T, CommunityCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityCommentAggregateArgs>(args: Subset<T, CommunityCommentAggregateArgs>): Prisma.PrismaPromise<GetCommunityCommentAggregateType<T>>

    /**
     * Group by CommunityComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityCommentGroupByArgs['orderBy'] }
        : { orderBy?: CommunityCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityComment model
   */
  readonly fields: CommunityCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    buzz<T extends CommunityBuzzDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityBuzzDefaultArgs<ExtArgs>>): Prisma__CommunityBuzzClient<$Result.GetResult<Prisma.$CommunityBuzzPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunityComment model
   */
  interface CommunityCommentFieldRefs {
    readonly id: FieldRef<"CommunityComment", 'Int'>
    readonly buzzId: FieldRef<"CommunityComment", 'Int'>
    readonly authorId: FieldRef<"CommunityComment", 'Int'>
    readonly content: FieldRef<"CommunityComment", 'String'>
    readonly createdAt: FieldRef<"CommunityComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommunityComment findUnique
   */
  export type CommunityCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityComment
     */
    select?: CommunityCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityComment
     */
    omit?: CommunityCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCommentInclude<ExtArgs> | null
    /**
     * Filter, which CommunityComment to fetch.
     */
    where: CommunityCommentWhereUniqueInput
  }

  /**
   * CommunityComment findUniqueOrThrow
   */
  export type CommunityCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityComment
     */
    select?: CommunityCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityComment
     */
    omit?: CommunityCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCommentInclude<ExtArgs> | null
    /**
     * Filter, which CommunityComment to fetch.
     */
    where: CommunityCommentWhereUniqueInput
  }

  /**
   * CommunityComment findFirst
   */
  export type CommunityCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityComment
     */
    select?: CommunityCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityComment
     */
    omit?: CommunityCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCommentInclude<ExtArgs> | null
    /**
     * Filter, which CommunityComment to fetch.
     */
    where?: CommunityCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityComments to fetch.
     */
    orderBy?: CommunityCommentOrderByWithRelationInput | CommunityCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityComments.
     */
    cursor?: CommunityCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityComments.
     */
    distinct?: CommunityCommentScalarFieldEnum | CommunityCommentScalarFieldEnum[]
  }

  /**
   * CommunityComment findFirstOrThrow
   */
  export type CommunityCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityComment
     */
    select?: CommunityCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityComment
     */
    omit?: CommunityCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCommentInclude<ExtArgs> | null
    /**
     * Filter, which CommunityComment to fetch.
     */
    where?: CommunityCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityComments to fetch.
     */
    orderBy?: CommunityCommentOrderByWithRelationInput | CommunityCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityComments.
     */
    cursor?: CommunityCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityComments.
     */
    distinct?: CommunityCommentScalarFieldEnum | CommunityCommentScalarFieldEnum[]
  }

  /**
   * CommunityComment findMany
   */
  export type CommunityCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityComment
     */
    select?: CommunityCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityComment
     */
    omit?: CommunityCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCommentInclude<ExtArgs> | null
    /**
     * Filter, which CommunityComments to fetch.
     */
    where?: CommunityCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityComments to fetch.
     */
    orderBy?: CommunityCommentOrderByWithRelationInput | CommunityCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityComments.
     */
    cursor?: CommunityCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityComments.
     */
    skip?: number
    distinct?: CommunityCommentScalarFieldEnum | CommunityCommentScalarFieldEnum[]
  }

  /**
   * CommunityComment create
   */
  export type CommunityCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityComment
     */
    select?: CommunityCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityComment
     */
    omit?: CommunityCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityComment.
     */
    data: XOR<CommunityCommentCreateInput, CommunityCommentUncheckedCreateInput>
  }

  /**
   * CommunityComment createMany
   */
  export type CommunityCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityComments.
     */
    data: CommunityCommentCreateManyInput | CommunityCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityComment update
   */
  export type CommunityCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityComment
     */
    select?: CommunityCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityComment
     */
    omit?: CommunityCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityComment.
     */
    data: XOR<CommunityCommentUpdateInput, CommunityCommentUncheckedUpdateInput>
    /**
     * Choose, which CommunityComment to update.
     */
    where: CommunityCommentWhereUniqueInput
  }

  /**
   * CommunityComment updateMany
   */
  export type CommunityCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityComments.
     */
    data: XOR<CommunityCommentUpdateManyMutationInput, CommunityCommentUncheckedUpdateManyInput>
    /**
     * Filter which CommunityComments to update
     */
    where?: CommunityCommentWhereInput
    /**
     * Limit how many CommunityComments to update.
     */
    limit?: number
  }

  /**
   * CommunityComment upsert
   */
  export type CommunityCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityComment
     */
    select?: CommunityCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityComment
     */
    omit?: CommunityCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityComment to update in case it exists.
     */
    where: CommunityCommentWhereUniqueInput
    /**
     * In case the CommunityComment found by the `where` argument doesn't exist, create a new CommunityComment with this data.
     */
    create: XOR<CommunityCommentCreateInput, CommunityCommentUncheckedCreateInput>
    /**
     * In case the CommunityComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityCommentUpdateInput, CommunityCommentUncheckedUpdateInput>
  }

  /**
   * CommunityComment delete
   */
  export type CommunityCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityComment
     */
    select?: CommunityCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityComment
     */
    omit?: CommunityCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCommentInclude<ExtArgs> | null
    /**
     * Filter which CommunityComment to delete.
     */
    where: CommunityCommentWhereUniqueInput
  }

  /**
   * CommunityComment deleteMany
   */
  export type CommunityCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityComments to delete
     */
    where?: CommunityCommentWhereInput
    /**
     * Limit how many CommunityComments to delete.
     */
    limit?: number
  }

  /**
   * CommunityComment without action
   */
  export type CommunityCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityComment
     */
    select?: CommunityCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityComment
     */
    omit?: CommunityCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCommentInclude<ExtArgs> | null
  }


  /**
   * Model BuzzLike
   */

  export type AggregateBuzzLike = {
    _count: BuzzLikeCountAggregateOutputType | null
    _avg: BuzzLikeAvgAggregateOutputType | null
    _sum: BuzzLikeSumAggregateOutputType | null
    _min: BuzzLikeMinAggregateOutputType | null
    _max: BuzzLikeMaxAggregateOutputType | null
  }

  export type BuzzLikeAvgAggregateOutputType = {
    id: number | null
    buzzId: number | null
    userId: number | null
  }

  export type BuzzLikeSumAggregateOutputType = {
    id: number | null
    buzzId: number | null
    userId: number | null
  }

  export type BuzzLikeMinAggregateOutputType = {
    id: number | null
    buzzId: number | null
    userId: number | null
    createdAt: Date | null
  }

  export type BuzzLikeMaxAggregateOutputType = {
    id: number | null
    buzzId: number | null
    userId: number | null
    createdAt: Date | null
  }

  export type BuzzLikeCountAggregateOutputType = {
    id: number
    buzzId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type BuzzLikeAvgAggregateInputType = {
    id?: true
    buzzId?: true
    userId?: true
  }

  export type BuzzLikeSumAggregateInputType = {
    id?: true
    buzzId?: true
    userId?: true
  }

  export type BuzzLikeMinAggregateInputType = {
    id?: true
    buzzId?: true
    userId?: true
    createdAt?: true
  }

  export type BuzzLikeMaxAggregateInputType = {
    id?: true
    buzzId?: true
    userId?: true
    createdAt?: true
  }

  export type BuzzLikeCountAggregateInputType = {
    id?: true
    buzzId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type BuzzLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuzzLike to aggregate.
     */
    where?: BuzzLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzLikes to fetch.
     */
    orderBy?: BuzzLikeOrderByWithRelationInput | BuzzLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuzzLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuzzLikes
    **/
    _count?: true | BuzzLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuzzLikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuzzLikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuzzLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuzzLikeMaxAggregateInputType
  }

  export type GetBuzzLikeAggregateType<T extends BuzzLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateBuzzLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuzzLike[P]>
      : GetScalarType<T[P], AggregateBuzzLike[P]>
  }




  export type BuzzLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuzzLikeWhereInput
    orderBy?: BuzzLikeOrderByWithAggregationInput | BuzzLikeOrderByWithAggregationInput[]
    by: BuzzLikeScalarFieldEnum[] | BuzzLikeScalarFieldEnum
    having?: BuzzLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuzzLikeCountAggregateInputType | true
    _avg?: BuzzLikeAvgAggregateInputType
    _sum?: BuzzLikeSumAggregateInputType
    _min?: BuzzLikeMinAggregateInputType
    _max?: BuzzLikeMaxAggregateInputType
  }

  export type BuzzLikeGroupByOutputType = {
    id: number
    buzzId: number
    userId: number
    createdAt: Date
    _count: BuzzLikeCountAggregateOutputType | null
    _avg: BuzzLikeAvgAggregateOutputType | null
    _sum: BuzzLikeSumAggregateOutputType | null
    _min: BuzzLikeMinAggregateOutputType | null
    _max: BuzzLikeMaxAggregateOutputType | null
  }

  type GetBuzzLikeGroupByPayload<T extends BuzzLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuzzLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuzzLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuzzLikeGroupByOutputType[P]>
            : GetScalarType<T[P], BuzzLikeGroupByOutputType[P]>
        }
      >
    >


  export type BuzzLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buzzId?: boolean
    userId?: boolean
    createdAt?: boolean
    buzz?: boolean | CommunityBuzzDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buzzLike"]>



  export type BuzzLikeSelectScalar = {
    id?: boolean
    buzzId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type BuzzLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "buzzId" | "userId" | "createdAt", ExtArgs["result"]["buzzLike"]>
  export type BuzzLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buzz?: boolean | CommunityBuzzDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BuzzLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuzzLike"
    objects: {
      buzz: Prisma.$CommunityBuzzPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      buzzId: number
      userId: number
      createdAt: Date
    }, ExtArgs["result"]["buzzLike"]>
    composites: {}
  }

  type BuzzLikeGetPayload<S extends boolean | null | undefined | BuzzLikeDefaultArgs> = $Result.GetResult<Prisma.$BuzzLikePayload, S>

  type BuzzLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BuzzLikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuzzLikeCountAggregateInputType | true
    }

  export interface BuzzLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuzzLike'], meta: { name: 'BuzzLike' } }
    /**
     * Find zero or one BuzzLike that matches the filter.
     * @param {BuzzLikeFindUniqueArgs} args - Arguments to find a BuzzLike
     * @example
     * // Get one BuzzLike
     * const buzzLike = await prisma.buzzLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuzzLikeFindUniqueArgs>(args: SelectSubset<T, BuzzLikeFindUniqueArgs<ExtArgs>>): Prisma__BuzzLikeClient<$Result.GetResult<Prisma.$BuzzLikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BuzzLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BuzzLikeFindUniqueOrThrowArgs} args - Arguments to find a BuzzLike
     * @example
     * // Get one BuzzLike
     * const buzzLike = await prisma.buzzLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuzzLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, BuzzLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuzzLikeClient<$Result.GetResult<Prisma.$BuzzLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuzzLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzLikeFindFirstArgs} args - Arguments to find a BuzzLike
     * @example
     * // Get one BuzzLike
     * const buzzLike = await prisma.buzzLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuzzLikeFindFirstArgs>(args?: SelectSubset<T, BuzzLikeFindFirstArgs<ExtArgs>>): Prisma__BuzzLikeClient<$Result.GetResult<Prisma.$BuzzLikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuzzLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzLikeFindFirstOrThrowArgs} args - Arguments to find a BuzzLike
     * @example
     * // Get one BuzzLike
     * const buzzLike = await prisma.buzzLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuzzLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, BuzzLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuzzLikeClient<$Result.GetResult<Prisma.$BuzzLikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BuzzLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuzzLikes
     * const buzzLikes = await prisma.buzzLike.findMany()
     * 
     * // Get first 10 BuzzLikes
     * const buzzLikes = await prisma.buzzLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buzzLikeWithIdOnly = await prisma.buzzLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuzzLikeFindManyArgs>(args?: SelectSubset<T, BuzzLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuzzLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BuzzLike.
     * @param {BuzzLikeCreateArgs} args - Arguments to create a BuzzLike.
     * @example
     * // Create one BuzzLike
     * const BuzzLike = await prisma.buzzLike.create({
     *   data: {
     *     // ... data to create a BuzzLike
     *   }
     * })
     * 
     */
    create<T extends BuzzLikeCreateArgs>(args: SelectSubset<T, BuzzLikeCreateArgs<ExtArgs>>): Prisma__BuzzLikeClient<$Result.GetResult<Prisma.$BuzzLikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BuzzLikes.
     * @param {BuzzLikeCreateManyArgs} args - Arguments to create many BuzzLikes.
     * @example
     * // Create many BuzzLikes
     * const buzzLike = await prisma.buzzLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuzzLikeCreateManyArgs>(args?: SelectSubset<T, BuzzLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuzzLike.
     * @param {BuzzLikeDeleteArgs} args - Arguments to delete one BuzzLike.
     * @example
     * // Delete one BuzzLike
     * const BuzzLike = await prisma.buzzLike.delete({
     *   where: {
     *     // ... filter to delete one BuzzLike
     *   }
     * })
     * 
     */
    delete<T extends BuzzLikeDeleteArgs>(args: SelectSubset<T, BuzzLikeDeleteArgs<ExtArgs>>): Prisma__BuzzLikeClient<$Result.GetResult<Prisma.$BuzzLikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BuzzLike.
     * @param {BuzzLikeUpdateArgs} args - Arguments to update one BuzzLike.
     * @example
     * // Update one BuzzLike
     * const buzzLike = await prisma.buzzLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuzzLikeUpdateArgs>(args: SelectSubset<T, BuzzLikeUpdateArgs<ExtArgs>>): Prisma__BuzzLikeClient<$Result.GetResult<Prisma.$BuzzLikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BuzzLikes.
     * @param {BuzzLikeDeleteManyArgs} args - Arguments to filter BuzzLikes to delete.
     * @example
     * // Delete a few BuzzLikes
     * const { count } = await prisma.buzzLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuzzLikeDeleteManyArgs>(args?: SelectSubset<T, BuzzLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuzzLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuzzLikes
     * const buzzLike = await prisma.buzzLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuzzLikeUpdateManyArgs>(args: SelectSubset<T, BuzzLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuzzLike.
     * @param {BuzzLikeUpsertArgs} args - Arguments to update or create a BuzzLike.
     * @example
     * // Update or create a BuzzLike
     * const buzzLike = await prisma.buzzLike.upsert({
     *   create: {
     *     // ... data to create a BuzzLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuzzLike we want to update
     *   }
     * })
     */
    upsert<T extends BuzzLikeUpsertArgs>(args: SelectSubset<T, BuzzLikeUpsertArgs<ExtArgs>>): Prisma__BuzzLikeClient<$Result.GetResult<Prisma.$BuzzLikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BuzzLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzLikeCountArgs} args - Arguments to filter BuzzLikes to count.
     * @example
     * // Count the number of BuzzLikes
     * const count = await prisma.buzzLike.count({
     *   where: {
     *     // ... the filter for the BuzzLikes we want to count
     *   }
     * })
    **/
    count<T extends BuzzLikeCountArgs>(
      args?: Subset<T, BuzzLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuzzLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuzzLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuzzLikeAggregateArgs>(args: Subset<T, BuzzLikeAggregateArgs>): Prisma.PrismaPromise<GetBuzzLikeAggregateType<T>>

    /**
     * Group by BuzzLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuzzLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuzzLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuzzLikeGroupByArgs['orderBy'] }
        : { orderBy?: BuzzLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuzzLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuzzLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuzzLike model
   */
  readonly fields: BuzzLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuzzLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuzzLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    buzz<T extends CommunityBuzzDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityBuzzDefaultArgs<ExtArgs>>): Prisma__CommunityBuzzClient<$Result.GetResult<Prisma.$CommunityBuzzPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuzzLike model
   */
  interface BuzzLikeFieldRefs {
    readonly id: FieldRef<"BuzzLike", 'Int'>
    readonly buzzId: FieldRef<"BuzzLike", 'Int'>
    readonly userId: FieldRef<"BuzzLike", 'Int'>
    readonly createdAt: FieldRef<"BuzzLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BuzzLike findUnique
   */
  export type BuzzLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzLike
     */
    select?: BuzzLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzLike
     */
    omit?: BuzzLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzLikeInclude<ExtArgs> | null
    /**
     * Filter, which BuzzLike to fetch.
     */
    where: BuzzLikeWhereUniqueInput
  }

  /**
   * BuzzLike findUniqueOrThrow
   */
  export type BuzzLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzLike
     */
    select?: BuzzLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzLike
     */
    omit?: BuzzLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzLikeInclude<ExtArgs> | null
    /**
     * Filter, which BuzzLike to fetch.
     */
    where: BuzzLikeWhereUniqueInput
  }

  /**
   * BuzzLike findFirst
   */
  export type BuzzLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzLike
     */
    select?: BuzzLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzLike
     */
    omit?: BuzzLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzLikeInclude<ExtArgs> | null
    /**
     * Filter, which BuzzLike to fetch.
     */
    where?: BuzzLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzLikes to fetch.
     */
    orderBy?: BuzzLikeOrderByWithRelationInput | BuzzLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuzzLikes.
     */
    cursor?: BuzzLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuzzLikes.
     */
    distinct?: BuzzLikeScalarFieldEnum | BuzzLikeScalarFieldEnum[]
  }

  /**
   * BuzzLike findFirstOrThrow
   */
  export type BuzzLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzLike
     */
    select?: BuzzLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzLike
     */
    omit?: BuzzLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzLikeInclude<ExtArgs> | null
    /**
     * Filter, which BuzzLike to fetch.
     */
    where?: BuzzLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzLikes to fetch.
     */
    orderBy?: BuzzLikeOrderByWithRelationInput | BuzzLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuzzLikes.
     */
    cursor?: BuzzLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuzzLikes.
     */
    distinct?: BuzzLikeScalarFieldEnum | BuzzLikeScalarFieldEnum[]
  }

  /**
   * BuzzLike findMany
   */
  export type BuzzLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzLike
     */
    select?: BuzzLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzLike
     */
    omit?: BuzzLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzLikeInclude<ExtArgs> | null
    /**
     * Filter, which BuzzLikes to fetch.
     */
    where?: BuzzLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuzzLikes to fetch.
     */
    orderBy?: BuzzLikeOrderByWithRelationInput | BuzzLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuzzLikes.
     */
    cursor?: BuzzLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuzzLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuzzLikes.
     */
    skip?: number
    distinct?: BuzzLikeScalarFieldEnum | BuzzLikeScalarFieldEnum[]
  }

  /**
   * BuzzLike create
   */
  export type BuzzLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzLike
     */
    select?: BuzzLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzLike
     */
    omit?: BuzzLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a BuzzLike.
     */
    data: XOR<BuzzLikeCreateInput, BuzzLikeUncheckedCreateInput>
  }

  /**
   * BuzzLike createMany
   */
  export type BuzzLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuzzLikes.
     */
    data: BuzzLikeCreateManyInput | BuzzLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuzzLike update
   */
  export type BuzzLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzLike
     */
    select?: BuzzLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzLike
     */
    omit?: BuzzLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a BuzzLike.
     */
    data: XOR<BuzzLikeUpdateInput, BuzzLikeUncheckedUpdateInput>
    /**
     * Choose, which BuzzLike to update.
     */
    where: BuzzLikeWhereUniqueInput
  }

  /**
   * BuzzLike updateMany
   */
  export type BuzzLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuzzLikes.
     */
    data: XOR<BuzzLikeUpdateManyMutationInput, BuzzLikeUncheckedUpdateManyInput>
    /**
     * Filter which BuzzLikes to update
     */
    where?: BuzzLikeWhereInput
    /**
     * Limit how many BuzzLikes to update.
     */
    limit?: number
  }

  /**
   * BuzzLike upsert
   */
  export type BuzzLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzLike
     */
    select?: BuzzLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzLike
     */
    omit?: BuzzLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the BuzzLike to update in case it exists.
     */
    where: BuzzLikeWhereUniqueInput
    /**
     * In case the BuzzLike found by the `where` argument doesn't exist, create a new BuzzLike with this data.
     */
    create: XOR<BuzzLikeCreateInput, BuzzLikeUncheckedCreateInput>
    /**
     * In case the BuzzLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuzzLikeUpdateInput, BuzzLikeUncheckedUpdateInput>
  }

  /**
   * BuzzLike delete
   */
  export type BuzzLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzLike
     */
    select?: BuzzLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzLike
     */
    omit?: BuzzLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzLikeInclude<ExtArgs> | null
    /**
     * Filter which BuzzLike to delete.
     */
    where: BuzzLikeWhereUniqueInput
  }

  /**
   * BuzzLike deleteMany
   */
  export type BuzzLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuzzLikes to delete
     */
    where?: BuzzLikeWhereInput
    /**
     * Limit how many BuzzLikes to delete.
     */
    limit?: number
  }

  /**
   * BuzzLike without action
   */
  export type BuzzLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuzzLike
     */
    select?: BuzzLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuzzLike
     */
    omit?: BuzzLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuzzLikeInclude<ExtArgs> | null
  }


  /**
   * Model UnitMember
   */

  export type AggregateUnitMember = {
    _count: UnitMemberCountAggregateOutputType | null
    _avg: UnitMemberAvgAggregateOutputType | null
    _sum: UnitMemberSumAggregateOutputType | null
    _min: UnitMemberMinAggregateOutputType | null
    _max: UnitMemberMaxAggregateOutputType | null
  }

  export type UnitMemberAvgAggregateOutputType = {
    id: number | null
    unitId: number | null
    age: number | null
  }

  export type UnitMemberSumAggregateOutputType = {
    id: number | null
    unitId: number | null
    age: number | null
  }

  export type UnitMemberMinAggregateOutputType = {
    id: number | null
    unitId: number | null
    name: string | null
    relation: string | null
    age: number | null
    gender: string | null
    phone: string | null
    email: string | null
    profileImg: string | null
    createdAt: Date | null
  }

  export type UnitMemberMaxAggregateOutputType = {
    id: number | null
    unitId: number | null
    name: string | null
    relation: string | null
    age: number | null
    gender: string | null
    phone: string | null
    email: string | null
    profileImg: string | null
    createdAt: Date | null
  }

  export type UnitMemberCountAggregateOutputType = {
    id: number
    unitId: number
    name: number
    relation: number
    age: number
    gender: number
    phone: number
    email: number
    profileImg: number
    createdAt: number
    _all: number
  }


  export type UnitMemberAvgAggregateInputType = {
    id?: true
    unitId?: true
    age?: true
  }

  export type UnitMemberSumAggregateInputType = {
    id?: true
    unitId?: true
    age?: true
  }

  export type UnitMemberMinAggregateInputType = {
    id?: true
    unitId?: true
    name?: true
    relation?: true
    age?: true
    gender?: true
    phone?: true
    email?: true
    profileImg?: true
    createdAt?: true
  }

  export type UnitMemberMaxAggregateInputType = {
    id?: true
    unitId?: true
    name?: true
    relation?: true
    age?: true
    gender?: true
    phone?: true
    email?: true
    profileImg?: true
    createdAt?: true
  }

  export type UnitMemberCountAggregateInputType = {
    id?: true
    unitId?: true
    name?: true
    relation?: true
    age?: true
    gender?: true
    phone?: true
    email?: true
    profileImg?: true
    createdAt?: true
    _all?: true
  }

  export type UnitMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitMember to aggregate.
     */
    where?: UnitMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitMembers to fetch.
     */
    orderBy?: UnitMemberOrderByWithRelationInput | UnitMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitMembers
    **/
    _count?: true | UnitMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMemberMaxAggregateInputType
  }

  export type GetUnitMemberAggregateType<T extends UnitMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitMember[P]>
      : GetScalarType<T[P], AggregateUnitMember[P]>
  }




  export type UnitMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitMemberWhereInput
    orderBy?: UnitMemberOrderByWithAggregationInput | UnitMemberOrderByWithAggregationInput[]
    by: UnitMemberScalarFieldEnum[] | UnitMemberScalarFieldEnum
    having?: UnitMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitMemberCountAggregateInputType | true
    _avg?: UnitMemberAvgAggregateInputType
    _sum?: UnitMemberSumAggregateInputType
    _min?: UnitMemberMinAggregateInputType
    _max?: UnitMemberMaxAggregateInputType
  }

  export type UnitMemberGroupByOutputType = {
    id: number
    unitId: number
    name: string
    relation: string
    age: number | null
    gender: string | null
    phone: string | null
    email: string | null
    profileImg: string | null
    createdAt: Date
    _count: UnitMemberCountAggregateOutputType | null
    _avg: UnitMemberAvgAggregateOutputType | null
    _sum: UnitMemberSumAggregateOutputType | null
    _min: UnitMemberMinAggregateOutputType | null
    _max: UnitMemberMaxAggregateOutputType | null
  }

  type GetUnitMemberGroupByPayload<T extends UnitMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitMemberGroupByOutputType[P]>
            : GetScalarType<T[P], UnitMemberGroupByOutputType[P]>
        }
      >
    >


  export type UnitMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    name?: boolean
    relation?: boolean
    age?: boolean
    gender?: boolean
    phone?: boolean
    email?: boolean
    profileImg?: boolean
    createdAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitMember"]>



  export type UnitMemberSelectScalar = {
    id?: boolean
    unitId?: boolean
    name?: boolean
    relation?: boolean
    age?: boolean
    gender?: boolean
    phone?: boolean
    email?: boolean
    profileImg?: boolean
    createdAt?: boolean
  }

  export type UnitMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "name" | "relation" | "age" | "gender" | "phone" | "email" | "profileImg" | "createdAt", ExtArgs["result"]["unitMember"]>
  export type UnitMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $UnitMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitMember"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      unitId: number
      name: string
      relation: string
      age: number | null
      gender: string | null
      phone: string | null
      email: string | null
      profileImg: string | null
      createdAt: Date
    }, ExtArgs["result"]["unitMember"]>
    composites: {}
  }

  type UnitMemberGetPayload<S extends boolean | null | undefined | UnitMemberDefaultArgs> = $Result.GetResult<Prisma.$UnitMemberPayload, S>

  type UnitMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitMemberCountAggregateInputType | true
    }

  export interface UnitMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitMember'], meta: { name: 'UnitMember' } }
    /**
     * Find zero or one UnitMember that matches the filter.
     * @param {UnitMemberFindUniqueArgs} args - Arguments to find a UnitMember
     * @example
     * // Get one UnitMember
     * const unitMember = await prisma.unitMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitMemberFindUniqueArgs>(args: SelectSubset<T, UnitMemberFindUniqueArgs<ExtArgs>>): Prisma__UnitMemberClient<$Result.GetResult<Prisma.$UnitMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitMemberFindUniqueOrThrowArgs} args - Arguments to find a UnitMember
     * @example
     * // Get one UnitMember
     * const unitMember = await prisma.unitMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitMemberClient<$Result.GetResult<Prisma.$UnitMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitMemberFindFirstArgs} args - Arguments to find a UnitMember
     * @example
     * // Get one UnitMember
     * const unitMember = await prisma.unitMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitMemberFindFirstArgs>(args?: SelectSubset<T, UnitMemberFindFirstArgs<ExtArgs>>): Prisma__UnitMemberClient<$Result.GetResult<Prisma.$UnitMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitMemberFindFirstOrThrowArgs} args - Arguments to find a UnitMember
     * @example
     * // Get one UnitMember
     * const unitMember = await prisma.unitMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitMemberClient<$Result.GetResult<Prisma.$UnitMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitMembers
     * const unitMembers = await prisma.unitMember.findMany()
     * 
     * // Get first 10 UnitMembers
     * const unitMembers = await prisma.unitMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitMemberWithIdOnly = await prisma.unitMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitMemberFindManyArgs>(args?: SelectSubset<T, UnitMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitMember.
     * @param {UnitMemberCreateArgs} args - Arguments to create a UnitMember.
     * @example
     * // Create one UnitMember
     * const UnitMember = await prisma.unitMember.create({
     *   data: {
     *     // ... data to create a UnitMember
     *   }
     * })
     * 
     */
    create<T extends UnitMemberCreateArgs>(args: SelectSubset<T, UnitMemberCreateArgs<ExtArgs>>): Prisma__UnitMemberClient<$Result.GetResult<Prisma.$UnitMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitMembers.
     * @param {UnitMemberCreateManyArgs} args - Arguments to create many UnitMembers.
     * @example
     * // Create many UnitMembers
     * const unitMember = await prisma.unitMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitMemberCreateManyArgs>(args?: SelectSubset<T, UnitMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UnitMember.
     * @param {UnitMemberDeleteArgs} args - Arguments to delete one UnitMember.
     * @example
     * // Delete one UnitMember
     * const UnitMember = await prisma.unitMember.delete({
     *   where: {
     *     // ... filter to delete one UnitMember
     *   }
     * })
     * 
     */
    delete<T extends UnitMemberDeleteArgs>(args: SelectSubset<T, UnitMemberDeleteArgs<ExtArgs>>): Prisma__UnitMemberClient<$Result.GetResult<Prisma.$UnitMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitMember.
     * @param {UnitMemberUpdateArgs} args - Arguments to update one UnitMember.
     * @example
     * // Update one UnitMember
     * const unitMember = await prisma.unitMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitMemberUpdateArgs>(args: SelectSubset<T, UnitMemberUpdateArgs<ExtArgs>>): Prisma__UnitMemberClient<$Result.GetResult<Prisma.$UnitMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitMembers.
     * @param {UnitMemberDeleteManyArgs} args - Arguments to filter UnitMembers to delete.
     * @example
     * // Delete a few UnitMembers
     * const { count } = await prisma.unitMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitMemberDeleteManyArgs>(args?: SelectSubset<T, UnitMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitMembers
     * const unitMember = await prisma.unitMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitMemberUpdateManyArgs>(args: SelectSubset<T, UnitMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnitMember.
     * @param {UnitMemberUpsertArgs} args - Arguments to update or create a UnitMember.
     * @example
     * // Update or create a UnitMember
     * const unitMember = await prisma.unitMember.upsert({
     *   create: {
     *     // ... data to create a UnitMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitMember we want to update
     *   }
     * })
     */
    upsert<T extends UnitMemberUpsertArgs>(args: SelectSubset<T, UnitMemberUpsertArgs<ExtArgs>>): Prisma__UnitMemberClient<$Result.GetResult<Prisma.$UnitMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitMemberCountArgs} args - Arguments to filter UnitMembers to count.
     * @example
     * // Count the number of UnitMembers
     * const count = await prisma.unitMember.count({
     *   where: {
     *     // ... the filter for the UnitMembers we want to count
     *   }
     * })
    **/
    count<T extends UnitMemberCountArgs>(
      args?: Subset<T, UnitMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitMemberAggregateArgs>(args: Subset<T, UnitMemberAggregateArgs>): Prisma.PrismaPromise<GetUnitMemberAggregateType<T>>

    /**
     * Group by UnitMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitMemberGroupByArgs['orderBy'] }
        : { orderBy?: UnitMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitMember model
   */
  readonly fields: UnitMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitMember model
   */
  interface UnitMemberFieldRefs {
    readonly id: FieldRef<"UnitMember", 'Int'>
    readonly unitId: FieldRef<"UnitMember", 'Int'>
    readonly name: FieldRef<"UnitMember", 'String'>
    readonly relation: FieldRef<"UnitMember", 'String'>
    readonly age: FieldRef<"UnitMember", 'Int'>
    readonly gender: FieldRef<"UnitMember", 'String'>
    readonly phone: FieldRef<"UnitMember", 'String'>
    readonly email: FieldRef<"UnitMember", 'String'>
    readonly profileImg: FieldRef<"UnitMember", 'String'>
    readonly createdAt: FieldRef<"UnitMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitMember findUnique
   */
  export type UnitMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMember
     */
    select?: UnitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMember
     */
    omit?: UnitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMemberInclude<ExtArgs> | null
    /**
     * Filter, which UnitMember to fetch.
     */
    where: UnitMemberWhereUniqueInput
  }

  /**
   * UnitMember findUniqueOrThrow
   */
  export type UnitMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMember
     */
    select?: UnitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMember
     */
    omit?: UnitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMemberInclude<ExtArgs> | null
    /**
     * Filter, which UnitMember to fetch.
     */
    where: UnitMemberWhereUniqueInput
  }

  /**
   * UnitMember findFirst
   */
  export type UnitMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMember
     */
    select?: UnitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMember
     */
    omit?: UnitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMemberInclude<ExtArgs> | null
    /**
     * Filter, which UnitMember to fetch.
     */
    where?: UnitMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitMembers to fetch.
     */
    orderBy?: UnitMemberOrderByWithRelationInput | UnitMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitMembers.
     */
    cursor?: UnitMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitMembers.
     */
    distinct?: UnitMemberScalarFieldEnum | UnitMemberScalarFieldEnum[]
  }

  /**
   * UnitMember findFirstOrThrow
   */
  export type UnitMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMember
     */
    select?: UnitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMember
     */
    omit?: UnitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMemberInclude<ExtArgs> | null
    /**
     * Filter, which UnitMember to fetch.
     */
    where?: UnitMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitMembers to fetch.
     */
    orderBy?: UnitMemberOrderByWithRelationInput | UnitMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitMembers.
     */
    cursor?: UnitMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitMembers.
     */
    distinct?: UnitMemberScalarFieldEnum | UnitMemberScalarFieldEnum[]
  }

  /**
   * UnitMember findMany
   */
  export type UnitMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMember
     */
    select?: UnitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMember
     */
    omit?: UnitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMemberInclude<ExtArgs> | null
    /**
     * Filter, which UnitMembers to fetch.
     */
    where?: UnitMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitMembers to fetch.
     */
    orderBy?: UnitMemberOrderByWithRelationInput | UnitMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitMembers.
     */
    cursor?: UnitMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitMembers.
     */
    skip?: number
    distinct?: UnitMemberScalarFieldEnum | UnitMemberScalarFieldEnum[]
  }

  /**
   * UnitMember create
   */
  export type UnitMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMember
     */
    select?: UnitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMember
     */
    omit?: UnitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitMember.
     */
    data: XOR<UnitMemberCreateInput, UnitMemberUncheckedCreateInput>
  }

  /**
   * UnitMember createMany
   */
  export type UnitMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitMembers.
     */
    data: UnitMemberCreateManyInput | UnitMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitMember update
   */
  export type UnitMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMember
     */
    select?: UnitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMember
     */
    omit?: UnitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitMember.
     */
    data: XOR<UnitMemberUpdateInput, UnitMemberUncheckedUpdateInput>
    /**
     * Choose, which UnitMember to update.
     */
    where: UnitMemberWhereUniqueInput
  }

  /**
   * UnitMember updateMany
   */
  export type UnitMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitMembers.
     */
    data: XOR<UnitMemberUpdateManyMutationInput, UnitMemberUncheckedUpdateManyInput>
    /**
     * Filter which UnitMembers to update
     */
    where?: UnitMemberWhereInput
    /**
     * Limit how many UnitMembers to update.
     */
    limit?: number
  }

  /**
   * UnitMember upsert
   */
  export type UnitMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMember
     */
    select?: UnitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMember
     */
    omit?: UnitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitMember to update in case it exists.
     */
    where: UnitMemberWhereUniqueInput
    /**
     * In case the UnitMember found by the `where` argument doesn't exist, create a new UnitMember with this data.
     */
    create: XOR<UnitMemberCreateInput, UnitMemberUncheckedCreateInput>
    /**
     * In case the UnitMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitMemberUpdateInput, UnitMemberUncheckedUpdateInput>
  }

  /**
   * UnitMember delete
   */
  export type UnitMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMember
     */
    select?: UnitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMember
     */
    omit?: UnitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMemberInclude<ExtArgs> | null
    /**
     * Filter which UnitMember to delete.
     */
    where: UnitMemberWhereUniqueInput
  }

  /**
   * UnitMember deleteMany
   */
  export type UnitMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitMembers to delete
     */
    where?: UnitMemberWhereInput
    /**
     * Limit how many UnitMembers to delete.
     */
    limit?: number
  }

  /**
   * UnitMember without action
   */
  export type UnitMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitMember
     */
    select?: UnitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitMember
     */
    omit?: UnitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitMemberInclude<ExtArgs> | null
  }


  /**
   * Model UnitVehicle
   */

  export type AggregateUnitVehicle = {
    _count: UnitVehicleCountAggregateOutputType | null
    _avg: UnitVehicleAvgAggregateOutputType | null
    _sum: UnitVehicleSumAggregateOutputType | null
    _min: UnitVehicleMinAggregateOutputType | null
    _max: UnitVehicleMaxAggregateOutputType | null
  }

  export type UnitVehicleAvgAggregateOutputType = {
    id: number | null
    unitId: number | null
  }

  export type UnitVehicleSumAggregateOutputType = {
    id: number | null
    unitId: number | null
  }

  export type UnitVehicleMinAggregateOutputType = {
    id: number | null
    unitId: number | null
    name: string | null
    number: string | null
    type: string | null
    color: string | null
    parkingSlot: string | null
    createdAt: Date | null
  }

  export type UnitVehicleMaxAggregateOutputType = {
    id: number | null
    unitId: number | null
    name: string | null
    number: string | null
    type: string | null
    color: string | null
    parkingSlot: string | null
    createdAt: Date | null
  }

  export type UnitVehicleCountAggregateOutputType = {
    id: number
    unitId: number
    name: number
    number: number
    type: number
    color: number
    parkingSlot: number
    createdAt: number
    _all: number
  }


  export type UnitVehicleAvgAggregateInputType = {
    id?: true
    unitId?: true
  }

  export type UnitVehicleSumAggregateInputType = {
    id?: true
    unitId?: true
  }

  export type UnitVehicleMinAggregateInputType = {
    id?: true
    unitId?: true
    name?: true
    number?: true
    type?: true
    color?: true
    parkingSlot?: true
    createdAt?: true
  }

  export type UnitVehicleMaxAggregateInputType = {
    id?: true
    unitId?: true
    name?: true
    number?: true
    type?: true
    color?: true
    parkingSlot?: true
    createdAt?: true
  }

  export type UnitVehicleCountAggregateInputType = {
    id?: true
    unitId?: true
    name?: true
    number?: true
    type?: true
    color?: true
    parkingSlot?: true
    createdAt?: true
    _all?: true
  }

  export type UnitVehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitVehicle to aggregate.
     */
    where?: UnitVehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitVehicles to fetch.
     */
    orderBy?: UnitVehicleOrderByWithRelationInput | UnitVehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitVehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitVehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitVehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitVehicles
    **/
    _count?: true | UnitVehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitVehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitVehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitVehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitVehicleMaxAggregateInputType
  }

  export type GetUnitVehicleAggregateType<T extends UnitVehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitVehicle[P]>
      : GetScalarType<T[P], AggregateUnitVehicle[P]>
  }




  export type UnitVehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitVehicleWhereInput
    orderBy?: UnitVehicleOrderByWithAggregationInput | UnitVehicleOrderByWithAggregationInput[]
    by: UnitVehicleScalarFieldEnum[] | UnitVehicleScalarFieldEnum
    having?: UnitVehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitVehicleCountAggregateInputType | true
    _avg?: UnitVehicleAvgAggregateInputType
    _sum?: UnitVehicleSumAggregateInputType
    _min?: UnitVehicleMinAggregateInputType
    _max?: UnitVehicleMaxAggregateInputType
  }

  export type UnitVehicleGroupByOutputType = {
    id: number
    unitId: number
    name: string
    number: string
    type: string
    color: string | null
    parkingSlot: string | null
    createdAt: Date
    _count: UnitVehicleCountAggregateOutputType | null
    _avg: UnitVehicleAvgAggregateOutputType | null
    _sum: UnitVehicleSumAggregateOutputType | null
    _min: UnitVehicleMinAggregateOutputType | null
    _max: UnitVehicleMaxAggregateOutputType | null
  }

  type GetUnitVehicleGroupByPayload<T extends UnitVehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitVehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitVehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitVehicleGroupByOutputType[P]>
            : GetScalarType<T[P], UnitVehicleGroupByOutputType[P]>
        }
      >
    >


  export type UnitVehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    name?: boolean
    number?: boolean
    type?: boolean
    color?: boolean
    parkingSlot?: boolean
    createdAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitVehicle"]>



  export type UnitVehicleSelectScalar = {
    id?: boolean
    unitId?: boolean
    name?: boolean
    number?: boolean
    type?: boolean
    color?: boolean
    parkingSlot?: boolean
    createdAt?: boolean
  }

  export type UnitVehicleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "name" | "number" | "type" | "color" | "parkingSlot" | "createdAt", ExtArgs["result"]["unitVehicle"]>
  export type UnitVehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $UnitVehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitVehicle"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      unitId: number
      name: string
      number: string
      type: string
      color: string | null
      parkingSlot: string | null
      createdAt: Date
    }, ExtArgs["result"]["unitVehicle"]>
    composites: {}
  }

  type UnitVehicleGetPayload<S extends boolean | null | undefined | UnitVehicleDefaultArgs> = $Result.GetResult<Prisma.$UnitVehiclePayload, S>

  type UnitVehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitVehicleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitVehicleCountAggregateInputType | true
    }

  export interface UnitVehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitVehicle'], meta: { name: 'UnitVehicle' } }
    /**
     * Find zero or one UnitVehicle that matches the filter.
     * @param {UnitVehicleFindUniqueArgs} args - Arguments to find a UnitVehicle
     * @example
     * // Get one UnitVehicle
     * const unitVehicle = await prisma.unitVehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitVehicleFindUniqueArgs>(args: SelectSubset<T, UnitVehicleFindUniqueArgs<ExtArgs>>): Prisma__UnitVehicleClient<$Result.GetResult<Prisma.$UnitVehiclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitVehicle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitVehicleFindUniqueOrThrowArgs} args - Arguments to find a UnitVehicle
     * @example
     * // Get one UnitVehicle
     * const unitVehicle = await prisma.unitVehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitVehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitVehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitVehicleClient<$Result.GetResult<Prisma.$UnitVehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitVehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitVehicleFindFirstArgs} args - Arguments to find a UnitVehicle
     * @example
     * // Get one UnitVehicle
     * const unitVehicle = await prisma.unitVehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitVehicleFindFirstArgs>(args?: SelectSubset<T, UnitVehicleFindFirstArgs<ExtArgs>>): Prisma__UnitVehicleClient<$Result.GetResult<Prisma.$UnitVehiclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitVehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitVehicleFindFirstOrThrowArgs} args - Arguments to find a UnitVehicle
     * @example
     * // Get one UnitVehicle
     * const unitVehicle = await prisma.unitVehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitVehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitVehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitVehicleClient<$Result.GetResult<Prisma.$UnitVehiclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitVehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitVehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitVehicles
     * const unitVehicles = await prisma.unitVehicle.findMany()
     * 
     * // Get first 10 UnitVehicles
     * const unitVehicles = await prisma.unitVehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitVehicleWithIdOnly = await prisma.unitVehicle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitVehicleFindManyArgs>(args?: SelectSubset<T, UnitVehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitVehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitVehicle.
     * @param {UnitVehicleCreateArgs} args - Arguments to create a UnitVehicle.
     * @example
     * // Create one UnitVehicle
     * const UnitVehicle = await prisma.unitVehicle.create({
     *   data: {
     *     // ... data to create a UnitVehicle
     *   }
     * })
     * 
     */
    create<T extends UnitVehicleCreateArgs>(args: SelectSubset<T, UnitVehicleCreateArgs<ExtArgs>>): Prisma__UnitVehicleClient<$Result.GetResult<Prisma.$UnitVehiclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitVehicles.
     * @param {UnitVehicleCreateManyArgs} args - Arguments to create many UnitVehicles.
     * @example
     * // Create many UnitVehicles
     * const unitVehicle = await prisma.unitVehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitVehicleCreateManyArgs>(args?: SelectSubset<T, UnitVehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UnitVehicle.
     * @param {UnitVehicleDeleteArgs} args - Arguments to delete one UnitVehicle.
     * @example
     * // Delete one UnitVehicle
     * const UnitVehicle = await prisma.unitVehicle.delete({
     *   where: {
     *     // ... filter to delete one UnitVehicle
     *   }
     * })
     * 
     */
    delete<T extends UnitVehicleDeleteArgs>(args: SelectSubset<T, UnitVehicleDeleteArgs<ExtArgs>>): Prisma__UnitVehicleClient<$Result.GetResult<Prisma.$UnitVehiclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitVehicle.
     * @param {UnitVehicleUpdateArgs} args - Arguments to update one UnitVehicle.
     * @example
     * // Update one UnitVehicle
     * const unitVehicle = await prisma.unitVehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitVehicleUpdateArgs>(args: SelectSubset<T, UnitVehicleUpdateArgs<ExtArgs>>): Prisma__UnitVehicleClient<$Result.GetResult<Prisma.$UnitVehiclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitVehicles.
     * @param {UnitVehicleDeleteManyArgs} args - Arguments to filter UnitVehicles to delete.
     * @example
     * // Delete a few UnitVehicles
     * const { count } = await prisma.unitVehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitVehicleDeleteManyArgs>(args?: SelectSubset<T, UnitVehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitVehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitVehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitVehicles
     * const unitVehicle = await prisma.unitVehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitVehicleUpdateManyArgs>(args: SelectSubset<T, UnitVehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnitVehicle.
     * @param {UnitVehicleUpsertArgs} args - Arguments to update or create a UnitVehicle.
     * @example
     * // Update or create a UnitVehicle
     * const unitVehicle = await prisma.unitVehicle.upsert({
     *   create: {
     *     // ... data to create a UnitVehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitVehicle we want to update
     *   }
     * })
     */
    upsert<T extends UnitVehicleUpsertArgs>(args: SelectSubset<T, UnitVehicleUpsertArgs<ExtArgs>>): Prisma__UnitVehicleClient<$Result.GetResult<Prisma.$UnitVehiclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitVehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitVehicleCountArgs} args - Arguments to filter UnitVehicles to count.
     * @example
     * // Count the number of UnitVehicles
     * const count = await prisma.unitVehicle.count({
     *   where: {
     *     // ... the filter for the UnitVehicles we want to count
     *   }
     * })
    **/
    count<T extends UnitVehicleCountArgs>(
      args?: Subset<T, UnitVehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitVehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitVehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitVehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitVehicleAggregateArgs>(args: Subset<T, UnitVehicleAggregateArgs>): Prisma.PrismaPromise<GetUnitVehicleAggregateType<T>>

    /**
     * Group by UnitVehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitVehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitVehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitVehicleGroupByArgs['orderBy'] }
        : { orderBy?: UnitVehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitVehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitVehicle model
   */
  readonly fields: UnitVehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitVehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitVehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitVehicle model
   */
  interface UnitVehicleFieldRefs {
    readonly id: FieldRef<"UnitVehicle", 'Int'>
    readonly unitId: FieldRef<"UnitVehicle", 'Int'>
    readonly name: FieldRef<"UnitVehicle", 'String'>
    readonly number: FieldRef<"UnitVehicle", 'String'>
    readonly type: FieldRef<"UnitVehicle", 'String'>
    readonly color: FieldRef<"UnitVehicle", 'String'>
    readonly parkingSlot: FieldRef<"UnitVehicle", 'String'>
    readonly createdAt: FieldRef<"UnitVehicle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitVehicle findUnique
   */
  export type UnitVehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitVehicle
     */
    select?: UnitVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitVehicle
     */
    omit?: UnitVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitVehicleInclude<ExtArgs> | null
    /**
     * Filter, which UnitVehicle to fetch.
     */
    where: UnitVehicleWhereUniqueInput
  }

  /**
   * UnitVehicle findUniqueOrThrow
   */
  export type UnitVehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitVehicle
     */
    select?: UnitVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitVehicle
     */
    omit?: UnitVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitVehicleInclude<ExtArgs> | null
    /**
     * Filter, which UnitVehicle to fetch.
     */
    where: UnitVehicleWhereUniqueInput
  }

  /**
   * UnitVehicle findFirst
   */
  export type UnitVehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitVehicle
     */
    select?: UnitVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitVehicle
     */
    omit?: UnitVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitVehicleInclude<ExtArgs> | null
    /**
     * Filter, which UnitVehicle to fetch.
     */
    where?: UnitVehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitVehicles to fetch.
     */
    orderBy?: UnitVehicleOrderByWithRelationInput | UnitVehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitVehicles.
     */
    cursor?: UnitVehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitVehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitVehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitVehicles.
     */
    distinct?: UnitVehicleScalarFieldEnum | UnitVehicleScalarFieldEnum[]
  }

  /**
   * UnitVehicle findFirstOrThrow
   */
  export type UnitVehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitVehicle
     */
    select?: UnitVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitVehicle
     */
    omit?: UnitVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitVehicleInclude<ExtArgs> | null
    /**
     * Filter, which UnitVehicle to fetch.
     */
    where?: UnitVehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitVehicles to fetch.
     */
    orderBy?: UnitVehicleOrderByWithRelationInput | UnitVehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitVehicles.
     */
    cursor?: UnitVehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitVehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitVehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitVehicles.
     */
    distinct?: UnitVehicleScalarFieldEnum | UnitVehicleScalarFieldEnum[]
  }

  /**
   * UnitVehicle findMany
   */
  export type UnitVehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitVehicle
     */
    select?: UnitVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitVehicle
     */
    omit?: UnitVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitVehicleInclude<ExtArgs> | null
    /**
     * Filter, which UnitVehicles to fetch.
     */
    where?: UnitVehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitVehicles to fetch.
     */
    orderBy?: UnitVehicleOrderByWithRelationInput | UnitVehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitVehicles.
     */
    cursor?: UnitVehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitVehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitVehicles.
     */
    skip?: number
    distinct?: UnitVehicleScalarFieldEnum | UnitVehicleScalarFieldEnum[]
  }

  /**
   * UnitVehicle create
   */
  export type UnitVehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitVehicle
     */
    select?: UnitVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitVehicle
     */
    omit?: UnitVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitVehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitVehicle.
     */
    data: XOR<UnitVehicleCreateInput, UnitVehicleUncheckedCreateInput>
  }

  /**
   * UnitVehicle createMany
   */
  export type UnitVehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitVehicles.
     */
    data: UnitVehicleCreateManyInput | UnitVehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitVehicle update
   */
  export type UnitVehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitVehicle
     */
    select?: UnitVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitVehicle
     */
    omit?: UnitVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitVehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitVehicle.
     */
    data: XOR<UnitVehicleUpdateInput, UnitVehicleUncheckedUpdateInput>
    /**
     * Choose, which UnitVehicle to update.
     */
    where: UnitVehicleWhereUniqueInput
  }

  /**
   * UnitVehicle updateMany
   */
  export type UnitVehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitVehicles.
     */
    data: XOR<UnitVehicleUpdateManyMutationInput, UnitVehicleUncheckedUpdateManyInput>
    /**
     * Filter which UnitVehicles to update
     */
    where?: UnitVehicleWhereInput
    /**
     * Limit how many UnitVehicles to update.
     */
    limit?: number
  }

  /**
   * UnitVehicle upsert
   */
  export type UnitVehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitVehicle
     */
    select?: UnitVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitVehicle
     */
    omit?: UnitVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitVehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitVehicle to update in case it exists.
     */
    where: UnitVehicleWhereUniqueInput
    /**
     * In case the UnitVehicle found by the `where` argument doesn't exist, create a new UnitVehicle with this data.
     */
    create: XOR<UnitVehicleCreateInput, UnitVehicleUncheckedCreateInput>
    /**
     * In case the UnitVehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitVehicleUpdateInput, UnitVehicleUncheckedUpdateInput>
  }

  /**
   * UnitVehicle delete
   */
  export type UnitVehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitVehicle
     */
    select?: UnitVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitVehicle
     */
    omit?: UnitVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitVehicleInclude<ExtArgs> | null
    /**
     * Filter which UnitVehicle to delete.
     */
    where: UnitVehicleWhereUniqueInput
  }

  /**
   * UnitVehicle deleteMany
   */
  export type UnitVehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitVehicles to delete
     */
    where?: UnitVehicleWhereInput
    /**
     * Limit how many UnitVehicles to delete.
     */
    limit?: number
  }

  /**
   * UnitVehicle without action
   */
  export type UnitVehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitVehicle
     */
    select?: UnitVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitVehicle
     */
    omit?: UnitVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitVehicleInclude<ExtArgs> | null
  }


  /**
   * Model UnitPet
   */

  export type AggregateUnitPet = {
    _count: UnitPetCountAggregateOutputType | null
    _avg: UnitPetAvgAggregateOutputType | null
    _sum: UnitPetSumAggregateOutputType | null
    _min: UnitPetMinAggregateOutputType | null
    _max: UnitPetMaxAggregateOutputType | null
  }

  export type UnitPetAvgAggregateOutputType = {
    id: number | null
    unitId: number | null
  }

  export type UnitPetSumAggregateOutputType = {
    id: number | null
    unitId: number | null
  }

  export type UnitPetMinAggregateOutputType = {
    id: number | null
    unitId: number | null
    name: string | null
    type: string | null
    breed: string | null
    vaccinationStatus: string | null
    lastVaccinationDate: Date | null
    createdAt: Date | null
  }

  export type UnitPetMaxAggregateOutputType = {
    id: number | null
    unitId: number | null
    name: string | null
    type: string | null
    breed: string | null
    vaccinationStatus: string | null
    lastVaccinationDate: Date | null
    createdAt: Date | null
  }

  export type UnitPetCountAggregateOutputType = {
    id: number
    unitId: number
    name: number
    type: number
    breed: number
    vaccinationStatus: number
    lastVaccinationDate: number
    createdAt: number
    _all: number
  }


  export type UnitPetAvgAggregateInputType = {
    id?: true
    unitId?: true
  }

  export type UnitPetSumAggregateInputType = {
    id?: true
    unitId?: true
  }

  export type UnitPetMinAggregateInputType = {
    id?: true
    unitId?: true
    name?: true
    type?: true
    breed?: true
    vaccinationStatus?: true
    lastVaccinationDate?: true
    createdAt?: true
  }

  export type UnitPetMaxAggregateInputType = {
    id?: true
    unitId?: true
    name?: true
    type?: true
    breed?: true
    vaccinationStatus?: true
    lastVaccinationDate?: true
    createdAt?: true
  }

  export type UnitPetCountAggregateInputType = {
    id?: true
    unitId?: true
    name?: true
    type?: true
    breed?: true
    vaccinationStatus?: true
    lastVaccinationDate?: true
    createdAt?: true
    _all?: true
  }

  export type UnitPetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitPet to aggregate.
     */
    where?: UnitPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitPets to fetch.
     */
    orderBy?: UnitPetOrderByWithRelationInput | UnitPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitPets
    **/
    _count?: true | UnitPetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitPetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitPetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitPetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitPetMaxAggregateInputType
  }

  export type GetUnitPetAggregateType<T extends UnitPetAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitPet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitPet[P]>
      : GetScalarType<T[P], AggregateUnitPet[P]>
  }




  export type UnitPetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitPetWhereInput
    orderBy?: UnitPetOrderByWithAggregationInput | UnitPetOrderByWithAggregationInput[]
    by: UnitPetScalarFieldEnum[] | UnitPetScalarFieldEnum
    having?: UnitPetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitPetCountAggregateInputType | true
    _avg?: UnitPetAvgAggregateInputType
    _sum?: UnitPetSumAggregateInputType
    _min?: UnitPetMinAggregateInputType
    _max?: UnitPetMaxAggregateInputType
  }

  export type UnitPetGroupByOutputType = {
    id: number
    unitId: number
    name: string
    type: string
    breed: string | null
    vaccinationStatus: string
    lastVaccinationDate: Date | null
    createdAt: Date
    _count: UnitPetCountAggregateOutputType | null
    _avg: UnitPetAvgAggregateOutputType | null
    _sum: UnitPetSumAggregateOutputType | null
    _min: UnitPetMinAggregateOutputType | null
    _max: UnitPetMaxAggregateOutputType | null
  }

  type GetUnitPetGroupByPayload<T extends UnitPetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitPetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitPetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitPetGroupByOutputType[P]>
            : GetScalarType<T[P], UnitPetGroupByOutputType[P]>
        }
      >
    >


  export type UnitPetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    name?: boolean
    type?: boolean
    breed?: boolean
    vaccinationStatus?: boolean
    lastVaccinationDate?: boolean
    createdAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitPet"]>



  export type UnitPetSelectScalar = {
    id?: boolean
    unitId?: boolean
    name?: boolean
    type?: boolean
    breed?: boolean
    vaccinationStatus?: boolean
    lastVaccinationDate?: boolean
    createdAt?: boolean
  }

  export type UnitPetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "name" | "type" | "breed" | "vaccinationStatus" | "lastVaccinationDate" | "createdAt", ExtArgs["result"]["unitPet"]>
  export type UnitPetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $UnitPetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitPet"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      unitId: number
      name: string
      type: string
      breed: string | null
      vaccinationStatus: string
      lastVaccinationDate: Date | null
      createdAt: Date
    }, ExtArgs["result"]["unitPet"]>
    composites: {}
  }

  type UnitPetGetPayload<S extends boolean | null | undefined | UnitPetDefaultArgs> = $Result.GetResult<Prisma.$UnitPetPayload, S>

  type UnitPetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitPetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitPetCountAggregateInputType | true
    }

  export interface UnitPetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitPet'], meta: { name: 'UnitPet' } }
    /**
     * Find zero or one UnitPet that matches the filter.
     * @param {UnitPetFindUniqueArgs} args - Arguments to find a UnitPet
     * @example
     * // Get one UnitPet
     * const unitPet = await prisma.unitPet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitPetFindUniqueArgs>(args: SelectSubset<T, UnitPetFindUniqueArgs<ExtArgs>>): Prisma__UnitPetClient<$Result.GetResult<Prisma.$UnitPetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitPet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitPetFindUniqueOrThrowArgs} args - Arguments to find a UnitPet
     * @example
     * // Get one UnitPet
     * const unitPet = await prisma.unitPet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitPetFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitPetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitPetClient<$Result.GetResult<Prisma.$UnitPetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitPet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitPetFindFirstArgs} args - Arguments to find a UnitPet
     * @example
     * // Get one UnitPet
     * const unitPet = await prisma.unitPet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitPetFindFirstArgs>(args?: SelectSubset<T, UnitPetFindFirstArgs<ExtArgs>>): Prisma__UnitPetClient<$Result.GetResult<Prisma.$UnitPetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitPet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitPetFindFirstOrThrowArgs} args - Arguments to find a UnitPet
     * @example
     * // Get one UnitPet
     * const unitPet = await prisma.unitPet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitPetFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitPetFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitPetClient<$Result.GetResult<Prisma.$UnitPetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitPets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitPetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitPets
     * const unitPets = await prisma.unitPet.findMany()
     * 
     * // Get first 10 UnitPets
     * const unitPets = await prisma.unitPet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitPetWithIdOnly = await prisma.unitPet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitPetFindManyArgs>(args?: SelectSubset<T, UnitPetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitPet.
     * @param {UnitPetCreateArgs} args - Arguments to create a UnitPet.
     * @example
     * // Create one UnitPet
     * const UnitPet = await prisma.unitPet.create({
     *   data: {
     *     // ... data to create a UnitPet
     *   }
     * })
     * 
     */
    create<T extends UnitPetCreateArgs>(args: SelectSubset<T, UnitPetCreateArgs<ExtArgs>>): Prisma__UnitPetClient<$Result.GetResult<Prisma.$UnitPetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitPets.
     * @param {UnitPetCreateManyArgs} args - Arguments to create many UnitPets.
     * @example
     * // Create many UnitPets
     * const unitPet = await prisma.unitPet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitPetCreateManyArgs>(args?: SelectSubset<T, UnitPetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UnitPet.
     * @param {UnitPetDeleteArgs} args - Arguments to delete one UnitPet.
     * @example
     * // Delete one UnitPet
     * const UnitPet = await prisma.unitPet.delete({
     *   where: {
     *     // ... filter to delete one UnitPet
     *   }
     * })
     * 
     */
    delete<T extends UnitPetDeleteArgs>(args: SelectSubset<T, UnitPetDeleteArgs<ExtArgs>>): Prisma__UnitPetClient<$Result.GetResult<Prisma.$UnitPetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitPet.
     * @param {UnitPetUpdateArgs} args - Arguments to update one UnitPet.
     * @example
     * // Update one UnitPet
     * const unitPet = await prisma.unitPet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitPetUpdateArgs>(args: SelectSubset<T, UnitPetUpdateArgs<ExtArgs>>): Prisma__UnitPetClient<$Result.GetResult<Prisma.$UnitPetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitPets.
     * @param {UnitPetDeleteManyArgs} args - Arguments to filter UnitPets to delete.
     * @example
     * // Delete a few UnitPets
     * const { count } = await prisma.unitPet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitPetDeleteManyArgs>(args?: SelectSubset<T, UnitPetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitPets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitPetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitPets
     * const unitPet = await prisma.unitPet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitPetUpdateManyArgs>(args: SelectSubset<T, UnitPetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnitPet.
     * @param {UnitPetUpsertArgs} args - Arguments to update or create a UnitPet.
     * @example
     * // Update or create a UnitPet
     * const unitPet = await prisma.unitPet.upsert({
     *   create: {
     *     // ... data to create a UnitPet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitPet we want to update
     *   }
     * })
     */
    upsert<T extends UnitPetUpsertArgs>(args: SelectSubset<T, UnitPetUpsertArgs<ExtArgs>>): Prisma__UnitPetClient<$Result.GetResult<Prisma.$UnitPetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitPets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitPetCountArgs} args - Arguments to filter UnitPets to count.
     * @example
     * // Count the number of UnitPets
     * const count = await prisma.unitPet.count({
     *   where: {
     *     // ... the filter for the UnitPets we want to count
     *   }
     * })
    **/
    count<T extends UnitPetCountArgs>(
      args?: Subset<T, UnitPetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitPetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitPet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitPetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitPetAggregateArgs>(args: Subset<T, UnitPetAggregateArgs>): Prisma.PrismaPromise<GetUnitPetAggregateType<T>>

    /**
     * Group by UnitPet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitPetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitPetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitPetGroupByArgs['orderBy'] }
        : { orderBy?: UnitPetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitPetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitPetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitPet model
   */
  readonly fields: UnitPetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitPet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitPetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitPet model
   */
  interface UnitPetFieldRefs {
    readonly id: FieldRef<"UnitPet", 'Int'>
    readonly unitId: FieldRef<"UnitPet", 'Int'>
    readonly name: FieldRef<"UnitPet", 'String'>
    readonly type: FieldRef<"UnitPet", 'String'>
    readonly breed: FieldRef<"UnitPet", 'String'>
    readonly vaccinationStatus: FieldRef<"UnitPet", 'String'>
    readonly lastVaccinationDate: FieldRef<"UnitPet", 'DateTime'>
    readonly createdAt: FieldRef<"UnitPet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitPet findUnique
   */
  export type UnitPetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPet
     */
    select?: UnitPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPet
     */
    omit?: UnitPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPetInclude<ExtArgs> | null
    /**
     * Filter, which UnitPet to fetch.
     */
    where: UnitPetWhereUniqueInput
  }

  /**
   * UnitPet findUniqueOrThrow
   */
  export type UnitPetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPet
     */
    select?: UnitPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPet
     */
    omit?: UnitPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPetInclude<ExtArgs> | null
    /**
     * Filter, which UnitPet to fetch.
     */
    where: UnitPetWhereUniqueInput
  }

  /**
   * UnitPet findFirst
   */
  export type UnitPetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPet
     */
    select?: UnitPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPet
     */
    omit?: UnitPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPetInclude<ExtArgs> | null
    /**
     * Filter, which UnitPet to fetch.
     */
    where?: UnitPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitPets to fetch.
     */
    orderBy?: UnitPetOrderByWithRelationInput | UnitPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitPets.
     */
    cursor?: UnitPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitPets.
     */
    distinct?: UnitPetScalarFieldEnum | UnitPetScalarFieldEnum[]
  }

  /**
   * UnitPet findFirstOrThrow
   */
  export type UnitPetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPet
     */
    select?: UnitPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPet
     */
    omit?: UnitPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPetInclude<ExtArgs> | null
    /**
     * Filter, which UnitPet to fetch.
     */
    where?: UnitPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitPets to fetch.
     */
    orderBy?: UnitPetOrderByWithRelationInput | UnitPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitPets.
     */
    cursor?: UnitPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitPets.
     */
    distinct?: UnitPetScalarFieldEnum | UnitPetScalarFieldEnum[]
  }

  /**
   * UnitPet findMany
   */
  export type UnitPetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPet
     */
    select?: UnitPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPet
     */
    omit?: UnitPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPetInclude<ExtArgs> | null
    /**
     * Filter, which UnitPets to fetch.
     */
    where?: UnitPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitPets to fetch.
     */
    orderBy?: UnitPetOrderByWithRelationInput | UnitPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitPets.
     */
    cursor?: UnitPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitPets.
     */
    skip?: number
    distinct?: UnitPetScalarFieldEnum | UnitPetScalarFieldEnum[]
  }

  /**
   * UnitPet create
   */
  export type UnitPetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPet
     */
    select?: UnitPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPet
     */
    omit?: UnitPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPetInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitPet.
     */
    data: XOR<UnitPetCreateInput, UnitPetUncheckedCreateInput>
  }

  /**
   * UnitPet createMany
   */
  export type UnitPetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitPets.
     */
    data: UnitPetCreateManyInput | UnitPetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitPet update
   */
  export type UnitPetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPet
     */
    select?: UnitPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPet
     */
    omit?: UnitPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPetInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitPet.
     */
    data: XOR<UnitPetUpdateInput, UnitPetUncheckedUpdateInput>
    /**
     * Choose, which UnitPet to update.
     */
    where: UnitPetWhereUniqueInput
  }

  /**
   * UnitPet updateMany
   */
  export type UnitPetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitPets.
     */
    data: XOR<UnitPetUpdateManyMutationInput, UnitPetUncheckedUpdateManyInput>
    /**
     * Filter which UnitPets to update
     */
    where?: UnitPetWhereInput
    /**
     * Limit how many UnitPets to update.
     */
    limit?: number
  }

  /**
   * UnitPet upsert
   */
  export type UnitPetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPet
     */
    select?: UnitPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPet
     */
    omit?: UnitPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPetInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitPet to update in case it exists.
     */
    where: UnitPetWhereUniqueInput
    /**
     * In case the UnitPet found by the `where` argument doesn't exist, create a new UnitPet with this data.
     */
    create: XOR<UnitPetCreateInput, UnitPetUncheckedCreateInput>
    /**
     * In case the UnitPet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitPetUpdateInput, UnitPetUncheckedUpdateInput>
  }

  /**
   * UnitPet delete
   */
  export type UnitPetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPet
     */
    select?: UnitPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPet
     */
    omit?: UnitPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPetInclude<ExtArgs> | null
    /**
     * Filter which UnitPet to delete.
     */
    where: UnitPetWhereUniqueInput
  }

  /**
   * UnitPet deleteMany
   */
  export type UnitPetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitPets to delete
     */
    where?: UnitPetWhereInput
    /**
     * Limit how many UnitPets to delete.
     */
    limit?: number
  }

  /**
   * UnitPet without action
   */
  export type UnitPetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPet
     */
    select?: UnitPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPet
     */
    omit?: UnitPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPetInclude<ExtArgs> | null
  }


  /**
   * Model SOSAlert
   */

  export type AggregateSOSAlert = {
    _count: SOSAlertCountAggregateOutputType | null
    _avg: SOSAlertAvgAggregateOutputType | null
    _sum: SOSAlertSumAggregateOutputType | null
    _min: SOSAlertMinAggregateOutputType | null
    _max: SOSAlertMaxAggregateOutputType | null
  }

  export type SOSAlertAvgAggregateOutputType = {
    id: number | null
    residentId: number | null
    societyId: number | null
  }

  export type SOSAlertSumAggregateOutputType = {
    id: number | null
    residentId: number | null
    societyId: number | null
  }

  export type SOSAlertMinAggregateOutputType = {
    id: number | null
    residentId: number | null
    societyId: number | null
    type: string | null
    status: string | null
    location: string | null
    createdAt: Date | null
    resolvedAt: Date | null
  }

  export type SOSAlertMaxAggregateOutputType = {
    id: number | null
    residentId: number | null
    societyId: number | null
    type: string | null
    status: string | null
    location: string | null
    createdAt: Date | null
    resolvedAt: Date | null
  }

  export type SOSAlertCountAggregateOutputType = {
    id: number
    residentId: number
    societyId: number
    type: number
    status: number
    location: number
    createdAt: number
    resolvedAt: number
    _all: number
  }


  export type SOSAlertAvgAggregateInputType = {
    id?: true
    residentId?: true
    societyId?: true
  }

  export type SOSAlertSumAggregateInputType = {
    id?: true
    residentId?: true
    societyId?: true
  }

  export type SOSAlertMinAggregateInputType = {
    id?: true
    residentId?: true
    societyId?: true
    type?: true
    status?: true
    location?: true
    createdAt?: true
    resolvedAt?: true
  }

  export type SOSAlertMaxAggregateInputType = {
    id?: true
    residentId?: true
    societyId?: true
    type?: true
    status?: true
    location?: true
    createdAt?: true
    resolvedAt?: true
  }

  export type SOSAlertCountAggregateInputType = {
    id?: true
    residentId?: true
    societyId?: true
    type?: true
    status?: true
    location?: true
    createdAt?: true
    resolvedAt?: true
    _all?: true
  }

  export type SOSAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SOSAlert to aggregate.
     */
    where?: SOSAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SOSAlerts to fetch.
     */
    orderBy?: SOSAlertOrderByWithRelationInput | SOSAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SOSAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SOSAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SOSAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SOSAlerts
    **/
    _count?: true | SOSAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SOSAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SOSAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SOSAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SOSAlertMaxAggregateInputType
  }

  export type GetSOSAlertAggregateType<T extends SOSAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateSOSAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSOSAlert[P]>
      : GetScalarType<T[P], AggregateSOSAlert[P]>
  }




  export type SOSAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SOSAlertWhereInput
    orderBy?: SOSAlertOrderByWithAggregationInput | SOSAlertOrderByWithAggregationInput[]
    by: SOSAlertScalarFieldEnum[] | SOSAlertScalarFieldEnum
    having?: SOSAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SOSAlertCountAggregateInputType | true
    _avg?: SOSAlertAvgAggregateInputType
    _sum?: SOSAlertSumAggregateInputType
    _min?: SOSAlertMinAggregateInputType
    _max?: SOSAlertMaxAggregateInputType
  }

  export type SOSAlertGroupByOutputType = {
    id: number
    residentId: number
    societyId: number
    type: string
    status: string
    location: string | null
    createdAt: Date
    resolvedAt: Date | null
    _count: SOSAlertCountAggregateOutputType | null
    _avg: SOSAlertAvgAggregateOutputType | null
    _sum: SOSAlertSumAggregateOutputType | null
    _min: SOSAlertMinAggregateOutputType | null
    _max: SOSAlertMaxAggregateOutputType | null
  }

  type GetSOSAlertGroupByPayload<T extends SOSAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SOSAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SOSAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SOSAlertGroupByOutputType[P]>
            : GetScalarType<T[P], SOSAlertGroupByOutputType[P]>
        }
      >
    >


  export type SOSAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    residentId?: boolean
    societyId?: boolean
    type?: boolean
    status?: boolean
    location?: boolean
    createdAt?: boolean
    resolvedAt?: boolean
    resident?: boolean | UserDefaultArgs<ExtArgs>
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sOSAlert"]>



  export type SOSAlertSelectScalar = {
    id?: boolean
    residentId?: boolean
    societyId?: boolean
    type?: boolean
    status?: boolean
    location?: boolean
    createdAt?: boolean
    resolvedAt?: boolean
  }

  export type SOSAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "residentId" | "societyId" | "type" | "status" | "location" | "createdAt" | "resolvedAt", ExtArgs["result"]["sOSAlert"]>
  export type SOSAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | UserDefaultArgs<ExtArgs>
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $SOSAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SOSAlert"
    objects: {
      resident: Prisma.$UserPayload<ExtArgs>
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      residentId: number
      societyId: number
      type: string
      status: string
      location: string | null
      createdAt: Date
      resolvedAt: Date | null
    }, ExtArgs["result"]["sOSAlert"]>
    composites: {}
  }

  type SOSAlertGetPayload<S extends boolean | null | undefined | SOSAlertDefaultArgs> = $Result.GetResult<Prisma.$SOSAlertPayload, S>

  type SOSAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SOSAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SOSAlertCountAggregateInputType | true
    }

  export interface SOSAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SOSAlert'], meta: { name: 'SOSAlert' } }
    /**
     * Find zero or one SOSAlert that matches the filter.
     * @param {SOSAlertFindUniqueArgs} args - Arguments to find a SOSAlert
     * @example
     * // Get one SOSAlert
     * const sOSAlert = await prisma.sOSAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SOSAlertFindUniqueArgs>(args: SelectSubset<T, SOSAlertFindUniqueArgs<ExtArgs>>): Prisma__SOSAlertClient<$Result.GetResult<Prisma.$SOSAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SOSAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SOSAlertFindUniqueOrThrowArgs} args - Arguments to find a SOSAlert
     * @example
     * // Get one SOSAlert
     * const sOSAlert = await prisma.sOSAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SOSAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, SOSAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SOSAlertClient<$Result.GetResult<Prisma.$SOSAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SOSAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOSAlertFindFirstArgs} args - Arguments to find a SOSAlert
     * @example
     * // Get one SOSAlert
     * const sOSAlert = await prisma.sOSAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SOSAlertFindFirstArgs>(args?: SelectSubset<T, SOSAlertFindFirstArgs<ExtArgs>>): Prisma__SOSAlertClient<$Result.GetResult<Prisma.$SOSAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SOSAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOSAlertFindFirstOrThrowArgs} args - Arguments to find a SOSAlert
     * @example
     * // Get one SOSAlert
     * const sOSAlert = await prisma.sOSAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SOSAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, SOSAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__SOSAlertClient<$Result.GetResult<Prisma.$SOSAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SOSAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOSAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SOSAlerts
     * const sOSAlerts = await prisma.sOSAlert.findMany()
     * 
     * // Get first 10 SOSAlerts
     * const sOSAlerts = await prisma.sOSAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sOSAlertWithIdOnly = await prisma.sOSAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SOSAlertFindManyArgs>(args?: SelectSubset<T, SOSAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SOSAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SOSAlert.
     * @param {SOSAlertCreateArgs} args - Arguments to create a SOSAlert.
     * @example
     * // Create one SOSAlert
     * const SOSAlert = await prisma.sOSAlert.create({
     *   data: {
     *     // ... data to create a SOSAlert
     *   }
     * })
     * 
     */
    create<T extends SOSAlertCreateArgs>(args: SelectSubset<T, SOSAlertCreateArgs<ExtArgs>>): Prisma__SOSAlertClient<$Result.GetResult<Prisma.$SOSAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SOSAlerts.
     * @param {SOSAlertCreateManyArgs} args - Arguments to create many SOSAlerts.
     * @example
     * // Create many SOSAlerts
     * const sOSAlert = await prisma.sOSAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SOSAlertCreateManyArgs>(args?: SelectSubset<T, SOSAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SOSAlert.
     * @param {SOSAlertDeleteArgs} args - Arguments to delete one SOSAlert.
     * @example
     * // Delete one SOSAlert
     * const SOSAlert = await prisma.sOSAlert.delete({
     *   where: {
     *     // ... filter to delete one SOSAlert
     *   }
     * })
     * 
     */
    delete<T extends SOSAlertDeleteArgs>(args: SelectSubset<T, SOSAlertDeleteArgs<ExtArgs>>): Prisma__SOSAlertClient<$Result.GetResult<Prisma.$SOSAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SOSAlert.
     * @param {SOSAlertUpdateArgs} args - Arguments to update one SOSAlert.
     * @example
     * // Update one SOSAlert
     * const sOSAlert = await prisma.sOSAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SOSAlertUpdateArgs>(args: SelectSubset<T, SOSAlertUpdateArgs<ExtArgs>>): Prisma__SOSAlertClient<$Result.GetResult<Prisma.$SOSAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SOSAlerts.
     * @param {SOSAlertDeleteManyArgs} args - Arguments to filter SOSAlerts to delete.
     * @example
     * // Delete a few SOSAlerts
     * const { count } = await prisma.sOSAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SOSAlertDeleteManyArgs>(args?: SelectSubset<T, SOSAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SOSAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOSAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SOSAlerts
     * const sOSAlert = await prisma.sOSAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SOSAlertUpdateManyArgs>(args: SelectSubset<T, SOSAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SOSAlert.
     * @param {SOSAlertUpsertArgs} args - Arguments to update or create a SOSAlert.
     * @example
     * // Update or create a SOSAlert
     * const sOSAlert = await prisma.sOSAlert.upsert({
     *   create: {
     *     // ... data to create a SOSAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SOSAlert we want to update
     *   }
     * })
     */
    upsert<T extends SOSAlertUpsertArgs>(args: SelectSubset<T, SOSAlertUpsertArgs<ExtArgs>>): Prisma__SOSAlertClient<$Result.GetResult<Prisma.$SOSAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SOSAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOSAlertCountArgs} args - Arguments to filter SOSAlerts to count.
     * @example
     * // Count the number of SOSAlerts
     * const count = await prisma.sOSAlert.count({
     *   where: {
     *     // ... the filter for the SOSAlerts we want to count
     *   }
     * })
    **/
    count<T extends SOSAlertCountArgs>(
      args?: Subset<T, SOSAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SOSAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SOSAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOSAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SOSAlertAggregateArgs>(args: Subset<T, SOSAlertAggregateArgs>): Prisma.PrismaPromise<GetSOSAlertAggregateType<T>>

    /**
     * Group by SOSAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SOSAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SOSAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SOSAlertGroupByArgs['orderBy'] }
        : { orderBy?: SOSAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SOSAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSOSAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SOSAlert model
   */
  readonly fields: SOSAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SOSAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SOSAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resident<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SOSAlert model
   */
  interface SOSAlertFieldRefs {
    readonly id: FieldRef<"SOSAlert", 'Int'>
    readonly residentId: FieldRef<"SOSAlert", 'Int'>
    readonly societyId: FieldRef<"SOSAlert", 'Int'>
    readonly type: FieldRef<"SOSAlert", 'String'>
    readonly status: FieldRef<"SOSAlert", 'String'>
    readonly location: FieldRef<"SOSAlert", 'String'>
    readonly createdAt: FieldRef<"SOSAlert", 'DateTime'>
    readonly resolvedAt: FieldRef<"SOSAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SOSAlert findUnique
   */
  export type SOSAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOSAlert
     */
    select?: SOSAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOSAlert
     */
    omit?: SOSAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSAlertInclude<ExtArgs> | null
    /**
     * Filter, which SOSAlert to fetch.
     */
    where: SOSAlertWhereUniqueInput
  }

  /**
   * SOSAlert findUniqueOrThrow
   */
  export type SOSAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOSAlert
     */
    select?: SOSAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOSAlert
     */
    omit?: SOSAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSAlertInclude<ExtArgs> | null
    /**
     * Filter, which SOSAlert to fetch.
     */
    where: SOSAlertWhereUniqueInput
  }

  /**
   * SOSAlert findFirst
   */
  export type SOSAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOSAlert
     */
    select?: SOSAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOSAlert
     */
    omit?: SOSAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSAlertInclude<ExtArgs> | null
    /**
     * Filter, which SOSAlert to fetch.
     */
    where?: SOSAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SOSAlerts to fetch.
     */
    orderBy?: SOSAlertOrderByWithRelationInput | SOSAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SOSAlerts.
     */
    cursor?: SOSAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SOSAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SOSAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SOSAlerts.
     */
    distinct?: SOSAlertScalarFieldEnum | SOSAlertScalarFieldEnum[]
  }

  /**
   * SOSAlert findFirstOrThrow
   */
  export type SOSAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOSAlert
     */
    select?: SOSAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOSAlert
     */
    omit?: SOSAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSAlertInclude<ExtArgs> | null
    /**
     * Filter, which SOSAlert to fetch.
     */
    where?: SOSAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SOSAlerts to fetch.
     */
    orderBy?: SOSAlertOrderByWithRelationInput | SOSAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SOSAlerts.
     */
    cursor?: SOSAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SOSAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SOSAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SOSAlerts.
     */
    distinct?: SOSAlertScalarFieldEnum | SOSAlertScalarFieldEnum[]
  }

  /**
   * SOSAlert findMany
   */
  export type SOSAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOSAlert
     */
    select?: SOSAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOSAlert
     */
    omit?: SOSAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSAlertInclude<ExtArgs> | null
    /**
     * Filter, which SOSAlerts to fetch.
     */
    where?: SOSAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SOSAlerts to fetch.
     */
    orderBy?: SOSAlertOrderByWithRelationInput | SOSAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SOSAlerts.
     */
    cursor?: SOSAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SOSAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SOSAlerts.
     */
    skip?: number
    distinct?: SOSAlertScalarFieldEnum | SOSAlertScalarFieldEnum[]
  }

  /**
   * SOSAlert create
   */
  export type SOSAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOSAlert
     */
    select?: SOSAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOSAlert
     */
    omit?: SOSAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a SOSAlert.
     */
    data: XOR<SOSAlertCreateInput, SOSAlertUncheckedCreateInput>
  }

  /**
   * SOSAlert createMany
   */
  export type SOSAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SOSAlerts.
     */
    data: SOSAlertCreateManyInput | SOSAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SOSAlert update
   */
  export type SOSAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOSAlert
     */
    select?: SOSAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOSAlert
     */
    omit?: SOSAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a SOSAlert.
     */
    data: XOR<SOSAlertUpdateInput, SOSAlertUncheckedUpdateInput>
    /**
     * Choose, which SOSAlert to update.
     */
    where: SOSAlertWhereUniqueInput
  }

  /**
   * SOSAlert updateMany
   */
  export type SOSAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SOSAlerts.
     */
    data: XOR<SOSAlertUpdateManyMutationInput, SOSAlertUncheckedUpdateManyInput>
    /**
     * Filter which SOSAlerts to update
     */
    where?: SOSAlertWhereInput
    /**
     * Limit how many SOSAlerts to update.
     */
    limit?: number
  }

  /**
   * SOSAlert upsert
   */
  export type SOSAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOSAlert
     */
    select?: SOSAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOSAlert
     */
    omit?: SOSAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the SOSAlert to update in case it exists.
     */
    where: SOSAlertWhereUniqueInput
    /**
     * In case the SOSAlert found by the `where` argument doesn't exist, create a new SOSAlert with this data.
     */
    create: XOR<SOSAlertCreateInput, SOSAlertUncheckedCreateInput>
    /**
     * In case the SOSAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SOSAlertUpdateInput, SOSAlertUncheckedUpdateInput>
  }

  /**
   * SOSAlert delete
   */
  export type SOSAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOSAlert
     */
    select?: SOSAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOSAlert
     */
    omit?: SOSAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSAlertInclude<ExtArgs> | null
    /**
     * Filter which SOSAlert to delete.
     */
    where: SOSAlertWhereUniqueInput
  }

  /**
   * SOSAlert deleteMany
   */
  export type SOSAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SOSAlerts to delete
     */
    where?: SOSAlertWhereInput
    /**
     * Limit how many SOSAlerts to delete.
     */
    limit?: number
  }

  /**
   * SOSAlert without action
   */
  export type SOSAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SOSAlert
     */
    select?: SOSAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SOSAlert
     */
    omit?: SOSAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SOSAlertInclude<ExtArgs> | null
  }


  /**
   * Model MarketplaceItem
   */

  export type AggregateMarketplaceItem = {
    _count: MarketplaceItemCountAggregateOutputType | null
    _avg: MarketplaceItemAvgAggregateOutputType | null
    _sum: MarketplaceItemSumAggregateOutputType | null
    _min: MarketplaceItemMinAggregateOutputType | null
    _max: MarketplaceItemMaxAggregateOutputType | null
  }

  export type MarketplaceItemAvgAggregateOutputType = {
    id: number | null
    price: number | null
    originalPrice: number | null
    views: number | null
    likes: number | null
    ownerId: number | null
    societyId: number | null
  }

  export type MarketplaceItemSumAggregateOutputType = {
    id: number | null
    price: number | null
    originalPrice: number | null
    views: number | null
    likes: number | null
    ownerId: number | null
    societyId: number | null
  }

  export type MarketplaceItemMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    price: number | null
    originalPrice: number | null
    condition: string | null
    type: string | null
    priceType: string | null
    category: string | null
    status: string | null
    views: number | null
    likes: number | null
    ownerId: number | null
    societyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketplaceItemMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    price: number | null
    originalPrice: number | null
    condition: string | null
    type: string | null
    priceType: string | null
    category: string | null
    status: string | null
    views: number | null
    likes: number | null
    ownerId: number | null
    societyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketplaceItemCountAggregateOutputType = {
    id: number
    title: number
    description: number
    price: number
    originalPrice: number
    condition: number
    type: number
    priceType: number
    category: number
    status: number
    images: number
    views: number
    likes: number
    ownerId: number
    societyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketplaceItemAvgAggregateInputType = {
    id?: true
    price?: true
    originalPrice?: true
    views?: true
    likes?: true
    ownerId?: true
    societyId?: true
  }

  export type MarketplaceItemSumAggregateInputType = {
    id?: true
    price?: true
    originalPrice?: true
    views?: true
    likes?: true
    ownerId?: true
    societyId?: true
  }

  export type MarketplaceItemMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    originalPrice?: true
    condition?: true
    type?: true
    priceType?: true
    category?: true
    status?: true
    views?: true
    likes?: true
    ownerId?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketplaceItemMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    originalPrice?: true
    condition?: true
    type?: true
    priceType?: true
    category?: true
    status?: true
    views?: true
    likes?: true
    ownerId?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketplaceItemCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    originalPrice?: true
    condition?: true
    type?: true
    priceType?: true
    category?: true
    status?: true
    images?: true
    views?: true
    likes?: true
    ownerId?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketplaceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceItem to aggregate.
     */
    where?: MarketplaceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceItems to fetch.
     */
    orderBy?: MarketplaceItemOrderByWithRelationInput | MarketplaceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketplaceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketplaceItems
    **/
    _count?: true | MarketplaceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketplaceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketplaceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketplaceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketplaceItemMaxAggregateInputType
  }

  export type GetMarketplaceItemAggregateType<T extends MarketplaceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketplaceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketplaceItem[P]>
      : GetScalarType<T[P], AggregateMarketplaceItem[P]>
  }




  export type MarketplaceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceItemWhereInput
    orderBy?: MarketplaceItemOrderByWithAggregationInput | MarketplaceItemOrderByWithAggregationInput[]
    by: MarketplaceItemScalarFieldEnum[] | MarketplaceItemScalarFieldEnum
    having?: MarketplaceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketplaceItemCountAggregateInputType | true
    _avg?: MarketplaceItemAvgAggregateInputType
    _sum?: MarketplaceItemSumAggregateInputType
    _min?: MarketplaceItemMinAggregateInputType
    _max?: MarketplaceItemMaxAggregateInputType
  }

  export type MarketplaceItemGroupByOutputType = {
    id: number
    title: string
    description: string
    price: number | null
    originalPrice: number | null
    condition: string | null
    type: string
    priceType: string | null
    category: string | null
    status: string
    images: JsonValue | null
    views: number
    likes: number
    ownerId: number
    societyId: number
    createdAt: Date
    updatedAt: Date
    _count: MarketplaceItemCountAggregateOutputType | null
    _avg: MarketplaceItemAvgAggregateOutputType | null
    _sum: MarketplaceItemSumAggregateOutputType | null
    _min: MarketplaceItemMinAggregateOutputType | null
    _max: MarketplaceItemMaxAggregateOutputType | null
  }

  type GetMarketplaceItemGroupByPayload<T extends MarketplaceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketplaceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketplaceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketplaceItemGroupByOutputType[P]>
            : GetScalarType<T[P], MarketplaceItemGroupByOutputType[P]>
        }
      >
    >


  export type MarketplaceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    originalPrice?: boolean
    condition?: boolean
    type?: boolean
    priceType?: boolean
    category?: boolean
    status?: boolean
    images?: boolean
    views?: boolean
    likes?: boolean
    ownerId?: boolean
    societyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceItem"]>



  export type MarketplaceItemSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    originalPrice?: boolean
    condition?: boolean
    type?: boolean
    priceType?: boolean
    category?: boolean
    status?: boolean
    images?: boolean
    views?: boolean
    likes?: boolean
    ownerId?: boolean
    societyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketplaceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "price" | "originalPrice" | "condition" | "type" | "priceType" | "category" | "status" | "images" | "views" | "likes" | "ownerId" | "societyId" | "createdAt" | "updatedAt", ExtArgs["result"]["marketplaceItem"]>
  export type MarketplaceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $MarketplaceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketplaceItem"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      price: number | null
      originalPrice: number | null
      condition: string | null
      type: string
      priceType: string | null
      category: string | null
      status: string
      images: Prisma.JsonValue | null
      views: number
      likes: number
      ownerId: number
      societyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketplaceItem"]>
    composites: {}
  }

  type MarketplaceItemGetPayload<S extends boolean | null | undefined | MarketplaceItemDefaultArgs> = $Result.GetResult<Prisma.$MarketplaceItemPayload, S>

  type MarketplaceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketplaceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketplaceItemCountAggregateInputType | true
    }

  export interface MarketplaceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketplaceItem'], meta: { name: 'MarketplaceItem' } }
    /**
     * Find zero or one MarketplaceItem that matches the filter.
     * @param {MarketplaceItemFindUniqueArgs} args - Arguments to find a MarketplaceItem
     * @example
     * // Get one MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketplaceItemFindUniqueArgs>(args: SelectSubset<T, MarketplaceItemFindUniqueArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketplaceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketplaceItemFindUniqueOrThrowArgs} args - Arguments to find a MarketplaceItem
     * @example
     * // Get one MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketplaceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketplaceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketplaceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemFindFirstArgs} args - Arguments to find a MarketplaceItem
     * @example
     * // Get one MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketplaceItemFindFirstArgs>(args?: SelectSubset<T, MarketplaceItemFindFirstArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketplaceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemFindFirstOrThrowArgs} args - Arguments to find a MarketplaceItem
     * @example
     * // Get one MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketplaceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketplaceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketplaceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketplaceItems
     * const marketplaceItems = await prisma.marketplaceItem.findMany()
     * 
     * // Get first 10 MarketplaceItems
     * const marketplaceItems = await prisma.marketplaceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketplaceItemWithIdOnly = await prisma.marketplaceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketplaceItemFindManyArgs>(args?: SelectSubset<T, MarketplaceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketplaceItem.
     * @param {MarketplaceItemCreateArgs} args - Arguments to create a MarketplaceItem.
     * @example
     * // Create one MarketplaceItem
     * const MarketplaceItem = await prisma.marketplaceItem.create({
     *   data: {
     *     // ... data to create a MarketplaceItem
     *   }
     * })
     * 
     */
    create<T extends MarketplaceItemCreateArgs>(args: SelectSubset<T, MarketplaceItemCreateArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketplaceItems.
     * @param {MarketplaceItemCreateManyArgs} args - Arguments to create many MarketplaceItems.
     * @example
     * // Create many MarketplaceItems
     * const marketplaceItem = await prisma.marketplaceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketplaceItemCreateManyArgs>(args?: SelectSubset<T, MarketplaceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MarketplaceItem.
     * @param {MarketplaceItemDeleteArgs} args - Arguments to delete one MarketplaceItem.
     * @example
     * // Delete one MarketplaceItem
     * const MarketplaceItem = await prisma.marketplaceItem.delete({
     *   where: {
     *     // ... filter to delete one MarketplaceItem
     *   }
     * })
     * 
     */
    delete<T extends MarketplaceItemDeleteArgs>(args: SelectSubset<T, MarketplaceItemDeleteArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketplaceItem.
     * @param {MarketplaceItemUpdateArgs} args - Arguments to update one MarketplaceItem.
     * @example
     * // Update one MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketplaceItemUpdateArgs>(args: SelectSubset<T, MarketplaceItemUpdateArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketplaceItems.
     * @param {MarketplaceItemDeleteManyArgs} args - Arguments to filter MarketplaceItems to delete.
     * @example
     * // Delete a few MarketplaceItems
     * const { count } = await prisma.marketplaceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketplaceItemDeleteManyArgs>(args?: SelectSubset<T, MarketplaceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketplaceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketplaceItems
     * const marketplaceItem = await prisma.marketplaceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketplaceItemUpdateManyArgs>(args: SelectSubset<T, MarketplaceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketplaceItem.
     * @param {MarketplaceItemUpsertArgs} args - Arguments to update or create a MarketplaceItem.
     * @example
     * // Update or create a MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.upsert({
     *   create: {
     *     // ... data to create a MarketplaceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketplaceItem we want to update
     *   }
     * })
     */
    upsert<T extends MarketplaceItemUpsertArgs>(args: SelectSubset<T, MarketplaceItemUpsertArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketplaceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemCountArgs} args - Arguments to filter MarketplaceItems to count.
     * @example
     * // Count the number of MarketplaceItems
     * const count = await prisma.marketplaceItem.count({
     *   where: {
     *     // ... the filter for the MarketplaceItems we want to count
     *   }
     * })
    **/
    count<T extends MarketplaceItemCountArgs>(
      args?: Subset<T, MarketplaceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketplaceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketplaceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketplaceItemAggregateArgs>(args: Subset<T, MarketplaceItemAggregateArgs>): Prisma.PrismaPromise<GetMarketplaceItemAggregateType<T>>

    /**
     * Group by MarketplaceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketplaceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketplaceItemGroupByArgs['orderBy'] }
        : { orderBy?: MarketplaceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketplaceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketplaceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketplaceItem model
   */
  readonly fields: MarketplaceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketplaceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketplaceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketplaceItem model
   */
  interface MarketplaceItemFieldRefs {
    readonly id: FieldRef<"MarketplaceItem", 'Int'>
    readonly title: FieldRef<"MarketplaceItem", 'String'>
    readonly description: FieldRef<"MarketplaceItem", 'String'>
    readonly price: FieldRef<"MarketplaceItem", 'Float'>
    readonly originalPrice: FieldRef<"MarketplaceItem", 'Float'>
    readonly condition: FieldRef<"MarketplaceItem", 'String'>
    readonly type: FieldRef<"MarketplaceItem", 'String'>
    readonly priceType: FieldRef<"MarketplaceItem", 'String'>
    readonly category: FieldRef<"MarketplaceItem", 'String'>
    readonly status: FieldRef<"MarketplaceItem", 'String'>
    readonly images: FieldRef<"MarketplaceItem", 'Json'>
    readonly views: FieldRef<"MarketplaceItem", 'Int'>
    readonly likes: FieldRef<"MarketplaceItem", 'Int'>
    readonly ownerId: FieldRef<"MarketplaceItem", 'Int'>
    readonly societyId: FieldRef<"MarketplaceItem", 'Int'>
    readonly createdAt: FieldRef<"MarketplaceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketplaceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketplaceItem findUnique
   */
  export type MarketplaceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceItem
     */
    omit?: MarketplaceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceItem to fetch.
     */
    where: MarketplaceItemWhereUniqueInput
  }

  /**
   * MarketplaceItem findUniqueOrThrow
   */
  export type MarketplaceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceItem
     */
    omit?: MarketplaceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceItem to fetch.
     */
    where: MarketplaceItemWhereUniqueInput
  }

  /**
   * MarketplaceItem findFirst
   */
  export type MarketplaceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceItem
     */
    omit?: MarketplaceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceItem to fetch.
     */
    where?: MarketplaceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceItems to fetch.
     */
    orderBy?: MarketplaceItemOrderByWithRelationInput | MarketplaceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceItems.
     */
    cursor?: MarketplaceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceItems.
     */
    distinct?: MarketplaceItemScalarFieldEnum | MarketplaceItemScalarFieldEnum[]
  }

  /**
   * MarketplaceItem findFirstOrThrow
   */
  export type MarketplaceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceItem
     */
    omit?: MarketplaceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceItem to fetch.
     */
    where?: MarketplaceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceItems to fetch.
     */
    orderBy?: MarketplaceItemOrderByWithRelationInput | MarketplaceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceItems.
     */
    cursor?: MarketplaceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceItems.
     */
    distinct?: MarketplaceItemScalarFieldEnum | MarketplaceItemScalarFieldEnum[]
  }

  /**
   * MarketplaceItem findMany
   */
  export type MarketplaceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceItem
     */
    omit?: MarketplaceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceItems to fetch.
     */
    where?: MarketplaceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceItems to fetch.
     */
    orderBy?: MarketplaceItemOrderByWithRelationInput | MarketplaceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketplaceItems.
     */
    cursor?: MarketplaceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceItems.
     */
    skip?: number
    distinct?: MarketplaceItemScalarFieldEnum | MarketplaceItemScalarFieldEnum[]
  }

  /**
   * MarketplaceItem create
   */
  export type MarketplaceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceItem
     */
    omit?: MarketplaceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketplaceItem.
     */
    data: XOR<MarketplaceItemCreateInput, MarketplaceItemUncheckedCreateInput>
  }

  /**
   * MarketplaceItem createMany
   */
  export type MarketplaceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketplaceItems.
     */
    data: MarketplaceItemCreateManyInput | MarketplaceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketplaceItem update
   */
  export type MarketplaceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceItem
     */
    omit?: MarketplaceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketplaceItem.
     */
    data: XOR<MarketplaceItemUpdateInput, MarketplaceItemUncheckedUpdateInput>
    /**
     * Choose, which MarketplaceItem to update.
     */
    where: MarketplaceItemWhereUniqueInput
  }

  /**
   * MarketplaceItem updateMany
   */
  export type MarketplaceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketplaceItems.
     */
    data: XOR<MarketplaceItemUpdateManyMutationInput, MarketplaceItemUncheckedUpdateManyInput>
    /**
     * Filter which MarketplaceItems to update
     */
    where?: MarketplaceItemWhereInput
    /**
     * Limit how many MarketplaceItems to update.
     */
    limit?: number
  }

  /**
   * MarketplaceItem upsert
   */
  export type MarketplaceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceItem
     */
    omit?: MarketplaceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketplaceItem to update in case it exists.
     */
    where: MarketplaceItemWhereUniqueInput
    /**
     * In case the MarketplaceItem found by the `where` argument doesn't exist, create a new MarketplaceItem with this data.
     */
    create: XOR<MarketplaceItemCreateInput, MarketplaceItemUncheckedCreateInput>
    /**
     * In case the MarketplaceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketplaceItemUpdateInput, MarketplaceItemUncheckedUpdateInput>
  }

  /**
   * MarketplaceItem delete
   */
  export type MarketplaceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceItem
     */
    omit?: MarketplaceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter which MarketplaceItem to delete.
     */
    where: MarketplaceItemWhereUniqueInput
  }

  /**
   * MarketplaceItem deleteMany
   */
  export type MarketplaceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceItems to delete
     */
    where?: MarketplaceItemWhereInput
    /**
     * Limit how many MarketplaceItems to delete.
     */
    limit?: number
  }

  /**
   * MarketplaceItem without action
   */
  export type MarketplaceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceItem
     */
    omit?: MarketplaceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
  }


  /**
   * Model Meeting
   */

  export type AggregateMeeting = {
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  export type MeetingAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type MeetingSumAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type MeetingMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    date: Date | null
    time: string | null
    location: string | null
    status: string | null
    societyId: number | null
  }

  export type MeetingMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    date: Date | null
    time: string | null
    location: string | null
    status: string | null
    societyId: number | null
  }

  export type MeetingCountAggregateOutputType = {
    id: number
    title: number
    description: number
    date: number
    time: number
    location: number
    attendees: number
    status: number
    societyId: number
    _all: number
  }


  export type MeetingAvgAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type MeetingSumAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type MeetingMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    location?: true
    status?: true
    societyId?: true
  }

  export type MeetingMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    location?: true
    status?: true
    societyId?: true
  }

  export type MeetingCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    location?: true
    attendees?: true
    status?: true
    societyId?: true
    _all?: true
  }

  export type MeetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meeting to aggregate.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Meetings
    **/
    _count?: true | MeetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeetingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeetingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingMaxAggregateInputType
  }

  export type GetMeetingAggregateType<T extends MeetingAggregateArgs> = {
        [P in keyof T & keyof AggregateMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeeting[P]>
      : GetScalarType<T[P], AggregateMeeting[P]>
  }




  export type MeetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithAggregationInput | MeetingOrderByWithAggregationInput[]
    by: MeetingScalarFieldEnum[] | MeetingScalarFieldEnum
    having?: MeetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingCountAggregateInputType | true
    _avg?: MeetingAvgAggregateInputType
    _sum?: MeetingSumAggregateInputType
    _min?: MeetingMinAggregateInputType
    _max?: MeetingMaxAggregateInputType
  }

  export type MeetingGroupByOutputType = {
    id: number
    title: string
    description: string | null
    date: Date
    time: string
    location: string
    attendees: JsonValue | null
    status: string
    societyId: number
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  type GetMeetingGroupByPayload<T extends MeetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingGroupByOutputType[P]>
        }
      >
    >


  export type MeetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    attendees?: boolean
    status?: boolean
    societyId?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>



  export type MeetingSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    attendees?: boolean
    status?: boolean
    societyId?: boolean
  }

  export type MeetingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "date" | "time" | "location" | "attendees" | "status" | "societyId", ExtArgs["result"]["meeting"]>
  export type MeetingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $MeetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Meeting"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      date: Date
      time: string
      location: string
      attendees: Prisma.JsonValue | null
      status: string
      societyId: number
    }, ExtArgs["result"]["meeting"]>
    composites: {}
  }

  type MeetingGetPayload<S extends boolean | null | undefined | MeetingDefaultArgs> = $Result.GetResult<Prisma.$MeetingPayload, S>

  type MeetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MeetingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeetingCountAggregateInputType | true
    }

  export interface MeetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Meeting'], meta: { name: 'Meeting' } }
    /**
     * Find zero or one Meeting that matches the filter.
     * @param {MeetingFindUniqueArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingFindUniqueArgs>(args: SelectSubset<T, MeetingFindUniqueArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Meeting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeetingFindUniqueOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingFindUniqueOrThrowArgs>(args: SelectSubset<T, MeetingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingFindFirstArgs>(args?: SelectSubset<T, MeetingFindFirstArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingFindFirstOrThrowArgs>(args?: SelectSubset<T, MeetingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Meetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meetings
     * const meetings = await prisma.meeting.findMany()
     * 
     * // Get first 10 Meetings
     * const meetings = await prisma.meeting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingWithIdOnly = await prisma.meeting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeetingFindManyArgs>(args?: SelectSubset<T, MeetingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Meeting.
     * @param {MeetingCreateArgs} args - Arguments to create a Meeting.
     * @example
     * // Create one Meeting
     * const Meeting = await prisma.meeting.create({
     *   data: {
     *     // ... data to create a Meeting
     *   }
     * })
     * 
     */
    create<T extends MeetingCreateArgs>(args: SelectSubset<T, MeetingCreateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Meetings.
     * @param {MeetingCreateManyArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeetingCreateManyArgs>(args?: SelectSubset<T, MeetingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meeting.
     * @param {MeetingDeleteArgs} args - Arguments to delete one Meeting.
     * @example
     * // Delete one Meeting
     * const Meeting = await prisma.meeting.delete({
     *   where: {
     *     // ... filter to delete one Meeting
     *   }
     * })
     * 
     */
    delete<T extends MeetingDeleteArgs>(args: SelectSubset<T, MeetingDeleteArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Meeting.
     * @param {MeetingUpdateArgs} args - Arguments to update one Meeting.
     * @example
     * // Update one Meeting
     * const meeting = await prisma.meeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeetingUpdateArgs>(args: SelectSubset<T, MeetingUpdateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Meetings.
     * @param {MeetingDeleteManyArgs} args - Arguments to filter Meetings to delete.
     * @example
     * // Delete a few Meetings
     * const { count } = await prisma.meeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeetingDeleteManyArgs>(args?: SelectSubset<T, MeetingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meetings
     * const meeting = await prisma.meeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeetingUpdateManyArgs>(args: SelectSubset<T, MeetingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meeting.
     * @param {MeetingUpsertArgs} args - Arguments to update or create a Meeting.
     * @example
     * // Update or create a Meeting
     * const meeting = await prisma.meeting.upsert({
     *   create: {
     *     // ... data to create a Meeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meeting we want to update
     *   }
     * })
     */
    upsert<T extends MeetingUpsertArgs>(args: SelectSubset<T, MeetingUpsertArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingCountArgs} args - Arguments to filter Meetings to count.
     * @example
     * // Count the number of Meetings
     * const count = await prisma.meeting.count({
     *   where: {
     *     // ... the filter for the Meetings we want to count
     *   }
     * })
    **/
    count<T extends MeetingCountArgs>(
      args?: Subset<T, MeetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingAggregateArgs>(args: Subset<T, MeetingAggregateArgs>): Prisma.PrismaPromise<GetMeetingAggregateType<T>>

    /**
     * Group by Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingGroupByArgs['orderBy'] }
        : { orderBy?: MeetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Meeting model
   */
  readonly fields: MeetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Meeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Meeting model
   */
  interface MeetingFieldRefs {
    readonly id: FieldRef<"Meeting", 'Int'>
    readonly title: FieldRef<"Meeting", 'String'>
    readonly description: FieldRef<"Meeting", 'String'>
    readonly date: FieldRef<"Meeting", 'DateTime'>
    readonly time: FieldRef<"Meeting", 'String'>
    readonly location: FieldRef<"Meeting", 'String'>
    readonly attendees: FieldRef<"Meeting", 'Json'>
    readonly status: FieldRef<"Meeting", 'String'>
    readonly societyId: FieldRef<"Meeting", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Meeting findUnique
   */
  export type MeetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findUniqueOrThrow
   */
  export type MeetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findFirst
   */
  export type MeetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findFirstOrThrow
   */
  export type MeetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findMany
   */
  export type MeetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meetings to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting create
   */
  export type MeetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to create a Meeting.
     */
    data: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
  }

  /**
   * Meeting createMany
   */
  export type MeetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Meeting update
   */
  export type MeetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to update a Meeting.
     */
    data: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
    /**
     * Choose, which Meeting to update.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting updateMany
   */
  export type MeetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Meetings.
     */
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyInput>
    /**
     * Filter which Meetings to update
     */
    where?: MeetingWhereInput
    /**
     * Limit how many Meetings to update.
     */
    limit?: number
  }

  /**
   * Meeting upsert
   */
  export type MeetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The filter to search for the Meeting to update in case it exists.
     */
    where: MeetingWhereUniqueInput
    /**
     * In case the Meeting found by the `where` argument doesn't exist, create a new Meeting with this data.
     */
    create: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
    /**
     * In case the Meeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
  }

  /**
   * Meeting delete
   */
  export type MeetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter which Meeting to delete.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting deleteMany
   */
  export type MeetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meetings to delete
     */
    where?: MeetingWhereInput
    /**
     * Limit how many Meetings to delete.
     */
    limit?: number
  }

  /**
   * Meeting without action
   */
  export type MeetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
  }


  /**
   * Model CommunityGuideline
   */

  export type AggregateCommunityGuideline = {
    _count: CommunityGuidelineCountAggregateOutputType | null
    _avg: CommunityGuidelineAvgAggregateOutputType | null
    _sum: CommunityGuidelineSumAggregateOutputType | null
    _min: CommunityGuidelineMinAggregateOutputType | null
    _max: CommunityGuidelineMaxAggregateOutputType | null
  }

  export type CommunityGuidelineAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type CommunityGuidelineSumAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type CommunityGuidelineMinAggregateOutputType = {
    id: number | null
    societyId: number | null
    title: string | null
    content: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityGuidelineMaxAggregateOutputType = {
    id: number | null
    societyId: number | null
    title: string | null
    content: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityGuidelineCountAggregateOutputType = {
    id: number
    societyId: number
    title: number
    content: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommunityGuidelineAvgAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type CommunityGuidelineSumAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type CommunityGuidelineMinAggregateInputType = {
    id?: true
    societyId?: true
    title?: true
    content?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityGuidelineMaxAggregateInputType = {
    id?: true
    societyId?: true
    title?: true
    content?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityGuidelineCountAggregateInputType = {
    id?: true
    societyId?: true
    title?: true
    content?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommunityGuidelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityGuideline to aggregate.
     */
    where?: CommunityGuidelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityGuidelines to fetch.
     */
    orderBy?: CommunityGuidelineOrderByWithRelationInput | CommunityGuidelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityGuidelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityGuidelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityGuidelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityGuidelines
    **/
    _count?: true | CommunityGuidelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityGuidelineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityGuidelineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityGuidelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityGuidelineMaxAggregateInputType
  }

  export type GetCommunityGuidelineAggregateType<T extends CommunityGuidelineAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityGuideline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityGuideline[P]>
      : GetScalarType<T[P], AggregateCommunityGuideline[P]>
  }




  export type CommunityGuidelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityGuidelineWhereInput
    orderBy?: CommunityGuidelineOrderByWithAggregationInput | CommunityGuidelineOrderByWithAggregationInput[]
    by: CommunityGuidelineScalarFieldEnum[] | CommunityGuidelineScalarFieldEnum
    having?: CommunityGuidelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityGuidelineCountAggregateInputType | true
    _avg?: CommunityGuidelineAvgAggregateInputType
    _sum?: CommunityGuidelineSumAggregateInputType
    _min?: CommunityGuidelineMinAggregateInputType
    _max?: CommunityGuidelineMaxAggregateInputType
  }

  export type CommunityGuidelineGroupByOutputType = {
    id: number
    societyId: number
    title: string
    content: string
    category: string
    createdAt: Date
    updatedAt: Date
    _count: CommunityGuidelineCountAggregateOutputType | null
    _avg: CommunityGuidelineAvgAggregateOutputType | null
    _sum: CommunityGuidelineSumAggregateOutputType | null
    _min: CommunityGuidelineMinAggregateOutputType | null
    _max: CommunityGuidelineMaxAggregateOutputType | null
  }

  type GetCommunityGuidelineGroupByPayload<T extends CommunityGuidelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityGuidelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityGuidelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityGuidelineGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityGuidelineGroupByOutputType[P]>
        }
      >
    >


  export type CommunityGuidelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    societyId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityGuideline"]>



  export type CommunityGuidelineSelectScalar = {
    id?: boolean
    societyId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommunityGuidelineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "societyId" | "title" | "content" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["communityGuideline"]>
  export type CommunityGuidelineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $CommunityGuidelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityGuideline"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      societyId: number
      title: string
      content: string
      category: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["communityGuideline"]>
    composites: {}
  }

  type CommunityGuidelineGetPayload<S extends boolean | null | undefined | CommunityGuidelineDefaultArgs> = $Result.GetResult<Prisma.$CommunityGuidelinePayload, S>

  type CommunityGuidelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunityGuidelineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunityGuidelineCountAggregateInputType | true
    }

  export interface CommunityGuidelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityGuideline'], meta: { name: 'CommunityGuideline' } }
    /**
     * Find zero or one CommunityGuideline that matches the filter.
     * @param {CommunityGuidelineFindUniqueArgs} args - Arguments to find a CommunityGuideline
     * @example
     * // Get one CommunityGuideline
     * const communityGuideline = await prisma.communityGuideline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityGuidelineFindUniqueArgs>(args: SelectSubset<T, CommunityGuidelineFindUniqueArgs<ExtArgs>>): Prisma__CommunityGuidelineClient<$Result.GetResult<Prisma.$CommunityGuidelinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommunityGuideline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunityGuidelineFindUniqueOrThrowArgs} args - Arguments to find a CommunityGuideline
     * @example
     * // Get one CommunityGuideline
     * const communityGuideline = await prisma.communityGuideline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityGuidelineFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityGuidelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityGuidelineClient<$Result.GetResult<Prisma.$CommunityGuidelinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityGuideline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGuidelineFindFirstArgs} args - Arguments to find a CommunityGuideline
     * @example
     * // Get one CommunityGuideline
     * const communityGuideline = await prisma.communityGuideline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityGuidelineFindFirstArgs>(args?: SelectSubset<T, CommunityGuidelineFindFirstArgs<ExtArgs>>): Prisma__CommunityGuidelineClient<$Result.GetResult<Prisma.$CommunityGuidelinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityGuideline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGuidelineFindFirstOrThrowArgs} args - Arguments to find a CommunityGuideline
     * @example
     * // Get one CommunityGuideline
     * const communityGuideline = await prisma.communityGuideline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityGuidelineFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityGuidelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityGuidelineClient<$Result.GetResult<Prisma.$CommunityGuidelinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommunityGuidelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGuidelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityGuidelines
     * const communityGuidelines = await prisma.communityGuideline.findMany()
     * 
     * // Get first 10 CommunityGuidelines
     * const communityGuidelines = await prisma.communityGuideline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityGuidelineWithIdOnly = await prisma.communityGuideline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityGuidelineFindManyArgs>(args?: SelectSubset<T, CommunityGuidelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityGuidelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommunityGuideline.
     * @param {CommunityGuidelineCreateArgs} args - Arguments to create a CommunityGuideline.
     * @example
     * // Create one CommunityGuideline
     * const CommunityGuideline = await prisma.communityGuideline.create({
     *   data: {
     *     // ... data to create a CommunityGuideline
     *   }
     * })
     * 
     */
    create<T extends CommunityGuidelineCreateArgs>(args: SelectSubset<T, CommunityGuidelineCreateArgs<ExtArgs>>): Prisma__CommunityGuidelineClient<$Result.GetResult<Prisma.$CommunityGuidelinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommunityGuidelines.
     * @param {CommunityGuidelineCreateManyArgs} args - Arguments to create many CommunityGuidelines.
     * @example
     * // Create many CommunityGuidelines
     * const communityGuideline = await prisma.communityGuideline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityGuidelineCreateManyArgs>(args?: SelectSubset<T, CommunityGuidelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityGuideline.
     * @param {CommunityGuidelineDeleteArgs} args - Arguments to delete one CommunityGuideline.
     * @example
     * // Delete one CommunityGuideline
     * const CommunityGuideline = await prisma.communityGuideline.delete({
     *   where: {
     *     // ... filter to delete one CommunityGuideline
     *   }
     * })
     * 
     */
    delete<T extends CommunityGuidelineDeleteArgs>(args: SelectSubset<T, CommunityGuidelineDeleteArgs<ExtArgs>>): Prisma__CommunityGuidelineClient<$Result.GetResult<Prisma.$CommunityGuidelinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommunityGuideline.
     * @param {CommunityGuidelineUpdateArgs} args - Arguments to update one CommunityGuideline.
     * @example
     * // Update one CommunityGuideline
     * const communityGuideline = await prisma.communityGuideline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityGuidelineUpdateArgs>(args: SelectSubset<T, CommunityGuidelineUpdateArgs<ExtArgs>>): Prisma__CommunityGuidelineClient<$Result.GetResult<Prisma.$CommunityGuidelinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommunityGuidelines.
     * @param {CommunityGuidelineDeleteManyArgs} args - Arguments to filter CommunityGuidelines to delete.
     * @example
     * // Delete a few CommunityGuidelines
     * const { count } = await prisma.communityGuideline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityGuidelineDeleteManyArgs>(args?: SelectSubset<T, CommunityGuidelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityGuidelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGuidelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityGuidelines
     * const communityGuideline = await prisma.communityGuideline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityGuidelineUpdateManyArgs>(args: SelectSubset<T, CommunityGuidelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityGuideline.
     * @param {CommunityGuidelineUpsertArgs} args - Arguments to update or create a CommunityGuideline.
     * @example
     * // Update or create a CommunityGuideline
     * const communityGuideline = await prisma.communityGuideline.upsert({
     *   create: {
     *     // ... data to create a CommunityGuideline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityGuideline we want to update
     *   }
     * })
     */
    upsert<T extends CommunityGuidelineUpsertArgs>(args: SelectSubset<T, CommunityGuidelineUpsertArgs<ExtArgs>>): Prisma__CommunityGuidelineClient<$Result.GetResult<Prisma.$CommunityGuidelinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommunityGuidelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGuidelineCountArgs} args - Arguments to filter CommunityGuidelines to count.
     * @example
     * // Count the number of CommunityGuidelines
     * const count = await prisma.communityGuideline.count({
     *   where: {
     *     // ... the filter for the CommunityGuidelines we want to count
     *   }
     * })
    **/
    count<T extends CommunityGuidelineCountArgs>(
      args?: Subset<T, CommunityGuidelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityGuidelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityGuideline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGuidelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityGuidelineAggregateArgs>(args: Subset<T, CommunityGuidelineAggregateArgs>): Prisma.PrismaPromise<GetCommunityGuidelineAggregateType<T>>

    /**
     * Group by CommunityGuideline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGuidelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityGuidelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityGuidelineGroupByArgs['orderBy'] }
        : { orderBy?: CommunityGuidelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityGuidelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityGuidelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityGuideline model
   */
  readonly fields: CommunityGuidelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityGuideline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityGuidelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunityGuideline model
   */
  interface CommunityGuidelineFieldRefs {
    readonly id: FieldRef<"CommunityGuideline", 'Int'>
    readonly societyId: FieldRef<"CommunityGuideline", 'Int'>
    readonly title: FieldRef<"CommunityGuideline", 'String'>
    readonly content: FieldRef<"CommunityGuideline", 'String'>
    readonly category: FieldRef<"CommunityGuideline", 'String'>
    readonly createdAt: FieldRef<"CommunityGuideline", 'DateTime'>
    readonly updatedAt: FieldRef<"CommunityGuideline", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommunityGuideline findUnique
   */
  export type CommunityGuidelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGuideline
     */
    select?: CommunityGuidelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityGuideline
     */
    omit?: CommunityGuidelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGuidelineInclude<ExtArgs> | null
    /**
     * Filter, which CommunityGuideline to fetch.
     */
    where: CommunityGuidelineWhereUniqueInput
  }

  /**
   * CommunityGuideline findUniqueOrThrow
   */
  export type CommunityGuidelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGuideline
     */
    select?: CommunityGuidelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityGuideline
     */
    omit?: CommunityGuidelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGuidelineInclude<ExtArgs> | null
    /**
     * Filter, which CommunityGuideline to fetch.
     */
    where: CommunityGuidelineWhereUniqueInput
  }

  /**
   * CommunityGuideline findFirst
   */
  export type CommunityGuidelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGuideline
     */
    select?: CommunityGuidelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityGuideline
     */
    omit?: CommunityGuidelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGuidelineInclude<ExtArgs> | null
    /**
     * Filter, which CommunityGuideline to fetch.
     */
    where?: CommunityGuidelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityGuidelines to fetch.
     */
    orderBy?: CommunityGuidelineOrderByWithRelationInput | CommunityGuidelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityGuidelines.
     */
    cursor?: CommunityGuidelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityGuidelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityGuidelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityGuidelines.
     */
    distinct?: CommunityGuidelineScalarFieldEnum | CommunityGuidelineScalarFieldEnum[]
  }

  /**
   * CommunityGuideline findFirstOrThrow
   */
  export type CommunityGuidelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGuideline
     */
    select?: CommunityGuidelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityGuideline
     */
    omit?: CommunityGuidelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGuidelineInclude<ExtArgs> | null
    /**
     * Filter, which CommunityGuideline to fetch.
     */
    where?: CommunityGuidelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityGuidelines to fetch.
     */
    orderBy?: CommunityGuidelineOrderByWithRelationInput | CommunityGuidelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityGuidelines.
     */
    cursor?: CommunityGuidelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityGuidelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityGuidelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityGuidelines.
     */
    distinct?: CommunityGuidelineScalarFieldEnum | CommunityGuidelineScalarFieldEnum[]
  }

  /**
   * CommunityGuideline findMany
   */
  export type CommunityGuidelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGuideline
     */
    select?: CommunityGuidelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityGuideline
     */
    omit?: CommunityGuidelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGuidelineInclude<ExtArgs> | null
    /**
     * Filter, which CommunityGuidelines to fetch.
     */
    where?: CommunityGuidelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityGuidelines to fetch.
     */
    orderBy?: CommunityGuidelineOrderByWithRelationInput | CommunityGuidelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityGuidelines.
     */
    cursor?: CommunityGuidelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityGuidelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityGuidelines.
     */
    skip?: number
    distinct?: CommunityGuidelineScalarFieldEnum | CommunityGuidelineScalarFieldEnum[]
  }

  /**
   * CommunityGuideline create
   */
  export type CommunityGuidelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGuideline
     */
    select?: CommunityGuidelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityGuideline
     */
    omit?: CommunityGuidelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGuidelineInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityGuideline.
     */
    data: XOR<CommunityGuidelineCreateInput, CommunityGuidelineUncheckedCreateInput>
  }

  /**
   * CommunityGuideline createMany
   */
  export type CommunityGuidelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityGuidelines.
     */
    data: CommunityGuidelineCreateManyInput | CommunityGuidelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityGuideline update
   */
  export type CommunityGuidelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGuideline
     */
    select?: CommunityGuidelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityGuideline
     */
    omit?: CommunityGuidelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGuidelineInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityGuideline.
     */
    data: XOR<CommunityGuidelineUpdateInput, CommunityGuidelineUncheckedUpdateInput>
    /**
     * Choose, which CommunityGuideline to update.
     */
    where: CommunityGuidelineWhereUniqueInput
  }

  /**
   * CommunityGuideline updateMany
   */
  export type CommunityGuidelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityGuidelines.
     */
    data: XOR<CommunityGuidelineUpdateManyMutationInput, CommunityGuidelineUncheckedUpdateManyInput>
    /**
     * Filter which CommunityGuidelines to update
     */
    where?: CommunityGuidelineWhereInput
    /**
     * Limit how many CommunityGuidelines to update.
     */
    limit?: number
  }

  /**
   * CommunityGuideline upsert
   */
  export type CommunityGuidelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGuideline
     */
    select?: CommunityGuidelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityGuideline
     */
    omit?: CommunityGuidelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGuidelineInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityGuideline to update in case it exists.
     */
    where: CommunityGuidelineWhereUniqueInput
    /**
     * In case the CommunityGuideline found by the `where` argument doesn't exist, create a new CommunityGuideline with this data.
     */
    create: XOR<CommunityGuidelineCreateInput, CommunityGuidelineUncheckedCreateInput>
    /**
     * In case the CommunityGuideline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityGuidelineUpdateInput, CommunityGuidelineUncheckedUpdateInput>
  }

  /**
   * CommunityGuideline delete
   */
  export type CommunityGuidelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGuideline
     */
    select?: CommunityGuidelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityGuideline
     */
    omit?: CommunityGuidelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGuidelineInclude<ExtArgs> | null
    /**
     * Filter which CommunityGuideline to delete.
     */
    where: CommunityGuidelineWhereUniqueInput
  }

  /**
   * CommunityGuideline deleteMany
   */
  export type CommunityGuidelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityGuidelines to delete
     */
    where?: CommunityGuidelineWhereInput
    /**
     * Limit how many CommunityGuidelines to delete.
     */
    limit?: number
  }

  /**
   * CommunityGuideline without action
   */
  export type CommunityGuidelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityGuideline
     */
    select?: CommunityGuidelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityGuideline
     */
    omit?: CommunityGuidelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityGuidelineInclude<ExtArgs> | null
  }


  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetAvgAggregateOutputType = {
    id: number | null
    value: number | null
    societyId: number | null
  }

  export type AssetSumAggregateOutputType = {
    id: number | null
    value: number | null
    societyId: number | null
  }

  export type AssetMinAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    value: number | null
    purchaseDate: Date | null
    status: string | null
    societyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetMaxAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    value: number | null
    purchaseDate: Date | null
    status: string | null
    societyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    name: number
    category: number
    value: number
    purchaseDate: number
    status: number
    societyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssetAvgAggregateInputType = {
    id?: true
    value?: true
    societyId?: true
  }

  export type AssetSumAggregateInputType = {
    id?: true
    value?: true
    societyId?: true
  }

  export type AssetMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    value?: true
    purchaseDate?: true
    status?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    value?: true
    purchaseDate?: true
    status?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    value?: true
    purchaseDate?: true
    status?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _avg?: AssetAvgAggregateInputType
    _sum?: AssetSumAggregateInputType
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: number
    name: string
    category: string
    value: number
    purchaseDate: Date
    status: string
    societyId: number
    createdAt: Date
    updatedAt: Date
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    value?: boolean
    purchaseDate?: boolean
    status?: boolean
    societyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>



  export type AssetSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    value?: boolean
    purchaseDate?: boolean
    status?: boolean
    societyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "value" | "purchaseDate" | "status" | "societyId" | "createdAt" | "updatedAt", ExtArgs["result"]["asset"]>
  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      category: string
      value: number
      purchaseDate: Date
      status: string
      societyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }

  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetFindUniqueArgs>(args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetFindFirstArgs>(args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetFindManyArgs>(args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
     */
    create<T extends AssetCreateArgs>(args: SelectSubset<T, AssetCreateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCreateManyArgs>(args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
     */
    delete<T extends AssetDeleteArgs>(args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetUpdateArgs>(args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDeleteManyArgs>(args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetUpdateManyArgs>(args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
     */
    upsert<T extends AssetUpsertArgs>(args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asset model
   */
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'Int'>
    readonly name: FieldRef<"Asset", 'String'>
    readonly category: FieldRef<"Asset", 'String'>
    readonly value: FieldRef<"Asset", 'Float'>
    readonly purchaseDate: FieldRef<"Asset", 'DateTime'>
    readonly status: FieldRef<"Asset", 'String'>
    readonly societyId: FieldRef<"Asset", 'Int'>
    readonly createdAt: FieldRef<"Asset", 'DateTime'>
    readonly updatedAt: FieldRef<"Asset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to update.
     */
    limit?: number
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to delete.
     */
    limit?: number
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type DocumentSumAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: number | null
    title: string | null
    category: string | null
    fileUrl: string | null
    societyId: number | null
    createdAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: number | null
    title: string | null
    category: string | null
    fileUrl: string | null
    societyId: number | null
    createdAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    title: number
    category: number
    fileUrl: number
    societyId: number
    createdAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type DocumentSumAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    title?: true
    category?: true
    fileUrl?: true
    societyId?: true
    createdAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    title?: true
    category?: true
    fileUrl?: true
    societyId?: true
    createdAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    title?: true
    category?: true
    fileUrl?: true
    societyId?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: number
    title: string
    category: string
    fileUrl: string
    societyId: number
    createdAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    category?: boolean
    fileUrl?: boolean
    societyId?: boolean
    createdAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>



  export type DocumentSelectScalar = {
    id?: boolean
    title?: boolean
    category?: boolean
    fileUrl?: boolean
    societyId?: boolean
    createdAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "category" | "fileUrl" | "societyId" | "createdAt", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      category: string
      fileUrl: string
      societyId: number
      createdAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'Int'>
    readonly title: FieldRef<"Document", 'String'>
    readonly category: FieldRef<"Document", 'String'>
    readonly fileUrl: FieldRef<"Document", 'String'>
    readonly societyId: FieldRef<"Document", 'Int'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Parcel
   */

  export type AggregateParcel = {
    _count: ParcelCountAggregateOutputType | null
    _avg: ParcelAvgAggregateOutputType | null
    _sum: ParcelSumAggregateOutputType | null
    _min: ParcelMinAggregateOutputType | null
    _max: ParcelMaxAggregateOutputType | null
  }

  export type ParcelAvgAggregateOutputType = {
    id: number | null
    unitId: number | null
    societyId: number | null
  }

  export type ParcelSumAggregateOutputType = {
    id: number | null
    unitId: number | null
    societyId: number | null
  }

  export type ParcelMinAggregateOutputType = {
    id: number | null
    unitId: number | null
    courierName: string | null
    trackingNumber: string | null
    description: string | null
    receivedBy: string | null
    status: string | null
    collectedBy: string | null
    collectedAt: Date | null
    societyId: number | null
    createdAt: Date | null
  }

  export type ParcelMaxAggregateOutputType = {
    id: number | null
    unitId: number | null
    courierName: string | null
    trackingNumber: string | null
    description: string | null
    receivedBy: string | null
    status: string | null
    collectedBy: string | null
    collectedAt: Date | null
    societyId: number | null
    createdAt: Date | null
  }

  export type ParcelCountAggregateOutputType = {
    id: number
    unitId: number
    courierName: number
    trackingNumber: number
    description: number
    receivedBy: number
    status: number
    collectedBy: number
    collectedAt: number
    societyId: number
    createdAt: number
    _all: number
  }


  export type ParcelAvgAggregateInputType = {
    id?: true
    unitId?: true
    societyId?: true
  }

  export type ParcelSumAggregateInputType = {
    id?: true
    unitId?: true
    societyId?: true
  }

  export type ParcelMinAggregateInputType = {
    id?: true
    unitId?: true
    courierName?: true
    trackingNumber?: true
    description?: true
    receivedBy?: true
    status?: true
    collectedBy?: true
    collectedAt?: true
    societyId?: true
    createdAt?: true
  }

  export type ParcelMaxAggregateInputType = {
    id?: true
    unitId?: true
    courierName?: true
    trackingNumber?: true
    description?: true
    receivedBy?: true
    status?: true
    collectedBy?: true
    collectedAt?: true
    societyId?: true
    createdAt?: true
  }

  export type ParcelCountAggregateInputType = {
    id?: true
    unitId?: true
    courierName?: true
    trackingNumber?: true
    description?: true
    receivedBy?: true
    status?: true
    collectedBy?: true
    collectedAt?: true
    societyId?: true
    createdAt?: true
    _all?: true
  }

  export type ParcelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parcel to aggregate.
     */
    where?: ParcelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parcels to fetch.
     */
    orderBy?: ParcelOrderByWithRelationInput | ParcelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParcelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parcels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parcels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parcels
    **/
    _count?: true | ParcelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParcelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParcelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParcelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParcelMaxAggregateInputType
  }

  export type GetParcelAggregateType<T extends ParcelAggregateArgs> = {
        [P in keyof T & keyof AggregateParcel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParcel[P]>
      : GetScalarType<T[P], AggregateParcel[P]>
  }




  export type ParcelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParcelWhereInput
    orderBy?: ParcelOrderByWithAggregationInput | ParcelOrderByWithAggregationInput[]
    by: ParcelScalarFieldEnum[] | ParcelScalarFieldEnum
    having?: ParcelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParcelCountAggregateInputType | true
    _avg?: ParcelAvgAggregateInputType
    _sum?: ParcelSumAggregateInputType
    _min?: ParcelMinAggregateInputType
    _max?: ParcelMaxAggregateInputType
  }

  export type ParcelGroupByOutputType = {
    id: number
    unitId: number
    courierName: string
    trackingNumber: string | null
    description: string | null
    receivedBy: string | null
    status: string
    collectedBy: string | null
    collectedAt: Date | null
    societyId: number
    createdAt: Date
    _count: ParcelCountAggregateOutputType | null
    _avg: ParcelAvgAggregateOutputType | null
    _sum: ParcelSumAggregateOutputType | null
    _min: ParcelMinAggregateOutputType | null
    _max: ParcelMaxAggregateOutputType | null
  }

  type GetParcelGroupByPayload<T extends ParcelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParcelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParcelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParcelGroupByOutputType[P]>
            : GetScalarType<T[P], ParcelGroupByOutputType[P]>
        }
      >
    >


  export type ParcelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    courierName?: boolean
    trackingNumber?: boolean
    description?: boolean
    receivedBy?: boolean
    status?: boolean
    collectedBy?: boolean
    collectedAt?: boolean
    societyId?: boolean
    createdAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parcel"]>



  export type ParcelSelectScalar = {
    id?: boolean
    unitId?: boolean
    courierName?: boolean
    trackingNumber?: boolean
    description?: boolean
    receivedBy?: boolean
    status?: boolean
    collectedBy?: boolean
    collectedAt?: boolean
    societyId?: boolean
    createdAt?: boolean
  }

  export type ParcelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "courierName" | "trackingNumber" | "description" | "receivedBy" | "status" | "collectedBy" | "collectedAt" | "societyId" | "createdAt", ExtArgs["result"]["parcel"]>
  export type ParcelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $ParcelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parcel"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      unitId: number
      courierName: string
      trackingNumber: string | null
      description: string | null
      receivedBy: string | null
      status: string
      collectedBy: string | null
      collectedAt: Date | null
      societyId: number
      createdAt: Date
    }, ExtArgs["result"]["parcel"]>
    composites: {}
  }

  type ParcelGetPayload<S extends boolean | null | undefined | ParcelDefaultArgs> = $Result.GetResult<Prisma.$ParcelPayload, S>

  type ParcelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParcelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParcelCountAggregateInputType | true
    }

  export interface ParcelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parcel'], meta: { name: 'Parcel' } }
    /**
     * Find zero or one Parcel that matches the filter.
     * @param {ParcelFindUniqueArgs} args - Arguments to find a Parcel
     * @example
     * // Get one Parcel
     * const parcel = await prisma.parcel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParcelFindUniqueArgs>(args: SelectSubset<T, ParcelFindUniqueArgs<ExtArgs>>): Prisma__ParcelClient<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parcel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParcelFindUniqueOrThrowArgs} args - Arguments to find a Parcel
     * @example
     * // Get one Parcel
     * const parcel = await prisma.parcel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParcelFindUniqueOrThrowArgs>(args: SelectSubset<T, ParcelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParcelClient<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parcel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelFindFirstArgs} args - Arguments to find a Parcel
     * @example
     * // Get one Parcel
     * const parcel = await prisma.parcel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParcelFindFirstArgs>(args?: SelectSubset<T, ParcelFindFirstArgs<ExtArgs>>): Prisma__ParcelClient<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parcel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelFindFirstOrThrowArgs} args - Arguments to find a Parcel
     * @example
     * // Get one Parcel
     * const parcel = await prisma.parcel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParcelFindFirstOrThrowArgs>(args?: SelectSubset<T, ParcelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParcelClient<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parcels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parcels
     * const parcels = await prisma.parcel.findMany()
     * 
     * // Get first 10 Parcels
     * const parcels = await prisma.parcel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parcelWithIdOnly = await prisma.parcel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParcelFindManyArgs>(args?: SelectSubset<T, ParcelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parcel.
     * @param {ParcelCreateArgs} args - Arguments to create a Parcel.
     * @example
     * // Create one Parcel
     * const Parcel = await prisma.parcel.create({
     *   data: {
     *     // ... data to create a Parcel
     *   }
     * })
     * 
     */
    create<T extends ParcelCreateArgs>(args: SelectSubset<T, ParcelCreateArgs<ExtArgs>>): Prisma__ParcelClient<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parcels.
     * @param {ParcelCreateManyArgs} args - Arguments to create many Parcels.
     * @example
     * // Create many Parcels
     * const parcel = await prisma.parcel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParcelCreateManyArgs>(args?: SelectSubset<T, ParcelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parcel.
     * @param {ParcelDeleteArgs} args - Arguments to delete one Parcel.
     * @example
     * // Delete one Parcel
     * const Parcel = await prisma.parcel.delete({
     *   where: {
     *     // ... filter to delete one Parcel
     *   }
     * })
     * 
     */
    delete<T extends ParcelDeleteArgs>(args: SelectSubset<T, ParcelDeleteArgs<ExtArgs>>): Prisma__ParcelClient<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parcel.
     * @param {ParcelUpdateArgs} args - Arguments to update one Parcel.
     * @example
     * // Update one Parcel
     * const parcel = await prisma.parcel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParcelUpdateArgs>(args: SelectSubset<T, ParcelUpdateArgs<ExtArgs>>): Prisma__ParcelClient<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parcels.
     * @param {ParcelDeleteManyArgs} args - Arguments to filter Parcels to delete.
     * @example
     * // Delete a few Parcels
     * const { count } = await prisma.parcel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParcelDeleteManyArgs>(args?: SelectSubset<T, ParcelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parcels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parcels
     * const parcel = await prisma.parcel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParcelUpdateManyArgs>(args: SelectSubset<T, ParcelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parcel.
     * @param {ParcelUpsertArgs} args - Arguments to update or create a Parcel.
     * @example
     * // Update or create a Parcel
     * const parcel = await prisma.parcel.upsert({
     *   create: {
     *     // ... data to create a Parcel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parcel we want to update
     *   }
     * })
     */
    upsert<T extends ParcelUpsertArgs>(args: SelectSubset<T, ParcelUpsertArgs<ExtArgs>>): Prisma__ParcelClient<$Result.GetResult<Prisma.$ParcelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parcels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelCountArgs} args - Arguments to filter Parcels to count.
     * @example
     * // Count the number of Parcels
     * const count = await prisma.parcel.count({
     *   where: {
     *     // ... the filter for the Parcels we want to count
     *   }
     * })
    **/
    count<T extends ParcelCountArgs>(
      args?: Subset<T, ParcelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParcelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parcel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParcelAggregateArgs>(args: Subset<T, ParcelAggregateArgs>): Prisma.PrismaPromise<GetParcelAggregateType<T>>

    /**
     * Group by Parcel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParcelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParcelGroupByArgs['orderBy'] }
        : { orderBy?: ParcelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParcelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParcelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parcel model
   */
  readonly fields: ParcelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parcel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParcelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parcel model
   */
  interface ParcelFieldRefs {
    readonly id: FieldRef<"Parcel", 'Int'>
    readonly unitId: FieldRef<"Parcel", 'Int'>
    readonly courierName: FieldRef<"Parcel", 'String'>
    readonly trackingNumber: FieldRef<"Parcel", 'String'>
    readonly description: FieldRef<"Parcel", 'String'>
    readonly receivedBy: FieldRef<"Parcel", 'String'>
    readonly status: FieldRef<"Parcel", 'String'>
    readonly collectedBy: FieldRef<"Parcel", 'String'>
    readonly collectedAt: FieldRef<"Parcel", 'DateTime'>
    readonly societyId: FieldRef<"Parcel", 'Int'>
    readonly createdAt: FieldRef<"Parcel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Parcel findUnique
   */
  export type ParcelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * Filter, which Parcel to fetch.
     */
    where: ParcelWhereUniqueInput
  }

  /**
   * Parcel findUniqueOrThrow
   */
  export type ParcelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * Filter, which Parcel to fetch.
     */
    where: ParcelWhereUniqueInput
  }

  /**
   * Parcel findFirst
   */
  export type ParcelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * Filter, which Parcel to fetch.
     */
    where?: ParcelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parcels to fetch.
     */
    orderBy?: ParcelOrderByWithRelationInput | ParcelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parcels.
     */
    cursor?: ParcelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parcels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parcels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parcels.
     */
    distinct?: ParcelScalarFieldEnum | ParcelScalarFieldEnum[]
  }

  /**
   * Parcel findFirstOrThrow
   */
  export type ParcelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * Filter, which Parcel to fetch.
     */
    where?: ParcelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parcels to fetch.
     */
    orderBy?: ParcelOrderByWithRelationInput | ParcelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parcels.
     */
    cursor?: ParcelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parcels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parcels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parcels.
     */
    distinct?: ParcelScalarFieldEnum | ParcelScalarFieldEnum[]
  }

  /**
   * Parcel findMany
   */
  export type ParcelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * Filter, which Parcels to fetch.
     */
    where?: ParcelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parcels to fetch.
     */
    orderBy?: ParcelOrderByWithRelationInput | ParcelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parcels.
     */
    cursor?: ParcelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parcels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parcels.
     */
    skip?: number
    distinct?: ParcelScalarFieldEnum | ParcelScalarFieldEnum[]
  }

  /**
   * Parcel create
   */
  export type ParcelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * The data needed to create a Parcel.
     */
    data: XOR<ParcelCreateInput, ParcelUncheckedCreateInput>
  }

  /**
   * Parcel createMany
   */
  export type ParcelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parcels.
     */
    data: ParcelCreateManyInput | ParcelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parcel update
   */
  export type ParcelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * The data needed to update a Parcel.
     */
    data: XOR<ParcelUpdateInput, ParcelUncheckedUpdateInput>
    /**
     * Choose, which Parcel to update.
     */
    where: ParcelWhereUniqueInput
  }

  /**
   * Parcel updateMany
   */
  export type ParcelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parcels.
     */
    data: XOR<ParcelUpdateManyMutationInput, ParcelUncheckedUpdateManyInput>
    /**
     * Filter which Parcels to update
     */
    where?: ParcelWhereInput
    /**
     * Limit how many Parcels to update.
     */
    limit?: number
  }

  /**
   * Parcel upsert
   */
  export type ParcelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * The filter to search for the Parcel to update in case it exists.
     */
    where: ParcelWhereUniqueInput
    /**
     * In case the Parcel found by the `where` argument doesn't exist, create a new Parcel with this data.
     */
    create: XOR<ParcelCreateInput, ParcelUncheckedCreateInput>
    /**
     * In case the Parcel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParcelUpdateInput, ParcelUncheckedUpdateInput>
  }

  /**
   * Parcel delete
   */
  export type ParcelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
    /**
     * Filter which Parcel to delete.
     */
    where: ParcelWhereUniqueInput
  }

  /**
   * Parcel deleteMany
   */
  export type ParcelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parcels to delete
     */
    where?: ParcelWhereInput
    /**
     * Limit how many Parcels to delete.
     */
    limit?: number
  }

  /**
   * Parcel without action
   */
  export type ParcelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parcel
     */
    select?: ParcelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parcel
     */
    omit?: ParcelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParcelInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type EventSumAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type EventMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    date: Date | null
    time: string | null
    location: string | null
    category: string | null
    status: string | null
    societyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    date: Date | null
    time: string | null
    location: string | null
    category: string | null
    status: string | null
    societyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    date: number
    time: number
    location: number
    category: number
    status: number
    societyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type EventSumAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    location?: true
    category?: true
    status?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    location?: true
    category?: true
    status?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    location?: true
    category?: true
    status?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: number
    title: string
    description: string | null
    date: Date
    time: string | null
    location: string | null
    category: string | null
    status: string
    societyId: number
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    category?: boolean
    status?: boolean
    societyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>



  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    category?: boolean
    status?: boolean
    societyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "date" | "time" | "location" | "category" | "status" | "societyId" | "createdAt" | "updatedAt", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      date: Date
      time: string | null
      location: string | null
      category: string | null
      status: string
      societyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'Int'>
    readonly title: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly date: FieldRef<"Event", 'DateTime'>
    readonly time: FieldRef<"Event", 'String'>
    readonly location: FieldRef<"Event", 'String'>
    readonly category: FieldRef<"Event", 'String'>
    readonly status: FieldRef<"Event", 'String'>
    readonly societyId: FieldRef<"Event", 'Int'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseRequest
   */

  export type AggregatePurchaseRequest = {
    _count: PurchaseRequestCountAggregateOutputType | null
    _avg: PurchaseRequestAvgAggregateOutputType | null
    _sum: PurchaseRequestSumAggregateOutputType | null
    _min: PurchaseRequestMinAggregateOutputType | null
    _max: PurchaseRequestMaxAggregateOutputType | null
  }

  export type PurchaseRequestAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    societyId: number | null
    requestedById: number | null
  }

  export type PurchaseRequestSumAggregateOutputType = {
    id: number | null
    amount: number | null
    societyId: number | null
    requestedById: number | null
  }

  export type PurchaseRequestMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    societyId: number | null
    requestedById: number | null
  }

  export type PurchaseRequestMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    societyId: number | null
    requestedById: number | null
  }

  export type PurchaseRequestCountAggregateOutputType = {
    id: number
    title: number
    description: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    societyId: number
    requestedById: number
    _all: number
  }


  export type PurchaseRequestAvgAggregateInputType = {
    id?: true
    amount?: true
    societyId?: true
    requestedById?: true
  }

  export type PurchaseRequestSumAggregateInputType = {
    id?: true
    amount?: true
    societyId?: true
    requestedById?: true
  }

  export type PurchaseRequestMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    societyId?: true
    requestedById?: true
  }

  export type PurchaseRequestMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    societyId?: true
    requestedById?: true
  }

  export type PurchaseRequestCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    societyId?: true
    requestedById?: true
    _all?: true
  }

  export type PurchaseRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseRequest to aggregate.
     */
    where?: PurchaseRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseRequests to fetch.
     */
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseRequests
    **/
    _count?: true | PurchaseRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseRequestMaxAggregateInputType
  }

  export type GetPurchaseRequestAggregateType<T extends PurchaseRequestAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseRequest[P]>
      : GetScalarType<T[P], AggregatePurchaseRequest[P]>
  }




  export type PurchaseRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseRequestWhereInput
    orderBy?: PurchaseRequestOrderByWithAggregationInput | PurchaseRequestOrderByWithAggregationInput[]
    by: PurchaseRequestScalarFieldEnum[] | PurchaseRequestScalarFieldEnum
    having?: PurchaseRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseRequestCountAggregateInputType | true
    _avg?: PurchaseRequestAvgAggregateInputType
    _sum?: PurchaseRequestSumAggregateInputType
    _min?: PurchaseRequestMinAggregateInputType
    _max?: PurchaseRequestMaxAggregateInputType
  }

  export type PurchaseRequestGroupByOutputType = {
    id: number
    title: string
    description: string | null
    amount: number
    status: string
    createdAt: Date
    updatedAt: Date
    societyId: number
    requestedById: number
    _count: PurchaseRequestCountAggregateOutputType | null
    _avg: PurchaseRequestAvgAggregateOutputType | null
    _sum: PurchaseRequestSumAggregateOutputType | null
    _min: PurchaseRequestMinAggregateOutputType | null
    _max: PurchaseRequestMaxAggregateOutputType | null
  }

  type GetPurchaseRequestGroupByPayload<T extends PurchaseRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseRequestGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseRequestGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    societyId?: boolean
    requestedById?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseRequest"]>



  export type PurchaseRequestSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    societyId?: boolean
    requestedById?: boolean
  }

  export type PurchaseRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "amount" | "status" | "createdAt" | "updatedAt" | "societyId" | "requestedById", ExtArgs["result"]["purchaseRequest"]>
  export type PurchaseRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PurchaseRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseRequest"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      requestedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      amount: number
      status: string
      createdAt: Date
      updatedAt: Date
      societyId: number
      requestedById: number
    }, ExtArgs["result"]["purchaseRequest"]>
    composites: {}
  }

  type PurchaseRequestGetPayload<S extends boolean | null | undefined | PurchaseRequestDefaultArgs> = $Result.GetResult<Prisma.$PurchaseRequestPayload, S>

  type PurchaseRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseRequestCountAggregateInputType | true
    }

  export interface PurchaseRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseRequest'], meta: { name: 'PurchaseRequest' } }
    /**
     * Find zero or one PurchaseRequest that matches the filter.
     * @param {PurchaseRequestFindUniqueArgs} args - Arguments to find a PurchaseRequest
     * @example
     * // Get one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseRequestFindUniqueArgs>(args: SelectSubset<T, PurchaseRequestFindUniqueArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseRequestFindUniqueOrThrowArgs} args - Arguments to find a PurchaseRequest
     * @example
     * // Get one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestFindFirstArgs} args - Arguments to find a PurchaseRequest
     * @example
     * // Get one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseRequestFindFirstArgs>(args?: SelectSubset<T, PurchaseRequestFindFirstArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestFindFirstOrThrowArgs} args - Arguments to find a PurchaseRequest
     * @example
     * // Get one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseRequests
     * const purchaseRequests = await prisma.purchaseRequest.findMany()
     * 
     * // Get first 10 PurchaseRequests
     * const purchaseRequests = await prisma.purchaseRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseRequestWithIdOnly = await prisma.purchaseRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseRequestFindManyArgs>(args?: SelectSubset<T, PurchaseRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseRequest.
     * @param {PurchaseRequestCreateArgs} args - Arguments to create a PurchaseRequest.
     * @example
     * // Create one PurchaseRequest
     * const PurchaseRequest = await prisma.purchaseRequest.create({
     *   data: {
     *     // ... data to create a PurchaseRequest
     *   }
     * })
     * 
     */
    create<T extends PurchaseRequestCreateArgs>(args: SelectSubset<T, PurchaseRequestCreateArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseRequests.
     * @param {PurchaseRequestCreateManyArgs} args - Arguments to create many PurchaseRequests.
     * @example
     * // Create many PurchaseRequests
     * const purchaseRequest = await prisma.purchaseRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseRequestCreateManyArgs>(args?: SelectSubset<T, PurchaseRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PurchaseRequest.
     * @param {PurchaseRequestDeleteArgs} args - Arguments to delete one PurchaseRequest.
     * @example
     * // Delete one PurchaseRequest
     * const PurchaseRequest = await prisma.purchaseRequest.delete({
     *   where: {
     *     // ... filter to delete one PurchaseRequest
     *   }
     * })
     * 
     */
    delete<T extends PurchaseRequestDeleteArgs>(args: SelectSubset<T, PurchaseRequestDeleteArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseRequest.
     * @param {PurchaseRequestUpdateArgs} args - Arguments to update one PurchaseRequest.
     * @example
     * // Update one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseRequestUpdateArgs>(args: SelectSubset<T, PurchaseRequestUpdateArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseRequests.
     * @param {PurchaseRequestDeleteManyArgs} args - Arguments to filter PurchaseRequests to delete.
     * @example
     * // Delete a few PurchaseRequests
     * const { count } = await prisma.purchaseRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseRequestDeleteManyArgs>(args?: SelectSubset<T, PurchaseRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseRequests
     * const purchaseRequest = await prisma.purchaseRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseRequestUpdateManyArgs>(args: SelectSubset<T, PurchaseRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseRequest.
     * @param {PurchaseRequestUpsertArgs} args - Arguments to update or create a PurchaseRequest.
     * @example
     * // Update or create a PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.upsert({
     *   create: {
     *     // ... data to create a PurchaseRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseRequest we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseRequestUpsertArgs>(args: SelectSubset<T, PurchaseRequestUpsertArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestCountArgs} args - Arguments to filter PurchaseRequests to count.
     * @example
     * // Count the number of PurchaseRequests
     * const count = await prisma.purchaseRequest.count({
     *   where: {
     *     // ... the filter for the PurchaseRequests we want to count
     *   }
     * })
    **/
    count<T extends PurchaseRequestCountArgs>(
      args?: Subset<T, PurchaseRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseRequestAggregateArgs>(args: Subset<T, PurchaseRequestAggregateArgs>): Prisma.PrismaPromise<GetPurchaseRequestAggregateType<T>>

    /**
     * Group by PurchaseRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseRequestGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseRequest model
   */
  readonly fields: PurchaseRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requestedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseRequest model
   */
  interface PurchaseRequestFieldRefs {
    readonly id: FieldRef<"PurchaseRequest", 'Int'>
    readonly title: FieldRef<"PurchaseRequest", 'String'>
    readonly description: FieldRef<"PurchaseRequest", 'String'>
    readonly amount: FieldRef<"PurchaseRequest", 'Float'>
    readonly status: FieldRef<"PurchaseRequest", 'String'>
    readonly createdAt: FieldRef<"PurchaseRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseRequest", 'DateTime'>
    readonly societyId: FieldRef<"PurchaseRequest", 'Int'>
    readonly requestedById: FieldRef<"PurchaseRequest", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseRequest findUnique
   */
  export type PurchaseRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseRequest to fetch.
     */
    where: PurchaseRequestWhereUniqueInput
  }

  /**
   * PurchaseRequest findUniqueOrThrow
   */
  export type PurchaseRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseRequest to fetch.
     */
    where: PurchaseRequestWhereUniqueInput
  }

  /**
   * PurchaseRequest findFirst
   */
  export type PurchaseRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseRequest to fetch.
     */
    where?: PurchaseRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseRequests to fetch.
     */
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseRequests.
     */
    cursor?: PurchaseRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseRequests.
     */
    distinct?: PurchaseRequestScalarFieldEnum | PurchaseRequestScalarFieldEnum[]
  }

  /**
   * PurchaseRequest findFirstOrThrow
   */
  export type PurchaseRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseRequest to fetch.
     */
    where?: PurchaseRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseRequests to fetch.
     */
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseRequests.
     */
    cursor?: PurchaseRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseRequests.
     */
    distinct?: PurchaseRequestScalarFieldEnum | PurchaseRequestScalarFieldEnum[]
  }

  /**
   * PurchaseRequest findMany
   */
  export type PurchaseRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseRequests to fetch.
     */
    where?: PurchaseRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseRequests to fetch.
     */
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseRequests.
     */
    cursor?: PurchaseRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseRequests.
     */
    skip?: number
    distinct?: PurchaseRequestScalarFieldEnum | PurchaseRequestScalarFieldEnum[]
  }

  /**
   * PurchaseRequest create
   */
  export type PurchaseRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseRequest.
     */
    data: XOR<PurchaseRequestCreateInput, PurchaseRequestUncheckedCreateInput>
  }

  /**
   * PurchaseRequest createMany
   */
  export type PurchaseRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseRequests.
     */
    data: PurchaseRequestCreateManyInput | PurchaseRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseRequest update
   */
  export type PurchaseRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseRequest.
     */
    data: XOR<PurchaseRequestUpdateInput, PurchaseRequestUncheckedUpdateInput>
    /**
     * Choose, which PurchaseRequest to update.
     */
    where: PurchaseRequestWhereUniqueInput
  }

  /**
   * PurchaseRequest updateMany
   */
  export type PurchaseRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseRequests.
     */
    data: XOR<PurchaseRequestUpdateManyMutationInput, PurchaseRequestUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseRequests to update
     */
    where?: PurchaseRequestWhereInput
    /**
     * Limit how many PurchaseRequests to update.
     */
    limit?: number
  }

  /**
   * PurchaseRequest upsert
   */
  export type PurchaseRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseRequest to update in case it exists.
     */
    where: PurchaseRequestWhereUniqueInput
    /**
     * In case the PurchaseRequest found by the `where` argument doesn't exist, create a new PurchaseRequest with this data.
     */
    create: XOR<PurchaseRequestCreateInput, PurchaseRequestUncheckedCreateInput>
    /**
     * In case the PurchaseRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseRequestUpdateInput, PurchaseRequestUncheckedUpdateInput>
  }

  /**
   * PurchaseRequest delete
   */
  export type PurchaseRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter which PurchaseRequest to delete.
     */
    where: PurchaseRequestWhereUniqueInput
  }

  /**
   * PurchaseRequest deleteMany
   */
  export type PurchaseRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseRequests to delete
     */
    where?: PurchaseRequestWhereInput
    /**
     * Limit how many PurchaseRequests to delete.
     */
    limit?: number
  }

  /**
   * PurchaseRequest without action
   */
  export type PurchaseRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
    participantId: number | null
  }

  export type ConversationSumAggregateOutputType = {
    id: number | null
    societyId: number | null
    participantId: number | null
  }

  export type ConversationMinAggregateOutputType = {
    id: number | null
    societyId: number | null
    type: string | null
    participantId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: number | null
    societyId: number | null
    type: string | null
    participantId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    societyId: number
    type: number
    participantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationAvgAggregateInputType = {
    id?: true
    societyId?: true
    participantId?: true
  }

  export type ConversationSumAggregateInputType = {
    id?: true
    societyId?: true
    participantId?: true
  }

  export type ConversationMinAggregateInputType = {
    id?: true
    societyId?: true
    type?: true
    participantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    societyId?: true
    type?: true
    participantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    societyId?: true
    type?: true
    participantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _avg?: ConversationAvgAggregateInputType
    _sum?: ConversationSumAggregateInputType
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: number
    societyId: number
    type: string
    participantId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    societyId?: boolean
    type?: boolean
    participantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    participant?: boolean | Conversation$participantArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>



  export type ConversationSelectScalar = {
    id?: boolean
    societyId?: boolean
    type?: boolean
    participantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "societyId" | "type" | "participantId" | "createdAt" | "updatedAt", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    participant?: boolean | Conversation$participantArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      participant: Prisma.$UserPayload<ExtArgs> | null
      messages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      societyId: number
      type: string
      participantId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participant<T extends Conversation$participantArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$participantArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'Int'>
    readonly societyId: FieldRef<"Conversation", 'Int'>
    readonly type: FieldRef<"Conversation", 'String'>
    readonly participantId: FieldRef<"Conversation", 'Int'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.participant
   */
  export type Conversation$participantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageAvgAggregateOutputType = {
    id: number | null
    conversationId: number | null
    senderId: number | null
  }

  export type ChatMessageSumAggregateOutputType = {
    id: number | null
    conversationId: number | null
    senderId: number | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: number | null
    conversationId: number | null
    senderId: number | null
    content: string | null
    status: string | null
    createdAt: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: number | null
    conversationId: number | null
    senderId: number | null
    content: string | null
    status: string | null
    createdAt: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    conversationId: number
    senderId: number
    content: number
    attachments: number
    status: number
    createdAt: number
    _all: number
  }


  export type ChatMessageAvgAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
  }

  export type ChatMessageSumAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
  }

  export type ChatMessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    status?: true
    createdAt?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    status?: true
    createdAt?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    attachments?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _avg?: ChatMessageAvgAggregateInputType
    _sum?: ChatMessageSumAggregateInputType
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: number
    conversationId: number
    senderId: number
    content: string
    attachments: JsonValue | null
    status: string
    createdAt: Date
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    attachments?: boolean
    status?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>



  export type ChatMessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    attachments?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "senderId" | "content" | "attachments" | "status" | "createdAt", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      conversationId: number
      senderId: number
      content: string
      attachments: Prisma.JsonValue | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'Int'>
    readonly conversationId: FieldRef<"ChatMessage", 'Int'>
    readonly senderId: FieldRef<"ChatMessage", 'Int'>
    readonly content: FieldRef<"ChatMessage", 'String'>
    readonly attachments: FieldRef<"ChatMessage", 'Json'>
    readonly status: FieldRef<"ChatMessage", 'String'>
    readonly createdAt: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model ServiceCategory
   */

  export type AggregateServiceCategory = {
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  export type ServiceCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
    createdAt: Date | null
  }

  export type ServiceCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
    createdAt: Date | null
  }

  export type ServiceCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    icon: number
    color: number
    createdAt: number
    _all: number
  }


  export type ServiceCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    createdAt?: true
  }

  export type ServiceCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    createdAt?: true
  }

  export type ServiceCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategory to aggregate.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceCategories
    **/
    _count?: true | ServiceCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type GetServiceCategoryAggregateType<T extends ServiceCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCategory[P]>
      : GetScalarType<T[P], AggregateServiceCategory[P]>
  }




  export type ServiceCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCategoryWhereInput
    orderBy?: ServiceCategoryOrderByWithAggregationInput | ServiceCategoryOrderByWithAggregationInput[]
    by: ServiceCategoryScalarFieldEnum[] | ServiceCategoryScalarFieldEnum
    having?: ServiceCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCategoryCountAggregateInputType | true
    _min?: ServiceCategoryMinAggregateInputType
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type ServiceCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    icon: string
    color: string
    createdAt: Date
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  type GetServiceCategoryGroupByPayload<T extends ServiceCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ServiceCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    createdAt?: boolean
    variants?: boolean | ServiceCategory$variantsArgs<ExtArgs>
    inquiries?: boolean | ServiceCategory$inquiriesArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCategory"]>



  export type ServiceCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    createdAt?: boolean
  }

  export type ServiceCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "icon" | "color" | "createdAt", ExtArgs["result"]["serviceCategory"]>
  export type ServiceCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | ServiceCategory$variantsArgs<ExtArgs>
    inquiries?: boolean | ServiceCategory$inquiriesArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServiceCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceCategory"
    objects: {
      variants: Prisma.$ServiceVariantPayload<ExtArgs>[]
      inquiries: Prisma.$ServiceInquiryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      icon: string
      color: string
      createdAt: Date
    }, ExtArgs["result"]["serviceCategory"]>
    composites: {}
  }

  type ServiceCategoryGetPayload<S extends boolean | null | undefined | ServiceCategoryDefaultArgs> = $Result.GetResult<Prisma.$ServiceCategoryPayload, S>

  type ServiceCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCategoryCountAggregateInputType | true
    }

  export interface ServiceCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceCategory'], meta: { name: 'ServiceCategory' } }
    /**
     * Find zero or one ServiceCategory that matches the filter.
     * @param {ServiceCategoryFindUniqueArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceCategoryFindUniqueArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceCategoryFindUniqueOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceCategoryFindFirstArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany()
     * 
     * // Get first 10 ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceCategoryFindManyArgs>(args?: SelectSubset<T, ServiceCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceCategory.
     * @param {ServiceCategoryCreateArgs} args - Arguments to create a ServiceCategory.
     * @example
     * // Create one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.create({
     *   data: {
     *     // ... data to create a ServiceCategory
     *   }
     * })
     * 
     */
    create<T extends ServiceCategoryCreateArgs>(args: SelectSubset<T, ServiceCategoryCreateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceCategories.
     * @param {ServiceCategoryCreateManyArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCategoryCreateManyArgs>(args?: SelectSubset<T, ServiceCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceCategory.
     * @param {ServiceCategoryDeleteArgs} args - Arguments to delete one ServiceCategory.
     * @example
     * // Delete one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.delete({
     *   where: {
     *     // ... filter to delete one ServiceCategory
     *   }
     * })
     * 
     */
    delete<T extends ServiceCategoryDeleteArgs>(args: SelectSubset<T, ServiceCategoryDeleteArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceCategory.
     * @param {ServiceCategoryUpdateArgs} args - Arguments to update one ServiceCategory.
     * @example
     * // Update one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceCategoryUpdateArgs>(args: SelectSubset<T, ServiceCategoryUpdateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceCategories.
     * @param {ServiceCategoryDeleteManyArgs} args - Arguments to filter ServiceCategories to delete.
     * @example
     * // Delete a few ServiceCategories
     * const { count } = await prisma.serviceCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceCategoryDeleteManyArgs>(args?: SelectSubset<T, ServiceCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceCategoryUpdateManyArgs>(args: SelectSubset<T, ServiceCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceCategory.
     * @param {ServiceCategoryUpsertArgs} args - Arguments to update or create a ServiceCategory.
     * @example
     * // Update or create a ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.upsert({
     *   create: {
     *     // ... data to create a ServiceCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCategory we want to update
     *   }
     * })
     */
    upsert<T extends ServiceCategoryUpsertArgs>(args: SelectSubset<T, ServiceCategoryUpsertArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryCountArgs} args - Arguments to filter ServiceCategories to count.
     * @example
     * // Count the number of ServiceCategories
     * const count = await prisma.serviceCategory.count({
     *   where: {
     *     // ... the filter for the ServiceCategories we want to count
     *   }
     * })
    **/
    count<T extends ServiceCategoryCountArgs>(
      args?: Subset<T, ServiceCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCategoryAggregateArgs>(args: Subset<T, ServiceCategoryAggregateArgs>): Prisma.PrismaPromise<GetServiceCategoryAggregateType<T>>

    /**
     * Group by ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ServiceCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceCategory model
   */
  readonly fields: ServiceCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variants<T extends ServiceCategory$variantsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategory$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inquiries<T extends ServiceCategory$inquiriesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategory$inquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceCategory model
   */
  interface ServiceCategoryFieldRefs {
    readonly id: FieldRef<"ServiceCategory", 'String'>
    readonly name: FieldRef<"ServiceCategory", 'String'>
    readonly description: FieldRef<"ServiceCategory", 'String'>
    readonly icon: FieldRef<"ServiceCategory", 'String'>
    readonly color: FieldRef<"ServiceCategory", 'String'>
    readonly createdAt: FieldRef<"ServiceCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceCategory findUnique
   */
  export type ServiceCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findUniqueOrThrow
   */
  export type ServiceCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findFirst
   */
  export type ServiceCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findFirstOrThrow
   */
  export type ServiceCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findMany
   */
  export type ServiceCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategories to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory create
   */
  export type ServiceCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceCategory.
     */
    data: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
  }

  /**
   * ServiceCategory createMany
   */
  export type ServiceCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceCategories.
     */
    data: ServiceCategoryCreateManyInput | ServiceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCategory update
   */
  export type ServiceCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceCategory.
     */
    data: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
    /**
     * Choose, which ServiceCategory to update.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory updateMany
   */
  export type ServiceCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceCategories.
     */
    data: XOR<ServiceCategoryUpdateManyMutationInput, ServiceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategories to update
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to update.
     */
    limit?: number
  }

  /**
   * ServiceCategory upsert
   */
  export type ServiceCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceCategory to update in case it exists.
     */
    where: ServiceCategoryWhereUniqueInput
    /**
     * In case the ServiceCategory found by the `where` argument doesn't exist, create a new ServiceCategory with this data.
     */
    create: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
    /**
     * In case the ServiceCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
  }

  /**
   * ServiceCategory delete
   */
  export type ServiceCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter which ServiceCategory to delete.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory deleteMany
   */
  export type ServiceCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategories to delete
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to delete.
     */
    limit?: number
  }

  /**
   * ServiceCategory.variants
   */
  export type ServiceCategory$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    where?: ServiceVariantWhereInput
    orderBy?: ServiceVariantOrderByWithRelationInput | ServiceVariantOrderByWithRelationInput[]
    cursor?: ServiceVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceVariantScalarFieldEnum | ServiceVariantScalarFieldEnum[]
  }

  /**
   * ServiceCategory.inquiries
   */
  export type ServiceCategory$inquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInquiryInclude<ExtArgs> | null
    where?: ServiceInquiryWhereInput
    orderBy?: ServiceInquiryOrderByWithRelationInput | ServiceInquiryOrderByWithRelationInput[]
    cursor?: ServiceInquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceInquiryScalarFieldEnum | ServiceInquiryScalarFieldEnum[]
  }

  /**
   * ServiceCategory without action
   */
  export type ServiceCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ServiceVariant
   */

  export type AggregateServiceVariant = {
    _count: ServiceVariantCountAggregateOutputType | null
    _avg: ServiceVariantAvgAggregateOutputType | null
    _sum: ServiceVariantSumAggregateOutputType | null
    _min: ServiceVariantMinAggregateOutputType | null
    _max: ServiceVariantMaxAggregateOutputType | null
  }

  export type ServiceVariantAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ServiceVariantSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ServiceVariantMinAggregateOutputType = {
    id: number | null
    categoryId: string | null
    name: string | null
    price: number | null
    createdAt: Date | null
  }

  export type ServiceVariantMaxAggregateOutputType = {
    id: number | null
    categoryId: string | null
    name: string | null
    price: number | null
    createdAt: Date | null
  }

  export type ServiceVariantCountAggregateOutputType = {
    id: number
    categoryId: number
    name: number
    price: number
    createdAt: number
    _all: number
  }


  export type ServiceVariantAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type ServiceVariantSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type ServiceVariantMinAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    price?: true
    createdAt?: true
  }

  export type ServiceVariantMaxAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    price?: true
    createdAt?: true
  }

  export type ServiceVariantCountAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    price?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceVariant to aggregate.
     */
    where?: ServiceVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceVariants to fetch.
     */
    orderBy?: ServiceVariantOrderByWithRelationInput | ServiceVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceVariants
    **/
    _count?: true | ServiceVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceVariantMaxAggregateInputType
  }

  export type GetServiceVariantAggregateType<T extends ServiceVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceVariant[P]>
      : GetScalarType<T[P], AggregateServiceVariant[P]>
  }




  export type ServiceVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceVariantWhereInput
    orderBy?: ServiceVariantOrderByWithAggregationInput | ServiceVariantOrderByWithAggregationInput[]
    by: ServiceVariantScalarFieldEnum[] | ServiceVariantScalarFieldEnum
    having?: ServiceVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceVariantCountAggregateInputType | true
    _avg?: ServiceVariantAvgAggregateInputType
    _sum?: ServiceVariantSumAggregateInputType
    _min?: ServiceVariantMinAggregateInputType
    _max?: ServiceVariantMaxAggregateInputType
  }

  export type ServiceVariantGroupByOutputType = {
    id: number
    categoryId: string
    name: string
    price: number | null
    createdAt: Date
    _count: ServiceVariantCountAggregateOutputType | null
    _avg: ServiceVariantAvgAggregateOutputType | null
    _sum: ServiceVariantSumAggregateOutputType | null
    _min: ServiceVariantMinAggregateOutputType | null
    _max: ServiceVariantMaxAggregateOutputType | null
  }

  type GetServiceVariantGroupByPayload<T extends ServiceVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceVariantGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceVariantGroupByOutputType[P]>
        }
      >
    >


  export type ServiceVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    price?: boolean
    createdAt?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceVariant"]>



  export type ServiceVariantSelectScalar = {
    id?: boolean
    categoryId?: boolean
    name?: boolean
    price?: boolean
    createdAt?: boolean
  }

  export type ServiceVariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "categoryId" | "name" | "price" | "createdAt", ExtArgs["result"]["serviceVariant"]>
  export type ServiceVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }

  export type $ServiceVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceVariant"
    objects: {
      category: Prisma.$ServiceCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      categoryId: string
      name: string
      price: number | null
      createdAt: Date
    }, ExtArgs["result"]["serviceVariant"]>
    composites: {}
  }

  type ServiceVariantGetPayload<S extends boolean | null | undefined | ServiceVariantDefaultArgs> = $Result.GetResult<Prisma.$ServiceVariantPayload, S>

  type ServiceVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceVariantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceVariantCountAggregateInputType | true
    }

  export interface ServiceVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceVariant'], meta: { name: 'ServiceVariant' } }
    /**
     * Find zero or one ServiceVariant that matches the filter.
     * @param {ServiceVariantFindUniqueArgs} args - Arguments to find a ServiceVariant
     * @example
     * // Get one ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceVariantFindUniqueArgs>(args: SelectSubset<T, ServiceVariantFindUniqueArgs<ExtArgs>>): Prisma__ServiceVariantClient<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceVariantFindUniqueOrThrowArgs} args - Arguments to find a ServiceVariant
     * @example
     * // Get one ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceVariantClient<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantFindFirstArgs} args - Arguments to find a ServiceVariant
     * @example
     * // Get one ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceVariantFindFirstArgs>(args?: SelectSubset<T, ServiceVariantFindFirstArgs<ExtArgs>>): Prisma__ServiceVariantClient<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantFindFirstOrThrowArgs} args - Arguments to find a ServiceVariant
     * @example
     * // Get one ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceVariantClient<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceVariants
     * const serviceVariants = await prisma.serviceVariant.findMany()
     * 
     * // Get first 10 ServiceVariants
     * const serviceVariants = await prisma.serviceVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceVariantWithIdOnly = await prisma.serviceVariant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceVariantFindManyArgs>(args?: SelectSubset<T, ServiceVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceVariant.
     * @param {ServiceVariantCreateArgs} args - Arguments to create a ServiceVariant.
     * @example
     * // Create one ServiceVariant
     * const ServiceVariant = await prisma.serviceVariant.create({
     *   data: {
     *     // ... data to create a ServiceVariant
     *   }
     * })
     * 
     */
    create<T extends ServiceVariantCreateArgs>(args: SelectSubset<T, ServiceVariantCreateArgs<ExtArgs>>): Prisma__ServiceVariantClient<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceVariants.
     * @param {ServiceVariantCreateManyArgs} args - Arguments to create many ServiceVariants.
     * @example
     * // Create many ServiceVariants
     * const serviceVariant = await prisma.serviceVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceVariantCreateManyArgs>(args?: SelectSubset<T, ServiceVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceVariant.
     * @param {ServiceVariantDeleteArgs} args - Arguments to delete one ServiceVariant.
     * @example
     * // Delete one ServiceVariant
     * const ServiceVariant = await prisma.serviceVariant.delete({
     *   where: {
     *     // ... filter to delete one ServiceVariant
     *   }
     * })
     * 
     */
    delete<T extends ServiceVariantDeleteArgs>(args: SelectSubset<T, ServiceVariantDeleteArgs<ExtArgs>>): Prisma__ServiceVariantClient<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceVariant.
     * @param {ServiceVariantUpdateArgs} args - Arguments to update one ServiceVariant.
     * @example
     * // Update one ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceVariantUpdateArgs>(args: SelectSubset<T, ServiceVariantUpdateArgs<ExtArgs>>): Prisma__ServiceVariantClient<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceVariants.
     * @param {ServiceVariantDeleteManyArgs} args - Arguments to filter ServiceVariants to delete.
     * @example
     * // Delete a few ServiceVariants
     * const { count } = await prisma.serviceVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceVariantDeleteManyArgs>(args?: SelectSubset<T, ServiceVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceVariants
     * const serviceVariant = await prisma.serviceVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceVariantUpdateManyArgs>(args: SelectSubset<T, ServiceVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceVariant.
     * @param {ServiceVariantUpsertArgs} args - Arguments to update or create a ServiceVariant.
     * @example
     * // Update or create a ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.upsert({
     *   create: {
     *     // ... data to create a ServiceVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceVariant we want to update
     *   }
     * })
     */
    upsert<T extends ServiceVariantUpsertArgs>(args: SelectSubset<T, ServiceVariantUpsertArgs<ExtArgs>>): Prisma__ServiceVariantClient<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantCountArgs} args - Arguments to filter ServiceVariants to count.
     * @example
     * // Count the number of ServiceVariants
     * const count = await prisma.serviceVariant.count({
     *   where: {
     *     // ... the filter for the ServiceVariants we want to count
     *   }
     * })
    **/
    count<T extends ServiceVariantCountArgs>(
      args?: Subset<T, ServiceVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceVariantAggregateArgs>(args: Subset<T, ServiceVariantAggregateArgs>): Prisma.PrismaPromise<GetServiceVariantAggregateType<T>>

    /**
     * Group by ServiceVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceVariantGroupByArgs['orderBy'] }
        : { orderBy?: ServiceVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceVariant model
   */
  readonly fields: ServiceVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends ServiceCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategoryDefaultArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceVariant model
   */
  interface ServiceVariantFieldRefs {
    readonly id: FieldRef<"ServiceVariant", 'Int'>
    readonly categoryId: FieldRef<"ServiceVariant", 'String'>
    readonly name: FieldRef<"ServiceVariant", 'String'>
    readonly price: FieldRef<"ServiceVariant", 'Float'>
    readonly createdAt: FieldRef<"ServiceVariant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceVariant findUnique
   */
  export type ServiceVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * Filter, which ServiceVariant to fetch.
     */
    where: ServiceVariantWhereUniqueInput
  }

  /**
   * ServiceVariant findUniqueOrThrow
   */
  export type ServiceVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * Filter, which ServiceVariant to fetch.
     */
    where: ServiceVariantWhereUniqueInput
  }

  /**
   * ServiceVariant findFirst
   */
  export type ServiceVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * Filter, which ServiceVariant to fetch.
     */
    where?: ServiceVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceVariants to fetch.
     */
    orderBy?: ServiceVariantOrderByWithRelationInput | ServiceVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceVariants.
     */
    cursor?: ServiceVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceVariants.
     */
    distinct?: ServiceVariantScalarFieldEnum | ServiceVariantScalarFieldEnum[]
  }

  /**
   * ServiceVariant findFirstOrThrow
   */
  export type ServiceVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * Filter, which ServiceVariant to fetch.
     */
    where?: ServiceVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceVariants to fetch.
     */
    orderBy?: ServiceVariantOrderByWithRelationInput | ServiceVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceVariants.
     */
    cursor?: ServiceVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceVariants.
     */
    distinct?: ServiceVariantScalarFieldEnum | ServiceVariantScalarFieldEnum[]
  }

  /**
   * ServiceVariant findMany
   */
  export type ServiceVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * Filter, which ServiceVariants to fetch.
     */
    where?: ServiceVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceVariants to fetch.
     */
    orderBy?: ServiceVariantOrderByWithRelationInput | ServiceVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceVariants.
     */
    cursor?: ServiceVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceVariants.
     */
    skip?: number
    distinct?: ServiceVariantScalarFieldEnum | ServiceVariantScalarFieldEnum[]
  }

  /**
   * ServiceVariant create
   */
  export type ServiceVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceVariant.
     */
    data: XOR<ServiceVariantCreateInput, ServiceVariantUncheckedCreateInput>
  }

  /**
   * ServiceVariant createMany
   */
  export type ServiceVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceVariants.
     */
    data: ServiceVariantCreateManyInput | ServiceVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceVariant update
   */
  export type ServiceVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceVariant.
     */
    data: XOR<ServiceVariantUpdateInput, ServiceVariantUncheckedUpdateInput>
    /**
     * Choose, which ServiceVariant to update.
     */
    where: ServiceVariantWhereUniqueInput
  }

  /**
   * ServiceVariant updateMany
   */
  export type ServiceVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceVariants.
     */
    data: XOR<ServiceVariantUpdateManyMutationInput, ServiceVariantUncheckedUpdateManyInput>
    /**
     * Filter which ServiceVariants to update
     */
    where?: ServiceVariantWhereInput
    /**
     * Limit how many ServiceVariants to update.
     */
    limit?: number
  }

  /**
   * ServiceVariant upsert
   */
  export type ServiceVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceVariant to update in case it exists.
     */
    where: ServiceVariantWhereUniqueInput
    /**
     * In case the ServiceVariant found by the `where` argument doesn't exist, create a new ServiceVariant with this data.
     */
    create: XOR<ServiceVariantCreateInput, ServiceVariantUncheckedCreateInput>
    /**
     * In case the ServiceVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceVariantUpdateInput, ServiceVariantUncheckedUpdateInput>
  }

  /**
   * ServiceVariant delete
   */
  export type ServiceVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * Filter which ServiceVariant to delete.
     */
    where: ServiceVariantWhereUniqueInput
  }

  /**
   * ServiceVariant deleteMany
   */
  export type ServiceVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceVariants to delete
     */
    where?: ServiceVariantWhereInput
    /**
     * Limit how many ServiceVariants to delete.
     */
    limit?: number
  }

  /**
   * ServiceVariant without action
   */
  export type ServiceVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
  }


  /**
   * Model ServiceInquiry
   */

  export type AggregateServiceInquiry = {
    _count: ServiceInquiryCountAggregateOutputType | null
    _avg: ServiceInquiryAvgAggregateOutputType | null
    _sum: ServiceInquirySumAggregateOutputType | null
    _min: ServiceInquiryMinAggregateOutputType | null
    _max: ServiceInquiryMaxAggregateOutputType | null
  }

  export type ServiceInquiryAvgAggregateOutputType = {
    id: number | null
    residentId: number | null
    societyId: number | null
    vendorId: number | null
  }

  export type ServiceInquirySumAggregateOutputType = {
    id: number | null
    residentId: number | null
    societyId: number | null
    vendorId: number | null
  }

  export type ServiceInquiryMinAggregateOutputType = {
    id: number | null
    residentId: number | null
    societyId: number | null
    serviceId: string | null
    serviceName: string | null
    type: string | null
    status: string | null
    preferredDate: string | null
    preferredTime: string | null
    phone: string | null
    notes: string | null
    vendorName: string | null
    vendorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceInquiryMaxAggregateOutputType = {
    id: number | null
    residentId: number | null
    societyId: number | null
    serviceId: string | null
    serviceName: string | null
    type: string | null
    status: string | null
    preferredDate: string | null
    preferredTime: string | null
    phone: string | null
    notes: string | null
    vendorName: string | null
    vendorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceInquiryCountAggregateOutputType = {
    id: number
    residentId: number
    societyId: number
    serviceId: number
    serviceName: number
    type: number
    status: number
    preferredDate: number
    preferredTime: number
    phone: number
    notes: number
    vendorName: number
    vendorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceInquiryAvgAggregateInputType = {
    id?: true
    residentId?: true
    societyId?: true
    vendorId?: true
  }

  export type ServiceInquirySumAggregateInputType = {
    id?: true
    residentId?: true
    societyId?: true
    vendorId?: true
  }

  export type ServiceInquiryMinAggregateInputType = {
    id?: true
    residentId?: true
    societyId?: true
    serviceId?: true
    serviceName?: true
    type?: true
    status?: true
    preferredDate?: true
    preferredTime?: true
    phone?: true
    notes?: true
    vendorName?: true
    vendorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceInquiryMaxAggregateInputType = {
    id?: true
    residentId?: true
    societyId?: true
    serviceId?: true
    serviceName?: true
    type?: true
    status?: true
    preferredDate?: true
    preferredTime?: true
    phone?: true
    notes?: true
    vendorName?: true
    vendorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceInquiryCountAggregateInputType = {
    id?: true
    residentId?: true
    societyId?: true
    serviceId?: true
    serviceName?: true
    type?: true
    status?: true
    preferredDate?: true
    preferredTime?: true
    phone?: true
    notes?: true
    vendorName?: true
    vendorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceInquiryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceInquiry to aggregate.
     */
    where?: ServiceInquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInquiries to fetch.
     */
    orderBy?: ServiceInquiryOrderByWithRelationInput | ServiceInquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceInquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceInquiries
    **/
    _count?: true | ServiceInquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceInquiryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceInquirySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceInquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceInquiryMaxAggregateInputType
  }

  export type GetServiceInquiryAggregateType<T extends ServiceInquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceInquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceInquiry[P]>
      : GetScalarType<T[P], AggregateServiceInquiry[P]>
  }




  export type ServiceInquiryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceInquiryWhereInput
    orderBy?: ServiceInquiryOrderByWithAggregationInput | ServiceInquiryOrderByWithAggregationInput[]
    by: ServiceInquiryScalarFieldEnum[] | ServiceInquiryScalarFieldEnum
    having?: ServiceInquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceInquiryCountAggregateInputType | true
    _avg?: ServiceInquiryAvgAggregateInputType
    _sum?: ServiceInquirySumAggregateInputType
    _min?: ServiceInquiryMinAggregateInputType
    _max?: ServiceInquiryMaxAggregateInputType
  }

  export type ServiceInquiryGroupByOutputType = {
    id: number
    residentId: number | null
    societyId: number | null
    serviceId: string | null
    serviceName: string | null
    type: string
    status: string
    preferredDate: string | null
    preferredTime: string | null
    phone: string | null
    notes: string | null
    vendorName: string | null
    vendorId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceInquiryCountAggregateOutputType | null
    _avg: ServiceInquiryAvgAggregateOutputType | null
    _sum: ServiceInquirySumAggregateOutputType | null
    _min: ServiceInquiryMinAggregateOutputType | null
    _max: ServiceInquiryMaxAggregateOutputType | null
  }

  type GetServiceInquiryGroupByPayload<T extends ServiceInquiryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceInquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceInquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceInquiryGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceInquiryGroupByOutputType[P]>
        }
      >
    >


  export type ServiceInquirySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    residentId?: boolean
    societyId?: boolean
    serviceId?: boolean
    serviceName?: boolean
    type?: boolean
    status?: boolean
    preferredDate?: boolean
    preferredTime?: boolean
    phone?: boolean
    notes?: boolean
    vendorName?: boolean
    vendorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resident?: boolean | ServiceInquiry$residentArgs<ExtArgs>
    society?: boolean | ServiceInquiry$societyArgs<ExtArgs>
    service?: boolean | ServiceInquiry$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["serviceInquiry"]>



  export type ServiceInquirySelectScalar = {
    id?: boolean
    residentId?: boolean
    societyId?: boolean
    serviceId?: boolean
    serviceName?: boolean
    type?: boolean
    status?: boolean
    preferredDate?: boolean
    preferredTime?: boolean
    phone?: boolean
    notes?: boolean
    vendorName?: boolean
    vendorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceInquiryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "residentId" | "societyId" | "serviceId" | "serviceName" | "type" | "status" | "preferredDate" | "preferredTime" | "phone" | "notes" | "vendorName" | "vendorId" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceInquiry"]>
  export type ServiceInquiryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | ServiceInquiry$residentArgs<ExtArgs>
    society?: boolean | ServiceInquiry$societyArgs<ExtArgs>
    service?: boolean | ServiceInquiry$serviceArgs<ExtArgs>
  }

  export type $ServiceInquiryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceInquiry"
    objects: {
      resident: Prisma.$UserPayload<ExtArgs> | null
      society: Prisma.$SocietyPayload<ExtArgs> | null
      service: Prisma.$ServiceCategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      residentId: number | null
      societyId: number | null
      serviceId: string | null
      serviceName: string | null
      type: string
      status: string
      preferredDate: string | null
      preferredTime: string | null
      phone: string | null
      notes: string | null
      vendorName: string | null
      vendorId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceInquiry"]>
    composites: {}
  }

  type ServiceInquiryGetPayload<S extends boolean | null | undefined | ServiceInquiryDefaultArgs> = $Result.GetResult<Prisma.$ServiceInquiryPayload, S>

  type ServiceInquiryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceInquiryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceInquiryCountAggregateInputType | true
    }

  export interface ServiceInquiryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceInquiry'], meta: { name: 'ServiceInquiry' } }
    /**
     * Find zero or one ServiceInquiry that matches the filter.
     * @param {ServiceInquiryFindUniqueArgs} args - Arguments to find a ServiceInquiry
     * @example
     * // Get one ServiceInquiry
     * const serviceInquiry = await prisma.serviceInquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceInquiryFindUniqueArgs>(args: SelectSubset<T, ServiceInquiryFindUniqueArgs<ExtArgs>>): Prisma__ServiceInquiryClient<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceInquiry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceInquiryFindUniqueOrThrowArgs} args - Arguments to find a ServiceInquiry
     * @example
     * // Get one ServiceInquiry
     * const serviceInquiry = await prisma.serviceInquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceInquiryFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceInquiryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceInquiryClient<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceInquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInquiryFindFirstArgs} args - Arguments to find a ServiceInquiry
     * @example
     * // Get one ServiceInquiry
     * const serviceInquiry = await prisma.serviceInquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceInquiryFindFirstArgs>(args?: SelectSubset<T, ServiceInquiryFindFirstArgs<ExtArgs>>): Prisma__ServiceInquiryClient<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceInquiry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInquiryFindFirstOrThrowArgs} args - Arguments to find a ServiceInquiry
     * @example
     * // Get one ServiceInquiry
     * const serviceInquiry = await prisma.serviceInquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceInquiryFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceInquiryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceInquiryClient<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceInquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInquiryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceInquiries
     * const serviceInquiries = await prisma.serviceInquiry.findMany()
     * 
     * // Get first 10 ServiceInquiries
     * const serviceInquiries = await prisma.serviceInquiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceInquiryWithIdOnly = await prisma.serviceInquiry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceInquiryFindManyArgs>(args?: SelectSubset<T, ServiceInquiryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceInquiry.
     * @param {ServiceInquiryCreateArgs} args - Arguments to create a ServiceInquiry.
     * @example
     * // Create one ServiceInquiry
     * const ServiceInquiry = await prisma.serviceInquiry.create({
     *   data: {
     *     // ... data to create a ServiceInquiry
     *   }
     * })
     * 
     */
    create<T extends ServiceInquiryCreateArgs>(args: SelectSubset<T, ServiceInquiryCreateArgs<ExtArgs>>): Prisma__ServiceInquiryClient<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceInquiries.
     * @param {ServiceInquiryCreateManyArgs} args - Arguments to create many ServiceInquiries.
     * @example
     * // Create many ServiceInquiries
     * const serviceInquiry = await prisma.serviceInquiry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceInquiryCreateManyArgs>(args?: SelectSubset<T, ServiceInquiryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceInquiry.
     * @param {ServiceInquiryDeleteArgs} args - Arguments to delete one ServiceInquiry.
     * @example
     * // Delete one ServiceInquiry
     * const ServiceInquiry = await prisma.serviceInquiry.delete({
     *   where: {
     *     // ... filter to delete one ServiceInquiry
     *   }
     * })
     * 
     */
    delete<T extends ServiceInquiryDeleteArgs>(args: SelectSubset<T, ServiceInquiryDeleteArgs<ExtArgs>>): Prisma__ServiceInquiryClient<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceInquiry.
     * @param {ServiceInquiryUpdateArgs} args - Arguments to update one ServiceInquiry.
     * @example
     * // Update one ServiceInquiry
     * const serviceInquiry = await prisma.serviceInquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceInquiryUpdateArgs>(args: SelectSubset<T, ServiceInquiryUpdateArgs<ExtArgs>>): Prisma__ServiceInquiryClient<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceInquiries.
     * @param {ServiceInquiryDeleteManyArgs} args - Arguments to filter ServiceInquiries to delete.
     * @example
     * // Delete a few ServiceInquiries
     * const { count } = await prisma.serviceInquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceInquiryDeleteManyArgs>(args?: SelectSubset<T, ServiceInquiryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceInquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceInquiries
     * const serviceInquiry = await prisma.serviceInquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceInquiryUpdateManyArgs>(args: SelectSubset<T, ServiceInquiryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceInquiry.
     * @param {ServiceInquiryUpsertArgs} args - Arguments to update or create a ServiceInquiry.
     * @example
     * // Update or create a ServiceInquiry
     * const serviceInquiry = await prisma.serviceInquiry.upsert({
     *   create: {
     *     // ... data to create a ServiceInquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceInquiry we want to update
     *   }
     * })
     */
    upsert<T extends ServiceInquiryUpsertArgs>(args: SelectSubset<T, ServiceInquiryUpsertArgs<ExtArgs>>): Prisma__ServiceInquiryClient<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceInquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInquiryCountArgs} args - Arguments to filter ServiceInquiries to count.
     * @example
     * // Count the number of ServiceInquiries
     * const count = await prisma.serviceInquiry.count({
     *   where: {
     *     // ... the filter for the ServiceInquiries we want to count
     *   }
     * })
    **/
    count<T extends ServiceInquiryCountArgs>(
      args?: Subset<T, ServiceInquiryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceInquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceInquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceInquiryAggregateArgs>(args: Subset<T, ServiceInquiryAggregateArgs>): Prisma.PrismaPromise<GetServiceInquiryAggregateType<T>>

    /**
     * Group by ServiceInquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceInquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceInquiryGroupByArgs['orderBy'] }
        : { orderBy?: ServiceInquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceInquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceInquiryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceInquiry model
   */
  readonly fields: ServiceInquiryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceInquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceInquiryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resident<T extends ServiceInquiry$residentArgs<ExtArgs> = {}>(args?: Subset<T, ServiceInquiry$residentArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    society<T extends ServiceInquiry$societyArgs<ExtArgs> = {}>(args?: Subset<T, ServiceInquiry$societyArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceInquiry$serviceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceInquiry$serviceArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceInquiry model
   */
  interface ServiceInquiryFieldRefs {
    readonly id: FieldRef<"ServiceInquiry", 'Int'>
    readonly residentId: FieldRef<"ServiceInquiry", 'Int'>
    readonly societyId: FieldRef<"ServiceInquiry", 'Int'>
    readonly serviceId: FieldRef<"ServiceInquiry", 'String'>
    readonly serviceName: FieldRef<"ServiceInquiry", 'String'>
    readonly type: FieldRef<"ServiceInquiry", 'String'>
    readonly status: FieldRef<"ServiceInquiry", 'String'>
    readonly preferredDate: FieldRef<"ServiceInquiry", 'String'>
    readonly preferredTime: FieldRef<"ServiceInquiry", 'String'>
    readonly phone: FieldRef<"ServiceInquiry", 'String'>
    readonly notes: FieldRef<"ServiceInquiry", 'String'>
    readonly vendorName: FieldRef<"ServiceInquiry", 'String'>
    readonly vendorId: FieldRef<"ServiceInquiry", 'Int'>
    readonly createdAt: FieldRef<"ServiceInquiry", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceInquiry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceInquiry findUnique
   */
  export type ServiceInquiryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInquiryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInquiry to fetch.
     */
    where: ServiceInquiryWhereUniqueInput
  }

  /**
   * ServiceInquiry findUniqueOrThrow
   */
  export type ServiceInquiryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInquiryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInquiry to fetch.
     */
    where: ServiceInquiryWhereUniqueInput
  }

  /**
   * ServiceInquiry findFirst
   */
  export type ServiceInquiryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInquiryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInquiry to fetch.
     */
    where?: ServiceInquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInquiries to fetch.
     */
    orderBy?: ServiceInquiryOrderByWithRelationInput | ServiceInquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceInquiries.
     */
    cursor?: ServiceInquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceInquiries.
     */
    distinct?: ServiceInquiryScalarFieldEnum | ServiceInquiryScalarFieldEnum[]
  }

  /**
   * ServiceInquiry findFirstOrThrow
   */
  export type ServiceInquiryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInquiryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInquiry to fetch.
     */
    where?: ServiceInquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInquiries to fetch.
     */
    orderBy?: ServiceInquiryOrderByWithRelationInput | ServiceInquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceInquiries.
     */
    cursor?: ServiceInquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceInquiries.
     */
    distinct?: ServiceInquiryScalarFieldEnum | ServiceInquiryScalarFieldEnum[]
  }

  /**
   * ServiceInquiry findMany
   */
  export type ServiceInquiryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInquiryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInquiries to fetch.
     */
    where?: ServiceInquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInquiries to fetch.
     */
    orderBy?: ServiceInquiryOrderByWithRelationInput | ServiceInquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceInquiries.
     */
    cursor?: ServiceInquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInquiries.
     */
    skip?: number
    distinct?: ServiceInquiryScalarFieldEnum | ServiceInquiryScalarFieldEnum[]
  }

  /**
   * ServiceInquiry create
   */
  export type ServiceInquiryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInquiryInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceInquiry.
     */
    data: XOR<ServiceInquiryCreateInput, ServiceInquiryUncheckedCreateInput>
  }

  /**
   * ServiceInquiry createMany
   */
  export type ServiceInquiryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceInquiries.
     */
    data: ServiceInquiryCreateManyInput | ServiceInquiryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceInquiry update
   */
  export type ServiceInquiryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInquiryInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceInquiry.
     */
    data: XOR<ServiceInquiryUpdateInput, ServiceInquiryUncheckedUpdateInput>
    /**
     * Choose, which ServiceInquiry to update.
     */
    where: ServiceInquiryWhereUniqueInput
  }

  /**
   * ServiceInquiry updateMany
   */
  export type ServiceInquiryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceInquiries.
     */
    data: XOR<ServiceInquiryUpdateManyMutationInput, ServiceInquiryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceInquiries to update
     */
    where?: ServiceInquiryWhereInput
    /**
     * Limit how many ServiceInquiries to update.
     */
    limit?: number
  }

  /**
   * ServiceInquiry upsert
   */
  export type ServiceInquiryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInquiryInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceInquiry to update in case it exists.
     */
    where: ServiceInquiryWhereUniqueInput
    /**
     * In case the ServiceInquiry found by the `where` argument doesn't exist, create a new ServiceInquiry with this data.
     */
    create: XOR<ServiceInquiryCreateInput, ServiceInquiryUncheckedCreateInput>
    /**
     * In case the ServiceInquiry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceInquiryUpdateInput, ServiceInquiryUncheckedUpdateInput>
  }

  /**
   * ServiceInquiry delete
   */
  export type ServiceInquiryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInquiryInclude<ExtArgs> | null
    /**
     * Filter which ServiceInquiry to delete.
     */
    where: ServiceInquiryWhereUniqueInput
  }

  /**
   * ServiceInquiry deleteMany
   */
  export type ServiceInquiryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceInquiries to delete
     */
    where?: ServiceInquiryWhereInput
    /**
     * Limit how many ServiceInquiries to delete.
     */
    limit?: number
  }

  /**
   * ServiceInquiry.resident
   */
  export type ServiceInquiry$residentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ServiceInquiry.society
   */
  export type ServiceInquiry$societyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    where?: SocietyWhereInput
  }

  /**
   * ServiceInquiry.service
   */
  export type ServiceInquiry$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    where?: ServiceCategoryWhereInput
  }

  /**
   * ServiceInquiry without action
   */
  export type ServiceInquiryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInquiryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SocietyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    city: 'city',
    state: 'state',
    pincode: 'pincode',
    code: 'code',
    status: 'status',
    subscriptionPlan: 'subscriptionPlan',
    expectedUnits: 'expectedUnits',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocietyScalarFieldEnum = (typeof SocietyScalarFieldEnum)[keyof typeof SocietyScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    phone: 'phone',
    role: 'role',
    status: 'status',
    profileImg: 'profileImg',
    roleId: 'roleId',
    societyId: 'societyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleModelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleModelScalarFieldEnum = (typeof RoleModelScalarFieldEnum)[keyof typeof RoleModelScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    label: 'label',
    description: 'description'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    roleId: 'roleId',
    permissionId: 'permissionId'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    device: 'device',
    ipAddress: 'ipAddress',
    lastActive: 'lastActive',
    token: 'token',
    createdAt: 'createdAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    block: 'block',
    number: 'number',
    floor: 'floor',
    type: 'type',
    areaSqFt: 'areaSqFt',
    status: 'status',
    pets: 'pets',
    membersCount: 'membersCount',
    societyId: 'societyId',
    ownerId: 'ownerId',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const ParkingSlotScalarFieldEnum: {
    id: 'id',
    number: 'number',
    type: 'type',
    status: 'status',
    societyId: 'societyId',
    allocatedToUnitId: 'allocatedToUnitId',
    vehicleNumber: 'vehicleNumber',
    createdAt: 'createdAt'
  };

  export type ParkingSlotScalarFieldEnum = (typeof ParkingSlotScalarFieldEnum)[keyof typeof ParkingSlotScalarFieldEnum]


  export const ComplaintScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    priority: 'priority',
    status: 'status',
    isPrivate: 'isPrivate',
    escalatedToTech: 'escalatedToTech',
    images: 'images',
    societyId: 'societyId',
    reportedById: 'reportedById',
    assignedToId: 'assignedToId',
    timeline: 'timeline',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComplaintScalarFieldEnum = (typeof ComplaintScalarFieldEnum)[keyof typeof ComplaintScalarFieldEnum]


  export const ComplaintCommentScalarFieldEnum: {
    id: 'id',
    complaintId: 'complaintId',
    userId: 'userId',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type ComplaintCommentScalarFieldEnum = (typeof ComplaintCommentScalarFieldEnum)[keyof typeof ComplaintCommentScalarFieldEnum]


  export const VisitorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    vehicleNo: 'vehicleNo',
    purpose: 'purpose',
    photo: 'photo',
    status: 'status',
    entryTime: 'entryTime',
    exitTime: 'exitTime',
    societyId: 'societyId',
    visitingUnitId: 'visitingUnitId',
    idType: 'idType',
    idNumber: 'idNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VisitorScalarFieldEnum = (typeof VisitorScalarFieldEnum)[keyof typeof VisitorScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    category: 'category',
    amount: 'amount',
    date: 'date',
    description: 'description',
    paymentMethod: 'paymentMethod',
    status: 'status',
    societyId: 'societyId',
    invoiceNo: 'invoiceNo',
    paidTo: 'paidTo',
    receivedFrom: 'receivedFrom',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    serviceType: 'serviceType',
    contact: 'contact',
    email: 'email',
    address: 'address',
    status: 'status',
    societyId: 'societyId',
    createdAt: 'createdAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const VendorPayoutScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    vendorName: 'vendorName',
    societyId: 'societyId',
    societyName: 'societyName',
    dealValue: 'dealValue',
    commissionPercent: 'commissionPercent',
    payableAmount: 'payableAmount',
    status: 'status',
    remarks: 'remarks',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorPayoutScalarFieldEnum = (typeof VendorPayoutScalarFieldEnum)[keyof typeof VendorPayoutScalarFieldEnum]


  export const EmergencyLogScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    visitorName: 'visitorName',
    visitorPhone: 'visitorPhone',
    residentName: 'residentName',
    unit: 'unit',
    isEmergency: 'isEmergency',
    reason: 'reason',
    barcodeId: 'barcodeId',
    societyId: 'societyId'
  };

  export type EmergencyLogScalarFieldEnum = (typeof EmergencyLogScalarFieldEnum)[keyof typeof EmergencyLogScalarFieldEnum]


  export const EmergencyBarcodeScalarFieldEnum: {
    id: 'id',
    residentName: 'residentName',
    unit: 'unit',
    phone: 'phone',
    label: 'label',
    type: 'type',
    status: 'status',
    qrCodeUrl: 'qrCodeUrl',
    createdAt: 'createdAt',
    societyId: 'societyId'
  };

  export type EmergencyBarcodeScalarFieldEnum = (typeof EmergencyBarcodeScalarFieldEnum)[keyof typeof EmergencyBarcodeScalarFieldEnum]


  export const EmergencyAlertScalarFieldEnum: {
    id: 'id',
    type: 'type',
    unit: 'unit',
    description: 'description',
    status: 'status',
    resolution: 'resolution',
    societyId: 'societyId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmergencyAlertScalarFieldEnum = (typeof EmergencyAlertScalarFieldEnum)[keyof typeof EmergencyAlertScalarFieldEnum]


  export const EmergencyContactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    category: 'category',
    available: 'available',
    societyId: 'societyId',
    residentId: 'residentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmergencyContactScalarFieldEnum = (typeof EmergencyContactScalarFieldEnum)[keyof typeof EmergencyContactScalarFieldEnum]


  export const NoticeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    audience: 'audience',
    societyId: 'societyId',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type NoticeScalarFieldEnum = (typeof NoticeScalarFieldEnum)[keyof typeof NoticeScalarFieldEnum]


  export const AmenityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    capacity: 'capacity',
    chargesPerHour: 'chargesPerHour',
    availableDays: 'availableDays',
    timings: 'timings',
    status: 'status',
    societyId: 'societyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AmenityScalarFieldEnum = (typeof AmenityScalarFieldEnum)[keyof typeof AmenityScalarFieldEnum]


  export const AmenityBookingScalarFieldEnum: {
    id: 'id',
    amenityId: 'amenityId',
    userId: 'userId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    purpose: 'purpose',
    status: 'status',
    amountPaid: 'amountPaid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AmenityBookingScalarFieldEnum = (typeof AmenityBookingScalarFieldEnum)[keyof typeof AmenityBookingScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const BillingPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    price: 'price',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillingPlanScalarFieldEnum = (typeof BillingPlanScalarFieldEnum)[keyof typeof BillingPlanScalarFieldEnum]


  export const PlatformInvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNo: 'invoiceNo',
    societyId: 'societyId',
    amount: 'amount',
    status: 'status',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    paidDate: 'paidDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlatformInvoiceScalarFieldEnum = (typeof PlatformInvoiceScalarFieldEnum)[keyof typeof PlatformInvoiceScalarFieldEnum]


  export const CommunityBuzzScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    content: 'content',
    authorId: 'authorId',
    societyId: 'societyId',
    hasResult: 'hasResult',
    imageUrls: 'imageUrls',
    likes: 'likes',
    createdAt: 'createdAt'
  };

  export type CommunityBuzzScalarFieldEnum = (typeof CommunityBuzzScalarFieldEnum)[keyof typeof CommunityBuzzScalarFieldEnum]


  export const CommunityCommentScalarFieldEnum: {
    id: 'id',
    buzzId: 'buzzId',
    authorId: 'authorId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type CommunityCommentScalarFieldEnum = (typeof CommunityCommentScalarFieldEnum)[keyof typeof CommunityCommentScalarFieldEnum]


  export const BuzzLikeScalarFieldEnum: {
    id: 'id',
    buzzId: 'buzzId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type BuzzLikeScalarFieldEnum = (typeof BuzzLikeScalarFieldEnum)[keyof typeof BuzzLikeScalarFieldEnum]


  export const UnitMemberScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    name: 'name',
    relation: 'relation',
    age: 'age',
    gender: 'gender',
    phone: 'phone',
    email: 'email',
    profileImg: 'profileImg',
    createdAt: 'createdAt'
  };

  export type UnitMemberScalarFieldEnum = (typeof UnitMemberScalarFieldEnum)[keyof typeof UnitMemberScalarFieldEnum]


  export const UnitVehicleScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    name: 'name',
    number: 'number',
    type: 'type',
    color: 'color',
    parkingSlot: 'parkingSlot',
    createdAt: 'createdAt'
  };

  export type UnitVehicleScalarFieldEnum = (typeof UnitVehicleScalarFieldEnum)[keyof typeof UnitVehicleScalarFieldEnum]


  export const UnitPetScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    name: 'name',
    type: 'type',
    breed: 'breed',
    vaccinationStatus: 'vaccinationStatus',
    lastVaccinationDate: 'lastVaccinationDate',
    createdAt: 'createdAt'
  };

  export type UnitPetScalarFieldEnum = (typeof UnitPetScalarFieldEnum)[keyof typeof UnitPetScalarFieldEnum]


  export const SOSAlertScalarFieldEnum: {
    id: 'id',
    residentId: 'residentId',
    societyId: 'societyId',
    type: 'type',
    status: 'status',
    location: 'location',
    createdAt: 'createdAt',
    resolvedAt: 'resolvedAt'
  };

  export type SOSAlertScalarFieldEnum = (typeof SOSAlertScalarFieldEnum)[keyof typeof SOSAlertScalarFieldEnum]


  export const MarketplaceItemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    price: 'price',
    originalPrice: 'originalPrice',
    condition: 'condition',
    type: 'type',
    priceType: 'priceType',
    category: 'category',
    status: 'status',
    images: 'images',
    views: 'views',
    likes: 'likes',
    ownerId: 'ownerId',
    societyId: 'societyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketplaceItemScalarFieldEnum = (typeof MarketplaceItemScalarFieldEnum)[keyof typeof MarketplaceItemScalarFieldEnum]


  export const MeetingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    date: 'date',
    time: 'time',
    location: 'location',
    attendees: 'attendees',
    status: 'status',
    societyId: 'societyId'
  };

  export type MeetingScalarFieldEnum = (typeof MeetingScalarFieldEnum)[keyof typeof MeetingScalarFieldEnum]


  export const CommunityGuidelineScalarFieldEnum: {
    id: 'id',
    societyId: 'societyId',
    title: 'title',
    content: 'content',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommunityGuidelineScalarFieldEnum = (typeof CommunityGuidelineScalarFieldEnum)[keyof typeof CommunityGuidelineScalarFieldEnum]


  export const AssetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    value: 'value',
    purchaseDate: 'purchaseDate',
    status: 'status',
    societyId: 'societyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    category: 'category',
    fileUrl: 'fileUrl',
    societyId: 'societyId',
    createdAt: 'createdAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const ParcelScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    courierName: 'courierName',
    trackingNumber: 'trackingNumber',
    description: 'description',
    receivedBy: 'receivedBy',
    status: 'status',
    collectedBy: 'collectedBy',
    collectedAt: 'collectedAt',
    societyId: 'societyId',
    createdAt: 'createdAt'
  };

  export type ParcelScalarFieldEnum = (typeof ParcelScalarFieldEnum)[keyof typeof ParcelScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    date: 'date',
    time: 'time',
    location: 'location',
    category: 'category',
    status: 'status',
    societyId: 'societyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const PurchaseRequestScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    societyId: 'societyId',
    requestedById: 'requestedById'
  };

  export type PurchaseRequestScalarFieldEnum = (typeof PurchaseRequestScalarFieldEnum)[keyof typeof PurchaseRequestScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    societyId: 'societyId',
    type: 'type',
    participantId: 'participantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    senderId: 'senderId',
    content: 'content',
    attachments: 'attachments',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const ServiceCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    icon: 'icon',
    color: 'color',
    createdAt: 'createdAt'
  };

  export type ServiceCategoryScalarFieldEnum = (typeof ServiceCategoryScalarFieldEnum)[keyof typeof ServiceCategoryScalarFieldEnum]


  export const ServiceVariantScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    name: 'name',
    price: 'price',
    createdAt: 'createdAt'
  };

  export type ServiceVariantScalarFieldEnum = (typeof ServiceVariantScalarFieldEnum)[keyof typeof ServiceVariantScalarFieldEnum]


  export const ServiceInquiryScalarFieldEnum: {
    id: 'id',
    residentId: 'residentId',
    societyId: 'societyId',
    serviceId: 'serviceId',
    serviceName: 'serviceName',
    type: 'type',
    status: 'status',
    preferredDate: 'preferredDate',
    preferredTime: 'preferredTime',
    phone: 'phone',
    notes: 'notes',
    vendorName: 'vendorName',
    vendorId: 'vendorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceInquiryScalarFieldEnum = (typeof ServiceInquiryScalarFieldEnum)[keyof typeof ServiceInquiryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const SocietyOrderByRelevanceFieldEnum: {
    name: 'name',
    address: 'address',
    city: 'city',
    state: 'state',
    pincode: 'pincode',
    code: 'code'
  };

  export type SocietyOrderByRelevanceFieldEnum = (typeof SocietyOrderByRelevanceFieldEnum)[keyof typeof SocietyOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    email: 'email',
    password: 'password',
    name: 'name',
    phone: 'phone',
    profileImg: 'profileImg'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const RoleModelOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type RoleModelOrderByRelevanceFieldEnum = (typeof RoleModelOrderByRelevanceFieldEnum)[keyof typeof RoleModelOrderByRelevanceFieldEnum]


  export const PermissionOrderByRelevanceFieldEnum: {
    id: 'id',
    label: 'label',
    description: 'description'
  };

  export type PermissionOrderByRelevanceFieldEnum = (typeof PermissionOrderByRelevanceFieldEnum)[keyof typeof PermissionOrderByRelevanceFieldEnum]


  export const RolePermissionOrderByRelevanceFieldEnum: {
    permissionId: 'permissionId'
  };

  export type RolePermissionOrderByRelevanceFieldEnum = (typeof RolePermissionOrderByRelevanceFieldEnum)[keyof typeof RolePermissionOrderByRelevanceFieldEnum]


  export const UserSessionOrderByRelevanceFieldEnum: {
    device: 'device',
    ipAddress: 'ipAddress',
    token: 'token'
  };

  export type UserSessionOrderByRelevanceFieldEnum = (typeof UserSessionOrderByRelevanceFieldEnum)[keyof typeof UserSessionOrderByRelevanceFieldEnum]


  export const UnitOrderByRelevanceFieldEnum: {
    block: 'block',
    number: 'number',
    type: 'type',
    status: 'status'
  };

  export type UnitOrderByRelevanceFieldEnum = (typeof UnitOrderByRelevanceFieldEnum)[keyof typeof UnitOrderByRelevanceFieldEnum]


  export const ParkingSlotOrderByRelevanceFieldEnum: {
    number: 'number',
    type: 'type',
    status: 'status',
    vehicleNumber: 'vehicleNumber'
  };

  export type ParkingSlotOrderByRelevanceFieldEnum = (typeof ParkingSlotOrderByRelevanceFieldEnum)[keyof typeof ParkingSlotOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const ComplaintOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    category: 'category'
  };

  export type ComplaintOrderByRelevanceFieldEnum = (typeof ComplaintOrderByRelevanceFieldEnum)[keyof typeof ComplaintOrderByRelevanceFieldEnum]


  export const ComplaintCommentOrderByRelevanceFieldEnum: {
    message: 'message'
  };

  export type ComplaintCommentOrderByRelevanceFieldEnum = (typeof ComplaintCommentOrderByRelevanceFieldEnum)[keyof typeof ComplaintCommentOrderByRelevanceFieldEnum]


  export const VisitorOrderByRelevanceFieldEnum: {
    name: 'name',
    phone: 'phone',
    vehicleNo: 'vehicleNo',
    purpose: 'purpose',
    photo: 'photo',
    idType: 'idType',
    idNumber: 'idNumber'
  };

  export type VisitorOrderByRelevanceFieldEnum = (typeof VisitorOrderByRelevanceFieldEnum)[keyof typeof VisitorOrderByRelevanceFieldEnum]


  export const TransactionOrderByRelevanceFieldEnum: {
    category: 'category',
    description: 'description',
    status: 'status',
    invoiceNo: 'invoiceNo',
    paidTo: 'paidTo',
    receivedFrom: 'receivedFrom'
  };

  export type TransactionOrderByRelevanceFieldEnum = (typeof TransactionOrderByRelevanceFieldEnum)[keyof typeof TransactionOrderByRelevanceFieldEnum]


  export const VendorOrderByRelevanceFieldEnum: {
    name: 'name',
    serviceType: 'serviceType',
    contact: 'contact',
    email: 'email',
    address: 'address'
  };

  export type VendorOrderByRelevanceFieldEnum = (typeof VendorOrderByRelevanceFieldEnum)[keyof typeof VendorOrderByRelevanceFieldEnum]


  export const VendorPayoutOrderByRelevanceFieldEnum: {
    vendorName: 'vendorName',
    societyName: 'societyName',
    status: 'status',
    remarks: 'remarks'
  };

  export type VendorPayoutOrderByRelevanceFieldEnum = (typeof VendorPayoutOrderByRelevanceFieldEnum)[keyof typeof VendorPayoutOrderByRelevanceFieldEnum]


  export const EmergencyLogOrderByRelevanceFieldEnum: {
    id: 'id',
    visitorName: 'visitorName',
    visitorPhone: 'visitorPhone',
    residentName: 'residentName',
    unit: 'unit',
    reason: 'reason',
    barcodeId: 'barcodeId'
  };

  export type EmergencyLogOrderByRelevanceFieldEnum = (typeof EmergencyLogOrderByRelevanceFieldEnum)[keyof typeof EmergencyLogOrderByRelevanceFieldEnum]


  export const EmergencyBarcodeOrderByRelevanceFieldEnum: {
    id: 'id',
    residentName: 'residentName',
    unit: 'unit',
    phone: 'phone',
    label: 'label',
    type: 'type',
    status: 'status',
    qrCodeUrl: 'qrCodeUrl'
  };

  export type EmergencyBarcodeOrderByRelevanceFieldEnum = (typeof EmergencyBarcodeOrderByRelevanceFieldEnum)[keyof typeof EmergencyBarcodeOrderByRelevanceFieldEnum]


  export const EmergencyAlertOrderByRelevanceFieldEnum: {
    type: 'type',
    unit: 'unit',
    description: 'description',
    status: 'status',
    resolution: 'resolution'
  };

  export type EmergencyAlertOrderByRelevanceFieldEnum = (typeof EmergencyAlertOrderByRelevanceFieldEnum)[keyof typeof EmergencyAlertOrderByRelevanceFieldEnum]


  export const EmergencyContactOrderByRelevanceFieldEnum: {
    name: 'name',
    phone: 'phone',
    category: 'category'
  };

  export type EmergencyContactOrderByRelevanceFieldEnum = (typeof EmergencyContactOrderByRelevanceFieldEnum)[keyof typeof EmergencyContactOrderByRelevanceFieldEnum]


  export const NoticeOrderByRelevanceFieldEnum: {
    title: 'title',
    content: 'content',
    audience: 'audience'
  };

  export type NoticeOrderByRelevanceFieldEnum = (typeof NoticeOrderByRelevanceFieldEnum)[keyof typeof NoticeOrderByRelevanceFieldEnum]


  export const AmenityOrderByRelevanceFieldEnum: {
    name: 'name',
    type: 'type',
    description: 'description',
    status: 'status'
  };

  export type AmenityOrderByRelevanceFieldEnum = (typeof AmenityOrderByRelevanceFieldEnum)[keyof typeof AmenityOrderByRelevanceFieldEnum]


  export const AmenityBookingOrderByRelevanceFieldEnum: {
    startTime: 'startTime',
    endTime: 'endTime',
    purpose: 'purpose',
    status: 'status'
  };

  export type AmenityBookingOrderByRelevanceFieldEnum = (typeof AmenityBookingOrderByRelevanceFieldEnum)[keyof typeof AmenityBookingOrderByRelevanceFieldEnum]


  export const SystemSettingOrderByRelevanceFieldEnum: {
    key: 'key',
    value: 'value'
  };

  export type SystemSettingOrderByRelevanceFieldEnum = (typeof SystemSettingOrderByRelevanceFieldEnum)[keyof typeof SystemSettingOrderByRelevanceFieldEnum]


  export const BillingPlanOrderByRelevanceFieldEnum: {
    name: 'name',
    type: 'type',
    price: 'price',
    description: 'description',
    status: 'status'
  };

  export type BillingPlanOrderByRelevanceFieldEnum = (typeof BillingPlanOrderByRelevanceFieldEnum)[keyof typeof BillingPlanOrderByRelevanceFieldEnum]


  export const PlatformInvoiceOrderByRelevanceFieldEnum: {
    invoiceNo: 'invoiceNo',
    status: 'status'
  };

  export type PlatformInvoiceOrderByRelevanceFieldEnum = (typeof PlatformInvoiceOrderByRelevanceFieldEnum)[keyof typeof PlatformInvoiceOrderByRelevanceFieldEnum]


  export const CommunityBuzzOrderByRelevanceFieldEnum: {
    type: 'type',
    title: 'title',
    content: 'content'
  };

  export type CommunityBuzzOrderByRelevanceFieldEnum = (typeof CommunityBuzzOrderByRelevanceFieldEnum)[keyof typeof CommunityBuzzOrderByRelevanceFieldEnum]


  export const CommunityCommentOrderByRelevanceFieldEnum: {
    content: 'content'
  };

  export type CommunityCommentOrderByRelevanceFieldEnum = (typeof CommunityCommentOrderByRelevanceFieldEnum)[keyof typeof CommunityCommentOrderByRelevanceFieldEnum]


  export const UnitMemberOrderByRelevanceFieldEnum: {
    name: 'name',
    relation: 'relation',
    gender: 'gender',
    phone: 'phone',
    email: 'email',
    profileImg: 'profileImg'
  };

  export type UnitMemberOrderByRelevanceFieldEnum = (typeof UnitMemberOrderByRelevanceFieldEnum)[keyof typeof UnitMemberOrderByRelevanceFieldEnum]


  export const UnitVehicleOrderByRelevanceFieldEnum: {
    name: 'name',
    number: 'number',
    type: 'type',
    color: 'color',
    parkingSlot: 'parkingSlot'
  };

  export type UnitVehicleOrderByRelevanceFieldEnum = (typeof UnitVehicleOrderByRelevanceFieldEnum)[keyof typeof UnitVehicleOrderByRelevanceFieldEnum]


  export const UnitPetOrderByRelevanceFieldEnum: {
    name: 'name',
    type: 'type',
    breed: 'breed',
    vaccinationStatus: 'vaccinationStatus'
  };

  export type UnitPetOrderByRelevanceFieldEnum = (typeof UnitPetOrderByRelevanceFieldEnum)[keyof typeof UnitPetOrderByRelevanceFieldEnum]


  export const SOSAlertOrderByRelevanceFieldEnum: {
    type: 'type',
    status: 'status',
    location: 'location'
  };

  export type SOSAlertOrderByRelevanceFieldEnum = (typeof SOSAlertOrderByRelevanceFieldEnum)[keyof typeof SOSAlertOrderByRelevanceFieldEnum]


  export const MarketplaceItemOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    condition: 'condition',
    type: 'type',
    priceType: 'priceType',
    category: 'category',
    status: 'status'
  };

  export type MarketplaceItemOrderByRelevanceFieldEnum = (typeof MarketplaceItemOrderByRelevanceFieldEnum)[keyof typeof MarketplaceItemOrderByRelevanceFieldEnum]


  export const MeetingOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    time: 'time',
    location: 'location',
    status: 'status'
  };

  export type MeetingOrderByRelevanceFieldEnum = (typeof MeetingOrderByRelevanceFieldEnum)[keyof typeof MeetingOrderByRelevanceFieldEnum]


  export const CommunityGuidelineOrderByRelevanceFieldEnum: {
    title: 'title',
    content: 'content',
    category: 'category'
  };

  export type CommunityGuidelineOrderByRelevanceFieldEnum = (typeof CommunityGuidelineOrderByRelevanceFieldEnum)[keyof typeof CommunityGuidelineOrderByRelevanceFieldEnum]


  export const AssetOrderByRelevanceFieldEnum: {
    name: 'name',
    category: 'category',
    status: 'status'
  };

  export type AssetOrderByRelevanceFieldEnum = (typeof AssetOrderByRelevanceFieldEnum)[keyof typeof AssetOrderByRelevanceFieldEnum]


  export const DocumentOrderByRelevanceFieldEnum: {
    title: 'title',
    category: 'category',
    fileUrl: 'fileUrl'
  };

  export type DocumentOrderByRelevanceFieldEnum = (typeof DocumentOrderByRelevanceFieldEnum)[keyof typeof DocumentOrderByRelevanceFieldEnum]


  export const ParcelOrderByRelevanceFieldEnum: {
    courierName: 'courierName',
    trackingNumber: 'trackingNumber',
    description: 'description',
    receivedBy: 'receivedBy',
    status: 'status',
    collectedBy: 'collectedBy'
  };

  export type ParcelOrderByRelevanceFieldEnum = (typeof ParcelOrderByRelevanceFieldEnum)[keyof typeof ParcelOrderByRelevanceFieldEnum]


  export const EventOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    time: 'time',
    location: 'location',
    category: 'category',
    status: 'status'
  };

  export type EventOrderByRelevanceFieldEnum = (typeof EventOrderByRelevanceFieldEnum)[keyof typeof EventOrderByRelevanceFieldEnum]


  export const PurchaseRequestOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    status: 'status'
  };

  export type PurchaseRequestOrderByRelevanceFieldEnum = (typeof PurchaseRequestOrderByRelevanceFieldEnum)[keyof typeof PurchaseRequestOrderByRelevanceFieldEnum]


  export const ConversationOrderByRelevanceFieldEnum: {
    type: 'type'
  };

  export type ConversationOrderByRelevanceFieldEnum = (typeof ConversationOrderByRelevanceFieldEnum)[keyof typeof ConversationOrderByRelevanceFieldEnum]


  export const ChatMessageOrderByRelevanceFieldEnum: {
    content: 'content',
    status: 'status'
  };

  export type ChatMessageOrderByRelevanceFieldEnum = (typeof ChatMessageOrderByRelevanceFieldEnum)[keyof typeof ChatMessageOrderByRelevanceFieldEnum]


  export const ServiceCategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    icon: 'icon',
    color: 'color'
  };

  export type ServiceCategoryOrderByRelevanceFieldEnum = (typeof ServiceCategoryOrderByRelevanceFieldEnum)[keyof typeof ServiceCategoryOrderByRelevanceFieldEnum]


  export const ServiceVariantOrderByRelevanceFieldEnum: {
    categoryId: 'categoryId',
    name: 'name'
  };

  export type ServiceVariantOrderByRelevanceFieldEnum = (typeof ServiceVariantOrderByRelevanceFieldEnum)[keyof typeof ServiceVariantOrderByRelevanceFieldEnum]


  export const ServiceInquiryOrderByRelevanceFieldEnum: {
    serviceId: 'serviceId',
    serviceName: 'serviceName',
    type: 'type',
    status: 'status',
    preferredDate: 'preferredDate',
    preferredTime: 'preferredTime',
    phone: 'phone',
    notes: 'notes',
    vendorName: 'vendorName'
  };

  export type ServiceInquiryOrderByRelevanceFieldEnum = (typeof ServiceInquiryOrderByRelevanceFieldEnum)[keyof typeof ServiceInquiryOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'SocietyStatus'
   */
  export type EnumSocietyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocietyStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan'
   */
  export type EnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'ComplaintStatus'
   */
  export type EnumComplaintStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintStatus'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'VisitorStatus'
   */
  export type EnumVisitorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitorStatus'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'VendorStatus'
   */
  export type EnumVendorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VendorStatus'>
    
  /**
   * Deep Input Types
   */


  export type SocietyWhereInput = {
    AND?: SocietyWhereInput | SocietyWhereInput[]
    OR?: SocietyWhereInput[]
    NOT?: SocietyWhereInput | SocietyWhereInput[]
    id?: IntFilter<"Society"> | number
    name?: StringFilter<"Society"> | string
    address?: StringNullableFilter<"Society"> | string | null
    city?: StringNullableFilter<"Society"> | string | null
    state?: StringNullableFilter<"Society"> | string | null
    pincode?: StringNullableFilter<"Society"> | string | null
    code?: StringFilter<"Society"> | string
    status?: EnumSocietyStatusFilter<"Society"> | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFilter<"Society"> | $Enums.SubscriptionPlan
    expectedUnits?: IntFilter<"Society"> | number
    createdAt?: DateTimeFilter<"Society"> | Date | string
    updatedAt?: DateTimeFilter<"Society"> | Date | string
    users?: UserListRelationFilter
    units?: UnitListRelationFilter
    complaints?: ComplaintListRelationFilter
    visitors?: VisitorListRelationFilter
    transactions?: TransactionListRelationFilter
    notices?: NoticeListRelationFilter
    vendors?: VendorListRelationFilter
    amenities?: AmenityListRelationFilter
    parkingSlots?: ParkingSlotListRelationFilter
    platformInvoices?: PlatformInvoiceListRelationFilter
    meetings?: MeetingListRelationFilter
    assets?: AssetListRelationFilter
    documents?: DocumentListRelationFilter
    parcels?: ParcelListRelationFilter
    events?: EventListRelationFilter
    purchaseRequests?: PurchaseRequestListRelationFilter
    emergencyAlerts?: EmergencyAlertListRelationFilter
    emergencyContacts?: EmergencyContactListRelationFilter
    serviceInquiries?: ServiceInquiryListRelationFilter
    conversations?: ConversationListRelationFilter
    buzzs?: CommunityBuzzListRelationFilter
    marketplaceItems?: MarketplaceItemListRelationFilter
    guidelines?: CommunityGuidelineListRelationFilter
    sosAlerts?: SOSAlertListRelationFilter
  }

  export type SocietyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    code?: SortOrder
    status?: SortOrder
    subscriptionPlan?: SortOrder
    expectedUnits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    units?: UnitOrderByRelationAggregateInput
    complaints?: ComplaintOrderByRelationAggregateInput
    visitors?: VisitorOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    notices?: NoticeOrderByRelationAggregateInput
    vendors?: VendorOrderByRelationAggregateInput
    amenities?: AmenityOrderByRelationAggregateInput
    parkingSlots?: ParkingSlotOrderByRelationAggregateInput
    platformInvoices?: PlatformInvoiceOrderByRelationAggregateInput
    meetings?: MeetingOrderByRelationAggregateInput
    assets?: AssetOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    parcels?: ParcelOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    purchaseRequests?: PurchaseRequestOrderByRelationAggregateInput
    emergencyAlerts?: EmergencyAlertOrderByRelationAggregateInput
    emergencyContacts?: EmergencyContactOrderByRelationAggregateInput
    serviceInquiries?: ServiceInquiryOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    buzzs?: CommunityBuzzOrderByRelationAggregateInput
    marketplaceItems?: MarketplaceItemOrderByRelationAggregateInput
    guidelines?: CommunityGuidelineOrderByRelationAggregateInput
    sosAlerts?: SOSAlertOrderByRelationAggregateInput
    _relevance?: SocietyOrderByRelevanceInput
  }

  export type SocietyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: SocietyWhereInput | SocietyWhereInput[]
    OR?: SocietyWhereInput[]
    NOT?: SocietyWhereInput | SocietyWhereInput[]
    name?: StringFilter<"Society"> | string
    address?: StringNullableFilter<"Society"> | string | null
    city?: StringNullableFilter<"Society"> | string | null
    state?: StringNullableFilter<"Society"> | string | null
    pincode?: StringNullableFilter<"Society"> | string | null
    status?: EnumSocietyStatusFilter<"Society"> | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFilter<"Society"> | $Enums.SubscriptionPlan
    expectedUnits?: IntFilter<"Society"> | number
    createdAt?: DateTimeFilter<"Society"> | Date | string
    updatedAt?: DateTimeFilter<"Society"> | Date | string
    users?: UserListRelationFilter
    units?: UnitListRelationFilter
    complaints?: ComplaintListRelationFilter
    visitors?: VisitorListRelationFilter
    transactions?: TransactionListRelationFilter
    notices?: NoticeListRelationFilter
    vendors?: VendorListRelationFilter
    amenities?: AmenityListRelationFilter
    parkingSlots?: ParkingSlotListRelationFilter
    platformInvoices?: PlatformInvoiceListRelationFilter
    meetings?: MeetingListRelationFilter
    assets?: AssetListRelationFilter
    documents?: DocumentListRelationFilter
    parcels?: ParcelListRelationFilter
    events?: EventListRelationFilter
    purchaseRequests?: PurchaseRequestListRelationFilter
    emergencyAlerts?: EmergencyAlertListRelationFilter
    emergencyContacts?: EmergencyContactListRelationFilter
    serviceInquiries?: ServiceInquiryListRelationFilter
    conversations?: ConversationListRelationFilter
    buzzs?: CommunityBuzzListRelationFilter
    marketplaceItems?: MarketplaceItemListRelationFilter
    guidelines?: CommunityGuidelineListRelationFilter
    sosAlerts?: SOSAlertListRelationFilter
  }, "id" | "code">

  export type SocietyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    code?: SortOrder
    status?: SortOrder
    subscriptionPlan?: SortOrder
    expectedUnits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SocietyCountOrderByAggregateInput
    _avg?: SocietyAvgOrderByAggregateInput
    _max?: SocietyMaxOrderByAggregateInput
    _min?: SocietyMinOrderByAggregateInput
    _sum?: SocietySumOrderByAggregateInput
  }

  export type SocietyScalarWhereWithAggregatesInput = {
    AND?: SocietyScalarWhereWithAggregatesInput | SocietyScalarWhereWithAggregatesInput[]
    OR?: SocietyScalarWhereWithAggregatesInput[]
    NOT?: SocietyScalarWhereWithAggregatesInput | SocietyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Society"> | number
    name?: StringWithAggregatesFilter<"Society"> | string
    address?: StringNullableWithAggregatesFilter<"Society"> | string | null
    city?: StringNullableWithAggregatesFilter<"Society"> | string | null
    state?: StringNullableWithAggregatesFilter<"Society"> | string | null
    pincode?: StringNullableWithAggregatesFilter<"Society"> | string | null
    code?: StringWithAggregatesFilter<"Society"> | string
    status?: EnumSocietyStatusWithAggregatesFilter<"Society"> | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanWithAggregatesFilter<"Society"> | $Enums.SubscriptionPlan
    expectedUnits?: IntWithAggregatesFilter<"Society"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Society"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Society"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    profileImg?: StringNullableFilter<"User"> | string | null
    roleId?: IntNullableFilter<"User"> | number | null
    societyId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    roleModel?: XOR<RoleModelNullableScalarRelationFilter, RoleModelWhereInput> | null
    sessions?: UserSessionListRelationFilter
    society?: XOR<SocietyNullableScalarRelationFilter, SocietyWhereInput> | null
    ownedUnits?: UnitListRelationFilter
    rentedUnits?: UnitListRelationFilter
    reportedComplaints?: ComplaintListRelationFilter
    assignedComplaints?: ComplaintListRelationFilter
    bookings?: AmenityBookingListRelationFilter
    comments?: ComplaintCommentListRelationFilter
    purchaseRequests?: PurchaseRequestListRelationFilter
    emergencyAlerts?: EmergencyAlertListRelationFilter
    serviceInquiries?: ServiceInquiryListRelationFilter
    conversations?: ConversationListRelationFilter
    sentMessages?: ChatMessageListRelationFilter
    buzzs?: CommunityBuzzListRelationFilter
    communityComments?: CommunityCommentListRelationFilter
    sosAlerts?: SOSAlertListRelationFilter
    emergencyContacts?: EmergencyContactListRelationFilter
    marketplaceItems?: MarketplaceItemListRelationFilter
    buzzLikes?: BuzzLikeListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    profileImg?: SortOrderInput | SortOrder
    roleId?: SortOrderInput | SortOrder
    societyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleModel?: RoleModelOrderByWithRelationInput
    sessions?: UserSessionOrderByRelationAggregateInput
    society?: SocietyOrderByWithRelationInput
    ownedUnits?: UnitOrderByRelationAggregateInput
    rentedUnits?: UnitOrderByRelationAggregateInput
    reportedComplaints?: ComplaintOrderByRelationAggregateInput
    assignedComplaints?: ComplaintOrderByRelationAggregateInput
    bookings?: AmenityBookingOrderByRelationAggregateInput
    comments?: ComplaintCommentOrderByRelationAggregateInput
    purchaseRequests?: PurchaseRequestOrderByRelationAggregateInput
    emergencyAlerts?: EmergencyAlertOrderByRelationAggregateInput
    serviceInquiries?: ServiceInquiryOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    sentMessages?: ChatMessageOrderByRelationAggregateInput
    buzzs?: CommunityBuzzOrderByRelationAggregateInput
    communityComments?: CommunityCommentOrderByRelationAggregateInput
    sosAlerts?: SOSAlertOrderByRelationAggregateInput
    emergencyContacts?: EmergencyContactOrderByRelationAggregateInput
    marketplaceItems?: MarketplaceItemOrderByRelationAggregateInput
    buzzLikes?: BuzzLikeOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    profileImg?: StringNullableFilter<"User"> | string | null
    roleId?: IntNullableFilter<"User"> | number | null
    societyId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    roleModel?: XOR<RoleModelNullableScalarRelationFilter, RoleModelWhereInput> | null
    sessions?: UserSessionListRelationFilter
    society?: XOR<SocietyNullableScalarRelationFilter, SocietyWhereInput> | null
    ownedUnits?: UnitListRelationFilter
    rentedUnits?: UnitListRelationFilter
    reportedComplaints?: ComplaintListRelationFilter
    assignedComplaints?: ComplaintListRelationFilter
    bookings?: AmenityBookingListRelationFilter
    comments?: ComplaintCommentListRelationFilter
    purchaseRequests?: PurchaseRequestListRelationFilter
    emergencyAlerts?: EmergencyAlertListRelationFilter
    serviceInquiries?: ServiceInquiryListRelationFilter
    conversations?: ConversationListRelationFilter
    sentMessages?: ChatMessageListRelationFilter
    buzzs?: CommunityBuzzListRelationFilter
    communityComments?: CommunityCommentListRelationFilter
    sosAlerts?: SOSAlertListRelationFilter
    emergencyContacts?: EmergencyContactListRelationFilter
    marketplaceItems?: MarketplaceItemListRelationFilter
    buzzLikes?: BuzzLikeListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    profileImg?: SortOrderInput | SortOrder
    roleId?: SortOrderInput | SortOrder
    societyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    profileImg?: StringNullableWithAggregatesFilter<"User"> | string | null
    roleId?: IntNullableWithAggregatesFilter<"User"> | number | null
    societyId?: IntNullableWithAggregatesFilter<"User"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RoleModelWhereInput = {
    AND?: RoleModelWhereInput | RoleModelWhereInput[]
    OR?: RoleModelWhereInput[]
    NOT?: RoleModelWhereInput | RoleModelWhereInput[]
    id?: IntFilter<"RoleModel"> | number
    name?: StringFilter<"RoleModel"> | string
    description?: StringNullableFilter<"RoleModel"> | string | null
    createdAt?: DateTimeFilter<"RoleModel"> | Date | string
    updatedAt?: DateTimeFilter<"RoleModel"> | Date | string
    permissions?: RolePermissionListRelationFilter
    users?: UserListRelationFilter
  }

  export type RoleModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissions?: RolePermissionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    _relevance?: RoleModelOrderByRelevanceInput
  }

  export type RoleModelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RoleModelWhereInput | RoleModelWhereInput[]
    OR?: RoleModelWhereInput[]
    NOT?: RoleModelWhereInput | RoleModelWhereInput[]
    description?: StringNullableFilter<"RoleModel"> | string | null
    createdAt?: DateTimeFilter<"RoleModel"> | Date | string
    updatedAt?: DateTimeFilter<"RoleModel"> | Date | string
    permissions?: RolePermissionListRelationFilter
    users?: UserListRelationFilter
  }, "id" | "name">

  export type RoleModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleModelCountOrderByAggregateInput
    _avg?: RoleModelAvgOrderByAggregateInput
    _max?: RoleModelMaxOrderByAggregateInput
    _min?: RoleModelMinOrderByAggregateInput
    _sum?: RoleModelSumOrderByAggregateInput
  }

  export type RoleModelScalarWhereWithAggregatesInput = {
    AND?: RoleModelScalarWhereWithAggregatesInput | RoleModelScalarWhereWithAggregatesInput[]
    OR?: RoleModelScalarWhereWithAggregatesInput[]
    NOT?: RoleModelScalarWhereWithAggregatesInput | RoleModelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoleModel"> | number
    name?: StringWithAggregatesFilter<"RoleModel"> | string
    description?: StringNullableWithAggregatesFilter<"RoleModel"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RoleModel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoleModel"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    label?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    roles?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    roles?: RolePermissionOrderByRelationAggregateInput
    _relevance?: PermissionOrderByRelevanceInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    label?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    roles?: RolePermissionListRelationFilter
  }, "id">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    label?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: StringFilter<"RolePermission"> | string
    role?: XOR<RoleModelScalarRelationFilter, RoleModelWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    role?: RoleModelOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
    _relevance?: RolePermissionOrderByRelevanceInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: StringFilter<"RolePermission"> | string
    role?: XOR<RoleModelScalarRelationFilter, RoleModelWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _avg?: RolePermissionAvgOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
    _sum?: RolePermissionSumOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    roleId?: IntWithAggregatesFilter<"RolePermission"> | number
    permissionId?: StringWithAggregatesFilter<"RolePermission"> | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: IntFilter<"UserSession"> | number
    userId?: IntFilter<"UserSession"> | number
    device?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    lastActive?: DateTimeFilter<"UserSession"> | Date | string
    token?: StringFilter<"UserSession"> | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    device?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    lastActive?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: UserSessionOrderByRelevanceInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: IntFilter<"UserSession"> | number
    device?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    lastActive?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    device?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    lastActive?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _avg?: UserSessionAvgOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
    _sum?: UserSessionSumOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserSession"> | number
    userId?: IntWithAggregatesFilter<"UserSession"> | number
    device?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    lastActive?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    token?: StringWithAggregatesFilter<"UserSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: IntFilter<"Unit"> | number
    block?: StringFilter<"Unit"> | string
    number?: StringFilter<"Unit"> | string
    floor?: IntFilter<"Unit"> | number
    type?: StringFilter<"Unit"> | string
    areaSqFt?: FloatFilter<"Unit"> | number
    status?: StringFilter<"Unit"> | string
    pets?: IntFilter<"Unit"> | number
    membersCount?: IntFilter<"Unit"> | number
    societyId?: IntFilter<"Unit"> | number
    ownerId?: IntNullableFilter<"Unit"> | number | null
    tenantId?: IntNullableFilter<"Unit"> | number | null
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tenant?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    visitors?: VisitorListRelationFilter
    parkingSlots?: ParkingSlotListRelationFilter
    parcels?: ParcelListRelationFilter
    members?: UnitMemberListRelationFilter
    vehicles?: UnitVehicleListRelationFilter
    petsList?: UnitPetListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    block?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    areaSqFt?: SortOrder
    status?: SortOrder
    pets?: SortOrder
    membersCount?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    tenant?: UserOrderByWithRelationInput
    visitors?: VisitorOrderByRelationAggregateInput
    parkingSlots?: ParkingSlotOrderByRelationAggregateInput
    parcels?: ParcelOrderByRelationAggregateInput
    members?: UnitMemberOrderByRelationAggregateInput
    vehicles?: UnitVehicleOrderByRelationAggregateInput
    petsList?: UnitPetOrderByRelationAggregateInput
    _relevance?: UnitOrderByRelevanceInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    societyId_block_number?: UnitSocietyIdBlockNumberCompoundUniqueInput
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    block?: StringFilter<"Unit"> | string
    number?: StringFilter<"Unit"> | string
    floor?: IntFilter<"Unit"> | number
    type?: StringFilter<"Unit"> | string
    areaSqFt?: FloatFilter<"Unit"> | number
    status?: StringFilter<"Unit"> | string
    pets?: IntFilter<"Unit"> | number
    membersCount?: IntFilter<"Unit"> | number
    societyId?: IntFilter<"Unit"> | number
    ownerId?: IntNullableFilter<"Unit"> | number | null
    tenantId?: IntNullableFilter<"Unit"> | number | null
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tenant?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    visitors?: VisitorListRelationFilter
    parkingSlots?: ParkingSlotListRelationFilter
    parcels?: ParcelListRelationFilter
    members?: UnitMemberListRelationFilter
    vehicles?: UnitVehicleListRelationFilter
    petsList?: UnitPetListRelationFilter
  }, "id" | "societyId_block_number">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    block?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    areaSqFt?: SortOrder
    status?: SortOrder
    pets?: SortOrder
    membersCount?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Unit"> | number
    block?: StringWithAggregatesFilter<"Unit"> | string
    number?: StringWithAggregatesFilter<"Unit"> | string
    floor?: IntWithAggregatesFilter<"Unit"> | number
    type?: StringWithAggregatesFilter<"Unit"> | string
    areaSqFt?: FloatWithAggregatesFilter<"Unit"> | number
    status?: StringWithAggregatesFilter<"Unit"> | string
    pets?: IntWithAggregatesFilter<"Unit"> | number
    membersCount?: IntWithAggregatesFilter<"Unit"> | number
    societyId?: IntWithAggregatesFilter<"Unit"> | number
    ownerId?: IntNullableWithAggregatesFilter<"Unit"> | number | null
    tenantId?: IntNullableWithAggregatesFilter<"Unit"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
  }

  export type ParkingSlotWhereInput = {
    AND?: ParkingSlotWhereInput | ParkingSlotWhereInput[]
    OR?: ParkingSlotWhereInput[]
    NOT?: ParkingSlotWhereInput | ParkingSlotWhereInput[]
    id?: IntFilter<"ParkingSlot"> | number
    number?: StringFilter<"ParkingSlot"> | string
    type?: StringFilter<"ParkingSlot"> | string
    status?: StringFilter<"ParkingSlot"> | string
    societyId?: IntFilter<"ParkingSlot"> | number
    allocatedToUnitId?: IntNullableFilter<"ParkingSlot"> | number | null
    vehicleNumber?: StringNullableFilter<"ParkingSlot"> | string | null
    createdAt?: DateTimeFilter<"ParkingSlot"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
  }

  export type ParkingSlotOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrderInput | SortOrder
    vehicleNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    _relevance?: ParkingSlotOrderByRelevanceInput
  }

  export type ParkingSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ParkingSlotWhereInput | ParkingSlotWhereInput[]
    OR?: ParkingSlotWhereInput[]
    NOT?: ParkingSlotWhereInput | ParkingSlotWhereInput[]
    number?: StringFilter<"ParkingSlot"> | string
    type?: StringFilter<"ParkingSlot"> | string
    status?: StringFilter<"ParkingSlot"> | string
    societyId?: IntFilter<"ParkingSlot"> | number
    allocatedToUnitId?: IntNullableFilter<"ParkingSlot"> | number | null
    vehicleNumber?: StringNullableFilter<"ParkingSlot"> | string | null
    createdAt?: DateTimeFilter<"ParkingSlot"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
  }, "id">

  export type ParkingSlotOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrderInput | SortOrder
    vehicleNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ParkingSlotCountOrderByAggregateInput
    _avg?: ParkingSlotAvgOrderByAggregateInput
    _max?: ParkingSlotMaxOrderByAggregateInput
    _min?: ParkingSlotMinOrderByAggregateInput
    _sum?: ParkingSlotSumOrderByAggregateInput
  }

  export type ParkingSlotScalarWhereWithAggregatesInput = {
    AND?: ParkingSlotScalarWhereWithAggregatesInput | ParkingSlotScalarWhereWithAggregatesInput[]
    OR?: ParkingSlotScalarWhereWithAggregatesInput[]
    NOT?: ParkingSlotScalarWhereWithAggregatesInput | ParkingSlotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ParkingSlot"> | number
    number?: StringWithAggregatesFilter<"ParkingSlot"> | string
    type?: StringWithAggregatesFilter<"ParkingSlot"> | string
    status?: StringWithAggregatesFilter<"ParkingSlot"> | string
    societyId?: IntWithAggregatesFilter<"ParkingSlot"> | number
    allocatedToUnitId?: IntNullableWithAggregatesFilter<"ParkingSlot"> | number | null
    vehicleNumber?: StringNullableWithAggregatesFilter<"ParkingSlot"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ParkingSlot"> | Date | string
  }

  export type ComplaintWhereInput = {
    AND?: ComplaintWhereInput | ComplaintWhereInput[]
    OR?: ComplaintWhereInput[]
    NOT?: ComplaintWhereInput | ComplaintWhereInput[]
    id?: IntFilter<"Complaint"> | number
    title?: StringFilter<"Complaint"> | string
    description?: StringFilter<"Complaint"> | string
    category?: StringFilter<"Complaint"> | string
    priority?: EnumPriorityFilter<"Complaint"> | $Enums.Priority
    status?: EnumComplaintStatusFilter<"Complaint"> | $Enums.ComplaintStatus
    isPrivate?: BoolFilter<"Complaint"> | boolean
    escalatedToTech?: BoolFilter<"Complaint"> | boolean
    images?: JsonNullableFilter<"Complaint">
    societyId?: IntFilter<"Complaint"> | number
    reportedById?: IntFilter<"Complaint"> | number
    assignedToId?: IntNullableFilter<"Complaint"> | number | null
    timeline?: JsonNullableFilter<"Complaint">
    createdAt?: DateTimeFilter<"Complaint"> | Date | string
    updatedAt?: DateTimeFilter<"Complaint"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    reportedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    comments?: ComplaintCommentListRelationFilter
  }

  export type ComplaintOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    isPrivate?: SortOrder
    escalatedToTech?: SortOrder
    images?: SortOrderInput | SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    timeline?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    reportedBy?: UserOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    comments?: ComplaintCommentOrderByRelationAggregateInput
    _relevance?: ComplaintOrderByRelevanceInput
  }

  export type ComplaintWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComplaintWhereInput | ComplaintWhereInput[]
    OR?: ComplaintWhereInput[]
    NOT?: ComplaintWhereInput | ComplaintWhereInput[]
    title?: StringFilter<"Complaint"> | string
    description?: StringFilter<"Complaint"> | string
    category?: StringFilter<"Complaint"> | string
    priority?: EnumPriorityFilter<"Complaint"> | $Enums.Priority
    status?: EnumComplaintStatusFilter<"Complaint"> | $Enums.ComplaintStatus
    isPrivate?: BoolFilter<"Complaint"> | boolean
    escalatedToTech?: BoolFilter<"Complaint"> | boolean
    images?: JsonNullableFilter<"Complaint">
    societyId?: IntFilter<"Complaint"> | number
    reportedById?: IntFilter<"Complaint"> | number
    assignedToId?: IntNullableFilter<"Complaint"> | number | null
    timeline?: JsonNullableFilter<"Complaint">
    createdAt?: DateTimeFilter<"Complaint"> | Date | string
    updatedAt?: DateTimeFilter<"Complaint"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    reportedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    comments?: ComplaintCommentListRelationFilter
  }, "id">

  export type ComplaintOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    isPrivate?: SortOrder
    escalatedToTech?: SortOrder
    images?: SortOrderInput | SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    timeline?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComplaintCountOrderByAggregateInput
    _avg?: ComplaintAvgOrderByAggregateInput
    _max?: ComplaintMaxOrderByAggregateInput
    _min?: ComplaintMinOrderByAggregateInput
    _sum?: ComplaintSumOrderByAggregateInput
  }

  export type ComplaintScalarWhereWithAggregatesInput = {
    AND?: ComplaintScalarWhereWithAggregatesInput | ComplaintScalarWhereWithAggregatesInput[]
    OR?: ComplaintScalarWhereWithAggregatesInput[]
    NOT?: ComplaintScalarWhereWithAggregatesInput | ComplaintScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Complaint"> | number
    title?: StringWithAggregatesFilter<"Complaint"> | string
    description?: StringWithAggregatesFilter<"Complaint"> | string
    category?: StringWithAggregatesFilter<"Complaint"> | string
    priority?: EnumPriorityWithAggregatesFilter<"Complaint"> | $Enums.Priority
    status?: EnumComplaintStatusWithAggregatesFilter<"Complaint"> | $Enums.ComplaintStatus
    isPrivate?: BoolWithAggregatesFilter<"Complaint"> | boolean
    escalatedToTech?: BoolWithAggregatesFilter<"Complaint"> | boolean
    images?: JsonNullableWithAggregatesFilter<"Complaint">
    societyId?: IntWithAggregatesFilter<"Complaint"> | number
    reportedById?: IntWithAggregatesFilter<"Complaint"> | number
    assignedToId?: IntNullableWithAggregatesFilter<"Complaint"> | number | null
    timeline?: JsonNullableWithAggregatesFilter<"Complaint">
    createdAt?: DateTimeWithAggregatesFilter<"Complaint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Complaint"> | Date | string
  }

  export type ComplaintCommentWhereInput = {
    AND?: ComplaintCommentWhereInput | ComplaintCommentWhereInput[]
    OR?: ComplaintCommentWhereInput[]
    NOT?: ComplaintCommentWhereInput | ComplaintCommentWhereInput[]
    id?: IntFilter<"ComplaintComment"> | number
    complaintId?: IntFilter<"ComplaintComment"> | number
    userId?: IntFilter<"ComplaintComment"> | number
    message?: StringFilter<"ComplaintComment"> | string
    createdAt?: DateTimeFilter<"ComplaintComment"> | Date | string
    complaint?: XOR<ComplaintScalarRelationFilter, ComplaintWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ComplaintCommentOrderByWithRelationInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    complaint?: ComplaintOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: ComplaintCommentOrderByRelevanceInput
  }

  export type ComplaintCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComplaintCommentWhereInput | ComplaintCommentWhereInput[]
    OR?: ComplaintCommentWhereInput[]
    NOT?: ComplaintCommentWhereInput | ComplaintCommentWhereInput[]
    complaintId?: IntFilter<"ComplaintComment"> | number
    userId?: IntFilter<"ComplaintComment"> | number
    message?: StringFilter<"ComplaintComment"> | string
    createdAt?: DateTimeFilter<"ComplaintComment"> | Date | string
    complaint?: XOR<ComplaintScalarRelationFilter, ComplaintWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ComplaintCommentOrderByWithAggregationInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: ComplaintCommentCountOrderByAggregateInput
    _avg?: ComplaintCommentAvgOrderByAggregateInput
    _max?: ComplaintCommentMaxOrderByAggregateInput
    _min?: ComplaintCommentMinOrderByAggregateInput
    _sum?: ComplaintCommentSumOrderByAggregateInput
  }

  export type ComplaintCommentScalarWhereWithAggregatesInput = {
    AND?: ComplaintCommentScalarWhereWithAggregatesInput | ComplaintCommentScalarWhereWithAggregatesInput[]
    OR?: ComplaintCommentScalarWhereWithAggregatesInput[]
    NOT?: ComplaintCommentScalarWhereWithAggregatesInput | ComplaintCommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ComplaintComment"> | number
    complaintId?: IntWithAggregatesFilter<"ComplaintComment"> | number
    userId?: IntWithAggregatesFilter<"ComplaintComment"> | number
    message?: StringWithAggregatesFilter<"ComplaintComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ComplaintComment"> | Date | string
  }

  export type VisitorWhereInput = {
    AND?: VisitorWhereInput | VisitorWhereInput[]
    OR?: VisitorWhereInput[]
    NOT?: VisitorWhereInput | VisitorWhereInput[]
    id?: IntFilter<"Visitor"> | number
    name?: StringFilter<"Visitor"> | string
    phone?: StringFilter<"Visitor"> | string
    vehicleNo?: StringNullableFilter<"Visitor"> | string | null
    purpose?: StringFilter<"Visitor"> | string
    photo?: StringNullableFilter<"Visitor"> | string | null
    status?: EnumVisitorStatusFilter<"Visitor"> | $Enums.VisitorStatus
    entryTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    exitTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    societyId?: IntFilter<"Visitor"> | number
    visitingUnitId?: IntFilter<"Visitor"> | number
    idType?: StringNullableFilter<"Visitor"> | string | null
    idNumber?: StringNullableFilter<"Visitor"> | string | null
    createdAt?: DateTimeFilter<"Visitor"> | Date | string
    updatedAt?: DateTimeFilter<"Visitor"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type VisitorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicleNo?: SortOrderInput | SortOrder
    purpose?: SortOrder
    photo?: SortOrderInput | SortOrder
    status?: SortOrder
    entryTime?: SortOrderInput | SortOrder
    exitTime?: SortOrderInput | SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
    idType?: SortOrderInput | SortOrder
    idNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    _relevance?: VisitorOrderByRelevanceInput
  }

  export type VisitorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VisitorWhereInput | VisitorWhereInput[]
    OR?: VisitorWhereInput[]
    NOT?: VisitorWhereInput | VisitorWhereInput[]
    name?: StringFilter<"Visitor"> | string
    phone?: StringFilter<"Visitor"> | string
    vehicleNo?: StringNullableFilter<"Visitor"> | string | null
    purpose?: StringFilter<"Visitor"> | string
    photo?: StringNullableFilter<"Visitor"> | string | null
    status?: EnumVisitorStatusFilter<"Visitor"> | $Enums.VisitorStatus
    entryTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    exitTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    societyId?: IntFilter<"Visitor"> | number
    visitingUnitId?: IntFilter<"Visitor"> | number
    idType?: StringNullableFilter<"Visitor"> | string | null
    idNumber?: StringNullableFilter<"Visitor"> | string | null
    createdAt?: DateTimeFilter<"Visitor"> | Date | string
    updatedAt?: DateTimeFilter<"Visitor"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "id">

  export type VisitorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicleNo?: SortOrderInput | SortOrder
    purpose?: SortOrder
    photo?: SortOrderInput | SortOrder
    status?: SortOrder
    entryTime?: SortOrderInput | SortOrder
    exitTime?: SortOrderInput | SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
    idType?: SortOrderInput | SortOrder
    idNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VisitorCountOrderByAggregateInput
    _avg?: VisitorAvgOrderByAggregateInput
    _max?: VisitorMaxOrderByAggregateInput
    _min?: VisitorMinOrderByAggregateInput
    _sum?: VisitorSumOrderByAggregateInput
  }

  export type VisitorScalarWhereWithAggregatesInput = {
    AND?: VisitorScalarWhereWithAggregatesInput | VisitorScalarWhereWithAggregatesInput[]
    OR?: VisitorScalarWhereWithAggregatesInput[]
    NOT?: VisitorScalarWhereWithAggregatesInput | VisitorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Visitor"> | number
    name?: StringWithAggregatesFilter<"Visitor"> | string
    phone?: StringWithAggregatesFilter<"Visitor"> | string
    vehicleNo?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    purpose?: StringWithAggregatesFilter<"Visitor"> | string
    photo?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    status?: EnumVisitorStatusWithAggregatesFilter<"Visitor"> | $Enums.VisitorStatus
    entryTime?: DateTimeNullableWithAggregatesFilter<"Visitor"> | Date | string | null
    exitTime?: DateTimeNullableWithAggregatesFilter<"Visitor"> | Date | string | null
    societyId?: IntWithAggregatesFilter<"Visitor"> | number
    visitingUnitId?: IntWithAggregatesFilter<"Visitor"> | number
    idType?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    idNumber?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Visitor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Visitor"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    category?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    status?: StringFilter<"Transaction"> | string
    societyId?: IntFilter<"Transaction"> | number
    invoiceNo?: StringNullableFilter<"Transaction"> | string | null
    paidTo?: StringNullableFilter<"Transaction"> | string | null
    receivedFrom?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    invoiceNo?: SortOrderInput | SortOrder
    paidTo?: SortOrderInput | SortOrder
    receivedFrom?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    _relevance?: TransactionOrderByRelevanceInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    category?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    status?: StringFilter<"Transaction"> | string
    societyId?: IntFilter<"Transaction"> | number
    invoiceNo?: StringNullableFilter<"Transaction"> | string | null
    paidTo?: StringNullableFilter<"Transaction"> | string | null
    receivedFrom?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    invoiceNo?: SortOrderInput | SortOrder
    paidTo?: SortOrderInput | SortOrder
    receivedFrom?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    category?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    date?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Transaction"> | $Enums.PaymentMethod
    status?: StringWithAggregatesFilter<"Transaction"> | string
    societyId?: IntWithAggregatesFilter<"Transaction"> | number
    invoiceNo?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    paidTo?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    receivedFrom?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: IntFilter<"Vendor"> | number
    name?: StringFilter<"Vendor"> | string
    serviceType?: StringFilter<"Vendor"> | string
    contact?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    status?: EnumVendorStatusFilter<"Vendor"> | $Enums.VendorStatus
    societyId?: IntNullableFilter<"Vendor"> | number | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    society?: XOR<SocietyNullableScalarRelationFilter, SocietyWhereInput> | null
    payouts?: VendorPayoutListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    contact?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    societyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    payouts?: VendorPayoutOrderByRelationAggregateInput
    _relevance?: VendorOrderByRelevanceInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    name?: StringFilter<"Vendor"> | string
    serviceType?: StringFilter<"Vendor"> | string
    contact?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    status?: EnumVendorStatusFilter<"Vendor"> | $Enums.VendorStatus
    societyId?: IntNullableFilter<"Vendor"> | number | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    society?: XOR<SocietyNullableScalarRelationFilter, SocietyWhereInput> | null
    payouts?: VendorPayoutListRelationFilter
  }, "id">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    contact?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    societyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vendor"> | number
    name?: StringWithAggregatesFilter<"Vendor"> | string
    serviceType?: StringWithAggregatesFilter<"Vendor"> | string
    contact?: StringWithAggregatesFilter<"Vendor"> | string
    email?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    address?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    status?: EnumVendorStatusWithAggregatesFilter<"Vendor"> | $Enums.VendorStatus
    societyId?: IntNullableWithAggregatesFilter<"Vendor"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
  }

  export type VendorPayoutWhereInput = {
    AND?: VendorPayoutWhereInput | VendorPayoutWhereInput[]
    OR?: VendorPayoutWhereInput[]
    NOT?: VendorPayoutWhereInput | VendorPayoutWhereInput[]
    id?: IntFilter<"VendorPayout"> | number
    vendorId?: IntFilter<"VendorPayout"> | number
    vendorName?: StringFilter<"VendorPayout"> | string
    societyId?: IntNullableFilter<"VendorPayout"> | number | null
    societyName?: StringNullableFilter<"VendorPayout"> | string | null
    dealValue?: FloatFilter<"VendorPayout"> | number
    commissionPercent?: FloatFilter<"VendorPayout"> | number
    payableAmount?: FloatFilter<"VendorPayout"> | number
    status?: StringFilter<"VendorPayout"> | string
    remarks?: StringNullableFilter<"VendorPayout"> | string | null
    date?: DateTimeFilter<"VendorPayout"> | Date | string
    createdAt?: DateTimeFilter<"VendorPayout"> | Date | string
    updatedAt?: DateTimeFilter<"VendorPayout"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }

  export type VendorPayoutOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    societyId?: SortOrderInput | SortOrder
    societyName?: SortOrderInput | SortOrder
    dealValue?: SortOrder
    commissionPercent?: SortOrder
    payableAmount?: SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    _relevance?: VendorPayoutOrderByRelevanceInput
  }

  export type VendorPayoutWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VendorPayoutWhereInput | VendorPayoutWhereInput[]
    OR?: VendorPayoutWhereInput[]
    NOT?: VendorPayoutWhereInput | VendorPayoutWhereInput[]
    vendorId?: IntFilter<"VendorPayout"> | number
    vendorName?: StringFilter<"VendorPayout"> | string
    societyId?: IntNullableFilter<"VendorPayout"> | number | null
    societyName?: StringNullableFilter<"VendorPayout"> | string | null
    dealValue?: FloatFilter<"VendorPayout"> | number
    commissionPercent?: FloatFilter<"VendorPayout"> | number
    payableAmount?: FloatFilter<"VendorPayout"> | number
    status?: StringFilter<"VendorPayout"> | string
    remarks?: StringNullableFilter<"VendorPayout"> | string | null
    date?: DateTimeFilter<"VendorPayout"> | Date | string
    createdAt?: DateTimeFilter<"VendorPayout"> | Date | string
    updatedAt?: DateTimeFilter<"VendorPayout"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }, "id">

  export type VendorPayoutOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    societyId?: SortOrderInput | SortOrder
    societyName?: SortOrderInput | SortOrder
    dealValue?: SortOrder
    commissionPercent?: SortOrder
    payableAmount?: SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorPayoutCountOrderByAggregateInput
    _avg?: VendorPayoutAvgOrderByAggregateInput
    _max?: VendorPayoutMaxOrderByAggregateInput
    _min?: VendorPayoutMinOrderByAggregateInput
    _sum?: VendorPayoutSumOrderByAggregateInput
  }

  export type VendorPayoutScalarWhereWithAggregatesInput = {
    AND?: VendorPayoutScalarWhereWithAggregatesInput | VendorPayoutScalarWhereWithAggregatesInput[]
    OR?: VendorPayoutScalarWhereWithAggregatesInput[]
    NOT?: VendorPayoutScalarWhereWithAggregatesInput | VendorPayoutScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VendorPayout"> | number
    vendorId?: IntWithAggregatesFilter<"VendorPayout"> | number
    vendorName?: StringWithAggregatesFilter<"VendorPayout"> | string
    societyId?: IntNullableWithAggregatesFilter<"VendorPayout"> | number | null
    societyName?: StringNullableWithAggregatesFilter<"VendorPayout"> | string | null
    dealValue?: FloatWithAggregatesFilter<"VendorPayout"> | number
    commissionPercent?: FloatWithAggregatesFilter<"VendorPayout"> | number
    payableAmount?: FloatWithAggregatesFilter<"VendorPayout"> | number
    status?: StringWithAggregatesFilter<"VendorPayout"> | string
    remarks?: StringNullableWithAggregatesFilter<"VendorPayout"> | string | null
    date?: DateTimeWithAggregatesFilter<"VendorPayout"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"VendorPayout"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VendorPayout"> | Date | string
  }

  export type EmergencyLogWhereInput = {
    AND?: EmergencyLogWhereInput | EmergencyLogWhereInput[]
    OR?: EmergencyLogWhereInput[]
    NOT?: EmergencyLogWhereInput | EmergencyLogWhereInput[]
    id?: StringFilter<"EmergencyLog"> | string
    timestamp?: DateTimeFilter<"EmergencyLog"> | Date | string
    visitorName?: StringFilter<"EmergencyLog"> | string
    visitorPhone?: StringFilter<"EmergencyLog"> | string
    residentName?: StringFilter<"EmergencyLog"> | string
    unit?: StringFilter<"EmergencyLog"> | string
    isEmergency?: BoolFilter<"EmergencyLog"> | boolean
    reason?: StringNullableFilter<"EmergencyLog"> | string | null
    barcodeId?: StringFilter<"EmergencyLog"> | string
    societyId?: IntNullableFilter<"EmergencyLog"> | number | null
  }

  export type EmergencyLogOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    visitorName?: SortOrder
    visitorPhone?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    isEmergency?: SortOrder
    reason?: SortOrderInput | SortOrder
    barcodeId?: SortOrder
    societyId?: SortOrderInput | SortOrder
    _relevance?: EmergencyLogOrderByRelevanceInput
  }

  export type EmergencyLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmergencyLogWhereInput | EmergencyLogWhereInput[]
    OR?: EmergencyLogWhereInput[]
    NOT?: EmergencyLogWhereInput | EmergencyLogWhereInput[]
    timestamp?: DateTimeFilter<"EmergencyLog"> | Date | string
    visitorName?: StringFilter<"EmergencyLog"> | string
    visitorPhone?: StringFilter<"EmergencyLog"> | string
    residentName?: StringFilter<"EmergencyLog"> | string
    unit?: StringFilter<"EmergencyLog"> | string
    isEmergency?: BoolFilter<"EmergencyLog"> | boolean
    reason?: StringNullableFilter<"EmergencyLog"> | string | null
    barcodeId?: StringFilter<"EmergencyLog"> | string
    societyId?: IntNullableFilter<"EmergencyLog"> | number | null
  }, "id">

  export type EmergencyLogOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    visitorName?: SortOrder
    visitorPhone?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    isEmergency?: SortOrder
    reason?: SortOrderInput | SortOrder
    barcodeId?: SortOrder
    societyId?: SortOrderInput | SortOrder
    _count?: EmergencyLogCountOrderByAggregateInput
    _avg?: EmergencyLogAvgOrderByAggregateInput
    _max?: EmergencyLogMaxOrderByAggregateInput
    _min?: EmergencyLogMinOrderByAggregateInput
    _sum?: EmergencyLogSumOrderByAggregateInput
  }

  export type EmergencyLogScalarWhereWithAggregatesInput = {
    AND?: EmergencyLogScalarWhereWithAggregatesInput | EmergencyLogScalarWhereWithAggregatesInput[]
    OR?: EmergencyLogScalarWhereWithAggregatesInput[]
    NOT?: EmergencyLogScalarWhereWithAggregatesInput | EmergencyLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmergencyLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"EmergencyLog"> | Date | string
    visitorName?: StringWithAggregatesFilter<"EmergencyLog"> | string
    visitorPhone?: StringWithAggregatesFilter<"EmergencyLog"> | string
    residentName?: StringWithAggregatesFilter<"EmergencyLog"> | string
    unit?: StringWithAggregatesFilter<"EmergencyLog"> | string
    isEmergency?: BoolWithAggregatesFilter<"EmergencyLog"> | boolean
    reason?: StringNullableWithAggregatesFilter<"EmergencyLog"> | string | null
    barcodeId?: StringWithAggregatesFilter<"EmergencyLog"> | string
    societyId?: IntNullableWithAggregatesFilter<"EmergencyLog"> | number | null
  }

  export type EmergencyBarcodeWhereInput = {
    AND?: EmergencyBarcodeWhereInput | EmergencyBarcodeWhereInput[]
    OR?: EmergencyBarcodeWhereInput[]
    NOT?: EmergencyBarcodeWhereInput | EmergencyBarcodeWhereInput[]
    id?: StringFilter<"EmergencyBarcode"> | string
    residentName?: StringFilter<"EmergencyBarcode"> | string
    unit?: StringFilter<"EmergencyBarcode"> | string
    phone?: StringFilter<"EmergencyBarcode"> | string
    label?: StringNullableFilter<"EmergencyBarcode"> | string | null
    type?: StringNullableFilter<"EmergencyBarcode"> | string | null
    status?: StringFilter<"EmergencyBarcode"> | string
    qrCodeUrl?: StringFilter<"EmergencyBarcode"> | string
    createdAt?: DateTimeFilter<"EmergencyBarcode"> | Date | string
    societyId?: IntNullableFilter<"EmergencyBarcode"> | number | null
  }

  export type EmergencyBarcodeOrderByWithRelationInput = {
    id?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    phone?: SortOrder
    label?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    status?: SortOrder
    qrCodeUrl?: SortOrder
    createdAt?: SortOrder
    societyId?: SortOrderInput | SortOrder
    _relevance?: EmergencyBarcodeOrderByRelevanceInput
  }

  export type EmergencyBarcodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmergencyBarcodeWhereInput | EmergencyBarcodeWhereInput[]
    OR?: EmergencyBarcodeWhereInput[]
    NOT?: EmergencyBarcodeWhereInput | EmergencyBarcodeWhereInput[]
    residentName?: StringFilter<"EmergencyBarcode"> | string
    unit?: StringFilter<"EmergencyBarcode"> | string
    phone?: StringFilter<"EmergencyBarcode"> | string
    label?: StringNullableFilter<"EmergencyBarcode"> | string | null
    type?: StringNullableFilter<"EmergencyBarcode"> | string | null
    status?: StringFilter<"EmergencyBarcode"> | string
    qrCodeUrl?: StringFilter<"EmergencyBarcode"> | string
    createdAt?: DateTimeFilter<"EmergencyBarcode"> | Date | string
    societyId?: IntNullableFilter<"EmergencyBarcode"> | number | null
  }, "id">

  export type EmergencyBarcodeOrderByWithAggregationInput = {
    id?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    phone?: SortOrder
    label?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    status?: SortOrder
    qrCodeUrl?: SortOrder
    createdAt?: SortOrder
    societyId?: SortOrderInput | SortOrder
    _count?: EmergencyBarcodeCountOrderByAggregateInput
    _avg?: EmergencyBarcodeAvgOrderByAggregateInput
    _max?: EmergencyBarcodeMaxOrderByAggregateInput
    _min?: EmergencyBarcodeMinOrderByAggregateInput
    _sum?: EmergencyBarcodeSumOrderByAggregateInput
  }

  export type EmergencyBarcodeScalarWhereWithAggregatesInput = {
    AND?: EmergencyBarcodeScalarWhereWithAggregatesInput | EmergencyBarcodeScalarWhereWithAggregatesInput[]
    OR?: EmergencyBarcodeScalarWhereWithAggregatesInput[]
    NOT?: EmergencyBarcodeScalarWhereWithAggregatesInput | EmergencyBarcodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmergencyBarcode"> | string
    residentName?: StringWithAggregatesFilter<"EmergencyBarcode"> | string
    unit?: StringWithAggregatesFilter<"EmergencyBarcode"> | string
    phone?: StringWithAggregatesFilter<"EmergencyBarcode"> | string
    label?: StringNullableWithAggregatesFilter<"EmergencyBarcode"> | string | null
    type?: StringNullableWithAggregatesFilter<"EmergencyBarcode"> | string | null
    status?: StringWithAggregatesFilter<"EmergencyBarcode"> | string
    qrCodeUrl?: StringWithAggregatesFilter<"EmergencyBarcode"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmergencyBarcode"> | Date | string
    societyId?: IntNullableWithAggregatesFilter<"EmergencyBarcode"> | number | null
  }

  export type EmergencyAlertWhereInput = {
    AND?: EmergencyAlertWhereInput | EmergencyAlertWhereInput[]
    OR?: EmergencyAlertWhereInput[]
    NOT?: EmergencyAlertWhereInput | EmergencyAlertWhereInput[]
    id?: IntFilter<"EmergencyAlert"> | number
    type?: StringFilter<"EmergencyAlert"> | string
    unit?: StringNullableFilter<"EmergencyAlert"> | string | null
    description?: StringNullableFilter<"EmergencyAlert"> | string | null
    status?: StringFilter<"EmergencyAlert"> | string
    resolution?: StringNullableFilter<"EmergencyAlert"> | string | null
    societyId?: IntFilter<"EmergencyAlert"> | number
    userId?: IntFilter<"EmergencyAlert"> | number
    createdAt?: DateTimeFilter<"EmergencyAlert"> | Date | string
    updatedAt?: DateTimeFilter<"EmergencyAlert"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmergencyAlertOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    unit?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    resolution?: SortOrderInput | SortOrder
    societyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: EmergencyAlertOrderByRelevanceInput
  }

  export type EmergencyAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmergencyAlertWhereInput | EmergencyAlertWhereInput[]
    OR?: EmergencyAlertWhereInput[]
    NOT?: EmergencyAlertWhereInput | EmergencyAlertWhereInput[]
    type?: StringFilter<"EmergencyAlert"> | string
    unit?: StringNullableFilter<"EmergencyAlert"> | string | null
    description?: StringNullableFilter<"EmergencyAlert"> | string | null
    status?: StringFilter<"EmergencyAlert"> | string
    resolution?: StringNullableFilter<"EmergencyAlert"> | string | null
    societyId?: IntFilter<"EmergencyAlert"> | number
    userId?: IntFilter<"EmergencyAlert"> | number
    createdAt?: DateTimeFilter<"EmergencyAlert"> | Date | string
    updatedAt?: DateTimeFilter<"EmergencyAlert"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type EmergencyAlertOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    unit?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    resolution?: SortOrderInput | SortOrder
    societyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmergencyAlertCountOrderByAggregateInput
    _avg?: EmergencyAlertAvgOrderByAggregateInput
    _max?: EmergencyAlertMaxOrderByAggregateInput
    _min?: EmergencyAlertMinOrderByAggregateInput
    _sum?: EmergencyAlertSumOrderByAggregateInput
  }

  export type EmergencyAlertScalarWhereWithAggregatesInput = {
    AND?: EmergencyAlertScalarWhereWithAggregatesInput | EmergencyAlertScalarWhereWithAggregatesInput[]
    OR?: EmergencyAlertScalarWhereWithAggregatesInput[]
    NOT?: EmergencyAlertScalarWhereWithAggregatesInput | EmergencyAlertScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmergencyAlert"> | number
    type?: StringWithAggregatesFilter<"EmergencyAlert"> | string
    unit?: StringNullableWithAggregatesFilter<"EmergencyAlert"> | string | null
    description?: StringNullableWithAggregatesFilter<"EmergencyAlert"> | string | null
    status?: StringWithAggregatesFilter<"EmergencyAlert"> | string
    resolution?: StringNullableWithAggregatesFilter<"EmergencyAlert"> | string | null
    societyId?: IntWithAggregatesFilter<"EmergencyAlert"> | number
    userId?: IntWithAggregatesFilter<"EmergencyAlert"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EmergencyAlert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmergencyAlert"> | Date | string
  }

  export type EmergencyContactWhereInput = {
    AND?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    OR?: EmergencyContactWhereInput[]
    NOT?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    id?: IntFilter<"EmergencyContact"> | number
    name?: StringFilter<"EmergencyContact"> | string
    phone?: StringFilter<"EmergencyContact"> | string
    category?: StringFilter<"EmergencyContact"> | string
    available?: BoolFilter<"EmergencyContact"> | boolean
    societyId?: IntNullableFilter<"EmergencyContact"> | number | null
    residentId?: IntNullableFilter<"EmergencyContact"> | number | null
    createdAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    society?: XOR<SocietyNullableScalarRelationFilter, SocietyWhereInput> | null
    resident?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type EmergencyContactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    category?: SortOrder
    available?: SortOrder
    societyId?: SortOrderInput | SortOrder
    residentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    resident?: UserOrderByWithRelationInput
    _relevance?: EmergencyContactOrderByRelevanceInput
  }

  export type EmergencyContactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    OR?: EmergencyContactWhereInput[]
    NOT?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    name?: StringFilter<"EmergencyContact"> | string
    phone?: StringFilter<"EmergencyContact"> | string
    category?: StringFilter<"EmergencyContact"> | string
    available?: BoolFilter<"EmergencyContact"> | boolean
    societyId?: IntNullableFilter<"EmergencyContact"> | number | null
    residentId?: IntNullableFilter<"EmergencyContact"> | number | null
    createdAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    society?: XOR<SocietyNullableScalarRelationFilter, SocietyWhereInput> | null
    resident?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type EmergencyContactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    category?: SortOrder
    available?: SortOrder
    societyId?: SortOrderInput | SortOrder
    residentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmergencyContactCountOrderByAggregateInput
    _avg?: EmergencyContactAvgOrderByAggregateInput
    _max?: EmergencyContactMaxOrderByAggregateInput
    _min?: EmergencyContactMinOrderByAggregateInput
    _sum?: EmergencyContactSumOrderByAggregateInput
  }

  export type EmergencyContactScalarWhereWithAggregatesInput = {
    AND?: EmergencyContactScalarWhereWithAggregatesInput | EmergencyContactScalarWhereWithAggregatesInput[]
    OR?: EmergencyContactScalarWhereWithAggregatesInput[]
    NOT?: EmergencyContactScalarWhereWithAggregatesInput | EmergencyContactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmergencyContact"> | number
    name?: StringWithAggregatesFilter<"EmergencyContact"> | string
    phone?: StringWithAggregatesFilter<"EmergencyContact"> | string
    category?: StringWithAggregatesFilter<"EmergencyContact"> | string
    available?: BoolWithAggregatesFilter<"EmergencyContact"> | boolean
    societyId?: IntNullableWithAggregatesFilter<"EmergencyContact"> | number | null
    residentId?: IntNullableWithAggregatesFilter<"EmergencyContact"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"EmergencyContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmergencyContact"> | Date | string
  }

  export type NoticeWhereInput = {
    AND?: NoticeWhereInput | NoticeWhereInput[]
    OR?: NoticeWhereInput[]
    NOT?: NoticeWhereInput | NoticeWhereInput[]
    id?: IntFilter<"Notice"> | number
    title?: StringFilter<"Notice"> | string
    content?: StringFilter<"Notice"> | string
    audience?: StringFilter<"Notice"> | string
    societyId?: IntFilter<"Notice"> | number
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notice"> | Date | string | null
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type NoticeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    society?: SocietyOrderByWithRelationInput
    _relevance?: NoticeOrderByRelevanceInput
  }

  export type NoticeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NoticeWhereInput | NoticeWhereInput[]
    OR?: NoticeWhereInput[]
    NOT?: NoticeWhereInput | NoticeWhereInput[]
    title?: StringFilter<"Notice"> | string
    content?: StringFilter<"Notice"> | string
    audience?: StringFilter<"Notice"> | string
    societyId?: IntFilter<"Notice"> | number
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notice"> | Date | string | null
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id">

  export type NoticeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: NoticeCountOrderByAggregateInput
    _avg?: NoticeAvgOrderByAggregateInput
    _max?: NoticeMaxOrderByAggregateInput
    _min?: NoticeMinOrderByAggregateInput
    _sum?: NoticeSumOrderByAggregateInput
  }

  export type NoticeScalarWhereWithAggregatesInput = {
    AND?: NoticeScalarWhereWithAggregatesInput | NoticeScalarWhereWithAggregatesInput[]
    OR?: NoticeScalarWhereWithAggregatesInput[]
    NOT?: NoticeScalarWhereWithAggregatesInput | NoticeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notice"> | number
    title?: StringWithAggregatesFilter<"Notice"> | string
    content?: StringWithAggregatesFilter<"Notice"> | string
    audience?: StringWithAggregatesFilter<"Notice"> | string
    societyId?: IntWithAggregatesFilter<"Notice"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Notice"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Notice"> | Date | string | null
  }

  export type AmenityWhereInput = {
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    id?: IntFilter<"Amenity"> | number
    name?: StringFilter<"Amenity"> | string
    type?: StringFilter<"Amenity"> | string
    description?: StringNullableFilter<"Amenity"> | string | null
    capacity?: IntFilter<"Amenity"> | number
    chargesPerHour?: FloatFilter<"Amenity"> | number
    availableDays?: JsonNullableFilter<"Amenity">
    timings?: JsonNullableFilter<"Amenity">
    status?: StringFilter<"Amenity"> | string
    societyId?: IntFilter<"Amenity"> | number
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
    updatedAt?: DateTimeFilter<"Amenity"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    bookings?: AmenityBookingListRelationFilter
  }

  export type AmenityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    capacity?: SortOrder
    chargesPerHour?: SortOrder
    availableDays?: SortOrderInput | SortOrder
    timings?: SortOrderInput | SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    bookings?: AmenityBookingOrderByRelationAggregateInput
    _relevance?: AmenityOrderByRelevanceInput
  }

  export type AmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    name?: StringFilter<"Amenity"> | string
    type?: StringFilter<"Amenity"> | string
    description?: StringNullableFilter<"Amenity"> | string | null
    capacity?: IntFilter<"Amenity"> | number
    chargesPerHour?: FloatFilter<"Amenity"> | number
    availableDays?: JsonNullableFilter<"Amenity">
    timings?: JsonNullableFilter<"Amenity">
    status?: StringFilter<"Amenity"> | string
    societyId?: IntFilter<"Amenity"> | number
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
    updatedAt?: DateTimeFilter<"Amenity"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    bookings?: AmenityBookingListRelationFilter
  }, "id">

  export type AmenityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    capacity?: SortOrder
    chargesPerHour?: SortOrder
    availableDays?: SortOrderInput | SortOrder
    timings?: SortOrderInput | SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AmenityCountOrderByAggregateInput
    _avg?: AmenityAvgOrderByAggregateInput
    _max?: AmenityMaxOrderByAggregateInput
    _min?: AmenityMinOrderByAggregateInput
    _sum?: AmenitySumOrderByAggregateInput
  }

  export type AmenityScalarWhereWithAggregatesInput = {
    AND?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    OR?: AmenityScalarWhereWithAggregatesInput[]
    NOT?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Amenity"> | number
    name?: StringWithAggregatesFilter<"Amenity"> | string
    type?: StringWithAggregatesFilter<"Amenity"> | string
    description?: StringNullableWithAggregatesFilter<"Amenity"> | string | null
    capacity?: IntWithAggregatesFilter<"Amenity"> | number
    chargesPerHour?: FloatWithAggregatesFilter<"Amenity"> | number
    availableDays?: JsonNullableWithAggregatesFilter<"Amenity">
    timings?: JsonNullableWithAggregatesFilter<"Amenity">
    status?: StringWithAggregatesFilter<"Amenity"> | string
    societyId?: IntWithAggregatesFilter<"Amenity"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Amenity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Amenity"> | Date | string
  }

  export type AmenityBookingWhereInput = {
    AND?: AmenityBookingWhereInput | AmenityBookingWhereInput[]
    OR?: AmenityBookingWhereInput[]
    NOT?: AmenityBookingWhereInput | AmenityBookingWhereInput[]
    id?: IntFilter<"AmenityBooking"> | number
    amenityId?: IntFilter<"AmenityBooking"> | number
    userId?: IntFilter<"AmenityBooking"> | number
    date?: DateTimeFilter<"AmenityBooking"> | Date | string
    startTime?: StringFilter<"AmenityBooking"> | string
    endTime?: StringFilter<"AmenityBooking"> | string
    purpose?: StringNullableFilter<"AmenityBooking"> | string | null
    status?: StringFilter<"AmenityBooking"> | string
    amountPaid?: FloatFilter<"AmenityBooking"> | number
    createdAt?: DateTimeFilter<"AmenityBooking"> | Date | string
    updatedAt?: DateTimeFilter<"AmenityBooking"> | Date | string
    amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AmenityBookingOrderByWithRelationInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    purpose?: SortOrderInput | SortOrder
    status?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    amenity?: AmenityOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: AmenityBookingOrderByRelevanceInput
  }

  export type AmenityBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AmenityBookingWhereInput | AmenityBookingWhereInput[]
    OR?: AmenityBookingWhereInput[]
    NOT?: AmenityBookingWhereInput | AmenityBookingWhereInput[]
    amenityId?: IntFilter<"AmenityBooking"> | number
    userId?: IntFilter<"AmenityBooking"> | number
    date?: DateTimeFilter<"AmenityBooking"> | Date | string
    startTime?: StringFilter<"AmenityBooking"> | string
    endTime?: StringFilter<"AmenityBooking"> | string
    purpose?: StringNullableFilter<"AmenityBooking"> | string | null
    status?: StringFilter<"AmenityBooking"> | string
    amountPaid?: FloatFilter<"AmenityBooking"> | number
    createdAt?: DateTimeFilter<"AmenityBooking"> | Date | string
    updatedAt?: DateTimeFilter<"AmenityBooking"> | Date | string
    amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AmenityBookingOrderByWithAggregationInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    purpose?: SortOrderInput | SortOrder
    status?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AmenityBookingCountOrderByAggregateInput
    _avg?: AmenityBookingAvgOrderByAggregateInput
    _max?: AmenityBookingMaxOrderByAggregateInput
    _min?: AmenityBookingMinOrderByAggregateInput
    _sum?: AmenityBookingSumOrderByAggregateInput
  }

  export type AmenityBookingScalarWhereWithAggregatesInput = {
    AND?: AmenityBookingScalarWhereWithAggregatesInput | AmenityBookingScalarWhereWithAggregatesInput[]
    OR?: AmenityBookingScalarWhereWithAggregatesInput[]
    NOT?: AmenityBookingScalarWhereWithAggregatesInput | AmenityBookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AmenityBooking"> | number
    amenityId?: IntWithAggregatesFilter<"AmenityBooking"> | number
    userId?: IntWithAggregatesFilter<"AmenityBooking"> | number
    date?: DateTimeWithAggregatesFilter<"AmenityBooking"> | Date | string
    startTime?: StringWithAggregatesFilter<"AmenityBooking"> | string
    endTime?: StringWithAggregatesFilter<"AmenityBooking"> | string
    purpose?: StringNullableWithAggregatesFilter<"AmenityBooking"> | string | null
    status?: StringWithAggregatesFilter<"AmenityBooking"> | string
    amountPaid?: FloatWithAggregatesFilter<"AmenityBooking"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AmenityBooking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AmenityBooking"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: IntFilter<"SystemSetting"> | number
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _relevance?: SystemSettingOrderByRelevanceInput
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: StringFilter<"SystemSetting"> | string
  }, "id" | "key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _avg?: SystemSettingAvgOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
    _sum?: SystemSettingSumOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemSetting"> | number
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringWithAggregatesFilter<"SystemSetting"> | string
  }

  export type BillingPlanWhereInput = {
    AND?: BillingPlanWhereInput | BillingPlanWhereInput[]
    OR?: BillingPlanWhereInput[]
    NOT?: BillingPlanWhereInput | BillingPlanWhereInput[]
    id?: IntFilter<"BillingPlan"> | number
    name?: StringFilter<"BillingPlan"> | string
    type?: StringFilter<"BillingPlan"> | string
    price?: StringFilter<"BillingPlan"> | string
    description?: StringNullableFilter<"BillingPlan"> | string | null
    status?: StringFilter<"BillingPlan"> | string
    createdAt?: DateTimeFilter<"BillingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"BillingPlan"> | Date | string
  }

  export type BillingPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: BillingPlanOrderByRelevanceInput
  }

  export type BillingPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BillingPlanWhereInput | BillingPlanWhereInput[]
    OR?: BillingPlanWhereInput[]
    NOT?: BillingPlanWhereInput | BillingPlanWhereInput[]
    name?: StringFilter<"BillingPlan"> | string
    type?: StringFilter<"BillingPlan"> | string
    price?: StringFilter<"BillingPlan"> | string
    description?: StringNullableFilter<"BillingPlan"> | string | null
    status?: StringFilter<"BillingPlan"> | string
    createdAt?: DateTimeFilter<"BillingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"BillingPlan"> | Date | string
  }, "id">

  export type BillingPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillingPlanCountOrderByAggregateInput
    _avg?: BillingPlanAvgOrderByAggregateInput
    _max?: BillingPlanMaxOrderByAggregateInput
    _min?: BillingPlanMinOrderByAggregateInput
    _sum?: BillingPlanSumOrderByAggregateInput
  }

  export type BillingPlanScalarWhereWithAggregatesInput = {
    AND?: BillingPlanScalarWhereWithAggregatesInput | BillingPlanScalarWhereWithAggregatesInput[]
    OR?: BillingPlanScalarWhereWithAggregatesInput[]
    NOT?: BillingPlanScalarWhereWithAggregatesInput | BillingPlanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BillingPlan"> | number
    name?: StringWithAggregatesFilter<"BillingPlan"> | string
    type?: StringWithAggregatesFilter<"BillingPlan"> | string
    price?: StringWithAggregatesFilter<"BillingPlan"> | string
    description?: StringNullableWithAggregatesFilter<"BillingPlan"> | string | null
    status?: StringWithAggregatesFilter<"BillingPlan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BillingPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillingPlan"> | Date | string
  }

  export type PlatformInvoiceWhereInput = {
    AND?: PlatformInvoiceWhereInput | PlatformInvoiceWhereInput[]
    OR?: PlatformInvoiceWhereInput[]
    NOT?: PlatformInvoiceWhereInput | PlatformInvoiceWhereInput[]
    id?: IntFilter<"PlatformInvoice"> | number
    invoiceNo?: StringFilter<"PlatformInvoice"> | string
    societyId?: IntFilter<"PlatformInvoice"> | number
    amount?: FloatFilter<"PlatformInvoice"> | number
    status?: StringFilter<"PlatformInvoice"> | string
    issueDate?: DateTimeFilter<"PlatformInvoice"> | Date | string
    dueDate?: DateTimeFilter<"PlatformInvoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"PlatformInvoice"> | Date | string | null
    createdAt?: DateTimeFilter<"PlatformInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformInvoice"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type PlatformInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    societyId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    _relevance?: PlatformInvoiceOrderByRelevanceInput
  }

  export type PlatformInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    invoiceNo?: string
    AND?: PlatformInvoiceWhereInput | PlatformInvoiceWhereInput[]
    OR?: PlatformInvoiceWhereInput[]
    NOT?: PlatformInvoiceWhereInput | PlatformInvoiceWhereInput[]
    societyId?: IntFilter<"PlatformInvoice"> | number
    amount?: FloatFilter<"PlatformInvoice"> | number
    status?: StringFilter<"PlatformInvoice"> | string
    issueDate?: DateTimeFilter<"PlatformInvoice"> | Date | string
    dueDate?: DateTimeFilter<"PlatformInvoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"PlatformInvoice"> | Date | string | null
    createdAt?: DateTimeFilter<"PlatformInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformInvoice"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id" | "invoiceNo">

  export type PlatformInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    societyId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlatformInvoiceCountOrderByAggregateInput
    _avg?: PlatformInvoiceAvgOrderByAggregateInput
    _max?: PlatformInvoiceMaxOrderByAggregateInput
    _min?: PlatformInvoiceMinOrderByAggregateInput
    _sum?: PlatformInvoiceSumOrderByAggregateInput
  }

  export type PlatformInvoiceScalarWhereWithAggregatesInput = {
    AND?: PlatformInvoiceScalarWhereWithAggregatesInput | PlatformInvoiceScalarWhereWithAggregatesInput[]
    OR?: PlatformInvoiceScalarWhereWithAggregatesInput[]
    NOT?: PlatformInvoiceScalarWhereWithAggregatesInput | PlatformInvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlatformInvoice"> | number
    invoiceNo?: StringWithAggregatesFilter<"PlatformInvoice"> | string
    societyId?: IntWithAggregatesFilter<"PlatformInvoice"> | number
    amount?: FloatWithAggregatesFilter<"PlatformInvoice"> | number
    status?: StringWithAggregatesFilter<"PlatformInvoice"> | string
    issueDate?: DateTimeWithAggregatesFilter<"PlatformInvoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"PlatformInvoice"> | Date | string
    paidDate?: DateTimeNullableWithAggregatesFilter<"PlatformInvoice"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlatformInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlatformInvoice"> | Date | string
  }

  export type CommunityBuzzWhereInput = {
    AND?: CommunityBuzzWhereInput | CommunityBuzzWhereInput[]
    OR?: CommunityBuzzWhereInput[]
    NOT?: CommunityBuzzWhereInput | CommunityBuzzWhereInput[]
    id?: IntFilter<"CommunityBuzz"> | number
    type?: StringFilter<"CommunityBuzz"> | string
    title?: StringFilter<"CommunityBuzz"> | string
    content?: StringNullableFilter<"CommunityBuzz"> | string | null
    authorId?: IntFilter<"CommunityBuzz"> | number
    societyId?: IntFilter<"CommunityBuzz"> | number
    hasResult?: BoolFilter<"CommunityBuzz"> | boolean
    imageUrls?: JsonNullableFilter<"CommunityBuzz">
    likes?: IntFilter<"CommunityBuzz"> | number
    createdAt?: DateTimeFilter<"CommunityBuzz"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    comments?: CommunityCommentListRelationFilter
    likedBy?: BuzzLikeListRelationFilter
  }

  export type CommunityBuzzOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    authorId?: SortOrder
    societyId?: SortOrder
    hasResult?: SortOrder
    imageUrls?: SortOrderInput | SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    author?: UserOrderByWithRelationInput
    society?: SocietyOrderByWithRelationInput
    comments?: CommunityCommentOrderByRelationAggregateInput
    likedBy?: BuzzLikeOrderByRelationAggregateInput
    _relevance?: CommunityBuzzOrderByRelevanceInput
  }

  export type CommunityBuzzWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommunityBuzzWhereInput | CommunityBuzzWhereInput[]
    OR?: CommunityBuzzWhereInput[]
    NOT?: CommunityBuzzWhereInput | CommunityBuzzWhereInput[]
    type?: StringFilter<"CommunityBuzz"> | string
    title?: StringFilter<"CommunityBuzz"> | string
    content?: StringNullableFilter<"CommunityBuzz"> | string | null
    authorId?: IntFilter<"CommunityBuzz"> | number
    societyId?: IntFilter<"CommunityBuzz"> | number
    hasResult?: BoolFilter<"CommunityBuzz"> | boolean
    imageUrls?: JsonNullableFilter<"CommunityBuzz">
    likes?: IntFilter<"CommunityBuzz"> | number
    createdAt?: DateTimeFilter<"CommunityBuzz"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    comments?: CommunityCommentListRelationFilter
    likedBy?: BuzzLikeListRelationFilter
  }, "id">

  export type CommunityBuzzOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    authorId?: SortOrder
    societyId?: SortOrder
    hasResult?: SortOrder
    imageUrls?: SortOrderInput | SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    _count?: CommunityBuzzCountOrderByAggregateInput
    _avg?: CommunityBuzzAvgOrderByAggregateInput
    _max?: CommunityBuzzMaxOrderByAggregateInput
    _min?: CommunityBuzzMinOrderByAggregateInput
    _sum?: CommunityBuzzSumOrderByAggregateInput
  }

  export type CommunityBuzzScalarWhereWithAggregatesInput = {
    AND?: CommunityBuzzScalarWhereWithAggregatesInput | CommunityBuzzScalarWhereWithAggregatesInput[]
    OR?: CommunityBuzzScalarWhereWithAggregatesInput[]
    NOT?: CommunityBuzzScalarWhereWithAggregatesInput | CommunityBuzzScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommunityBuzz"> | number
    type?: StringWithAggregatesFilter<"CommunityBuzz"> | string
    title?: StringWithAggregatesFilter<"CommunityBuzz"> | string
    content?: StringNullableWithAggregatesFilter<"CommunityBuzz"> | string | null
    authorId?: IntWithAggregatesFilter<"CommunityBuzz"> | number
    societyId?: IntWithAggregatesFilter<"CommunityBuzz"> | number
    hasResult?: BoolWithAggregatesFilter<"CommunityBuzz"> | boolean
    imageUrls?: JsonNullableWithAggregatesFilter<"CommunityBuzz">
    likes?: IntWithAggregatesFilter<"CommunityBuzz"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CommunityBuzz"> | Date | string
  }

  export type CommunityCommentWhereInput = {
    AND?: CommunityCommentWhereInput | CommunityCommentWhereInput[]
    OR?: CommunityCommentWhereInput[]
    NOT?: CommunityCommentWhereInput | CommunityCommentWhereInput[]
    id?: IntFilter<"CommunityComment"> | number
    buzzId?: IntFilter<"CommunityComment"> | number
    authorId?: IntFilter<"CommunityComment"> | number
    content?: StringFilter<"CommunityComment"> | string
    createdAt?: DateTimeFilter<"CommunityComment"> | Date | string
    buzz?: XOR<CommunityBuzzScalarRelationFilter, CommunityBuzzWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CommunityCommentOrderByWithRelationInput = {
    id?: SortOrder
    buzzId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    buzz?: CommunityBuzzOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    _relevance?: CommunityCommentOrderByRelevanceInput
  }

  export type CommunityCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommunityCommentWhereInput | CommunityCommentWhereInput[]
    OR?: CommunityCommentWhereInput[]
    NOT?: CommunityCommentWhereInput | CommunityCommentWhereInput[]
    buzzId?: IntFilter<"CommunityComment"> | number
    authorId?: IntFilter<"CommunityComment"> | number
    content?: StringFilter<"CommunityComment"> | string
    createdAt?: DateTimeFilter<"CommunityComment"> | Date | string
    buzz?: XOR<CommunityBuzzScalarRelationFilter, CommunityBuzzWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CommunityCommentOrderByWithAggregationInput = {
    id?: SortOrder
    buzzId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: CommunityCommentCountOrderByAggregateInput
    _avg?: CommunityCommentAvgOrderByAggregateInput
    _max?: CommunityCommentMaxOrderByAggregateInput
    _min?: CommunityCommentMinOrderByAggregateInput
    _sum?: CommunityCommentSumOrderByAggregateInput
  }

  export type CommunityCommentScalarWhereWithAggregatesInput = {
    AND?: CommunityCommentScalarWhereWithAggregatesInput | CommunityCommentScalarWhereWithAggregatesInput[]
    OR?: CommunityCommentScalarWhereWithAggregatesInput[]
    NOT?: CommunityCommentScalarWhereWithAggregatesInput | CommunityCommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommunityComment"> | number
    buzzId?: IntWithAggregatesFilter<"CommunityComment"> | number
    authorId?: IntWithAggregatesFilter<"CommunityComment"> | number
    content?: StringWithAggregatesFilter<"CommunityComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CommunityComment"> | Date | string
  }

  export type BuzzLikeWhereInput = {
    AND?: BuzzLikeWhereInput | BuzzLikeWhereInput[]
    OR?: BuzzLikeWhereInput[]
    NOT?: BuzzLikeWhereInput | BuzzLikeWhereInput[]
    id?: IntFilter<"BuzzLike"> | number
    buzzId?: IntFilter<"BuzzLike"> | number
    userId?: IntFilter<"BuzzLike"> | number
    createdAt?: DateTimeFilter<"BuzzLike"> | Date | string
    buzz?: XOR<CommunityBuzzScalarRelationFilter, CommunityBuzzWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BuzzLikeOrderByWithRelationInput = {
    id?: SortOrder
    buzzId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    buzz?: CommunityBuzzOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BuzzLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    buzzId_userId?: BuzzLikeBuzzIdUserIdCompoundUniqueInput
    AND?: BuzzLikeWhereInput | BuzzLikeWhereInput[]
    OR?: BuzzLikeWhereInput[]
    NOT?: BuzzLikeWhereInput | BuzzLikeWhereInput[]
    buzzId?: IntFilter<"BuzzLike"> | number
    userId?: IntFilter<"BuzzLike"> | number
    createdAt?: DateTimeFilter<"BuzzLike"> | Date | string
    buzz?: XOR<CommunityBuzzScalarRelationFilter, CommunityBuzzWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "buzzId_userId">

  export type BuzzLikeOrderByWithAggregationInput = {
    id?: SortOrder
    buzzId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: BuzzLikeCountOrderByAggregateInput
    _avg?: BuzzLikeAvgOrderByAggregateInput
    _max?: BuzzLikeMaxOrderByAggregateInput
    _min?: BuzzLikeMinOrderByAggregateInput
    _sum?: BuzzLikeSumOrderByAggregateInput
  }

  export type BuzzLikeScalarWhereWithAggregatesInput = {
    AND?: BuzzLikeScalarWhereWithAggregatesInput | BuzzLikeScalarWhereWithAggregatesInput[]
    OR?: BuzzLikeScalarWhereWithAggregatesInput[]
    NOT?: BuzzLikeScalarWhereWithAggregatesInput | BuzzLikeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BuzzLike"> | number
    buzzId?: IntWithAggregatesFilter<"BuzzLike"> | number
    userId?: IntWithAggregatesFilter<"BuzzLike"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BuzzLike"> | Date | string
  }

  export type UnitMemberWhereInput = {
    AND?: UnitMemberWhereInput | UnitMemberWhereInput[]
    OR?: UnitMemberWhereInput[]
    NOT?: UnitMemberWhereInput | UnitMemberWhereInput[]
    id?: IntFilter<"UnitMember"> | number
    unitId?: IntFilter<"UnitMember"> | number
    name?: StringFilter<"UnitMember"> | string
    relation?: StringFilter<"UnitMember"> | string
    age?: IntNullableFilter<"UnitMember"> | number | null
    gender?: StringNullableFilter<"UnitMember"> | string | null
    phone?: StringNullableFilter<"UnitMember"> | string | null
    email?: StringNullableFilter<"UnitMember"> | string | null
    profileImg?: StringNullableFilter<"UnitMember"> | string | null
    createdAt?: DateTimeFilter<"UnitMember"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type UnitMemberOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    age?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    profileImg?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    unit?: UnitOrderByWithRelationInput
    _relevance?: UnitMemberOrderByRelevanceInput
  }

  export type UnitMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UnitMemberWhereInput | UnitMemberWhereInput[]
    OR?: UnitMemberWhereInput[]
    NOT?: UnitMemberWhereInput | UnitMemberWhereInput[]
    unitId?: IntFilter<"UnitMember"> | number
    name?: StringFilter<"UnitMember"> | string
    relation?: StringFilter<"UnitMember"> | string
    age?: IntNullableFilter<"UnitMember"> | number | null
    gender?: StringNullableFilter<"UnitMember"> | string | null
    phone?: StringNullableFilter<"UnitMember"> | string | null
    email?: StringNullableFilter<"UnitMember"> | string | null
    profileImg?: StringNullableFilter<"UnitMember"> | string | null
    createdAt?: DateTimeFilter<"UnitMember"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "id">

  export type UnitMemberOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    age?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    profileImg?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UnitMemberCountOrderByAggregateInput
    _avg?: UnitMemberAvgOrderByAggregateInput
    _max?: UnitMemberMaxOrderByAggregateInput
    _min?: UnitMemberMinOrderByAggregateInput
    _sum?: UnitMemberSumOrderByAggregateInput
  }

  export type UnitMemberScalarWhereWithAggregatesInput = {
    AND?: UnitMemberScalarWhereWithAggregatesInput | UnitMemberScalarWhereWithAggregatesInput[]
    OR?: UnitMemberScalarWhereWithAggregatesInput[]
    NOT?: UnitMemberScalarWhereWithAggregatesInput | UnitMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UnitMember"> | number
    unitId?: IntWithAggregatesFilter<"UnitMember"> | number
    name?: StringWithAggregatesFilter<"UnitMember"> | string
    relation?: StringWithAggregatesFilter<"UnitMember"> | string
    age?: IntNullableWithAggregatesFilter<"UnitMember"> | number | null
    gender?: StringNullableWithAggregatesFilter<"UnitMember"> | string | null
    phone?: StringNullableWithAggregatesFilter<"UnitMember"> | string | null
    email?: StringNullableWithAggregatesFilter<"UnitMember"> | string | null
    profileImg?: StringNullableWithAggregatesFilter<"UnitMember"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UnitMember"> | Date | string
  }

  export type UnitVehicleWhereInput = {
    AND?: UnitVehicleWhereInput | UnitVehicleWhereInput[]
    OR?: UnitVehicleWhereInput[]
    NOT?: UnitVehicleWhereInput | UnitVehicleWhereInput[]
    id?: IntFilter<"UnitVehicle"> | number
    unitId?: IntFilter<"UnitVehicle"> | number
    name?: StringFilter<"UnitVehicle"> | string
    number?: StringFilter<"UnitVehicle"> | string
    type?: StringFilter<"UnitVehicle"> | string
    color?: StringNullableFilter<"UnitVehicle"> | string | null
    parkingSlot?: StringNullableFilter<"UnitVehicle"> | string | null
    createdAt?: DateTimeFilter<"UnitVehicle"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type UnitVehicleOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    number?: SortOrder
    type?: SortOrder
    color?: SortOrderInput | SortOrder
    parkingSlot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    unit?: UnitOrderByWithRelationInput
    _relevance?: UnitVehicleOrderByRelevanceInput
  }

  export type UnitVehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UnitVehicleWhereInput | UnitVehicleWhereInput[]
    OR?: UnitVehicleWhereInput[]
    NOT?: UnitVehicleWhereInput | UnitVehicleWhereInput[]
    unitId?: IntFilter<"UnitVehicle"> | number
    name?: StringFilter<"UnitVehicle"> | string
    number?: StringFilter<"UnitVehicle"> | string
    type?: StringFilter<"UnitVehicle"> | string
    color?: StringNullableFilter<"UnitVehicle"> | string | null
    parkingSlot?: StringNullableFilter<"UnitVehicle"> | string | null
    createdAt?: DateTimeFilter<"UnitVehicle"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "id">

  export type UnitVehicleOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    number?: SortOrder
    type?: SortOrder
    color?: SortOrderInput | SortOrder
    parkingSlot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UnitVehicleCountOrderByAggregateInput
    _avg?: UnitVehicleAvgOrderByAggregateInput
    _max?: UnitVehicleMaxOrderByAggregateInput
    _min?: UnitVehicleMinOrderByAggregateInput
    _sum?: UnitVehicleSumOrderByAggregateInput
  }

  export type UnitVehicleScalarWhereWithAggregatesInput = {
    AND?: UnitVehicleScalarWhereWithAggregatesInput | UnitVehicleScalarWhereWithAggregatesInput[]
    OR?: UnitVehicleScalarWhereWithAggregatesInput[]
    NOT?: UnitVehicleScalarWhereWithAggregatesInput | UnitVehicleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UnitVehicle"> | number
    unitId?: IntWithAggregatesFilter<"UnitVehicle"> | number
    name?: StringWithAggregatesFilter<"UnitVehicle"> | string
    number?: StringWithAggregatesFilter<"UnitVehicle"> | string
    type?: StringWithAggregatesFilter<"UnitVehicle"> | string
    color?: StringNullableWithAggregatesFilter<"UnitVehicle"> | string | null
    parkingSlot?: StringNullableWithAggregatesFilter<"UnitVehicle"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UnitVehicle"> | Date | string
  }

  export type UnitPetWhereInput = {
    AND?: UnitPetWhereInput | UnitPetWhereInput[]
    OR?: UnitPetWhereInput[]
    NOT?: UnitPetWhereInput | UnitPetWhereInput[]
    id?: IntFilter<"UnitPet"> | number
    unitId?: IntFilter<"UnitPet"> | number
    name?: StringFilter<"UnitPet"> | string
    type?: StringFilter<"UnitPet"> | string
    breed?: StringNullableFilter<"UnitPet"> | string | null
    vaccinationStatus?: StringFilter<"UnitPet"> | string
    lastVaccinationDate?: DateTimeNullableFilter<"UnitPet"> | Date | string | null
    createdAt?: DateTimeFilter<"UnitPet"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type UnitPetOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    breed?: SortOrderInput | SortOrder
    vaccinationStatus?: SortOrder
    lastVaccinationDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    unit?: UnitOrderByWithRelationInput
    _relevance?: UnitPetOrderByRelevanceInput
  }

  export type UnitPetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UnitPetWhereInput | UnitPetWhereInput[]
    OR?: UnitPetWhereInput[]
    NOT?: UnitPetWhereInput | UnitPetWhereInput[]
    unitId?: IntFilter<"UnitPet"> | number
    name?: StringFilter<"UnitPet"> | string
    type?: StringFilter<"UnitPet"> | string
    breed?: StringNullableFilter<"UnitPet"> | string | null
    vaccinationStatus?: StringFilter<"UnitPet"> | string
    lastVaccinationDate?: DateTimeNullableFilter<"UnitPet"> | Date | string | null
    createdAt?: DateTimeFilter<"UnitPet"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "id">

  export type UnitPetOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    breed?: SortOrderInput | SortOrder
    vaccinationStatus?: SortOrder
    lastVaccinationDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UnitPetCountOrderByAggregateInput
    _avg?: UnitPetAvgOrderByAggregateInput
    _max?: UnitPetMaxOrderByAggregateInput
    _min?: UnitPetMinOrderByAggregateInput
    _sum?: UnitPetSumOrderByAggregateInput
  }

  export type UnitPetScalarWhereWithAggregatesInput = {
    AND?: UnitPetScalarWhereWithAggregatesInput | UnitPetScalarWhereWithAggregatesInput[]
    OR?: UnitPetScalarWhereWithAggregatesInput[]
    NOT?: UnitPetScalarWhereWithAggregatesInput | UnitPetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UnitPet"> | number
    unitId?: IntWithAggregatesFilter<"UnitPet"> | number
    name?: StringWithAggregatesFilter<"UnitPet"> | string
    type?: StringWithAggregatesFilter<"UnitPet"> | string
    breed?: StringNullableWithAggregatesFilter<"UnitPet"> | string | null
    vaccinationStatus?: StringWithAggregatesFilter<"UnitPet"> | string
    lastVaccinationDate?: DateTimeNullableWithAggregatesFilter<"UnitPet"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UnitPet"> | Date | string
  }

  export type SOSAlertWhereInput = {
    AND?: SOSAlertWhereInput | SOSAlertWhereInput[]
    OR?: SOSAlertWhereInput[]
    NOT?: SOSAlertWhereInput | SOSAlertWhereInput[]
    id?: IntFilter<"SOSAlert"> | number
    residentId?: IntFilter<"SOSAlert"> | number
    societyId?: IntFilter<"SOSAlert"> | number
    type?: StringFilter<"SOSAlert"> | string
    status?: StringFilter<"SOSAlert"> | string
    location?: StringNullableFilter<"SOSAlert"> | string | null
    createdAt?: DateTimeFilter<"SOSAlert"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"SOSAlert"> | Date | string | null
    resident?: XOR<UserScalarRelationFilter, UserWhereInput>
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type SOSAlertOrderByWithRelationInput = {
    id?: SortOrder
    residentId?: SortOrder
    societyId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resident?: UserOrderByWithRelationInput
    society?: SocietyOrderByWithRelationInput
    _relevance?: SOSAlertOrderByRelevanceInput
  }

  export type SOSAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SOSAlertWhereInput | SOSAlertWhereInput[]
    OR?: SOSAlertWhereInput[]
    NOT?: SOSAlertWhereInput | SOSAlertWhereInput[]
    residentId?: IntFilter<"SOSAlert"> | number
    societyId?: IntFilter<"SOSAlert"> | number
    type?: StringFilter<"SOSAlert"> | string
    status?: StringFilter<"SOSAlert"> | string
    location?: StringNullableFilter<"SOSAlert"> | string | null
    createdAt?: DateTimeFilter<"SOSAlert"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"SOSAlert"> | Date | string | null
    resident?: XOR<UserScalarRelationFilter, UserWhereInput>
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id">

  export type SOSAlertOrderByWithAggregationInput = {
    id?: SortOrder
    residentId?: SortOrder
    societyId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: SOSAlertCountOrderByAggregateInput
    _avg?: SOSAlertAvgOrderByAggregateInput
    _max?: SOSAlertMaxOrderByAggregateInput
    _min?: SOSAlertMinOrderByAggregateInput
    _sum?: SOSAlertSumOrderByAggregateInput
  }

  export type SOSAlertScalarWhereWithAggregatesInput = {
    AND?: SOSAlertScalarWhereWithAggregatesInput | SOSAlertScalarWhereWithAggregatesInput[]
    OR?: SOSAlertScalarWhereWithAggregatesInput[]
    NOT?: SOSAlertScalarWhereWithAggregatesInput | SOSAlertScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SOSAlert"> | number
    residentId?: IntWithAggregatesFilter<"SOSAlert"> | number
    societyId?: IntWithAggregatesFilter<"SOSAlert"> | number
    type?: StringWithAggregatesFilter<"SOSAlert"> | string
    status?: StringWithAggregatesFilter<"SOSAlert"> | string
    location?: StringNullableWithAggregatesFilter<"SOSAlert"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SOSAlert"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"SOSAlert"> | Date | string | null
  }

  export type MarketplaceItemWhereInput = {
    AND?: MarketplaceItemWhereInput | MarketplaceItemWhereInput[]
    OR?: MarketplaceItemWhereInput[]
    NOT?: MarketplaceItemWhereInput | MarketplaceItemWhereInput[]
    id?: IntFilter<"MarketplaceItem"> | number
    title?: StringFilter<"MarketplaceItem"> | string
    description?: StringFilter<"MarketplaceItem"> | string
    price?: FloatNullableFilter<"MarketplaceItem"> | number | null
    originalPrice?: FloatNullableFilter<"MarketplaceItem"> | number | null
    condition?: StringNullableFilter<"MarketplaceItem"> | string | null
    type?: StringFilter<"MarketplaceItem"> | string
    priceType?: StringNullableFilter<"MarketplaceItem"> | string | null
    category?: StringNullableFilter<"MarketplaceItem"> | string | null
    status?: StringFilter<"MarketplaceItem"> | string
    images?: JsonNullableFilter<"MarketplaceItem">
    views?: IntFilter<"MarketplaceItem"> | number
    likes?: IntFilter<"MarketplaceItem"> | number
    ownerId?: IntFilter<"MarketplaceItem"> | number
    societyId?: IntFilter<"MarketplaceItem"> | number
    createdAt?: DateTimeFilter<"MarketplaceItem"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceItem"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type MarketplaceItemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrderInput | SortOrder
    originalPrice?: SortOrderInput | SortOrder
    condition?: SortOrderInput | SortOrder
    type?: SortOrder
    priceType?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    images?: SortOrderInput | SortOrder
    views?: SortOrder
    likes?: SortOrder
    ownerId?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    society?: SocietyOrderByWithRelationInput
    _relevance?: MarketplaceItemOrderByRelevanceInput
  }

  export type MarketplaceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MarketplaceItemWhereInput | MarketplaceItemWhereInput[]
    OR?: MarketplaceItemWhereInput[]
    NOT?: MarketplaceItemWhereInput | MarketplaceItemWhereInput[]
    title?: StringFilter<"MarketplaceItem"> | string
    description?: StringFilter<"MarketplaceItem"> | string
    price?: FloatNullableFilter<"MarketplaceItem"> | number | null
    originalPrice?: FloatNullableFilter<"MarketplaceItem"> | number | null
    condition?: StringNullableFilter<"MarketplaceItem"> | string | null
    type?: StringFilter<"MarketplaceItem"> | string
    priceType?: StringNullableFilter<"MarketplaceItem"> | string | null
    category?: StringNullableFilter<"MarketplaceItem"> | string | null
    status?: StringFilter<"MarketplaceItem"> | string
    images?: JsonNullableFilter<"MarketplaceItem">
    views?: IntFilter<"MarketplaceItem"> | number
    likes?: IntFilter<"MarketplaceItem"> | number
    ownerId?: IntFilter<"MarketplaceItem"> | number
    societyId?: IntFilter<"MarketplaceItem"> | number
    createdAt?: DateTimeFilter<"MarketplaceItem"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceItem"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id">

  export type MarketplaceItemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrderInput | SortOrder
    originalPrice?: SortOrderInput | SortOrder
    condition?: SortOrderInput | SortOrder
    type?: SortOrder
    priceType?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    images?: SortOrderInput | SortOrder
    views?: SortOrder
    likes?: SortOrder
    ownerId?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketplaceItemCountOrderByAggregateInput
    _avg?: MarketplaceItemAvgOrderByAggregateInput
    _max?: MarketplaceItemMaxOrderByAggregateInput
    _min?: MarketplaceItemMinOrderByAggregateInput
    _sum?: MarketplaceItemSumOrderByAggregateInput
  }

  export type MarketplaceItemScalarWhereWithAggregatesInput = {
    AND?: MarketplaceItemScalarWhereWithAggregatesInput | MarketplaceItemScalarWhereWithAggregatesInput[]
    OR?: MarketplaceItemScalarWhereWithAggregatesInput[]
    NOT?: MarketplaceItemScalarWhereWithAggregatesInput | MarketplaceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MarketplaceItem"> | number
    title?: StringWithAggregatesFilter<"MarketplaceItem"> | string
    description?: StringWithAggregatesFilter<"MarketplaceItem"> | string
    price?: FloatNullableWithAggregatesFilter<"MarketplaceItem"> | number | null
    originalPrice?: FloatNullableWithAggregatesFilter<"MarketplaceItem"> | number | null
    condition?: StringNullableWithAggregatesFilter<"MarketplaceItem"> | string | null
    type?: StringWithAggregatesFilter<"MarketplaceItem"> | string
    priceType?: StringNullableWithAggregatesFilter<"MarketplaceItem"> | string | null
    category?: StringNullableWithAggregatesFilter<"MarketplaceItem"> | string | null
    status?: StringWithAggregatesFilter<"MarketplaceItem"> | string
    images?: JsonNullableWithAggregatesFilter<"MarketplaceItem">
    views?: IntWithAggregatesFilter<"MarketplaceItem"> | number
    likes?: IntWithAggregatesFilter<"MarketplaceItem"> | number
    ownerId?: IntWithAggregatesFilter<"MarketplaceItem"> | number
    societyId?: IntWithAggregatesFilter<"MarketplaceItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MarketplaceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketplaceItem"> | Date | string
  }

  export type MeetingWhereInput = {
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    id?: IntFilter<"Meeting"> | number
    title?: StringFilter<"Meeting"> | string
    description?: StringNullableFilter<"Meeting"> | string | null
    date?: DateTimeFilter<"Meeting"> | Date | string
    time?: StringFilter<"Meeting"> | string
    location?: StringFilter<"Meeting"> | string
    attendees?: JsonNullableFilter<"Meeting">
    status?: StringFilter<"Meeting"> | string
    societyId?: IntFilter<"Meeting"> | number
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type MeetingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    attendees?: SortOrderInput | SortOrder
    status?: SortOrder
    societyId?: SortOrder
    society?: SocietyOrderByWithRelationInput
    _relevance?: MeetingOrderByRelevanceInput
  }

  export type MeetingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    title?: StringFilter<"Meeting"> | string
    description?: StringNullableFilter<"Meeting"> | string | null
    date?: DateTimeFilter<"Meeting"> | Date | string
    time?: StringFilter<"Meeting"> | string
    location?: StringFilter<"Meeting"> | string
    attendees?: JsonNullableFilter<"Meeting">
    status?: StringFilter<"Meeting"> | string
    societyId?: IntFilter<"Meeting"> | number
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id">

  export type MeetingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    attendees?: SortOrderInput | SortOrder
    status?: SortOrder
    societyId?: SortOrder
    _count?: MeetingCountOrderByAggregateInput
    _avg?: MeetingAvgOrderByAggregateInput
    _max?: MeetingMaxOrderByAggregateInput
    _min?: MeetingMinOrderByAggregateInput
    _sum?: MeetingSumOrderByAggregateInput
  }

  export type MeetingScalarWhereWithAggregatesInput = {
    AND?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    OR?: MeetingScalarWhereWithAggregatesInput[]
    NOT?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Meeting"> | number
    title?: StringWithAggregatesFilter<"Meeting"> | string
    description?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    date?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
    time?: StringWithAggregatesFilter<"Meeting"> | string
    location?: StringWithAggregatesFilter<"Meeting"> | string
    attendees?: JsonNullableWithAggregatesFilter<"Meeting">
    status?: StringWithAggregatesFilter<"Meeting"> | string
    societyId?: IntWithAggregatesFilter<"Meeting"> | number
  }

  export type CommunityGuidelineWhereInput = {
    AND?: CommunityGuidelineWhereInput | CommunityGuidelineWhereInput[]
    OR?: CommunityGuidelineWhereInput[]
    NOT?: CommunityGuidelineWhereInput | CommunityGuidelineWhereInput[]
    id?: IntFilter<"CommunityGuideline"> | number
    societyId?: IntFilter<"CommunityGuideline"> | number
    title?: StringFilter<"CommunityGuideline"> | string
    content?: StringFilter<"CommunityGuideline"> | string
    category?: StringFilter<"CommunityGuideline"> | string
    createdAt?: DateTimeFilter<"CommunityGuideline"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityGuideline"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type CommunityGuidelineOrderByWithRelationInput = {
    id?: SortOrder
    societyId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    _relevance?: CommunityGuidelineOrderByRelevanceInput
  }

  export type CommunityGuidelineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommunityGuidelineWhereInput | CommunityGuidelineWhereInput[]
    OR?: CommunityGuidelineWhereInput[]
    NOT?: CommunityGuidelineWhereInput | CommunityGuidelineWhereInput[]
    societyId?: IntFilter<"CommunityGuideline"> | number
    title?: StringFilter<"CommunityGuideline"> | string
    content?: StringFilter<"CommunityGuideline"> | string
    category?: StringFilter<"CommunityGuideline"> | string
    createdAt?: DateTimeFilter<"CommunityGuideline"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityGuideline"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id">

  export type CommunityGuidelineOrderByWithAggregationInput = {
    id?: SortOrder
    societyId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommunityGuidelineCountOrderByAggregateInput
    _avg?: CommunityGuidelineAvgOrderByAggregateInput
    _max?: CommunityGuidelineMaxOrderByAggregateInput
    _min?: CommunityGuidelineMinOrderByAggregateInput
    _sum?: CommunityGuidelineSumOrderByAggregateInput
  }

  export type CommunityGuidelineScalarWhereWithAggregatesInput = {
    AND?: CommunityGuidelineScalarWhereWithAggregatesInput | CommunityGuidelineScalarWhereWithAggregatesInput[]
    OR?: CommunityGuidelineScalarWhereWithAggregatesInput[]
    NOT?: CommunityGuidelineScalarWhereWithAggregatesInput | CommunityGuidelineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommunityGuideline"> | number
    societyId?: IntWithAggregatesFilter<"CommunityGuideline"> | number
    title?: StringWithAggregatesFilter<"CommunityGuideline"> | string
    content?: StringWithAggregatesFilter<"CommunityGuideline"> | string
    category?: StringWithAggregatesFilter<"CommunityGuideline"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CommunityGuideline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommunityGuideline"> | Date | string
  }

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: IntFilter<"Asset"> | number
    name?: StringFilter<"Asset"> | string
    category?: StringFilter<"Asset"> | string
    value?: FloatFilter<"Asset"> | number
    purchaseDate?: DateTimeFilter<"Asset"> | Date | string
    status?: StringFilter<"Asset"> | string
    societyId?: IntFilter<"Asset"> | number
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    value?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    _relevance?: AssetOrderByRelevanceInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    name?: StringFilter<"Asset"> | string
    category?: StringFilter<"Asset"> | string
    value?: FloatFilter<"Asset"> | number
    purchaseDate?: DateTimeFilter<"Asset"> | Date | string
    status?: StringFilter<"Asset"> | string
    societyId?: IntFilter<"Asset"> | number
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    value?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssetCountOrderByAggregateInput
    _avg?: AssetAvgOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
    _sum?: AssetSumOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Asset"> | number
    name?: StringWithAggregatesFilter<"Asset"> | string
    category?: StringWithAggregatesFilter<"Asset"> | string
    value?: FloatWithAggregatesFilter<"Asset"> | number
    purchaseDate?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    status?: StringWithAggregatesFilter<"Asset"> | string
    societyId?: IntWithAggregatesFilter<"Asset"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: IntFilter<"Document"> | number
    title?: StringFilter<"Document"> | string
    category?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    societyId?: IntFilter<"Document"> | number
    createdAt?: DateTimeFilter<"Document"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    _relevance?: DocumentOrderByRelevanceInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    title?: StringFilter<"Document"> | string
    category?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    societyId?: IntFilter<"Document"> | number
    createdAt?: DateTimeFilter<"Document"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Document"> | number
    title?: StringWithAggregatesFilter<"Document"> | string
    category?: StringWithAggregatesFilter<"Document"> | string
    fileUrl?: StringWithAggregatesFilter<"Document"> | string
    societyId?: IntWithAggregatesFilter<"Document"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type ParcelWhereInput = {
    AND?: ParcelWhereInput | ParcelWhereInput[]
    OR?: ParcelWhereInput[]
    NOT?: ParcelWhereInput | ParcelWhereInput[]
    id?: IntFilter<"Parcel"> | number
    unitId?: IntFilter<"Parcel"> | number
    courierName?: StringFilter<"Parcel"> | string
    trackingNumber?: StringNullableFilter<"Parcel"> | string | null
    description?: StringNullableFilter<"Parcel"> | string | null
    receivedBy?: StringNullableFilter<"Parcel"> | string | null
    status?: StringFilter<"Parcel"> | string
    collectedBy?: StringNullableFilter<"Parcel"> | string | null
    collectedAt?: DateTimeNullableFilter<"Parcel"> | Date | string | null
    societyId?: IntFilter<"Parcel"> | number
    createdAt?: DateTimeFilter<"Parcel"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type ParcelOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    courierName?: SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    receivedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    collectedBy?: SortOrderInput | SortOrder
    collectedAt?: SortOrderInput | SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    unit?: UnitOrderByWithRelationInput
    society?: SocietyOrderByWithRelationInput
    _relevance?: ParcelOrderByRelevanceInput
  }

  export type ParcelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ParcelWhereInput | ParcelWhereInput[]
    OR?: ParcelWhereInput[]
    NOT?: ParcelWhereInput | ParcelWhereInput[]
    unitId?: IntFilter<"Parcel"> | number
    courierName?: StringFilter<"Parcel"> | string
    trackingNumber?: StringNullableFilter<"Parcel"> | string | null
    description?: StringNullableFilter<"Parcel"> | string | null
    receivedBy?: StringNullableFilter<"Parcel"> | string | null
    status?: StringFilter<"Parcel"> | string
    collectedBy?: StringNullableFilter<"Parcel"> | string | null
    collectedAt?: DateTimeNullableFilter<"Parcel"> | Date | string | null
    societyId?: IntFilter<"Parcel"> | number
    createdAt?: DateTimeFilter<"Parcel"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id">

  export type ParcelOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    courierName?: SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    receivedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    collectedBy?: SortOrderInput | SortOrder
    collectedAt?: SortOrderInput | SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    _count?: ParcelCountOrderByAggregateInput
    _avg?: ParcelAvgOrderByAggregateInput
    _max?: ParcelMaxOrderByAggregateInput
    _min?: ParcelMinOrderByAggregateInput
    _sum?: ParcelSumOrderByAggregateInput
  }

  export type ParcelScalarWhereWithAggregatesInput = {
    AND?: ParcelScalarWhereWithAggregatesInput | ParcelScalarWhereWithAggregatesInput[]
    OR?: ParcelScalarWhereWithAggregatesInput[]
    NOT?: ParcelScalarWhereWithAggregatesInput | ParcelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Parcel"> | number
    unitId?: IntWithAggregatesFilter<"Parcel"> | number
    courierName?: StringWithAggregatesFilter<"Parcel"> | string
    trackingNumber?: StringNullableWithAggregatesFilter<"Parcel"> | string | null
    description?: StringNullableWithAggregatesFilter<"Parcel"> | string | null
    receivedBy?: StringNullableWithAggregatesFilter<"Parcel"> | string | null
    status?: StringWithAggregatesFilter<"Parcel"> | string
    collectedBy?: StringNullableWithAggregatesFilter<"Parcel"> | string | null
    collectedAt?: DateTimeNullableWithAggregatesFilter<"Parcel"> | Date | string | null
    societyId?: IntWithAggregatesFilter<"Parcel"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Parcel"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: IntFilter<"Event"> | number
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    date?: DateTimeFilter<"Event"> | Date | string
    time?: StringNullableFilter<"Event"> | string | null
    location?: StringNullableFilter<"Event"> | string | null
    category?: StringNullableFilter<"Event"> | string | null
    status?: StringFilter<"Event"> | string
    societyId?: IntFilter<"Event"> | number
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    _relevance?: EventOrderByRelevanceInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    date?: DateTimeFilter<"Event"> | Date | string
    time?: StringNullableFilter<"Event"> | string | null
    location?: StringNullableFilter<"Event"> | string | null
    category?: StringNullableFilter<"Event"> | string | null
    status?: StringFilter<"Event"> | string
    societyId?: IntFilter<"Event"> | number
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Event"> | number
    title?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    date?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    time?: StringNullableWithAggregatesFilter<"Event"> | string | null
    location?: StringNullableWithAggregatesFilter<"Event"> | string | null
    category?: StringNullableWithAggregatesFilter<"Event"> | string | null
    status?: StringWithAggregatesFilter<"Event"> | string
    societyId?: IntWithAggregatesFilter<"Event"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type PurchaseRequestWhereInput = {
    AND?: PurchaseRequestWhereInput | PurchaseRequestWhereInput[]
    OR?: PurchaseRequestWhereInput[]
    NOT?: PurchaseRequestWhereInput | PurchaseRequestWhereInput[]
    id?: IntFilter<"PurchaseRequest"> | number
    title?: StringFilter<"PurchaseRequest"> | string
    description?: StringNullableFilter<"PurchaseRequest"> | string | null
    amount?: FloatFilter<"PurchaseRequest"> | number
    status?: StringFilter<"PurchaseRequest"> | string
    createdAt?: DateTimeFilter<"PurchaseRequest"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseRequest"> | Date | string
    societyId?: IntFilter<"PurchaseRequest"> | number
    requestedById?: IntFilter<"PurchaseRequest"> | number
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    requestedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PurchaseRequestOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    societyId?: SortOrder
    requestedById?: SortOrder
    society?: SocietyOrderByWithRelationInput
    requestedBy?: UserOrderByWithRelationInput
    _relevance?: PurchaseRequestOrderByRelevanceInput
  }

  export type PurchaseRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseRequestWhereInput | PurchaseRequestWhereInput[]
    OR?: PurchaseRequestWhereInput[]
    NOT?: PurchaseRequestWhereInput | PurchaseRequestWhereInput[]
    title?: StringFilter<"PurchaseRequest"> | string
    description?: StringNullableFilter<"PurchaseRequest"> | string | null
    amount?: FloatFilter<"PurchaseRequest"> | number
    status?: StringFilter<"PurchaseRequest"> | string
    createdAt?: DateTimeFilter<"PurchaseRequest"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseRequest"> | Date | string
    societyId?: IntFilter<"PurchaseRequest"> | number
    requestedById?: IntFilter<"PurchaseRequest"> | number
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    requestedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PurchaseRequestOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    societyId?: SortOrder
    requestedById?: SortOrder
    _count?: PurchaseRequestCountOrderByAggregateInput
    _avg?: PurchaseRequestAvgOrderByAggregateInput
    _max?: PurchaseRequestMaxOrderByAggregateInput
    _min?: PurchaseRequestMinOrderByAggregateInput
    _sum?: PurchaseRequestSumOrderByAggregateInput
  }

  export type PurchaseRequestScalarWhereWithAggregatesInput = {
    AND?: PurchaseRequestScalarWhereWithAggregatesInput | PurchaseRequestScalarWhereWithAggregatesInput[]
    OR?: PurchaseRequestScalarWhereWithAggregatesInput[]
    NOT?: PurchaseRequestScalarWhereWithAggregatesInput | PurchaseRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseRequest"> | number
    title?: StringWithAggregatesFilter<"PurchaseRequest"> | string
    description?: StringNullableWithAggregatesFilter<"PurchaseRequest"> | string | null
    amount?: FloatWithAggregatesFilter<"PurchaseRequest"> | number
    status?: StringWithAggregatesFilter<"PurchaseRequest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseRequest"> | Date | string
    societyId?: IntWithAggregatesFilter<"PurchaseRequest"> | number
    requestedById?: IntWithAggregatesFilter<"PurchaseRequest"> | number
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: IntFilter<"Conversation"> | number
    societyId?: IntFilter<"Conversation"> | number
    type?: StringFilter<"Conversation"> | string
    participantId?: IntNullableFilter<"Conversation"> | number | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    participant?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    messages?: ChatMessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    societyId?: SortOrder
    type?: SortOrder
    participantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    participant?: UserOrderByWithRelationInput
    messages?: ChatMessageOrderByRelationAggregateInput
    _relevance?: ConversationOrderByRelevanceInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    societyId_type_participantId?: ConversationSocietyIdTypeParticipantIdCompoundUniqueInput
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    societyId?: IntFilter<"Conversation"> | number
    type?: StringFilter<"Conversation"> | string
    participantId?: IntNullableFilter<"Conversation"> | number | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    participant?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    messages?: ChatMessageListRelationFilter
  }, "id" | "societyId_type_participantId">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    societyId?: SortOrder
    type?: SortOrder
    participantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _avg?: ConversationAvgOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
    _sum?: ConversationSumOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Conversation"> | number
    societyId?: IntWithAggregatesFilter<"Conversation"> | number
    type?: StringWithAggregatesFilter<"Conversation"> | string
    participantId?: IntNullableWithAggregatesFilter<"Conversation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: IntFilter<"ChatMessage"> | number
    conversationId?: IntFilter<"ChatMessage"> | number
    senderId?: IntFilter<"ChatMessage"> | number
    content?: StringFilter<"ChatMessage"> | string
    attachments?: JsonNullableFilter<"ChatMessage">
    status?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    attachments?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
    _relevance?: ChatMessageOrderByRelevanceInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    conversationId?: IntFilter<"ChatMessage"> | number
    senderId?: IntFilter<"ChatMessage"> | number
    content?: StringFilter<"ChatMessage"> | string
    attachments?: JsonNullableFilter<"ChatMessage">
    status?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    attachments?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _avg?: ChatMessageAvgOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
    _sum?: ChatMessageSumOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChatMessage"> | number
    conversationId?: IntWithAggregatesFilter<"ChatMessage"> | number
    senderId?: IntWithAggregatesFilter<"ChatMessage"> | number
    content?: StringWithAggregatesFilter<"ChatMessage"> | string
    attachments?: JsonNullableWithAggregatesFilter<"ChatMessage">
    status?: StringWithAggregatesFilter<"ChatMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type ServiceCategoryWhereInput = {
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    id?: StringFilter<"ServiceCategory"> | string
    name?: StringFilter<"ServiceCategory"> | string
    description?: StringNullableFilter<"ServiceCategory"> | string | null
    icon?: StringFilter<"ServiceCategory"> | string
    color?: StringFilter<"ServiceCategory"> | string
    createdAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    variants?: ServiceVariantListRelationFilter
    inquiries?: ServiceInquiryListRelationFilter
  }

  export type ServiceCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    variants?: ServiceVariantOrderByRelationAggregateInput
    inquiries?: ServiceInquiryOrderByRelationAggregateInput
    _relevance?: ServiceCategoryOrderByRelevanceInput
  }

  export type ServiceCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    name?: StringFilter<"ServiceCategory"> | string
    description?: StringNullableFilter<"ServiceCategory"> | string | null
    icon?: StringFilter<"ServiceCategory"> | string
    color?: StringFilter<"ServiceCategory"> | string
    createdAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    variants?: ServiceVariantListRelationFilter
    inquiries?: ServiceInquiryListRelationFilter
  }, "id">

  export type ServiceCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    _count?: ServiceCategoryCountOrderByAggregateInput
    _max?: ServiceCategoryMaxOrderByAggregateInput
    _min?: ServiceCategoryMinOrderByAggregateInput
  }

  export type ServiceCategoryScalarWhereWithAggregatesInput = {
    AND?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    OR?: ServiceCategoryScalarWhereWithAggregatesInput[]
    NOT?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceCategory"> | string
    name?: StringWithAggregatesFilter<"ServiceCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ServiceCategory"> | string | null
    icon?: StringWithAggregatesFilter<"ServiceCategory"> | string
    color?: StringWithAggregatesFilter<"ServiceCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ServiceCategory"> | Date | string
  }

  export type ServiceVariantWhereInput = {
    AND?: ServiceVariantWhereInput | ServiceVariantWhereInput[]
    OR?: ServiceVariantWhereInput[]
    NOT?: ServiceVariantWhereInput | ServiceVariantWhereInput[]
    id?: IntFilter<"ServiceVariant"> | number
    categoryId?: StringFilter<"ServiceVariant"> | string
    name?: StringFilter<"ServiceVariant"> | string
    price?: FloatNullableFilter<"ServiceVariant"> | number | null
    createdAt?: DateTimeFilter<"ServiceVariant"> | Date | string
    category?: XOR<ServiceCategoryScalarRelationFilter, ServiceCategoryWhereInput>
  }

  export type ServiceVariantOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    price?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    category?: ServiceCategoryOrderByWithRelationInput
    _relevance?: ServiceVariantOrderByRelevanceInput
  }

  export type ServiceVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServiceVariantWhereInput | ServiceVariantWhereInput[]
    OR?: ServiceVariantWhereInput[]
    NOT?: ServiceVariantWhereInput | ServiceVariantWhereInput[]
    categoryId?: StringFilter<"ServiceVariant"> | string
    name?: StringFilter<"ServiceVariant"> | string
    price?: FloatNullableFilter<"ServiceVariant"> | number | null
    createdAt?: DateTimeFilter<"ServiceVariant"> | Date | string
    category?: XOR<ServiceCategoryScalarRelationFilter, ServiceCategoryWhereInput>
  }, "id">

  export type ServiceVariantOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    price?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ServiceVariantCountOrderByAggregateInput
    _avg?: ServiceVariantAvgOrderByAggregateInput
    _max?: ServiceVariantMaxOrderByAggregateInput
    _min?: ServiceVariantMinOrderByAggregateInput
    _sum?: ServiceVariantSumOrderByAggregateInput
  }

  export type ServiceVariantScalarWhereWithAggregatesInput = {
    AND?: ServiceVariantScalarWhereWithAggregatesInput | ServiceVariantScalarWhereWithAggregatesInput[]
    OR?: ServiceVariantScalarWhereWithAggregatesInput[]
    NOT?: ServiceVariantScalarWhereWithAggregatesInput | ServiceVariantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceVariant"> | number
    categoryId?: StringWithAggregatesFilter<"ServiceVariant"> | string
    name?: StringWithAggregatesFilter<"ServiceVariant"> | string
    price?: FloatNullableWithAggregatesFilter<"ServiceVariant"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceVariant"> | Date | string
  }

  export type ServiceInquiryWhereInput = {
    AND?: ServiceInquiryWhereInput | ServiceInquiryWhereInput[]
    OR?: ServiceInquiryWhereInput[]
    NOT?: ServiceInquiryWhereInput | ServiceInquiryWhereInput[]
    id?: IntFilter<"ServiceInquiry"> | number
    residentId?: IntNullableFilter<"ServiceInquiry"> | number | null
    societyId?: IntNullableFilter<"ServiceInquiry"> | number | null
    serviceId?: StringNullableFilter<"ServiceInquiry"> | string | null
    serviceName?: StringNullableFilter<"ServiceInquiry"> | string | null
    type?: StringFilter<"ServiceInquiry"> | string
    status?: StringFilter<"ServiceInquiry"> | string
    preferredDate?: StringNullableFilter<"ServiceInquiry"> | string | null
    preferredTime?: StringNullableFilter<"ServiceInquiry"> | string | null
    phone?: StringNullableFilter<"ServiceInquiry"> | string | null
    notes?: StringNullableFilter<"ServiceInquiry"> | string | null
    vendorName?: StringNullableFilter<"ServiceInquiry"> | string | null
    vendorId?: IntNullableFilter<"ServiceInquiry"> | number | null
    createdAt?: DateTimeFilter<"ServiceInquiry"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceInquiry"> | Date | string
    resident?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    society?: XOR<SocietyNullableScalarRelationFilter, SocietyWhereInput> | null
    service?: XOR<ServiceCategoryNullableScalarRelationFilter, ServiceCategoryWhereInput> | null
  }

  export type ServiceInquiryOrderByWithRelationInput = {
    id?: SortOrder
    residentId?: SortOrderInput | SortOrder
    societyId?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    serviceName?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    preferredDate?: SortOrderInput | SortOrder
    preferredTime?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    vendorName?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resident?: UserOrderByWithRelationInput
    society?: SocietyOrderByWithRelationInput
    service?: ServiceCategoryOrderByWithRelationInput
    _relevance?: ServiceInquiryOrderByRelevanceInput
  }

  export type ServiceInquiryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServiceInquiryWhereInput | ServiceInquiryWhereInput[]
    OR?: ServiceInquiryWhereInput[]
    NOT?: ServiceInquiryWhereInput | ServiceInquiryWhereInput[]
    residentId?: IntNullableFilter<"ServiceInquiry"> | number | null
    societyId?: IntNullableFilter<"ServiceInquiry"> | number | null
    serviceId?: StringNullableFilter<"ServiceInquiry"> | string | null
    serviceName?: StringNullableFilter<"ServiceInquiry"> | string | null
    type?: StringFilter<"ServiceInquiry"> | string
    status?: StringFilter<"ServiceInquiry"> | string
    preferredDate?: StringNullableFilter<"ServiceInquiry"> | string | null
    preferredTime?: StringNullableFilter<"ServiceInquiry"> | string | null
    phone?: StringNullableFilter<"ServiceInquiry"> | string | null
    notes?: StringNullableFilter<"ServiceInquiry"> | string | null
    vendorName?: StringNullableFilter<"ServiceInquiry"> | string | null
    vendorId?: IntNullableFilter<"ServiceInquiry"> | number | null
    createdAt?: DateTimeFilter<"ServiceInquiry"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceInquiry"> | Date | string
    resident?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    society?: XOR<SocietyNullableScalarRelationFilter, SocietyWhereInput> | null
    service?: XOR<ServiceCategoryNullableScalarRelationFilter, ServiceCategoryWhereInput> | null
  }, "id">

  export type ServiceInquiryOrderByWithAggregationInput = {
    id?: SortOrder
    residentId?: SortOrderInput | SortOrder
    societyId?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    serviceName?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    preferredDate?: SortOrderInput | SortOrder
    preferredTime?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    vendorName?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceInquiryCountOrderByAggregateInput
    _avg?: ServiceInquiryAvgOrderByAggregateInput
    _max?: ServiceInquiryMaxOrderByAggregateInput
    _min?: ServiceInquiryMinOrderByAggregateInput
    _sum?: ServiceInquirySumOrderByAggregateInput
  }

  export type ServiceInquiryScalarWhereWithAggregatesInput = {
    AND?: ServiceInquiryScalarWhereWithAggregatesInput | ServiceInquiryScalarWhereWithAggregatesInput[]
    OR?: ServiceInquiryScalarWhereWithAggregatesInput[]
    NOT?: ServiceInquiryScalarWhereWithAggregatesInput | ServiceInquiryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceInquiry"> | number
    residentId?: IntNullableWithAggregatesFilter<"ServiceInquiry"> | number | null
    societyId?: IntNullableWithAggregatesFilter<"ServiceInquiry"> | number | null
    serviceId?: StringNullableWithAggregatesFilter<"ServiceInquiry"> | string | null
    serviceName?: StringNullableWithAggregatesFilter<"ServiceInquiry"> | string | null
    type?: StringWithAggregatesFilter<"ServiceInquiry"> | string
    status?: StringWithAggregatesFilter<"ServiceInquiry"> | string
    preferredDate?: StringNullableWithAggregatesFilter<"ServiceInquiry"> | string | null
    preferredTime?: StringNullableWithAggregatesFilter<"ServiceInquiry"> | string | null
    phone?: StringNullableWithAggregatesFilter<"ServiceInquiry"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ServiceInquiry"> | string | null
    vendorName?: StringNullableWithAggregatesFilter<"ServiceInquiry"> | string | null
    vendorId?: IntNullableWithAggregatesFilter<"ServiceInquiry"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceInquiry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceInquiry"> | Date | string
  }

  export type SocietyCreateInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyCreateManyInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocietyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocietyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleModelCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
    users?: UserCreateNestedManyWithoutRoleModelInput
  }

  export type RoleModelUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    users?: UserUncheckedCreateNestedManyWithoutRoleModelInput
  }

  export type RoleModelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    users?: UserUpdateManyWithoutRoleModelNestedInput
  }

  export type RoleModelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    users?: UserUncheckedUpdateManyWithoutRoleModelNestedInput
  }

  export type RoleModelCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleModelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleModelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id: string
    label: string
    description?: string | null
    roles?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id: string
    label: string
    description?: string | null
    roles?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id: string
    label: string
    description?: string | null
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionCreateInput = {
    role: RoleModelCreateNestedOneWithoutPermissionsInput
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateInput = {
    roleId: number
    permissionId: string
  }

  export type RolePermissionUpdateInput = {
    role?: RoleModelUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateManyInput = {
    roleId: number
    permissionId: string
  }

  export type RolePermissionUpdateManyMutationInput = {

  }

  export type RolePermissionUncheckedUpdateManyInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSessionCreateInput = {
    device?: string | null
    ipAddress?: string | null
    lastActive?: Date | string
    token: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: number
    userId: number
    device?: string | null
    ipAddress?: string | null
    lastActive?: Date | string
    token: string
    createdAt?: Date | string
  }

  export type UserSessionUpdateInput = {
    device?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    device?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: number
    userId: number
    device?: string | null
    ipAddress?: string | null
    lastActive?: Date | string
    token: string
    createdAt?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    device?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    device?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
    parcels?: ParcelCreateNestedManyWithoutUnitInput
    members?: UnitMemberCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleCreateNestedManyWithoutUnitInput
    petsList?: UnitPetCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    societyId: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutUnitInput
    members?: UnitMemberUncheckedCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleUncheckedCreateNestedManyWithoutUnitInput
    petsList?: UnitPetUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUncheckedUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUncheckedUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    societyId: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitUpdateManyMutationInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotCreateInput = {
    number: string
    type: string
    status: string
    vehicleNumber?: string | null
    createdAt?: Date | string
    society: SocietyCreateNestedOneWithoutParkingSlotsInput
    unit?: UnitCreateNestedOneWithoutParkingSlotsInput
  }

  export type ParkingSlotUncheckedCreateInput = {
    id?: number
    number: string
    type: string
    status: string
    societyId: number
    allocatedToUnitId?: number | null
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type ParkingSlotUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutParkingSlotsNestedInput
    unit?: UnitUpdateOneWithoutParkingSlotsNestedInput
  }

  export type ParkingSlotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    allocatedToUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotCreateManyInput = {
    id?: number
    number: string
    type: string
    status: string
    societyId: number
    allocatedToUnitId?: number | null
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type ParkingSlotUpdateManyMutationInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    allocatedToUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCreateInput = {
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    isPrivate?: boolean
    escalatedToTech?: boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutComplaintsInput
    reportedBy: UserCreateNestedOneWithoutReportedComplaintsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedComplaintsInput
    comments?: ComplaintCommentCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    isPrivate?: boolean
    escalatedToTech?: boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    reportedById: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    escalatedToTech?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutComplaintsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutReportedComplaintsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedComplaintsNestedInput
    comments?: ComplaintCommentUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    escalatedToTech?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ComplaintCommentUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintCreateManyInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    isPrivate?: boolean
    escalatedToTech?: boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    reportedById: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    escalatedToTech?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    escalatedToTech?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentCreateInput = {
    message: string
    createdAt?: Date | string
    complaint: ComplaintCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type ComplaintCommentUncheckedCreateInput = {
    id?: number
    complaintId: number
    userId: number
    message: string
    createdAt?: Date | string
  }

  export type ComplaintCommentUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint?: ComplaintUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ComplaintCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaintId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentCreateManyInput = {
    id?: number
    complaintId: number
    userId: number
    message: string
    createdAt?: Date | string
  }

  export type ComplaintCommentUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaintId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorCreateInput = {
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutVisitorsInput
    unit: UnitCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    societyId: number
    visitingUnitId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutVisitorsNestedInput
    unit?: UnitUpdateOneRequiredWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    visitingUnitId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorCreateManyInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    societyId: number
    visitingUnitId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    visitingUnitId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    societyId: number
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: number
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    societyId: number
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateInput = {
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    status?: $Enums.VendorStatus
    createdAt?: Date | string
    society?: SocietyCreateNestedOneWithoutVendorsInput
    payouts?: VendorPayoutCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: number
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    status?: $Enums.VendorStatus
    societyId?: number | null
    createdAt?: Date | string
    payouts?: VendorPayoutUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutVendorsNestedInput
    payouts?: VendorPayoutUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payouts?: VendorPayoutUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    id?: number
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    status?: $Enums.VendorStatus
    societyId?: number | null
    createdAt?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPayoutCreateInput = {
    vendorName: string
    societyId?: number | null
    societyName?: string | null
    dealValue: number
    commissionPercent: number
    payableAmount: number
    status?: string
    remarks?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPayoutsInput
  }

  export type VendorPayoutUncheckedCreateInput = {
    id?: number
    vendorId: number
    vendorName: string
    societyId?: number | null
    societyName?: string | null
    dealValue: number
    commissionPercent: number
    payableAmount: number
    status?: string
    remarks?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorPayoutUpdateInput = {
    vendorName?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    societyName?: NullableStringFieldUpdateOperationsInput | string | null
    dealValue?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    payableAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPayoutsNestedInput
  }

  export type VendorPayoutUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    vendorName?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    societyName?: NullableStringFieldUpdateOperationsInput | string | null
    dealValue?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    payableAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPayoutCreateManyInput = {
    id?: number
    vendorId: number
    vendorName: string
    societyId?: number | null
    societyName?: string | null
    dealValue: number
    commissionPercent: number
    payableAmount: number
    status?: string
    remarks?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorPayoutUpdateManyMutationInput = {
    vendorName?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    societyName?: NullableStringFieldUpdateOperationsInput | string | null
    dealValue?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    payableAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPayoutUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    vendorName?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    societyName?: NullableStringFieldUpdateOperationsInput | string | null
    dealValue?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    payableAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyLogCreateInput = {
    id?: string
    timestamp?: Date | string
    visitorName: string
    visitorPhone: string
    residentName: string
    unit: string
    isEmergency?: boolean
    reason?: string | null
    barcodeId: string
    societyId?: number | null
  }

  export type EmergencyLogUncheckedCreateInput = {
    id?: string
    timestamp?: Date | string
    visitorName: string
    visitorPhone: string
    residentName: string
    unit: string
    isEmergency?: boolean
    reason?: string | null
    barcodeId: string
    societyId?: number | null
  }

  export type EmergencyLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    visitorName?: StringFieldUpdateOperationsInput | string
    visitorPhone?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    barcodeId?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmergencyLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    visitorName?: StringFieldUpdateOperationsInput | string
    visitorPhone?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    barcodeId?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmergencyLogCreateManyInput = {
    id?: string
    timestamp?: Date | string
    visitorName: string
    visitorPhone: string
    residentName: string
    unit: string
    isEmergency?: boolean
    reason?: string | null
    barcodeId: string
    societyId?: number | null
  }

  export type EmergencyLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    visitorName?: StringFieldUpdateOperationsInput | string
    visitorPhone?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    barcodeId?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmergencyLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    visitorName?: StringFieldUpdateOperationsInput | string
    visitorPhone?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    barcodeId?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmergencyBarcodeCreateInput = {
    id: string
    residentName: string
    unit: string
    phone: string
    label?: string | null
    type?: string | null
    status?: string
    qrCodeUrl: string
    createdAt?: Date | string
    societyId?: number | null
  }

  export type EmergencyBarcodeUncheckedCreateInput = {
    id: string
    residentName: string
    unit: string
    phone: string
    label?: string | null
    type?: string | null
    status?: string
    qrCodeUrl: string
    createdAt?: Date | string
    societyId?: number | null
  }

  export type EmergencyBarcodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmergencyBarcodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmergencyBarcodeCreateManyInput = {
    id: string
    residentName: string
    unit: string
    phone: string
    label?: string | null
    type?: string | null
    status?: string
    qrCodeUrl: string
    createdAt?: Date | string
    societyId?: number | null
  }

  export type EmergencyBarcodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmergencyBarcodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmergencyAlertCreateInput = {
    type: string
    unit?: string | null
    description?: string | null
    status?: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutEmergencyAlertsInput
    user: UserCreateNestedOneWithoutEmergencyAlertsInput
  }

  export type EmergencyAlertUncheckedCreateInput = {
    id?: number
    type: string
    unit?: string | null
    description?: string | null
    status?: string
    resolution?: string | null
    societyId: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyAlertUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutEmergencyAlertsNestedInput
    user?: UserUpdateOneRequiredWithoutEmergencyAlertsNestedInput
  }

  export type EmergencyAlertUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyAlertCreateManyInput = {
    id?: number
    type: string
    unit?: string | null
    description?: string | null
    status?: string
    resolution?: string | null
    societyId: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyAlertUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyAlertUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactCreateInput = {
    name: string
    phone: string
    category?: string
    available?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutEmergencyContactsInput
    resident?: UserCreateNestedOneWithoutEmergencyContactsInput
  }

  export type EmergencyContactUncheckedCreateInput = {
    id?: number
    name: string
    phone: string
    category?: string
    available?: boolean
    societyId?: number | null
    residentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyContactUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutEmergencyContactsNestedInput
    resident?: UserUpdateOneWithoutEmergencyContactsNestedInput
  }

  export type EmergencyContactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    available?: BoolFieldUpdateOperationsInput | boolean
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    residentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactCreateManyInput = {
    id?: number
    name: string
    phone: string
    category?: string
    available?: boolean
    societyId?: number | null
    residentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyContactUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    available?: BoolFieldUpdateOperationsInput | boolean
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    residentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeCreateInput = {
    title: string
    content: string
    audience: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    society: SocietyCreateNestedOneWithoutNoticesInput
  }

  export type NoticeUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    audience: string
    societyId: number
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NoticeUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    society?: SocietyUpdateOneRequiredWithoutNoticesNestedInput
  }

  export type NoticeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoticeCreateManyInput = {
    id?: number
    title: string
    content: string
    audience: string
    societyId: number
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NoticeUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoticeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AmenityCreateInput = {
    name: string
    type?: string
    description?: string | null
    capacity?: number
    chargesPerHour?: number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutAmenitiesInput
    bookings?: AmenityBookingCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUncheckedCreateInput = {
    id?: number
    name: string
    type?: string
    description?: string | null
    capacity?: number
    chargesPerHour?: number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    societyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutAmenitiesNestedInput
    bookings?: AmenityBookingUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: AmenityBookingUncheckedUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityCreateManyInput = {
    id?: number
    name: string
    type?: string
    description?: string | null
    capacity?: number
    chargesPerHour?: number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    societyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingCreateInput = {
    date: Date | string
    startTime: string
    endTime: string
    purpose?: string | null
    status?: string
    amountPaid?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    amenity: AmenityCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
  }

  export type AmenityBookingUncheckedCreateInput = {
    id?: number
    amenityId: number
    userId: number
    date: Date | string
    startTime: string
    endTime: string
    purpose?: string | null
    status?: string
    amountPaid?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenityBookingUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenity?: AmenityUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type AmenityBookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingCreateManyInput = {
    id?: number
    amenityId: number
    userId: number
    date: Date | string
    startTime: string
    endTime: string
    purpose?: string | null
    status?: string
    amountPaid?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenityBookingUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    key: string
    value: string
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: number
    key: string
    value: string
  }

  export type SystemSettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SystemSettingCreateManyInput = {
    id?: number
    key: string
    value: string
  }

  export type SystemSettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type BillingPlanCreateInput = {
    name: string
    type: string
    price: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingPlanUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    price: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingPlanUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPlanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPlanCreateManyInput = {
    id?: number
    name: string
    type: string
    price: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingPlanUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPlanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformInvoiceCreateInput = {
    invoiceNo: string
    amount: number
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutPlatformInvoicesInput
  }

  export type PlatformInvoiceUncheckedCreateInput = {
    id?: number
    invoiceNo: string
    societyId: number
    amount: number
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformInvoiceUpdateInput = {
    invoiceNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutPlatformInvoicesNestedInput
  }

  export type PlatformInvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformInvoiceCreateManyInput = {
    id?: number
    invoiceNo: string
    societyId: number
    amount: number
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformInvoiceUpdateManyMutationInput = {
    invoiceNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformInvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBuzzCreateInput = {
    type: string
    title: string
    content?: string | null
    hasResult?: boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutBuzzsInput
    society: SocietyCreateNestedOneWithoutBuzzsInput
    comments?: CommunityCommentCreateNestedManyWithoutBuzzInput
    likedBy?: BuzzLikeCreateNestedManyWithoutBuzzInput
  }

  export type CommunityBuzzUncheckedCreateInput = {
    id?: number
    type: string
    title: string
    content?: string | null
    authorId: number
    societyId: number
    hasResult?: boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    createdAt?: Date | string
    comments?: CommunityCommentUncheckedCreateNestedManyWithoutBuzzInput
    likedBy?: BuzzLikeUncheckedCreateNestedManyWithoutBuzzInput
  }

  export type CommunityBuzzUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    hasResult?: BoolFieldUpdateOperationsInput | boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutBuzzsNestedInput
    society?: SocietyUpdateOneRequiredWithoutBuzzsNestedInput
    comments?: CommunityCommentUpdateManyWithoutBuzzNestedInput
    likedBy?: BuzzLikeUpdateManyWithoutBuzzNestedInput
  }

  export type CommunityBuzzUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    hasResult?: BoolFieldUpdateOperationsInput | boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommunityCommentUncheckedUpdateManyWithoutBuzzNestedInput
    likedBy?: BuzzLikeUncheckedUpdateManyWithoutBuzzNestedInput
  }

  export type CommunityBuzzCreateManyInput = {
    id?: number
    type: string
    title: string
    content?: string | null
    authorId: number
    societyId: number
    hasResult?: boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    createdAt?: Date | string
  }

  export type CommunityBuzzUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    hasResult?: BoolFieldUpdateOperationsInput | boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBuzzUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    hasResult?: BoolFieldUpdateOperationsInput | boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityCommentCreateInput = {
    content: string
    createdAt?: Date | string
    buzz: CommunityBuzzCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommunityCommentsInput
  }

  export type CommunityCommentUncheckedCreateInput = {
    id?: number
    buzzId: number
    authorId: number
    content: string
    createdAt?: Date | string
  }

  export type CommunityCommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buzz?: CommunityBuzzUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommunityCommentsNestedInput
  }

  export type CommunityCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    buzzId?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityCommentCreateManyInput = {
    id?: number
    buzzId: number
    authorId: number
    content: string
    createdAt?: Date | string
  }

  export type CommunityCommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    buzzId?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuzzLikeCreateInput = {
    createdAt?: Date | string
    buzz: CommunityBuzzCreateNestedOneWithoutLikedByInput
    user: UserCreateNestedOneWithoutBuzzLikesInput
  }

  export type BuzzLikeUncheckedCreateInput = {
    id?: number
    buzzId: number
    userId: number
    createdAt?: Date | string
  }

  export type BuzzLikeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buzz?: CommunityBuzzUpdateOneRequiredWithoutLikedByNestedInput
    user?: UserUpdateOneRequiredWithoutBuzzLikesNestedInput
  }

  export type BuzzLikeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    buzzId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuzzLikeCreateManyInput = {
    id?: number
    buzzId: number
    userId: number
    createdAt?: Date | string
  }

  export type BuzzLikeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuzzLikeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    buzzId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitMemberCreateInput = {
    name: string
    relation: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    email?: string | null
    profileImg?: string | null
    createdAt?: Date | string
    unit: UnitCreateNestedOneWithoutMembersInput
  }

  export type UnitMemberUncheckedCreateInput = {
    id?: number
    unitId: number
    name: string
    relation: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    email?: string | null
    profileImg?: string | null
    createdAt?: Date | string
  }

  export type UnitMemberUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutMembersNestedInput
  }

  export type UnitMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitMemberCreateManyInput = {
    id?: number
    unitId: number
    name: string
    relation: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    email?: string | null
    profileImg?: string | null
    createdAt?: Date | string
  }

  export type UnitMemberUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitVehicleCreateInput = {
    name: string
    number: string
    type: string
    color?: string | null
    parkingSlot?: string | null
    createdAt?: Date | string
    unit: UnitCreateNestedOneWithoutVehiclesInput
  }

  export type UnitVehicleUncheckedCreateInput = {
    id?: number
    unitId: number
    name: string
    number: string
    type: string
    color?: string | null
    parkingSlot?: string | null
    createdAt?: Date | string
  }

  export type UnitVehicleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingSlot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutVehiclesNestedInput
  }

  export type UnitVehicleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingSlot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitVehicleCreateManyInput = {
    id?: number
    unitId: number
    name: string
    number: string
    type: string
    color?: string | null
    parkingSlot?: string | null
    createdAt?: Date | string
  }

  export type UnitVehicleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingSlot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitVehicleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingSlot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitPetCreateInput = {
    name: string
    type: string
    breed?: string | null
    vaccinationStatus?: string
    lastVaccinationDate?: Date | string | null
    createdAt?: Date | string
    unit: UnitCreateNestedOneWithoutPetsListInput
  }

  export type UnitPetUncheckedCreateInput = {
    id?: number
    unitId: number
    name: string
    type: string
    breed?: string | null
    vaccinationStatus?: string
    lastVaccinationDate?: Date | string | null
    createdAt?: Date | string
  }

  export type UnitPetUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    vaccinationStatus?: StringFieldUpdateOperationsInput | string
    lastVaccinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutPetsListNestedInput
  }

  export type UnitPetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    vaccinationStatus?: StringFieldUpdateOperationsInput | string
    lastVaccinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitPetCreateManyInput = {
    id?: number
    unitId: number
    name: string
    type: string
    breed?: string | null
    vaccinationStatus?: string
    lastVaccinationDate?: Date | string | null
    createdAt?: Date | string
  }

  export type UnitPetUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    vaccinationStatus?: StringFieldUpdateOperationsInput | string
    lastVaccinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitPetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    vaccinationStatus?: StringFieldUpdateOperationsInput | string
    lastVaccinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SOSAlertCreateInput = {
    type: string
    status?: string
    location?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
    resident: UserCreateNestedOneWithoutSosAlertsInput
    society: SocietyCreateNestedOneWithoutSosAlertsInput
  }

  export type SOSAlertUncheckedCreateInput = {
    id?: number
    residentId: number
    societyId: number
    type: string
    status?: string
    location?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SOSAlertUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resident?: UserUpdateOneRequiredWithoutSosAlertsNestedInput
    society?: SocietyUpdateOneRequiredWithoutSosAlertsNestedInput
  }

  export type SOSAlertUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    residentId?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SOSAlertCreateManyInput = {
    id?: number
    residentId: number
    societyId: number
    type: string
    status?: string
    location?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SOSAlertUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SOSAlertUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    residentId?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MarketplaceItemCreateInput = {
    title: string
    description: string
    price?: number | null
    originalPrice?: number | null
    condition?: string | null
    type?: string
    priceType?: string | null
    category?: string | null
    status?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: number
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutMarketplaceItemsInput
    society: SocietyCreateNestedOneWithoutMarketplaceItemsInput
  }

  export type MarketplaceItemUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    price?: number | null
    originalPrice?: number | null
    condition?: string | null
    type?: string
    priceType?: string | null
    category?: string | null
    status?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: number
    likes?: number
    ownerId: number
    societyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceItemUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutMarketplaceItemsNestedInput
    society?: SocietyUpdateOneRequiredWithoutMarketplaceItemsNestedInput
  }

  export type MarketplaceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceItemCreateManyInput = {
    id?: number
    title: string
    description: string
    price?: number | null
    originalPrice?: number | null
    condition?: string | null
    type?: string
    priceType?: string | null
    category?: string | null
    status?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: number
    likes?: number
    ownerId: number
    societyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceItemUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingCreateInput = {
    title: string
    description?: string | null
    date: Date | string
    time: string
    location: string
    attendees?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    society: SocietyCreateNestedOneWithoutMeetingsInput
  }

  export type MeetingUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    date: Date | string
    time: string
    location: string
    attendees?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    societyId: number
  }

  export type MeetingUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    attendees?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    society?: SocietyUpdateOneRequiredWithoutMeetingsNestedInput
  }

  export type MeetingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    attendees?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
  }

  export type MeetingCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    date: Date | string
    time: string
    location: string
    attendees?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    societyId: number
  }

  export type MeetingUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    attendees?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MeetingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    attendees?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityGuidelineCreateInput = {
    title: string
    content: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutGuidelinesInput
  }

  export type CommunityGuidelineUncheckedCreateInput = {
    id?: number
    societyId: number
    title: string
    content: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityGuidelineUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutGuidelinesNestedInput
  }

  export type CommunityGuidelineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityGuidelineCreateManyInput = {
    id?: number
    societyId: number
    title: string
    content: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityGuidelineUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityGuidelineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateInput = {
    name: string
    category: string
    value: number
    purchaseDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateInput = {
    id?: number
    name: string
    category: string
    value: number
    purchaseDate: Date | string
    status?: string
    societyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateManyInput = {
    id?: number
    name: string
    category: string
    value: number
    purchaseDate: Date | string
    status?: string
    societyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    title: string
    category: string
    fileUrl: string
    createdAt?: Date | string
    society: SocietyCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: number
    title: string
    category: string
    fileUrl: string
    societyId: number
    createdAt?: Date | string
  }

  export type DocumentUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: number
    title: string
    category: string
    fileUrl: string
    societyId: number
    createdAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParcelCreateInput = {
    courierName: string
    trackingNumber?: string | null
    description?: string | null
    receivedBy?: string | null
    status?: string
    collectedBy?: string | null
    collectedAt?: Date | string | null
    createdAt?: Date | string
    unit: UnitCreateNestedOneWithoutParcelsInput
    society: SocietyCreateNestedOneWithoutParcelsInput
  }

  export type ParcelUncheckedCreateInput = {
    id?: number
    unitId: number
    courierName: string
    trackingNumber?: string | null
    description?: string | null
    receivedBy?: string | null
    status?: string
    collectedBy?: string | null
    collectedAt?: Date | string | null
    societyId: number
    createdAt?: Date | string
  }

  export type ParcelUpdateInput = {
    courierName?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutParcelsNestedInput
    society?: SocietyUpdateOneRequiredWithoutParcelsNestedInput
  }

  export type ParcelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    courierName?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParcelCreateManyInput = {
    id?: number
    unitId: number
    courierName: string
    trackingNumber?: string | null
    description?: string | null
    receivedBy?: string | null
    status?: string
    collectedBy?: string | null
    collectedAt?: Date | string | null
    societyId: number
    createdAt?: Date | string
  }

  export type ParcelUpdateManyMutationInput = {
    courierName?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParcelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    courierName?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    category?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    category?: string | null
    status?: string
    societyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    category?: string | null
    status?: string
    societyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseRequestCreateInput = {
    title: string
    description?: string | null
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutPurchaseRequestsInput
    requestedBy: UserCreateNestedOneWithoutPurchaseRequestsInput
  }

  export type PurchaseRequestUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    societyId: number
    requestedById: number
  }

  export type PurchaseRequestUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutPurchaseRequestsNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutPurchaseRequestsNestedInput
  }

  export type PurchaseRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    societyId?: IntFieldUpdateOperationsInput | number
    requestedById?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseRequestCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    societyId: number
    requestedById: number
  }

  export type PurchaseRequestUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    societyId?: IntFieldUpdateOperationsInput | number
    requestedById?: IntFieldUpdateOperationsInput | number
  }

  export type ConversationCreateInput = {
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutConversationsInput
    participant?: UserCreateNestedOneWithoutConversationsInput
    messages?: ChatMessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: number
    societyId: number
    type: string
    participantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutConversationsNestedInput
    participant?: UserUpdateOneWithoutConversationsNestedInput
    messages?: ChatMessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: number
    societyId: number
    type: string
    participantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    content: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: number
    conversationId: number
    senderId: number
    content: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversationId?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: number
    conversationId: number
    senderId: number
    content: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversationId?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryCreateInput = {
    id: string
    name: string
    description?: string | null
    icon: string
    color?: string
    createdAt?: Date | string
    variants?: ServiceVariantCreateNestedManyWithoutCategoryInput
    inquiries?: ServiceInquiryCreateNestedManyWithoutServiceInput
  }

  export type ServiceCategoryUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    icon: string
    color?: string
    createdAt?: Date | string
    variants?: ServiceVariantUncheckedCreateNestedManyWithoutCategoryInput
    inquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ServiceVariantUpdateManyWithoutCategoryNestedInput
    inquiries?: ServiceInquiryUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ServiceVariantUncheckedUpdateManyWithoutCategoryNestedInput
    inquiries?: ServiceInquiryUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCategoryCreateManyInput = {
    id: string
    name: string
    description?: string | null
    icon: string
    color?: string
    createdAt?: Date | string
  }

  export type ServiceCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceVariantCreateInput = {
    name: string
    price?: number | null
    createdAt?: Date | string
    category: ServiceCategoryCreateNestedOneWithoutVariantsInput
  }

  export type ServiceVariantUncheckedCreateInput = {
    id?: number
    categoryId: string
    name: string
    price?: number | null
    createdAt?: Date | string
  }

  export type ServiceVariantUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type ServiceVariantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceVariantCreateManyInput = {
    id?: number
    categoryId: string
    name: string
    price?: number | null
    createdAt?: Date | string
  }

  export type ServiceVariantUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceVariantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceInquiryCreateInput = {
    serviceName?: string | null
    type: string
    status?: string
    preferredDate?: string | null
    preferredTime?: string | null
    phone?: string | null
    notes?: string | null
    vendorName?: string | null
    vendorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resident?: UserCreateNestedOneWithoutServiceInquiriesInput
    society?: SocietyCreateNestedOneWithoutServiceInquiriesInput
    service?: ServiceCategoryCreateNestedOneWithoutInquiriesInput
  }

  export type ServiceInquiryUncheckedCreateInput = {
    id?: number
    residentId?: number | null
    societyId?: number | null
    serviceId?: string | null
    serviceName?: string | null
    type: string
    status?: string
    preferredDate?: string | null
    preferredTime?: string | null
    phone?: string | null
    notes?: string | null
    vendorName?: string | null
    vendorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceInquiryUpdateInput = {
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    preferredDate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: UserUpdateOneWithoutServiceInquiriesNestedInput
    society?: SocietyUpdateOneWithoutServiceInquiriesNestedInput
    service?: ServiceCategoryUpdateOneWithoutInquiriesNestedInput
  }

  export type ServiceInquiryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    residentId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    preferredDate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceInquiryCreateManyInput = {
    id?: number
    residentId?: number | null
    societyId?: number | null
    serviceId?: string | null
    serviceName?: string | null
    type: string
    status?: string
    preferredDate?: string | null
    preferredTime?: string | null
    phone?: string | null
    notes?: string | null
    vendorName?: string | null
    vendorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceInquiryUpdateManyMutationInput = {
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    preferredDate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceInquiryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    residentId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    preferredDate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumSocietyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SocietyStatus | EnumSocietyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SocietyStatus[]
    notIn?: $Enums.SocietyStatus[]
    not?: NestedEnumSocietyStatusFilter<$PrismaModel> | $Enums.SocietyStatus
  }

  export type EnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UnitListRelationFilter = {
    every?: UnitWhereInput
    some?: UnitWhereInput
    none?: UnitWhereInput
  }

  export type ComplaintListRelationFilter = {
    every?: ComplaintWhereInput
    some?: ComplaintWhereInput
    none?: ComplaintWhereInput
  }

  export type VisitorListRelationFilter = {
    every?: VisitorWhereInput
    some?: VisitorWhereInput
    none?: VisitorWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type NoticeListRelationFilter = {
    every?: NoticeWhereInput
    some?: NoticeWhereInput
    none?: NoticeWhereInput
  }

  export type VendorListRelationFilter = {
    every?: VendorWhereInput
    some?: VendorWhereInput
    none?: VendorWhereInput
  }

  export type AmenityListRelationFilter = {
    every?: AmenityWhereInput
    some?: AmenityWhereInput
    none?: AmenityWhereInput
  }

  export type ParkingSlotListRelationFilter = {
    every?: ParkingSlotWhereInput
    some?: ParkingSlotWhereInput
    none?: ParkingSlotWhereInput
  }

  export type PlatformInvoiceListRelationFilter = {
    every?: PlatformInvoiceWhereInput
    some?: PlatformInvoiceWhereInput
    none?: PlatformInvoiceWhereInput
  }

  export type MeetingListRelationFilter = {
    every?: MeetingWhereInput
    some?: MeetingWhereInput
    none?: MeetingWhereInput
  }

  export type AssetListRelationFilter = {
    every?: AssetWhereInput
    some?: AssetWhereInput
    none?: AssetWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type ParcelListRelationFilter = {
    every?: ParcelWhereInput
    some?: ParcelWhereInput
    none?: ParcelWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type PurchaseRequestListRelationFilter = {
    every?: PurchaseRequestWhereInput
    some?: PurchaseRequestWhereInput
    none?: PurchaseRequestWhereInput
  }

  export type EmergencyAlertListRelationFilter = {
    every?: EmergencyAlertWhereInput
    some?: EmergencyAlertWhereInput
    none?: EmergencyAlertWhereInput
  }

  export type EmergencyContactListRelationFilter = {
    every?: EmergencyContactWhereInput
    some?: EmergencyContactWhereInput
    none?: EmergencyContactWhereInput
  }

  export type ServiceInquiryListRelationFilter = {
    every?: ServiceInquiryWhereInput
    some?: ServiceInquiryWhereInput
    none?: ServiceInquiryWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type CommunityBuzzListRelationFilter = {
    every?: CommunityBuzzWhereInput
    some?: CommunityBuzzWhereInput
    none?: CommunityBuzzWhereInput
  }

  export type MarketplaceItemListRelationFilter = {
    every?: MarketplaceItemWhereInput
    some?: MarketplaceItemWhereInput
    none?: MarketplaceItemWhereInput
  }

  export type CommunityGuidelineListRelationFilter = {
    every?: CommunityGuidelineWhereInput
    some?: CommunityGuidelineWhereInput
    none?: CommunityGuidelineWhereInput
  }

  export type SOSAlertListRelationFilter = {
    every?: SOSAlertWhereInput
    some?: SOSAlertWhereInput
    none?: SOSAlertWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplaintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisitorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoticeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AmenityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParkingSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlatformInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeetingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParcelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmergencyAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmergencyContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceInquiryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityBuzzOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketplaceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityGuidelineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SOSAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocietyOrderByRelevanceInput = {
    fields: SocietyOrderByRelevanceFieldEnum | SocietyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SocietyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    code?: SortOrder
    status?: SortOrder
    subscriptionPlan?: SortOrder
    expectedUnits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocietyAvgOrderByAggregateInput = {
    id?: SortOrder
    expectedUnits?: SortOrder
  }

  export type SocietyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    code?: SortOrder
    status?: SortOrder
    subscriptionPlan?: SortOrder
    expectedUnits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocietyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    code?: SortOrder
    status?: SortOrder
    subscriptionPlan?: SortOrder
    expectedUnits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocietySumOrderByAggregateInput = {
    id?: SortOrder
    expectedUnits?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumSocietyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocietyStatus | EnumSocietyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SocietyStatus[]
    notIn?: $Enums.SocietyStatus[]
    not?: NestedEnumSocietyStatusWithAggregatesFilter<$PrismaModel> | $Enums.SocietyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocietyStatusFilter<$PrismaModel>
    _max?: NestedEnumSocietyStatusFilter<$PrismaModel>
  }

  export type EnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[]
    notIn?: $Enums.UserStatus[]
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type RoleModelNullableScalarRelationFilter = {
    is?: RoleModelWhereInput | null
    isNot?: RoleModelWhereInput | null
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type SocietyNullableScalarRelationFilter = {
    is?: SocietyWhereInput | null
    isNot?: SocietyWhereInput | null
  }

  export type AmenityBookingListRelationFilter = {
    every?: AmenityBookingWhereInput
    some?: AmenityBookingWhereInput
    none?: AmenityBookingWhereInput
  }

  export type ComplaintCommentListRelationFilter = {
    every?: ComplaintCommentWhereInput
    some?: ComplaintCommentWhereInput
    none?: ComplaintCommentWhereInput
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type CommunityCommentListRelationFilter = {
    every?: CommunityCommentWhereInput
    some?: CommunityCommentWhereInput
    none?: CommunityCommentWhereInput
  }

  export type BuzzLikeListRelationFilter = {
    every?: BuzzLikeWhereInput
    some?: BuzzLikeWhereInput
    none?: BuzzLikeWhereInput
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AmenityBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplaintCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuzzLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    status?: SortOrder
    profileImg?: SortOrder
    roleId?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    societyId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    status?: SortOrder
    profileImg?: SortOrder
    roleId?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    status?: SortOrder
    profileImg?: SortOrder
    roleId?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    societyId?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[]
    notIn?: $Enums.UserStatus[]
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleModelOrderByRelevanceInput = {
    fields: RoleModelOrderByRelevanceFieldEnum | RoleModelOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoleModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleModelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleModelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionOrderByRelevanceInput = {
    fields: PermissionOrderByRelevanceFieldEnum | PermissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    description?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    description?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    description?: SortOrder
  }

  export type RoleModelScalarRelationFilter = {
    is?: RoleModelWhereInput
    isNot?: RoleModelWhereInput
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionOrderByRelevanceInput = {
    fields: RolePermissionOrderByRelevanceFieldEnum | RolePermissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: number
    permissionId: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionAvgOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionSumOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserSessionOrderByRelevanceInput = {
    fields: UserSessionOrderByRelevanceFieldEnum | UserSessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    device?: SortOrder
    ipAddress?: SortOrder
    lastActive?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    device?: SortOrder
    ipAddress?: SortOrder
    lastActive?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    device?: SortOrder
    ipAddress?: SortOrder
    lastActive?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SocietyScalarRelationFilter = {
    is?: SocietyWhereInput
    isNot?: SocietyWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UnitMemberListRelationFilter = {
    every?: UnitMemberWhereInput
    some?: UnitMemberWhereInput
    none?: UnitMemberWhereInput
  }

  export type UnitVehicleListRelationFilter = {
    every?: UnitVehicleWhereInput
    some?: UnitVehicleWhereInput
    none?: UnitVehicleWhereInput
  }

  export type UnitPetListRelationFilter = {
    every?: UnitPetWhereInput
    some?: UnitPetWhereInput
    none?: UnitPetWhereInput
  }

  export type UnitMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitVehicleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitPetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitOrderByRelevanceInput = {
    fields: UnitOrderByRelevanceFieldEnum | UnitOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UnitSocietyIdBlockNumberCompoundUniqueInput = {
    societyId: number
    block: string
    number: string
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    block?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    areaSqFt?: SortOrder
    status?: SortOrder
    pets?: SortOrder
    membersCount?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    id?: SortOrder
    floor?: SortOrder
    areaSqFt?: SortOrder
    pets?: SortOrder
    membersCount?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    block?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    areaSqFt?: SortOrder
    status?: SortOrder
    pets?: SortOrder
    membersCount?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    block?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    areaSqFt?: SortOrder
    status?: SortOrder
    pets?: SortOrder
    membersCount?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    id?: SortOrder
    floor?: SortOrder
    areaSqFt?: SortOrder
    pets?: SortOrder
    membersCount?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UnitNullableScalarRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type ParkingSlotOrderByRelevanceInput = {
    fields: ParkingSlotOrderByRelevanceFieldEnum | ParkingSlotOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ParkingSlotCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrder
    vehicleNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type ParkingSlotAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrder
  }

  export type ParkingSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrder
    vehicleNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type ParkingSlotMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrder
    vehicleNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type ParkingSlotSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrder
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[]
    notIn?: $Enums.Priority[]
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type EnumComplaintStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[]
    notIn?: $Enums.ComplaintStatus[]
    not?: NestedEnumComplaintStatusFilter<$PrismaModel> | $Enums.ComplaintStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ComplaintOrderByRelevanceInput = {
    fields: ComplaintOrderByRelevanceFieldEnum | ComplaintOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ComplaintCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    isPrivate?: SortOrder
    escalatedToTech?: SortOrder
    images?: SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    timeline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplaintAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
  }

  export type ComplaintMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    isPrivate?: SortOrder
    escalatedToTech?: SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplaintMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    isPrivate?: SortOrder
    escalatedToTech?: SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplaintSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[]
    notIn?: $Enums.Priority[]
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumComplaintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[]
    notIn?: $Enums.ComplaintStatus[]
    not?: NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintStatusFilter<$PrismaModel>
    _max?: NestedEnumComplaintStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ComplaintScalarRelationFilter = {
    is?: ComplaintWhereInput
    isNot?: ComplaintWhereInput
  }

  export type ComplaintCommentOrderByRelevanceInput = {
    fields: ComplaintCommentOrderByRelevanceFieldEnum | ComplaintCommentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ComplaintCommentCountOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ComplaintCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
  }

  export type ComplaintCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ComplaintCommentMinOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ComplaintCommentSumOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
  }

  export type EnumVisitorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitorStatus | EnumVisitorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitorStatus[]
    notIn?: $Enums.VisitorStatus[]
    not?: NestedEnumVisitorStatusFilter<$PrismaModel> | $Enums.VisitorStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UnitScalarRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type VisitorOrderByRelevanceInput = {
    fields: VisitorOrderByRelevanceFieldEnum | VisitorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VisitorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicleNo?: SortOrder
    purpose?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    entryTime?: SortOrder
    exitTime?: SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitorAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
  }

  export type VisitorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicleNo?: SortOrder
    purpose?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    entryTime?: SortOrder
    exitTime?: SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicleNo?: SortOrder
    purpose?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    entryTime?: SortOrder
    exitTime?: SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitorSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
  }

  export type EnumVisitorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitorStatus | EnumVisitorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitorStatus[]
    notIn?: $Enums.VisitorStatus[]
    not?: NestedEnumVisitorStatusWithAggregatesFilter<$PrismaModel> | $Enums.VisitorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitorStatusFilter<$PrismaModel>
    _max?: NestedEnumVisitorStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type TransactionOrderByRelevanceInput = {
    fields: TransactionOrderByRelevanceFieldEnum | TransactionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    invoiceNo?: SortOrder
    paidTo?: SortOrder
    receivedFrom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    societyId?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    invoiceNo?: SortOrder
    paidTo?: SortOrder
    receivedFrom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    invoiceNo?: SortOrder
    paidTo?: SortOrder
    receivedFrom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    societyId?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumVendorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorStatus | EnumVendorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorStatus[]
    notIn?: $Enums.VendorStatus[]
    not?: NestedEnumVendorStatusFilter<$PrismaModel> | $Enums.VendorStatus
  }

  export type VendorPayoutListRelationFilter = {
    every?: VendorPayoutWhereInput
    some?: VendorPayoutWhereInput
    none?: VendorPayoutWhereInput
  }

  export type VendorPayoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorOrderByRelevanceInput = {
    fields: VendorOrderByRelevanceFieldEnum | VendorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    address?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    address?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    address?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type EnumVendorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorStatus | EnumVendorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorStatus[]
    notIn?: $Enums.VendorStatus[]
    not?: NestedEnumVendorStatusWithAggregatesFilter<$PrismaModel> | $Enums.VendorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVendorStatusFilter<$PrismaModel>
    _max?: NestedEnumVendorStatusFilter<$PrismaModel>
  }

  export type VendorScalarRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type VendorPayoutOrderByRelevanceInput = {
    fields: VendorPayoutOrderByRelevanceFieldEnum | VendorPayoutOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VendorPayoutCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    societyId?: SortOrder
    societyName?: SortOrder
    dealValue?: SortOrder
    commissionPercent?: SortOrder
    payableAmount?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorPayoutAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    societyId?: SortOrder
    dealValue?: SortOrder
    commissionPercent?: SortOrder
    payableAmount?: SortOrder
  }

  export type VendorPayoutMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    societyId?: SortOrder
    societyName?: SortOrder
    dealValue?: SortOrder
    commissionPercent?: SortOrder
    payableAmount?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorPayoutMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    societyId?: SortOrder
    societyName?: SortOrder
    dealValue?: SortOrder
    commissionPercent?: SortOrder
    payableAmount?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorPayoutSumOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    societyId?: SortOrder
    dealValue?: SortOrder
    commissionPercent?: SortOrder
    payableAmount?: SortOrder
  }

  export type EmergencyLogOrderByRelevanceInput = {
    fields: EmergencyLogOrderByRelevanceFieldEnum | EmergencyLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmergencyLogCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    visitorName?: SortOrder
    visitorPhone?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    isEmergency?: SortOrder
    reason?: SortOrder
    barcodeId?: SortOrder
    societyId?: SortOrder
  }

  export type EmergencyLogAvgOrderByAggregateInput = {
    societyId?: SortOrder
  }

  export type EmergencyLogMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    visitorName?: SortOrder
    visitorPhone?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    isEmergency?: SortOrder
    reason?: SortOrder
    barcodeId?: SortOrder
    societyId?: SortOrder
  }

  export type EmergencyLogMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    visitorName?: SortOrder
    visitorPhone?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    isEmergency?: SortOrder
    reason?: SortOrder
    barcodeId?: SortOrder
    societyId?: SortOrder
  }

  export type EmergencyLogSumOrderByAggregateInput = {
    societyId?: SortOrder
  }

  export type EmergencyBarcodeOrderByRelevanceInput = {
    fields: EmergencyBarcodeOrderByRelevanceFieldEnum | EmergencyBarcodeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmergencyBarcodeCountOrderByAggregateInput = {
    id?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    phone?: SortOrder
    label?: SortOrder
    type?: SortOrder
    status?: SortOrder
    qrCodeUrl?: SortOrder
    createdAt?: SortOrder
    societyId?: SortOrder
  }

  export type EmergencyBarcodeAvgOrderByAggregateInput = {
    societyId?: SortOrder
  }

  export type EmergencyBarcodeMaxOrderByAggregateInput = {
    id?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    phone?: SortOrder
    label?: SortOrder
    type?: SortOrder
    status?: SortOrder
    qrCodeUrl?: SortOrder
    createdAt?: SortOrder
    societyId?: SortOrder
  }

  export type EmergencyBarcodeMinOrderByAggregateInput = {
    id?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    phone?: SortOrder
    label?: SortOrder
    type?: SortOrder
    status?: SortOrder
    qrCodeUrl?: SortOrder
    createdAt?: SortOrder
    societyId?: SortOrder
  }

  export type EmergencyBarcodeSumOrderByAggregateInput = {
    societyId?: SortOrder
  }

  export type EmergencyAlertOrderByRelevanceInput = {
    fields: EmergencyAlertOrderByRelevanceFieldEnum | EmergencyAlertOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmergencyAlertCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    societyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmergencyAlertAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    userId?: SortOrder
  }

  export type EmergencyAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    societyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmergencyAlertMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    societyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmergencyAlertSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    userId?: SortOrder
  }

  export type EmergencyContactOrderByRelevanceInput = {
    fields: EmergencyContactOrderByRelevanceFieldEnum | EmergencyContactOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmergencyContactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    category?: SortOrder
    available?: SortOrder
    societyId?: SortOrder
    residentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmergencyContactAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    residentId?: SortOrder
  }

  export type EmergencyContactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    category?: SortOrder
    available?: SortOrder
    societyId?: SortOrder
    residentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmergencyContactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    category?: SortOrder
    available?: SortOrder
    societyId?: SortOrder
    residentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmergencyContactSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    residentId?: SortOrder
  }

  export type NoticeOrderByRelevanceInput = {
    fields: NoticeOrderByRelevanceFieldEnum | NoticeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NoticeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NoticeAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type NoticeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NoticeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NoticeSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type AmenityOrderByRelevanceInput = {
    fields: AmenityOrderByRelevanceFieldEnum | AmenityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AmenityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    capacity?: SortOrder
    chargesPerHour?: SortOrder
    availableDays?: SortOrder
    timings?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenityAvgOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
    chargesPerHour?: SortOrder
    societyId?: SortOrder
  }

  export type AmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    capacity?: SortOrder
    chargesPerHour?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    capacity?: SortOrder
    chargesPerHour?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenitySumOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
    chargesPerHour?: SortOrder
    societyId?: SortOrder
  }

  export type AmenityScalarRelationFilter = {
    is?: AmenityWhereInput
    isNot?: AmenityWhereInput
  }

  export type AmenityBookingOrderByRelevanceInput = {
    fields: AmenityBookingOrderByRelevanceFieldEnum | AmenityBookingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AmenityBookingCountOrderByAggregateInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenityBookingAvgOrderByAggregateInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    amountPaid?: SortOrder
  }

  export type AmenityBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenityBookingMinOrderByAggregateInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenityBookingSumOrderByAggregateInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    amountPaid?: SortOrder
  }

  export type SystemSettingOrderByRelevanceInput = {
    fields: SystemSettingOrderByRelevanceFieldEnum | SystemSettingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SystemSettingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SystemSettingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BillingPlanOrderByRelevanceInput = {
    fields: BillingPlanOrderByRelevanceFieldEnum | BillingPlanOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BillingPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    price?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingPlanAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BillingPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    price?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    price?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingPlanSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlatformInvoiceOrderByRelevanceInput = {
    fields: PlatformInvoiceOrderByRelevanceFieldEnum | PlatformInvoiceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PlatformInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    societyId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformInvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    amount?: SortOrder
  }

  export type PlatformInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    societyId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    societyId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformInvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    amount?: SortOrder
  }

  export type CommunityBuzzOrderByRelevanceInput = {
    fields: CommunityBuzzOrderByRelevanceFieldEnum | CommunityBuzzOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CommunityBuzzCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    societyId?: SortOrder
    hasResult?: SortOrder
    imageUrls?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityBuzzAvgOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    societyId?: SortOrder
    likes?: SortOrder
  }

  export type CommunityBuzzMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    societyId?: SortOrder
    hasResult?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityBuzzMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    societyId?: SortOrder
    hasResult?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityBuzzSumOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    societyId?: SortOrder
    likes?: SortOrder
  }

  export type CommunityBuzzScalarRelationFilter = {
    is?: CommunityBuzzWhereInput
    isNot?: CommunityBuzzWhereInput
  }

  export type CommunityCommentOrderByRelevanceInput = {
    fields: CommunityCommentOrderByRelevanceFieldEnum | CommunityCommentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CommunityCommentCountOrderByAggregateInput = {
    id?: SortOrder
    buzzId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    buzzId?: SortOrder
    authorId?: SortOrder
  }

  export type CommunityCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    buzzId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityCommentMinOrderByAggregateInput = {
    id?: SortOrder
    buzzId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityCommentSumOrderByAggregateInput = {
    id?: SortOrder
    buzzId?: SortOrder
    authorId?: SortOrder
  }

  export type BuzzLikeBuzzIdUserIdCompoundUniqueInput = {
    buzzId: number
    userId: number
  }

  export type BuzzLikeCountOrderByAggregateInput = {
    id?: SortOrder
    buzzId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type BuzzLikeAvgOrderByAggregateInput = {
    id?: SortOrder
    buzzId?: SortOrder
    userId?: SortOrder
  }

  export type BuzzLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    buzzId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type BuzzLikeMinOrderByAggregateInput = {
    id?: SortOrder
    buzzId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type BuzzLikeSumOrderByAggregateInput = {
    id?: SortOrder
    buzzId?: SortOrder
    userId?: SortOrder
  }

  export type UnitMemberOrderByRelevanceInput = {
    fields: UnitMemberOrderByRelevanceFieldEnum | UnitMemberOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UnitMemberCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    profileImg?: SortOrder
    createdAt?: SortOrder
  }

  export type UnitMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    age?: SortOrder
  }

  export type UnitMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    profileImg?: SortOrder
    createdAt?: SortOrder
  }

  export type UnitMemberMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    profileImg?: SortOrder
    createdAt?: SortOrder
  }

  export type UnitMemberSumOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    age?: SortOrder
  }

  export type UnitVehicleOrderByRelevanceInput = {
    fields: UnitVehicleOrderByRelevanceFieldEnum | UnitVehicleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UnitVehicleCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    number?: SortOrder
    type?: SortOrder
    color?: SortOrder
    parkingSlot?: SortOrder
    createdAt?: SortOrder
  }

  export type UnitVehicleAvgOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
  }

  export type UnitVehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    number?: SortOrder
    type?: SortOrder
    color?: SortOrder
    parkingSlot?: SortOrder
    createdAt?: SortOrder
  }

  export type UnitVehicleMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    number?: SortOrder
    type?: SortOrder
    color?: SortOrder
    parkingSlot?: SortOrder
    createdAt?: SortOrder
  }

  export type UnitVehicleSumOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
  }

  export type UnitPetOrderByRelevanceInput = {
    fields: UnitPetOrderByRelevanceFieldEnum | UnitPetOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UnitPetCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    breed?: SortOrder
    vaccinationStatus?: SortOrder
    lastVaccinationDate?: SortOrder
    createdAt?: SortOrder
  }

  export type UnitPetAvgOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
  }

  export type UnitPetMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    breed?: SortOrder
    vaccinationStatus?: SortOrder
    lastVaccinationDate?: SortOrder
    createdAt?: SortOrder
  }

  export type UnitPetMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    breed?: SortOrder
    vaccinationStatus?: SortOrder
    lastVaccinationDate?: SortOrder
    createdAt?: SortOrder
  }

  export type UnitPetSumOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
  }

  export type SOSAlertOrderByRelevanceInput = {
    fields: SOSAlertOrderByRelevanceFieldEnum | SOSAlertOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SOSAlertCountOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    societyId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type SOSAlertAvgOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    societyId?: SortOrder
  }

  export type SOSAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    societyId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type SOSAlertMinOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    societyId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type SOSAlertSumOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    societyId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type MarketplaceItemOrderByRelevanceInput = {
    fields: MarketplaceItemOrderByRelevanceFieldEnum | MarketplaceItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MarketplaceItemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    condition?: SortOrder
    type?: SortOrder
    priceType?: SortOrder
    category?: SortOrder
    status?: SortOrder
    images?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    ownerId?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    ownerId?: SortOrder
    societyId?: SortOrder
  }

  export type MarketplaceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    condition?: SortOrder
    type?: SortOrder
    priceType?: SortOrder
    category?: SortOrder
    status?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    ownerId?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceItemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    condition?: SortOrder
    type?: SortOrder
    priceType?: SortOrder
    category?: SortOrder
    status?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    ownerId?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceItemSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    ownerId?: SortOrder
    societyId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type MeetingOrderByRelevanceInput = {
    fields: MeetingOrderByRelevanceFieldEnum | MeetingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MeetingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    attendees?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
  }

  export type MeetingAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type MeetingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
  }

  export type MeetingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
  }

  export type MeetingSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type CommunityGuidelineOrderByRelevanceInput = {
    fields: CommunityGuidelineOrderByRelevanceFieldEnum | CommunityGuidelineOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CommunityGuidelineCountOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityGuidelineAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type CommunityGuidelineMaxOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityGuidelineMinOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityGuidelineSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type AssetOrderByRelevanceInput = {
    fields: AssetOrderByRelevanceFieldEnum | AssetOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    value?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    societyId?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    value?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    value?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    societyId?: SortOrder
  }

  export type DocumentOrderByRelevanceInput = {
    fields: DocumentOrderByRelevanceFieldEnum | DocumentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type ParcelOrderByRelevanceInput = {
    fields: ParcelOrderByRelevanceFieldEnum | ParcelOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ParcelCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    courierName?: SortOrder
    trackingNumber?: SortOrder
    description?: SortOrder
    receivedBy?: SortOrder
    status?: SortOrder
    collectedBy?: SortOrder
    collectedAt?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type ParcelAvgOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    societyId?: SortOrder
  }

  export type ParcelMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    courierName?: SortOrder
    trackingNumber?: SortOrder
    description?: SortOrder
    receivedBy?: SortOrder
    status?: SortOrder
    collectedBy?: SortOrder
    collectedAt?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type ParcelMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    courierName?: SortOrder
    trackingNumber?: SortOrder
    description?: SortOrder
    receivedBy?: SortOrder
    status?: SortOrder
    collectedBy?: SortOrder
    collectedAt?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type ParcelSumOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    societyId?: SortOrder
  }

  export type EventOrderByRelevanceInput = {
    fields: EventOrderByRelevanceFieldEnum | EventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    category?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    category?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    category?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type PurchaseRequestOrderByRelevanceInput = {
    fields: PurchaseRequestOrderByRelevanceFieldEnum | PurchaseRequestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PurchaseRequestCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    societyId?: SortOrder
    requestedById?: SortOrder
  }

  export type PurchaseRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    societyId?: SortOrder
    requestedById?: SortOrder
  }

  export type PurchaseRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    societyId?: SortOrder
    requestedById?: SortOrder
  }

  export type PurchaseRequestMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    societyId?: SortOrder
    requestedById?: SortOrder
  }

  export type PurchaseRequestSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    societyId?: SortOrder
    requestedById?: SortOrder
  }

  export type ConversationOrderByRelevanceInput = {
    fields: ConversationOrderByRelevanceFieldEnum | ConversationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ConversationSocietyIdTypeParticipantIdCompoundUniqueInput = {
    societyId: number
    type: string
    participantId: number
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    type?: SortOrder
    participantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    participantId?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    type?: SortOrder
    participantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    type?: SortOrder
    participantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    participantId?: SortOrder
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type ChatMessageOrderByRelevanceInput = {
    fields: ChatMessageOrderByRelevanceFieldEnum | ChatMessageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageSumOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
  }

  export type ServiceVariantListRelationFilter = {
    every?: ServiceVariantWhereInput
    some?: ServiceVariantWhereInput
    none?: ServiceVariantWhereInput
  }

  export type ServiceVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCategoryOrderByRelevanceInput = {
    fields: ServiceCategoryOrderByRelevanceFieldEnum | ServiceCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ServiceCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceCategoryScalarRelationFilter = {
    is?: ServiceCategoryWhereInput
    isNot?: ServiceCategoryWhereInput
  }

  export type ServiceVariantOrderByRelevanceInput = {
    fields: ServiceVariantOrderByRelevanceFieldEnum | ServiceVariantOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ServiceVariantCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceVariantAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type ServiceVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceVariantMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceVariantSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type ServiceCategoryNullableScalarRelationFilter = {
    is?: ServiceCategoryWhereInput | null
    isNot?: ServiceCategoryWhereInput | null
  }

  export type ServiceInquiryOrderByRelevanceInput = {
    fields: ServiceInquiryOrderByRelevanceFieldEnum | ServiceInquiryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ServiceInquiryCountOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    societyId?: SortOrder
    serviceId?: SortOrder
    serviceName?: SortOrder
    type?: SortOrder
    status?: SortOrder
    preferredDate?: SortOrder
    preferredTime?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    vendorName?: SortOrder
    vendorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceInquiryAvgOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    societyId?: SortOrder
    vendorId?: SortOrder
  }

  export type ServiceInquiryMaxOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    societyId?: SortOrder
    serviceId?: SortOrder
    serviceName?: SortOrder
    type?: SortOrder
    status?: SortOrder
    preferredDate?: SortOrder
    preferredTime?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    vendorName?: SortOrder
    vendorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceInquiryMinOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    societyId?: SortOrder
    serviceId?: SortOrder
    serviceName?: SortOrder
    type?: SortOrder
    status?: SortOrder
    preferredDate?: SortOrder
    preferredTime?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    vendorName?: SortOrder
    vendorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceInquirySumOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    societyId?: SortOrder
    vendorId?: SortOrder
  }

  export type UserCreateNestedManyWithoutSocietyInput = {
    create?: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput> | UserCreateWithoutSocietyInput[] | UserUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSocietyInput | UserCreateOrConnectWithoutSocietyInput[]
    createMany?: UserCreateManySocietyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UnitCreateNestedManyWithoutSocietyInput = {
    create?: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput> | UnitCreateWithoutSocietyInput[] | UnitUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutSocietyInput | UnitCreateOrConnectWithoutSocietyInput[]
    createMany?: UnitCreateManySocietyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type ComplaintCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput> | ComplaintCreateWithoutSocietyInput[] | ComplaintUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutSocietyInput | ComplaintCreateOrConnectWithoutSocietyInput[]
    createMany?: ComplaintCreateManySocietyInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type VisitorCreateNestedManyWithoutSocietyInput = {
    create?: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput> | VisitorCreateWithoutSocietyInput[] | VisitorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutSocietyInput | VisitorCreateOrConnectWithoutSocietyInput[]
    createMany?: VisitorCreateManySocietyInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutSocietyInput = {
    create?: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput> | TransactionCreateWithoutSocietyInput[] | TransactionUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSocietyInput | TransactionCreateOrConnectWithoutSocietyInput[]
    createMany?: TransactionCreateManySocietyInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type NoticeCreateNestedManyWithoutSocietyInput = {
    create?: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput> | NoticeCreateWithoutSocietyInput[] | NoticeUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutSocietyInput | NoticeCreateOrConnectWithoutSocietyInput[]
    createMany?: NoticeCreateManySocietyInputEnvelope
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
  }

  export type VendorCreateNestedManyWithoutSocietyInput = {
    create?: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput> | VendorCreateWithoutSocietyInput[] | VendorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutSocietyInput | VendorCreateOrConnectWithoutSocietyInput[]
    createMany?: VendorCreateManySocietyInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type AmenityCreateNestedManyWithoutSocietyInput = {
    create?: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput> | AmenityCreateWithoutSocietyInput[] | AmenityUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: AmenityCreateOrConnectWithoutSocietyInput | AmenityCreateOrConnectWithoutSocietyInput[]
    createMany?: AmenityCreateManySocietyInputEnvelope
    connect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
  }

  export type ParkingSlotCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput> | ParkingSlotCreateWithoutSocietyInput[] | ParkingSlotUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutSocietyInput | ParkingSlotCreateOrConnectWithoutSocietyInput[]
    createMany?: ParkingSlotCreateManySocietyInputEnvelope
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
  }

  export type PlatformInvoiceCreateNestedManyWithoutSocietyInput = {
    create?: XOR<PlatformInvoiceCreateWithoutSocietyInput, PlatformInvoiceUncheckedCreateWithoutSocietyInput> | PlatformInvoiceCreateWithoutSocietyInput[] | PlatformInvoiceUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: PlatformInvoiceCreateOrConnectWithoutSocietyInput | PlatformInvoiceCreateOrConnectWithoutSocietyInput[]
    createMany?: PlatformInvoiceCreateManySocietyInputEnvelope
    connect?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
  }

  export type MeetingCreateNestedManyWithoutSocietyInput = {
    create?: XOR<MeetingCreateWithoutSocietyInput, MeetingUncheckedCreateWithoutSocietyInput> | MeetingCreateWithoutSocietyInput[] | MeetingUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutSocietyInput | MeetingCreateOrConnectWithoutSocietyInput[]
    createMany?: MeetingCreateManySocietyInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutSocietyInput = {
    create?: XOR<AssetCreateWithoutSocietyInput, AssetUncheckedCreateWithoutSocietyInput> | AssetCreateWithoutSocietyInput[] | AssetUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutSocietyInput | AssetCreateOrConnectWithoutSocietyInput[]
    createMany?: AssetCreateManySocietyInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutSocietyInput = {
    create?: XOR<DocumentCreateWithoutSocietyInput, DocumentUncheckedCreateWithoutSocietyInput> | DocumentCreateWithoutSocietyInput[] | DocumentUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSocietyInput | DocumentCreateOrConnectWithoutSocietyInput[]
    createMany?: DocumentCreateManySocietyInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ParcelCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ParcelCreateWithoutSocietyInput, ParcelUncheckedCreateWithoutSocietyInput> | ParcelCreateWithoutSocietyInput[] | ParcelUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ParcelCreateOrConnectWithoutSocietyInput | ParcelCreateOrConnectWithoutSocietyInput[]
    createMany?: ParcelCreateManySocietyInputEnvelope
    connect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutSocietyInput = {
    create?: XOR<EventCreateWithoutSocietyInput, EventUncheckedCreateWithoutSocietyInput> | EventCreateWithoutSocietyInput[] | EventUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: EventCreateOrConnectWithoutSocietyInput | EventCreateOrConnectWithoutSocietyInput[]
    createMany?: EventCreateManySocietyInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type PurchaseRequestCreateNestedManyWithoutSocietyInput = {
    create?: XOR<PurchaseRequestCreateWithoutSocietyInput, PurchaseRequestUncheckedCreateWithoutSocietyInput> | PurchaseRequestCreateWithoutSocietyInput[] | PurchaseRequestUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutSocietyInput | PurchaseRequestCreateOrConnectWithoutSocietyInput[]
    createMany?: PurchaseRequestCreateManySocietyInputEnvelope
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
  }

  export type EmergencyAlertCreateNestedManyWithoutSocietyInput = {
    create?: XOR<EmergencyAlertCreateWithoutSocietyInput, EmergencyAlertUncheckedCreateWithoutSocietyInput> | EmergencyAlertCreateWithoutSocietyInput[] | EmergencyAlertUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: EmergencyAlertCreateOrConnectWithoutSocietyInput | EmergencyAlertCreateOrConnectWithoutSocietyInput[]
    createMany?: EmergencyAlertCreateManySocietyInputEnvelope
    connect?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
  }

  export type EmergencyContactCreateNestedManyWithoutSocietyInput = {
    create?: XOR<EmergencyContactCreateWithoutSocietyInput, EmergencyContactUncheckedCreateWithoutSocietyInput> | EmergencyContactCreateWithoutSocietyInput[] | EmergencyContactUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutSocietyInput | EmergencyContactCreateOrConnectWithoutSocietyInput[]
    createMany?: EmergencyContactCreateManySocietyInputEnvelope
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
  }

  export type ServiceInquiryCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ServiceInquiryCreateWithoutSocietyInput, ServiceInquiryUncheckedCreateWithoutSocietyInput> | ServiceInquiryCreateWithoutSocietyInput[] | ServiceInquiryUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ServiceInquiryCreateOrConnectWithoutSocietyInput | ServiceInquiryCreateOrConnectWithoutSocietyInput[]
    createMany?: ServiceInquiryCreateManySocietyInputEnvelope
    connect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ConversationCreateWithoutSocietyInput, ConversationUncheckedCreateWithoutSocietyInput> | ConversationCreateWithoutSocietyInput[] | ConversationUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutSocietyInput | ConversationCreateOrConnectWithoutSocietyInput[]
    createMany?: ConversationCreateManySocietyInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type CommunityBuzzCreateNestedManyWithoutSocietyInput = {
    create?: XOR<CommunityBuzzCreateWithoutSocietyInput, CommunityBuzzUncheckedCreateWithoutSocietyInput> | CommunityBuzzCreateWithoutSocietyInput[] | CommunityBuzzUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: CommunityBuzzCreateOrConnectWithoutSocietyInput | CommunityBuzzCreateOrConnectWithoutSocietyInput[]
    createMany?: CommunityBuzzCreateManySocietyInputEnvelope
    connect?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
  }

  export type MarketplaceItemCreateNestedManyWithoutSocietyInput = {
    create?: XOR<MarketplaceItemCreateWithoutSocietyInput, MarketplaceItemUncheckedCreateWithoutSocietyInput> | MarketplaceItemCreateWithoutSocietyInput[] | MarketplaceItemUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutSocietyInput | MarketplaceItemCreateOrConnectWithoutSocietyInput[]
    createMany?: MarketplaceItemCreateManySocietyInputEnvelope
    connect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
  }

  export type CommunityGuidelineCreateNestedManyWithoutSocietyInput = {
    create?: XOR<CommunityGuidelineCreateWithoutSocietyInput, CommunityGuidelineUncheckedCreateWithoutSocietyInput> | CommunityGuidelineCreateWithoutSocietyInput[] | CommunityGuidelineUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: CommunityGuidelineCreateOrConnectWithoutSocietyInput | CommunityGuidelineCreateOrConnectWithoutSocietyInput[]
    createMany?: CommunityGuidelineCreateManySocietyInputEnvelope
    connect?: CommunityGuidelineWhereUniqueInput | CommunityGuidelineWhereUniqueInput[]
  }

  export type SOSAlertCreateNestedManyWithoutSocietyInput = {
    create?: XOR<SOSAlertCreateWithoutSocietyInput, SOSAlertUncheckedCreateWithoutSocietyInput> | SOSAlertCreateWithoutSocietyInput[] | SOSAlertUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: SOSAlertCreateOrConnectWithoutSocietyInput | SOSAlertCreateOrConnectWithoutSocietyInput[]
    createMany?: SOSAlertCreateManySocietyInputEnvelope
    connect?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput> | UserCreateWithoutSocietyInput[] | UserUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSocietyInput | UserCreateOrConnectWithoutSocietyInput[]
    createMany?: UserCreateManySocietyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput> | UnitCreateWithoutSocietyInput[] | UnitUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutSocietyInput | UnitCreateOrConnectWithoutSocietyInput[]
    createMany?: UnitCreateManySocietyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type ComplaintUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput> | ComplaintCreateWithoutSocietyInput[] | ComplaintUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutSocietyInput | ComplaintCreateOrConnectWithoutSocietyInput[]
    createMany?: ComplaintCreateManySocietyInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type VisitorUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput> | VisitorCreateWithoutSocietyInput[] | VisitorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutSocietyInput | VisitorCreateOrConnectWithoutSocietyInput[]
    createMany?: VisitorCreateManySocietyInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput> | TransactionCreateWithoutSocietyInput[] | TransactionUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSocietyInput | TransactionCreateOrConnectWithoutSocietyInput[]
    createMany?: TransactionCreateManySocietyInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type NoticeUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput> | NoticeCreateWithoutSocietyInput[] | NoticeUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutSocietyInput | NoticeCreateOrConnectWithoutSocietyInput[]
    createMany?: NoticeCreateManySocietyInputEnvelope
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
  }

  export type VendorUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput> | VendorCreateWithoutSocietyInput[] | VendorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutSocietyInput | VendorCreateOrConnectWithoutSocietyInput[]
    createMany?: VendorCreateManySocietyInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type AmenityUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput> | AmenityCreateWithoutSocietyInput[] | AmenityUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: AmenityCreateOrConnectWithoutSocietyInput | AmenityCreateOrConnectWithoutSocietyInput[]
    createMany?: AmenityCreateManySocietyInputEnvelope
    connect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
  }

  export type ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput> | ParkingSlotCreateWithoutSocietyInput[] | ParkingSlotUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutSocietyInput | ParkingSlotCreateOrConnectWithoutSocietyInput[]
    createMany?: ParkingSlotCreateManySocietyInputEnvelope
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
  }

  export type PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<PlatformInvoiceCreateWithoutSocietyInput, PlatformInvoiceUncheckedCreateWithoutSocietyInput> | PlatformInvoiceCreateWithoutSocietyInput[] | PlatformInvoiceUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: PlatformInvoiceCreateOrConnectWithoutSocietyInput | PlatformInvoiceCreateOrConnectWithoutSocietyInput[]
    createMany?: PlatformInvoiceCreateManySocietyInputEnvelope
    connect?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
  }

  export type MeetingUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<MeetingCreateWithoutSocietyInput, MeetingUncheckedCreateWithoutSocietyInput> | MeetingCreateWithoutSocietyInput[] | MeetingUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutSocietyInput | MeetingCreateOrConnectWithoutSocietyInput[]
    createMany?: MeetingCreateManySocietyInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<AssetCreateWithoutSocietyInput, AssetUncheckedCreateWithoutSocietyInput> | AssetCreateWithoutSocietyInput[] | AssetUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutSocietyInput | AssetCreateOrConnectWithoutSocietyInput[]
    createMany?: AssetCreateManySocietyInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<DocumentCreateWithoutSocietyInput, DocumentUncheckedCreateWithoutSocietyInput> | DocumentCreateWithoutSocietyInput[] | DocumentUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSocietyInput | DocumentCreateOrConnectWithoutSocietyInput[]
    createMany?: DocumentCreateManySocietyInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ParcelUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ParcelCreateWithoutSocietyInput, ParcelUncheckedCreateWithoutSocietyInput> | ParcelCreateWithoutSocietyInput[] | ParcelUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ParcelCreateOrConnectWithoutSocietyInput | ParcelCreateOrConnectWithoutSocietyInput[]
    createMany?: ParcelCreateManySocietyInputEnvelope
    connect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<EventCreateWithoutSocietyInput, EventUncheckedCreateWithoutSocietyInput> | EventCreateWithoutSocietyInput[] | EventUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: EventCreateOrConnectWithoutSocietyInput | EventCreateOrConnectWithoutSocietyInput[]
    createMany?: EventCreateManySocietyInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<PurchaseRequestCreateWithoutSocietyInput, PurchaseRequestUncheckedCreateWithoutSocietyInput> | PurchaseRequestCreateWithoutSocietyInput[] | PurchaseRequestUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutSocietyInput | PurchaseRequestCreateOrConnectWithoutSocietyInput[]
    createMany?: PurchaseRequestCreateManySocietyInputEnvelope
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
  }

  export type EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<EmergencyAlertCreateWithoutSocietyInput, EmergencyAlertUncheckedCreateWithoutSocietyInput> | EmergencyAlertCreateWithoutSocietyInput[] | EmergencyAlertUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: EmergencyAlertCreateOrConnectWithoutSocietyInput | EmergencyAlertCreateOrConnectWithoutSocietyInput[]
    createMany?: EmergencyAlertCreateManySocietyInputEnvelope
    connect?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
  }

  export type EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<EmergencyContactCreateWithoutSocietyInput, EmergencyContactUncheckedCreateWithoutSocietyInput> | EmergencyContactCreateWithoutSocietyInput[] | EmergencyContactUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutSocietyInput | EmergencyContactCreateOrConnectWithoutSocietyInput[]
    createMany?: EmergencyContactCreateManySocietyInputEnvelope
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
  }

  export type ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ServiceInquiryCreateWithoutSocietyInput, ServiceInquiryUncheckedCreateWithoutSocietyInput> | ServiceInquiryCreateWithoutSocietyInput[] | ServiceInquiryUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ServiceInquiryCreateOrConnectWithoutSocietyInput | ServiceInquiryCreateOrConnectWithoutSocietyInput[]
    createMany?: ServiceInquiryCreateManySocietyInputEnvelope
    connect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ConversationCreateWithoutSocietyInput, ConversationUncheckedCreateWithoutSocietyInput> | ConversationCreateWithoutSocietyInput[] | ConversationUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutSocietyInput | ConversationCreateOrConnectWithoutSocietyInput[]
    createMany?: ConversationCreateManySocietyInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<CommunityBuzzCreateWithoutSocietyInput, CommunityBuzzUncheckedCreateWithoutSocietyInput> | CommunityBuzzCreateWithoutSocietyInput[] | CommunityBuzzUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: CommunityBuzzCreateOrConnectWithoutSocietyInput | CommunityBuzzCreateOrConnectWithoutSocietyInput[]
    createMany?: CommunityBuzzCreateManySocietyInputEnvelope
    connect?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
  }

  export type MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<MarketplaceItemCreateWithoutSocietyInput, MarketplaceItemUncheckedCreateWithoutSocietyInput> | MarketplaceItemCreateWithoutSocietyInput[] | MarketplaceItemUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutSocietyInput | MarketplaceItemCreateOrConnectWithoutSocietyInput[]
    createMany?: MarketplaceItemCreateManySocietyInputEnvelope
    connect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
  }

  export type CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<CommunityGuidelineCreateWithoutSocietyInput, CommunityGuidelineUncheckedCreateWithoutSocietyInput> | CommunityGuidelineCreateWithoutSocietyInput[] | CommunityGuidelineUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: CommunityGuidelineCreateOrConnectWithoutSocietyInput | CommunityGuidelineCreateOrConnectWithoutSocietyInput[]
    createMany?: CommunityGuidelineCreateManySocietyInputEnvelope
    connect?: CommunityGuidelineWhereUniqueInput | CommunityGuidelineWhereUniqueInput[]
  }

  export type SOSAlertUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<SOSAlertCreateWithoutSocietyInput, SOSAlertUncheckedCreateWithoutSocietyInput> | SOSAlertCreateWithoutSocietyInput[] | SOSAlertUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: SOSAlertCreateOrConnectWithoutSocietyInput | SOSAlertCreateOrConnectWithoutSocietyInput[]
    createMany?: SOSAlertCreateManySocietyInputEnvelope
    connect?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumSocietyStatusFieldUpdateOperationsInput = {
    set?: $Enums.SocietyStatus
  }

  export type EnumSubscriptionPlanFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPlan
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput> | UserCreateWithoutSocietyInput[] | UserUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSocietyInput | UserCreateOrConnectWithoutSocietyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSocietyInput | UserUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: UserCreateManySocietyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSocietyInput | UserUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSocietyInput | UserUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UnitUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput> | UnitCreateWithoutSocietyInput[] | UnitUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutSocietyInput | UnitCreateOrConnectWithoutSocietyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutSocietyInput | UnitUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: UnitCreateManySocietyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutSocietyInput | UnitUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutSocietyInput | UnitUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type ComplaintUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput> | ComplaintCreateWithoutSocietyInput[] | ComplaintUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutSocietyInput | ComplaintCreateOrConnectWithoutSocietyInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutSocietyInput | ComplaintUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ComplaintCreateManySocietyInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutSocietyInput | ComplaintUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutSocietyInput | ComplaintUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type VisitorUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput> | VisitorCreateWithoutSocietyInput[] | VisitorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutSocietyInput | VisitorCreateOrConnectWithoutSocietyInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutSocietyInput | VisitorUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: VisitorCreateManySocietyInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutSocietyInput | VisitorUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutSocietyInput | VisitorUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput> | TransactionCreateWithoutSocietyInput[] | TransactionUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSocietyInput | TransactionCreateOrConnectWithoutSocietyInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSocietyInput | TransactionUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: TransactionCreateManySocietyInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSocietyInput | TransactionUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSocietyInput | TransactionUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type NoticeUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput> | NoticeCreateWithoutSocietyInput[] | NoticeUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutSocietyInput | NoticeCreateOrConnectWithoutSocietyInput[]
    upsert?: NoticeUpsertWithWhereUniqueWithoutSocietyInput | NoticeUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: NoticeCreateManySocietyInputEnvelope
    set?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    disconnect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    delete?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    update?: NoticeUpdateWithWhereUniqueWithoutSocietyInput | NoticeUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: NoticeUpdateManyWithWhereWithoutSocietyInput | NoticeUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
  }

  export type VendorUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput> | VendorCreateWithoutSocietyInput[] | VendorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutSocietyInput | VendorCreateOrConnectWithoutSocietyInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutSocietyInput | VendorUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: VendorCreateManySocietyInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutSocietyInput | VendorUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutSocietyInput | VendorUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type AmenityUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput> | AmenityCreateWithoutSocietyInput[] | AmenityUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: AmenityCreateOrConnectWithoutSocietyInput | AmenityCreateOrConnectWithoutSocietyInput[]
    upsert?: AmenityUpsertWithWhereUniqueWithoutSocietyInput | AmenityUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: AmenityCreateManySocietyInputEnvelope
    set?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    disconnect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    delete?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    connect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    update?: AmenityUpdateWithWhereUniqueWithoutSocietyInput | AmenityUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: AmenityUpdateManyWithWhereWithoutSocietyInput | AmenityUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: AmenityScalarWhereInput | AmenityScalarWhereInput[]
  }

  export type ParkingSlotUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput> | ParkingSlotCreateWithoutSocietyInput[] | ParkingSlotUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutSocietyInput | ParkingSlotCreateOrConnectWithoutSocietyInput[]
    upsert?: ParkingSlotUpsertWithWhereUniqueWithoutSocietyInput | ParkingSlotUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ParkingSlotCreateManySocietyInputEnvelope
    set?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    disconnect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    delete?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    update?: ParkingSlotUpdateWithWhereUniqueWithoutSocietyInput | ParkingSlotUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ParkingSlotUpdateManyWithWhereWithoutSocietyInput | ParkingSlotUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
  }

  export type PlatformInvoiceUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<PlatformInvoiceCreateWithoutSocietyInput, PlatformInvoiceUncheckedCreateWithoutSocietyInput> | PlatformInvoiceCreateWithoutSocietyInput[] | PlatformInvoiceUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: PlatformInvoiceCreateOrConnectWithoutSocietyInput | PlatformInvoiceCreateOrConnectWithoutSocietyInput[]
    upsert?: PlatformInvoiceUpsertWithWhereUniqueWithoutSocietyInput | PlatformInvoiceUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: PlatformInvoiceCreateManySocietyInputEnvelope
    set?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
    disconnect?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
    delete?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
    connect?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
    update?: PlatformInvoiceUpdateWithWhereUniqueWithoutSocietyInput | PlatformInvoiceUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: PlatformInvoiceUpdateManyWithWhereWithoutSocietyInput | PlatformInvoiceUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: PlatformInvoiceScalarWhereInput | PlatformInvoiceScalarWhereInput[]
  }

  export type MeetingUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<MeetingCreateWithoutSocietyInput, MeetingUncheckedCreateWithoutSocietyInput> | MeetingCreateWithoutSocietyInput[] | MeetingUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutSocietyInput | MeetingCreateOrConnectWithoutSocietyInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutSocietyInput | MeetingUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: MeetingCreateManySocietyInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutSocietyInput | MeetingUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutSocietyInput | MeetingUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<AssetCreateWithoutSocietyInput, AssetUncheckedCreateWithoutSocietyInput> | AssetCreateWithoutSocietyInput[] | AssetUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutSocietyInput | AssetCreateOrConnectWithoutSocietyInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutSocietyInput | AssetUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: AssetCreateManySocietyInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutSocietyInput | AssetUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutSocietyInput | AssetUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<DocumentCreateWithoutSocietyInput, DocumentUncheckedCreateWithoutSocietyInput> | DocumentCreateWithoutSocietyInput[] | DocumentUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSocietyInput | DocumentCreateOrConnectWithoutSocietyInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutSocietyInput | DocumentUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: DocumentCreateManySocietyInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutSocietyInput | DocumentUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutSocietyInput | DocumentUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ParcelUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ParcelCreateWithoutSocietyInput, ParcelUncheckedCreateWithoutSocietyInput> | ParcelCreateWithoutSocietyInput[] | ParcelUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ParcelCreateOrConnectWithoutSocietyInput | ParcelCreateOrConnectWithoutSocietyInput[]
    upsert?: ParcelUpsertWithWhereUniqueWithoutSocietyInput | ParcelUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ParcelCreateManySocietyInputEnvelope
    set?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    disconnect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    delete?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    connect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    update?: ParcelUpdateWithWhereUniqueWithoutSocietyInput | ParcelUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ParcelUpdateManyWithWhereWithoutSocietyInput | ParcelUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ParcelScalarWhereInput | ParcelScalarWhereInput[]
  }

  export type EventUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<EventCreateWithoutSocietyInput, EventUncheckedCreateWithoutSocietyInput> | EventCreateWithoutSocietyInput[] | EventUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: EventCreateOrConnectWithoutSocietyInput | EventCreateOrConnectWithoutSocietyInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutSocietyInput | EventUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: EventCreateManySocietyInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutSocietyInput | EventUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: EventUpdateManyWithWhereWithoutSocietyInput | EventUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type PurchaseRequestUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<PurchaseRequestCreateWithoutSocietyInput, PurchaseRequestUncheckedCreateWithoutSocietyInput> | PurchaseRequestCreateWithoutSocietyInput[] | PurchaseRequestUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutSocietyInput | PurchaseRequestCreateOrConnectWithoutSocietyInput[]
    upsert?: PurchaseRequestUpsertWithWhereUniqueWithoutSocietyInput | PurchaseRequestUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: PurchaseRequestCreateManySocietyInputEnvelope
    set?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    disconnect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    delete?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    update?: PurchaseRequestUpdateWithWhereUniqueWithoutSocietyInput | PurchaseRequestUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: PurchaseRequestUpdateManyWithWhereWithoutSocietyInput | PurchaseRequestUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
  }

  export type EmergencyAlertUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<EmergencyAlertCreateWithoutSocietyInput, EmergencyAlertUncheckedCreateWithoutSocietyInput> | EmergencyAlertCreateWithoutSocietyInput[] | EmergencyAlertUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: EmergencyAlertCreateOrConnectWithoutSocietyInput | EmergencyAlertCreateOrConnectWithoutSocietyInput[]
    upsert?: EmergencyAlertUpsertWithWhereUniqueWithoutSocietyInput | EmergencyAlertUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: EmergencyAlertCreateManySocietyInputEnvelope
    set?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
    disconnect?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
    delete?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
    connect?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
    update?: EmergencyAlertUpdateWithWhereUniqueWithoutSocietyInput | EmergencyAlertUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: EmergencyAlertUpdateManyWithWhereWithoutSocietyInput | EmergencyAlertUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: EmergencyAlertScalarWhereInput | EmergencyAlertScalarWhereInput[]
  }

  export type EmergencyContactUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<EmergencyContactCreateWithoutSocietyInput, EmergencyContactUncheckedCreateWithoutSocietyInput> | EmergencyContactCreateWithoutSocietyInput[] | EmergencyContactUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutSocietyInput | EmergencyContactCreateOrConnectWithoutSocietyInput[]
    upsert?: EmergencyContactUpsertWithWhereUniqueWithoutSocietyInput | EmergencyContactUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: EmergencyContactCreateManySocietyInputEnvelope
    set?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    disconnect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    delete?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    update?: EmergencyContactUpdateWithWhereUniqueWithoutSocietyInput | EmergencyContactUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: EmergencyContactUpdateManyWithWhereWithoutSocietyInput | EmergencyContactUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
  }

  export type ServiceInquiryUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ServiceInquiryCreateWithoutSocietyInput, ServiceInquiryUncheckedCreateWithoutSocietyInput> | ServiceInquiryCreateWithoutSocietyInput[] | ServiceInquiryUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ServiceInquiryCreateOrConnectWithoutSocietyInput | ServiceInquiryCreateOrConnectWithoutSocietyInput[]
    upsert?: ServiceInquiryUpsertWithWhereUniqueWithoutSocietyInput | ServiceInquiryUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ServiceInquiryCreateManySocietyInputEnvelope
    set?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    disconnect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    delete?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    connect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    update?: ServiceInquiryUpdateWithWhereUniqueWithoutSocietyInput | ServiceInquiryUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ServiceInquiryUpdateManyWithWhereWithoutSocietyInput | ServiceInquiryUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ServiceInquiryScalarWhereInput | ServiceInquiryScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ConversationCreateWithoutSocietyInput, ConversationUncheckedCreateWithoutSocietyInput> | ConversationCreateWithoutSocietyInput[] | ConversationUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutSocietyInput | ConversationCreateOrConnectWithoutSocietyInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutSocietyInput | ConversationUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ConversationCreateManySocietyInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutSocietyInput | ConversationUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutSocietyInput | ConversationUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type CommunityBuzzUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<CommunityBuzzCreateWithoutSocietyInput, CommunityBuzzUncheckedCreateWithoutSocietyInput> | CommunityBuzzCreateWithoutSocietyInput[] | CommunityBuzzUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: CommunityBuzzCreateOrConnectWithoutSocietyInput | CommunityBuzzCreateOrConnectWithoutSocietyInput[]
    upsert?: CommunityBuzzUpsertWithWhereUniqueWithoutSocietyInput | CommunityBuzzUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: CommunityBuzzCreateManySocietyInputEnvelope
    set?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
    disconnect?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
    delete?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
    connect?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
    update?: CommunityBuzzUpdateWithWhereUniqueWithoutSocietyInput | CommunityBuzzUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: CommunityBuzzUpdateManyWithWhereWithoutSocietyInput | CommunityBuzzUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: CommunityBuzzScalarWhereInput | CommunityBuzzScalarWhereInput[]
  }

  export type MarketplaceItemUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<MarketplaceItemCreateWithoutSocietyInput, MarketplaceItemUncheckedCreateWithoutSocietyInput> | MarketplaceItemCreateWithoutSocietyInput[] | MarketplaceItemUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutSocietyInput | MarketplaceItemCreateOrConnectWithoutSocietyInput[]
    upsert?: MarketplaceItemUpsertWithWhereUniqueWithoutSocietyInput | MarketplaceItemUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: MarketplaceItemCreateManySocietyInputEnvelope
    set?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    disconnect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    delete?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    connect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    update?: MarketplaceItemUpdateWithWhereUniqueWithoutSocietyInput | MarketplaceItemUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: MarketplaceItemUpdateManyWithWhereWithoutSocietyInput | MarketplaceItemUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: MarketplaceItemScalarWhereInput | MarketplaceItemScalarWhereInput[]
  }

  export type CommunityGuidelineUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<CommunityGuidelineCreateWithoutSocietyInput, CommunityGuidelineUncheckedCreateWithoutSocietyInput> | CommunityGuidelineCreateWithoutSocietyInput[] | CommunityGuidelineUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: CommunityGuidelineCreateOrConnectWithoutSocietyInput | CommunityGuidelineCreateOrConnectWithoutSocietyInput[]
    upsert?: CommunityGuidelineUpsertWithWhereUniqueWithoutSocietyInput | CommunityGuidelineUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: CommunityGuidelineCreateManySocietyInputEnvelope
    set?: CommunityGuidelineWhereUniqueInput | CommunityGuidelineWhereUniqueInput[]
    disconnect?: CommunityGuidelineWhereUniqueInput | CommunityGuidelineWhereUniqueInput[]
    delete?: CommunityGuidelineWhereUniqueInput | CommunityGuidelineWhereUniqueInput[]
    connect?: CommunityGuidelineWhereUniqueInput | CommunityGuidelineWhereUniqueInput[]
    update?: CommunityGuidelineUpdateWithWhereUniqueWithoutSocietyInput | CommunityGuidelineUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: CommunityGuidelineUpdateManyWithWhereWithoutSocietyInput | CommunityGuidelineUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: CommunityGuidelineScalarWhereInput | CommunityGuidelineScalarWhereInput[]
  }

  export type SOSAlertUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<SOSAlertCreateWithoutSocietyInput, SOSAlertUncheckedCreateWithoutSocietyInput> | SOSAlertCreateWithoutSocietyInput[] | SOSAlertUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: SOSAlertCreateOrConnectWithoutSocietyInput | SOSAlertCreateOrConnectWithoutSocietyInput[]
    upsert?: SOSAlertUpsertWithWhereUniqueWithoutSocietyInput | SOSAlertUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: SOSAlertCreateManySocietyInputEnvelope
    set?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
    disconnect?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
    delete?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
    connect?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
    update?: SOSAlertUpdateWithWhereUniqueWithoutSocietyInput | SOSAlertUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: SOSAlertUpdateManyWithWhereWithoutSocietyInput | SOSAlertUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: SOSAlertScalarWhereInput | SOSAlertScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput> | UserCreateWithoutSocietyInput[] | UserUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSocietyInput | UserCreateOrConnectWithoutSocietyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSocietyInput | UserUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: UserCreateManySocietyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSocietyInput | UserUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSocietyInput | UserUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput> | UnitCreateWithoutSocietyInput[] | UnitUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutSocietyInput | UnitCreateOrConnectWithoutSocietyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutSocietyInput | UnitUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: UnitCreateManySocietyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutSocietyInput | UnitUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutSocietyInput | UnitUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type ComplaintUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput> | ComplaintCreateWithoutSocietyInput[] | ComplaintUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutSocietyInput | ComplaintCreateOrConnectWithoutSocietyInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutSocietyInput | ComplaintUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ComplaintCreateManySocietyInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutSocietyInput | ComplaintUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutSocietyInput | ComplaintUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type VisitorUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput> | VisitorCreateWithoutSocietyInput[] | VisitorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutSocietyInput | VisitorCreateOrConnectWithoutSocietyInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutSocietyInput | VisitorUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: VisitorCreateManySocietyInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutSocietyInput | VisitorUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutSocietyInput | VisitorUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput> | TransactionCreateWithoutSocietyInput[] | TransactionUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSocietyInput | TransactionCreateOrConnectWithoutSocietyInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSocietyInput | TransactionUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: TransactionCreateManySocietyInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSocietyInput | TransactionUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSocietyInput | TransactionUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type NoticeUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput> | NoticeCreateWithoutSocietyInput[] | NoticeUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutSocietyInput | NoticeCreateOrConnectWithoutSocietyInput[]
    upsert?: NoticeUpsertWithWhereUniqueWithoutSocietyInput | NoticeUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: NoticeCreateManySocietyInputEnvelope
    set?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    disconnect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    delete?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    update?: NoticeUpdateWithWhereUniqueWithoutSocietyInput | NoticeUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: NoticeUpdateManyWithWhereWithoutSocietyInput | NoticeUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
  }

  export type VendorUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput> | VendorCreateWithoutSocietyInput[] | VendorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutSocietyInput | VendorCreateOrConnectWithoutSocietyInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutSocietyInput | VendorUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: VendorCreateManySocietyInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutSocietyInput | VendorUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutSocietyInput | VendorUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type AmenityUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput> | AmenityCreateWithoutSocietyInput[] | AmenityUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: AmenityCreateOrConnectWithoutSocietyInput | AmenityCreateOrConnectWithoutSocietyInput[]
    upsert?: AmenityUpsertWithWhereUniqueWithoutSocietyInput | AmenityUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: AmenityCreateManySocietyInputEnvelope
    set?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    disconnect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    delete?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    connect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    update?: AmenityUpdateWithWhereUniqueWithoutSocietyInput | AmenityUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: AmenityUpdateManyWithWhereWithoutSocietyInput | AmenityUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: AmenityScalarWhereInput | AmenityScalarWhereInput[]
  }

  export type ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput> | ParkingSlotCreateWithoutSocietyInput[] | ParkingSlotUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutSocietyInput | ParkingSlotCreateOrConnectWithoutSocietyInput[]
    upsert?: ParkingSlotUpsertWithWhereUniqueWithoutSocietyInput | ParkingSlotUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ParkingSlotCreateManySocietyInputEnvelope
    set?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    disconnect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    delete?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    update?: ParkingSlotUpdateWithWhereUniqueWithoutSocietyInput | ParkingSlotUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ParkingSlotUpdateManyWithWhereWithoutSocietyInput | ParkingSlotUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
  }

  export type PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<PlatformInvoiceCreateWithoutSocietyInput, PlatformInvoiceUncheckedCreateWithoutSocietyInput> | PlatformInvoiceCreateWithoutSocietyInput[] | PlatformInvoiceUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: PlatformInvoiceCreateOrConnectWithoutSocietyInput | PlatformInvoiceCreateOrConnectWithoutSocietyInput[]
    upsert?: PlatformInvoiceUpsertWithWhereUniqueWithoutSocietyInput | PlatformInvoiceUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: PlatformInvoiceCreateManySocietyInputEnvelope
    set?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
    disconnect?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
    delete?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
    connect?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
    update?: PlatformInvoiceUpdateWithWhereUniqueWithoutSocietyInput | PlatformInvoiceUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: PlatformInvoiceUpdateManyWithWhereWithoutSocietyInput | PlatformInvoiceUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: PlatformInvoiceScalarWhereInput | PlatformInvoiceScalarWhereInput[]
  }

  export type MeetingUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<MeetingCreateWithoutSocietyInput, MeetingUncheckedCreateWithoutSocietyInput> | MeetingCreateWithoutSocietyInput[] | MeetingUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutSocietyInput | MeetingCreateOrConnectWithoutSocietyInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutSocietyInput | MeetingUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: MeetingCreateManySocietyInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutSocietyInput | MeetingUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutSocietyInput | MeetingUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<AssetCreateWithoutSocietyInput, AssetUncheckedCreateWithoutSocietyInput> | AssetCreateWithoutSocietyInput[] | AssetUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutSocietyInput | AssetCreateOrConnectWithoutSocietyInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutSocietyInput | AssetUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: AssetCreateManySocietyInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutSocietyInput | AssetUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutSocietyInput | AssetUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<DocumentCreateWithoutSocietyInput, DocumentUncheckedCreateWithoutSocietyInput> | DocumentCreateWithoutSocietyInput[] | DocumentUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSocietyInput | DocumentCreateOrConnectWithoutSocietyInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutSocietyInput | DocumentUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: DocumentCreateManySocietyInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutSocietyInput | DocumentUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutSocietyInput | DocumentUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ParcelUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ParcelCreateWithoutSocietyInput, ParcelUncheckedCreateWithoutSocietyInput> | ParcelCreateWithoutSocietyInput[] | ParcelUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ParcelCreateOrConnectWithoutSocietyInput | ParcelCreateOrConnectWithoutSocietyInput[]
    upsert?: ParcelUpsertWithWhereUniqueWithoutSocietyInput | ParcelUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ParcelCreateManySocietyInputEnvelope
    set?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    disconnect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    delete?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    connect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    update?: ParcelUpdateWithWhereUniqueWithoutSocietyInput | ParcelUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ParcelUpdateManyWithWhereWithoutSocietyInput | ParcelUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ParcelScalarWhereInput | ParcelScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<EventCreateWithoutSocietyInput, EventUncheckedCreateWithoutSocietyInput> | EventCreateWithoutSocietyInput[] | EventUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: EventCreateOrConnectWithoutSocietyInput | EventCreateOrConnectWithoutSocietyInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutSocietyInput | EventUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: EventCreateManySocietyInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutSocietyInput | EventUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: EventUpdateManyWithWhereWithoutSocietyInput | EventUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<PurchaseRequestCreateWithoutSocietyInput, PurchaseRequestUncheckedCreateWithoutSocietyInput> | PurchaseRequestCreateWithoutSocietyInput[] | PurchaseRequestUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutSocietyInput | PurchaseRequestCreateOrConnectWithoutSocietyInput[]
    upsert?: PurchaseRequestUpsertWithWhereUniqueWithoutSocietyInput | PurchaseRequestUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: PurchaseRequestCreateManySocietyInputEnvelope
    set?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    disconnect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    delete?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    update?: PurchaseRequestUpdateWithWhereUniqueWithoutSocietyInput | PurchaseRequestUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: PurchaseRequestUpdateManyWithWhereWithoutSocietyInput | PurchaseRequestUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
  }

  export type EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<EmergencyAlertCreateWithoutSocietyInput, EmergencyAlertUncheckedCreateWithoutSocietyInput> | EmergencyAlertCreateWithoutSocietyInput[] | EmergencyAlertUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: EmergencyAlertCreateOrConnectWithoutSocietyInput | EmergencyAlertCreateOrConnectWithoutSocietyInput[]
    upsert?: EmergencyAlertUpsertWithWhereUniqueWithoutSocietyInput | EmergencyAlertUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: EmergencyAlertCreateManySocietyInputEnvelope
    set?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
    disconnect?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
    delete?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
    connect?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
    update?: EmergencyAlertUpdateWithWhereUniqueWithoutSocietyInput | EmergencyAlertUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: EmergencyAlertUpdateManyWithWhereWithoutSocietyInput | EmergencyAlertUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: EmergencyAlertScalarWhereInput | EmergencyAlertScalarWhereInput[]
  }

  export type EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<EmergencyContactCreateWithoutSocietyInput, EmergencyContactUncheckedCreateWithoutSocietyInput> | EmergencyContactCreateWithoutSocietyInput[] | EmergencyContactUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutSocietyInput | EmergencyContactCreateOrConnectWithoutSocietyInput[]
    upsert?: EmergencyContactUpsertWithWhereUniqueWithoutSocietyInput | EmergencyContactUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: EmergencyContactCreateManySocietyInputEnvelope
    set?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    disconnect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    delete?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    update?: EmergencyContactUpdateWithWhereUniqueWithoutSocietyInput | EmergencyContactUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: EmergencyContactUpdateManyWithWhereWithoutSocietyInput | EmergencyContactUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
  }

  export type ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ServiceInquiryCreateWithoutSocietyInput, ServiceInquiryUncheckedCreateWithoutSocietyInput> | ServiceInquiryCreateWithoutSocietyInput[] | ServiceInquiryUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ServiceInquiryCreateOrConnectWithoutSocietyInput | ServiceInquiryCreateOrConnectWithoutSocietyInput[]
    upsert?: ServiceInquiryUpsertWithWhereUniqueWithoutSocietyInput | ServiceInquiryUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ServiceInquiryCreateManySocietyInputEnvelope
    set?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    disconnect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    delete?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    connect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    update?: ServiceInquiryUpdateWithWhereUniqueWithoutSocietyInput | ServiceInquiryUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ServiceInquiryUpdateManyWithWhereWithoutSocietyInput | ServiceInquiryUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ServiceInquiryScalarWhereInput | ServiceInquiryScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ConversationCreateWithoutSocietyInput, ConversationUncheckedCreateWithoutSocietyInput> | ConversationCreateWithoutSocietyInput[] | ConversationUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutSocietyInput | ConversationCreateOrConnectWithoutSocietyInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutSocietyInput | ConversationUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ConversationCreateManySocietyInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutSocietyInput | ConversationUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutSocietyInput | ConversationUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<CommunityBuzzCreateWithoutSocietyInput, CommunityBuzzUncheckedCreateWithoutSocietyInput> | CommunityBuzzCreateWithoutSocietyInput[] | CommunityBuzzUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: CommunityBuzzCreateOrConnectWithoutSocietyInput | CommunityBuzzCreateOrConnectWithoutSocietyInput[]
    upsert?: CommunityBuzzUpsertWithWhereUniqueWithoutSocietyInput | CommunityBuzzUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: CommunityBuzzCreateManySocietyInputEnvelope
    set?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
    disconnect?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
    delete?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
    connect?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
    update?: CommunityBuzzUpdateWithWhereUniqueWithoutSocietyInput | CommunityBuzzUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: CommunityBuzzUpdateManyWithWhereWithoutSocietyInput | CommunityBuzzUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: CommunityBuzzScalarWhereInput | CommunityBuzzScalarWhereInput[]
  }

  export type MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<MarketplaceItemCreateWithoutSocietyInput, MarketplaceItemUncheckedCreateWithoutSocietyInput> | MarketplaceItemCreateWithoutSocietyInput[] | MarketplaceItemUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutSocietyInput | MarketplaceItemCreateOrConnectWithoutSocietyInput[]
    upsert?: MarketplaceItemUpsertWithWhereUniqueWithoutSocietyInput | MarketplaceItemUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: MarketplaceItemCreateManySocietyInputEnvelope
    set?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    disconnect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    delete?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    connect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    update?: MarketplaceItemUpdateWithWhereUniqueWithoutSocietyInput | MarketplaceItemUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: MarketplaceItemUpdateManyWithWhereWithoutSocietyInput | MarketplaceItemUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: MarketplaceItemScalarWhereInput | MarketplaceItemScalarWhereInput[]
  }

  export type CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<CommunityGuidelineCreateWithoutSocietyInput, CommunityGuidelineUncheckedCreateWithoutSocietyInput> | CommunityGuidelineCreateWithoutSocietyInput[] | CommunityGuidelineUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: CommunityGuidelineCreateOrConnectWithoutSocietyInput | CommunityGuidelineCreateOrConnectWithoutSocietyInput[]
    upsert?: CommunityGuidelineUpsertWithWhereUniqueWithoutSocietyInput | CommunityGuidelineUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: CommunityGuidelineCreateManySocietyInputEnvelope
    set?: CommunityGuidelineWhereUniqueInput | CommunityGuidelineWhereUniqueInput[]
    disconnect?: CommunityGuidelineWhereUniqueInput | CommunityGuidelineWhereUniqueInput[]
    delete?: CommunityGuidelineWhereUniqueInput | CommunityGuidelineWhereUniqueInput[]
    connect?: CommunityGuidelineWhereUniqueInput | CommunityGuidelineWhereUniqueInput[]
    update?: CommunityGuidelineUpdateWithWhereUniqueWithoutSocietyInput | CommunityGuidelineUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: CommunityGuidelineUpdateManyWithWhereWithoutSocietyInput | CommunityGuidelineUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: CommunityGuidelineScalarWhereInput | CommunityGuidelineScalarWhereInput[]
  }

  export type SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<SOSAlertCreateWithoutSocietyInput, SOSAlertUncheckedCreateWithoutSocietyInput> | SOSAlertCreateWithoutSocietyInput[] | SOSAlertUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: SOSAlertCreateOrConnectWithoutSocietyInput | SOSAlertCreateOrConnectWithoutSocietyInput[]
    upsert?: SOSAlertUpsertWithWhereUniqueWithoutSocietyInput | SOSAlertUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: SOSAlertCreateManySocietyInputEnvelope
    set?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
    disconnect?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
    delete?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
    connect?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
    update?: SOSAlertUpdateWithWhereUniqueWithoutSocietyInput | SOSAlertUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: SOSAlertUpdateManyWithWhereWithoutSocietyInput | SOSAlertUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: SOSAlertScalarWhereInput | SOSAlertScalarWhereInput[]
  }

  export type RoleModelCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleModelCreateWithoutUsersInput, RoleModelUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleModelCreateOrConnectWithoutUsersInput
    connect?: RoleModelWhereUniqueInput
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type SocietyCreateNestedOneWithoutUsersInput = {
    create?: XOR<SocietyCreateWithoutUsersInput, SocietyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutUsersInput
    connect?: SocietyWhereUniqueInput
  }

  export type UnitCreateNestedManyWithoutOwnerInput = {
    create?: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput> | UnitCreateWithoutOwnerInput[] | UnitUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutOwnerInput | UnitCreateOrConnectWithoutOwnerInput[]
    createMany?: UnitCreateManyOwnerInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type UnitCreateNestedManyWithoutTenantInput = {
    create?: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput> | UnitCreateWithoutTenantInput[] | UnitUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutTenantInput | UnitCreateOrConnectWithoutTenantInput[]
    createMany?: UnitCreateManyTenantInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type ComplaintCreateNestedManyWithoutReportedByInput = {
    create?: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput> | ComplaintCreateWithoutReportedByInput[] | ComplaintUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutReportedByInput | ComplaintCreateOrConnectWithoutReportedByInput[]
    createMany?: ComplaintCreateManyReportedByInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type ComplaintCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput> | ComplaintCreateWithoutAssignedToInput[] | ComplaintUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutAssignedToInput | ComplaintCreateOrConnectWithoutAssignedToInput[]
    createMany?: ComplaintCreateManyAssignedToInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type AmenityBookingCreateNestedManyWithoutUserInput = {
    create?: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput> | AmenityBookingCreateWithoutUserInput[] | AmenityBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutUserInput | AmenityBookingCreateOrConnectWithoutUserInput[]
    createMany?: AmenityBookingCreateManyUserInputEnvelope
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
  }

  export type ComplaintCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput> | ComplaintCommentCreateWithoutUserInput[] | ComplaintCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutUserInput | ComplaintCommentCreateOrConnectWithoutUserInput[]
    createMany?: ComplaintCommentCreateManyUserInputEnvelope
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
  }

  export type PurchaseRequestCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<PurchaseRequestCreateWithoutRequestedByInput, PurchaseRequestUncheckedCreateWithoutRequestedByInput> | PurchaseRequestCreateWithoutRequestedByInput[] | PurchaseRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutRequestedByInput | PurchaseRequestCreateOrConnectWithoutRequestedByInput[]
    createMany?: PurchaseRequestCreateManyRequestedByInputEnvelope
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
  }

  export type EmergencyAlertCreateNestedManyWithoutUserInput = {
    create?: XOR<EmergencyAlertCreateWithoutUserInput, EmergencyAlertUncheckedCreateWithoutUserInput> | EmergencyAlertCreateWithoutUserInput[] | EmergencyAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmergencyAlertCreateOrConnectWithoutUserInput | EmergencyAlertCreateOrConnectWithoutUserInput[]
    createMany?: EmergencyAlertCreateManyUserInputEnvelope
    connect?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
  }

  export type ServiceInquiryCreateNestedManyWithoutResidentInput = {
    create?: XOR<ServiceInquiryCreateWithoutResidentInput, ServiceInquiryUncheckedCreateWithoutResidentInput> | ServiceInquiryCreateWithoutResidentInput[] | ServiceInquiryUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: ServiceInquiryCreateOrConnectWithoutResidentInput | ServiceInquiryCreateOrConnectWithoutResidentInput[]
    createMany?: ServiceInquiryCreateManyResidentInputEnvelope
    connect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ConversationCreateWithoutParticipantInput, ConversationUncheckedCreateWithoutParticipantInput> | ConversationCreateWithoutParticipantInput[] | ConversationUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantInput | ConversationCreateOrConnectWithoutParticipantInput[]
    createMany?: ConversationCreateManyParticipantInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type CommunityBuzzCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommunityBuzzCreateWithoutAuthorInput, CommunityBuzzUncheckedCreateWithoutAuthorInput> | CommunityBuzzCreateWithoutAuthorInput[] | CommunityBuzzUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommunityBuzzCreateOrConnectWithoutAuthorInput | CommunityBuzzCreateOrConnectWithoutAuthorInput[]
    createMany?: CommunityBuzzCreateManyAuthorInputEnvelope
    connect?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
  }

  export type CommunityCommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommunityCommentCreateWithoutAuthorInput, CommunityCommentUncheckedCreateWithoutAuthorInput> | CommunityCommentCreateWithoutAuthorInput[] | CommunityCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommunityCommentCreateOrConnectWithoutAuthorInput | CommunityCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommunityCommentCreateManyAuthorInputEnvelope
    connect?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
  }

  export type SOSAlertCreateNestedManyWithoutResidentInput = {
    create?: XOR<SOSAlertCreateWithoutResidentInput, SOSAlertUncheckedCreateWithoutResidentInput> | SOSAlertCreateWithoutResidentInput[] | SOSAlertUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: SOSAlertCreateOrConnectWithoutResidentInput | SOSAlertCreateOrConnectWithoutResidentInput[]
    createMany?: SOSAlertCreateManyResidentInputEnvelope
    connect?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
  }

  export type EmergencyContactCreateNestedManyWithoutResidentInput = {
    create?: XOR<EmergencyContactCreateWithoutResidentInput, EmergencyContactUncheckedCreateWithoutResidentInput> | EmergencyContactCreateWithoutResidentInput[] | EmergencyContactUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutResidentInput | EmergencyContactCreateOrConnectWithoutResidentInput[]
    createMany?: EmergencyContactCreateManyResidentInputEnvelope
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
  }

  export type MarketplaceItemCreateNestedManyWithoutOwnerInput = {
    create?: XOR<MarketplaceItemCreateWithoutOwnerInput, MarketplaceItemUncheckedCreateWithoutOwnerInput> | MarketplaceItemCreateWithoutOwnerInput[] | MarketplaceItemUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutOwnerInput | MarketplaceItemCreateOrConnectWithoutOwnerInput[]
    createMany?: MarketplaceItemCreateManyOwnerInputEnvelope
    connect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
  }

  export type BuzzLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<BuzzLikeCreateWithoutUserInput, BuzzLikeUncheckedCreateWithoutUserInput> | BuzzLikeCreateWithoutUserInput[] | BuzzLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BuzzLikeCreateOrConnectWithoutUserInput | BuzzLikeCreateOrConnectWithoutUserInput[]
    createMany?: BuzzLikeCreateManyUserInputEnvelope
    connect?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput> | UnitCreateWithoutOwnerInput[] | UnitUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutOwnerInput | UnitCreateOrConnectWithoutOwnerInput[]
    createMany?: UnitCreateManyOwnerInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput> | UnitCreateWithoutTenantInput[] | UnitUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutTenantInput | UnitCreateOrConnectWithoutTenantInput[]
    createMany?: UnitCreateManyTenantInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type ComplaintUncheckedCreateNestedManyWithoutReportedByInput = {
    create?: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput> | ComplaintCreateWithoutReportedByInput[] | ComplaintUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutReportedByInput | ComplaintCreateOrConnectWithoutReportedByInput[]
    createMany?: ComplaintCreateManyReportedByInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type ComplaintUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput> | ComplaintCreateWithoutAssignedToInput[] | ComplaintUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutAssignedToInput | ComplaintCreateOrConnectWithoutAssignedToInput[]
    createMany?: ComplaintCreateManyAssignedToInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type AmenityBookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput> | AmenityBookingCreateWithoutUserInput[] | AmenityBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutUserInput | AmenityBookingCreateOrConnectWithoutUserInput[]
    createMany?: AmenityBookingCreateManyUserInputEnvelope
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
  }

  export type ComplaintCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput> | ComplaintCommentCreateWithoutUserInput[] | ComplaintCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutUserInput | ComplaintCommentCreateOrConnectWithoutUserInput[]
    createMany?: ComplaintCommentCreateManyUserInputEnvelope
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
  }

  export type PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<PurchaseRequestCreateWithoutRequestedByInput, PurchaseRequestUncheckedCreateWithoutRequestedByInput> | PurchaseRequestCreateWithoutRequestedByInput[] | PurchaseRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutRequestedByInput | PurchaseRequestCreateOrConnectWithoutRequestedByInput[]
    createMany?: PurchaseRequestCreateManyRequestedByInputEnvelope
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
  }

  export type EmergencyAlertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmergencyAlertCreateWithoutUserInput, EmergencyAlertUncheckedCreateWithoutUserInput> | EmergencyAlertCreateWithoutUserInput[] | EmergencyAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmergencyAlertCreateOrConnectWithoutUserInput | EmergencyAlertCreateOrConnectWithoutUserInput[]
    createMany?: EmergencyAlertCreateManyUserInputEnvelope
    connect?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
  }

  export type ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput = {
    create?: XOR<ServiceInquiryCreateWithoutResidentInput, ServiceInquiryUncheckedCreateWithoutResidentInput> | ServiceInquiryCreateWithoutResidentInput[] | ServiceInquiryUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: ServiceInquiryCreateOrConnectWithoutResidentInput | ServiceInquiryCreateOrConnectWithoutResidentInput[]
    createMany?: ServiceInquiryCreateManyResidentInputEnvelope
    connect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ConversationCreateWithoutParticipantInput, ConversationUncheckedCreateWithoutParticipantInput> | ConversationCreateWithoutParticipantInput[] | ConversationUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantInput | ConversationCreateOrConnectWithoutParticipantInput[]
    createMany?: ConversationCreateManyParticipantInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommunityBuzzCreateWithoutAuthorInput, CommunityBuzzUncheckedCreateWithoutAuthorInput> | CommunityBuzzCreateWithoutAuthorInput[] | CommunityBuzzUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommunityBuzzCreateOrConnectWithoutAuthorInput | CommunityBuzzCreateOrConnectWithoutAuthorInput[]
    createMany?: CommunityBuzzCreateManyAuthorInputEnvelope
    connect?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
  }

  export type CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommunityCommentCreateWithoutAuthorInput, CommunityCommentUncheckedCreateWithoutAuthorInput> | CommunityCommentCreateWithoutAuthorInput[] | CommunityCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommunityCommentCreateOrConnectWithoutAuthorInput | CommunityCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommunityCommentCreateManyAuthorInputEnvelope
    connect?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
  }

  export type SOSAlertUncheckedCreateNestedManyWithoutResidentInput = {
    create?: XOR<SOSAlertCreateWithoutResidentInput, SOSAlertUncheckedCreateWithoutResidentInput> | SOSAlertCreateWithoutResidentInput[] | SOSAlertUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: SOSAlertCreateOrConnectWithoutResidentInput | SOSAlertCreateOrConnectWithoutResidentInput[]
    createMany?: SOSAlertCreateManyResidentInputEnvelope
    connect?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
  }

  export type EmergencyContactUncheckedCreateNestedManyWithoutResidentInput = {
    create?: XOR<EmergencyContactCreateWithoutResidentInput, EmergencyContactUncheckedCreateWithoutResidentInput> | EmergencyContactCreateWithoutResidentInput[] | EmergencyContactUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutResidentInput | EmergencyContactCreateOrConnectWithoutResidentInput[]
    createMany?: EmergencyContactCreateManyResidentInputEnvelope
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
  }

  export type MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<MarketplaceItemCreateWithoutOwnerInput, MarketplaceItemUncheckedCreateWithoutOwnerInput> | MarketplaceItemCreateWithoutOwnerInput[] | MarketplaceItemUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutOwnerInput | MarketplaceItemCreateOrConnectWithoutOwnerInput[]
    createMany?: MarketplaceItemCreateManyOwnerInputEnvelope
    connect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
  }

  export type BuzzLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BuzzLikeCreateWithoutUserInput, BuzzLikeUncheckedCreateWithoutUserInput> | BuzzLikeCreateWithoutUserInput[] | BuzzLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BuzzLikeCreateOrConnectWithoutUserInput | BuzzLikeCreateOrConnectWithoutUserInput[]
    createMany?: BuzzLikeCreateManyUserInputEnvelope
    connect?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type RoleModelUpdateOneWithoutUsersNestedInput = {
    create?: XOR<RoleModelCreateWithoutUsersInput, RoleModelUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleModelCreateOrConnectWithoutUsersInput
    upsert?: RoleModelUpsertWithoutUsersInput
    disconnect?: RoleModelWhereInput | boolean
    delete?: RoleModelWhereInput | boolean
    connect?: RoleModelWhereUniqueInput
    update?: XOR<XOR<RoleModelUpdateToOneWithWhereWithoutUsersInput, RoleModelUpdateWithoutUsersInput>, RoleModelUncheckedUpdateWithoutUsersInput>
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type SocietyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<SocietyCreateWithoutUsersInput, SocietyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutUsersInput
    upsert?: SocietyUpsertWithoutUsersInput
    disconnect?: SocietyWhereInput | boolean
    delete?: SocietyWhereInput | boolean
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutUsersInput, SocietyUpdateWithoutUsersInput>, SocietyUncheckedUpdateWithoutUsersInput>
  }

  export type UnitUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput> | UnitCreateWithoutOwnerInput[] | UnitUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutOwnerInput | UnitCreateOrConnectWithoutOwnerInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutOwnerInput | UnitUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: UnitCreateManyOwnerInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutOwnerInput | UnitUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutOwnerInput | UnitUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type UnitUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput> | UnitCreateWithoutTenantInput[] | UnitUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutTenantInput | UnitCreateOrConnectWithoutTenantInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutTenantInput | UnitUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UnitCreateManyTenantInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutTenantInput | UnitUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutTenantInput | UnitUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type ComplaintUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput> | ComplaintCreateWithoutReportedByInput[] | ComplaintUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutReportedByInput | ComplaintCreateOrConnectWithoutReportedByInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutReportedByInput | ComplaintUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: ComplaintCreateManyReportedByInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutReportedByInput | ComplaintUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutReportedByInput | ComplaintUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type ComplaintUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput> | ComplaintCreateWithoutAssignedToInput[] | ComplaintUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutAssignedToInput | ComplaintCreateOrConnectWithoutAssignedToInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutAssignedToInput | ComplaintUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: ComplaintCreateManyAssignedToInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutAssignedToInput | ComplaintUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutAssignedToInput | ComplaintUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type AmenityBookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput> | AmenityBookingCreateWithoutUserInput[] | AmenityBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutUserInput | AmenityBookingCreateOrConnectWithoutUserInput[]
    upsert?: AmenityBookingUpsertWithWhereUniqueWithoutUserInput | AmenityBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AmenityBookingCreateManyUserInputEnvelope
    set?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    disconnect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    delete?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    update?: AmenityBookingUpdateWithWhereUniqueWithoutUserInput | AmenityBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AmenityBookingUpdateManyWithWhereWithoutUserInput | AmenityBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
  }

  export type ComplaintCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput> | ComplaintCommentCreateWithoutUserInput[] | ComplaintCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutUserInput | ComplaintCommentCreateOrConnectWithoutUserInput[]
    upsert?: ComplaintCommentUpsertWithWhereUniqueWithoutUserInput | ComplaintCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComplaintCommentCreateManyUserInputEnvelope
    set?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    disconnect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    delete?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    update?: ComplaintCommentUpdateWithWhereUniqueWithoutUserInput | ComplaintCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComplaintCommentUpdateManyWithWhereWithoutUserInput | ComplaintCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
  }

  export type PurchaseRequestUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<PurchaseRequestCreateWithoutRequestedByInput, PurchaseRequestUncheckedCreateWithoutRequestedByInput> | PurchaseRequestCreateWithoutRequestedByInput[] | PurchaseRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutRequestedByInput | PurchaseRequestCreateOrConnectWithoutRequestedByInput[]
    upsert?: PurchaseRequestUpsertWithWhereUniqueWithoutRequestedByInput | PurchaseRequestUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: PurchaseRequestCreateManyRequestedByInputEnvelope
    set?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    disconnect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    delete?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    update?: PurchaseRequestUpdateWithWhereUniqueWithoutRequestedByInput | PurchaseRequestUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: PurchaseRequestUpdateManyWithWhereWithoutRequestedByInput | PurchaseRequestUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
  }

  export type EmergencyAlertUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmergencyAlertCreateWithoutUserInput, EmergencyAlertUncheckedCreateWithoutUserInput> | EmergencyAlertCreateWithoutUserInput[] | EmergencyAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmergencyAlertCreateOrConnectWithoutUserInput | EmergencyAlertCreateOrConnectWithoutUserInput[]
    upsert?: EmergencyAlertUpsertWithWhereUniqueWithoutUserInput | EmergencyAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmergencyAlertCreateManyUserInputEnvelope
    set?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
    disconnect?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
    delete?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
    connect?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
    update?: EmergencyAlertUpdateWithWhereUniqueWithoutUserInput | EmergencyAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmergencyAlertUpdateManyWithWhereWithoutUserInput | EmergencyAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmergencyAlertScalarWhereInput | EmergencyAlertScalarWhereInput[]
  }

  export type ServiceInquiryUpdateManyWithoutResidentNestedInput = {
    create?: XOR<ServiceInquiryCreateWithoutResidentInput, ServiceInquiryUncheckedCreateWithoutResidentInput> | ServiceInquiryCreateWithoutResidentInput[] | ServiceInquiryUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: ServiceInquiryCreateOrConnectWithoutResidentInput | ServiceInquiryCreateOrConnectWithoutResidentInput[]
    upsert?: ServiceInquiryUpsertWithWhereUniqueWithoutResidentInput | ServiceInquiryUpsertWithWhereUniqueWithoutResidentInput[]
    createMany?: ServiceInquiryCreateManyResidentInputEnvelope
    set?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    disconnect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    delete?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    connect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    update?: ServiceInquiryUpdateWithWhereUniqueWithoutResidentInput | ServiceInquiryUpdateWithWhereUniqueWithoutResidentInput[]
    updateMany?: ServiceInquiryUpdateManyWithWhereWithoutResidentInput | ServiceInquiryUpdateManyWithWhereWithoutResidentInput[]
    deleteMany?: ServiceInquiryScalarWhereInput | ServiceInquiryScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ConversationCreateWithoutParticipantInput, ConversationUncheckedCreateWithoutParticipantInput> | ConversationCreateWithoutParticipantInput[] | ConversationUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantInput | ConversationCreateOrConnectWithoutParticipantInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutParticipantInput | ConversationUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ConversationCreateManyParticipantInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutParticipantInput | ConversationUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutParticipantInput | ConversationUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type CommunityBuzzUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommunityBuzzCreateWithoutAuthorInput, CommunityBuzzUncheckedCreateWithoutAuthorInput> | CommunityBuzzCreateWithoutAuthorInput[] | CommunityBuzzUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommunityBuzzCreateOrConnectWithoutAuthorInput | CommunityBuzzCreateOrConnectWithoutAuthorInput[]
    upsert?: CommunityBuzzUpsertWithWhereUniqueWithoutAuthorInput | CommunityBuzzUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommunityBuzzCreateManyAuthorInputEnvelope
    set?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
    disconnect?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
    delete?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
    connect?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
    update?: CommunityBuzzUpdateWithWhereUniqueWithoutAuthorInput | CommunityBuzzUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommunityBuzzUpdateManyWithWhereWithoutAuthorInput | CommunityBuzzUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommunityBuzzScalarWhereInput | CommunityBuzzScalarWhereInput[]
  }

  export type CommunityCommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommunityCommentCreateWithoutAuthorInput, CommunityCommentUncheckedCreateWithoutAuthorInput> | CommunityCommentCreateWithoutAuthorInput[] | CommunityCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommunityCommentCreateOrConnectWithoutAuthorInput | CommunityCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommunityCommentUpsertWithWhereUniqueWithoutAuthorInput | CommunityCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommunityCommentCreateManyAuthorInputEnvelope
    set?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
    disconnect?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
    delete?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
    connect?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
    update?: CommunityCommentUpdateWithWhereUniqueWithoutAuthorInput | CommunityCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommunityCommentUpdateManyWithWhereWithoutAuthorInput | CommunityCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommunityCommentScalarWhereInput | CommunityCommentScalarWhereInput[]
  }

  export type SOSAlertUpdateManyWithoutResidentNestedInput = {
    create?: XOR<SOSAlertCreateWithoutResidentInput, SOSAlertUncheckedCreateWithoutResidentInput> | SOSAlertCreateWithoutResidentInput[] | SOSAlertUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: SOSAlertCreateOrConnectWithoutResidentInput | SOSAlertCreateOrConnectWithoutResidentInput[]
    upsert?: SOSAlertUpsertWithWhereUniqueWithoutResidentInput | SOSAlertUpsertWithWhereUniqueWithoutResidentInput[]
    createMany?: SOSAlertCreateManyResidentInputEnvelope
    set?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
    disconnect?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
    delete?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
    connect?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
    update?: SOSAlertUpdateWithWhereUniqueWithoutResidentInput | SOSAlertUpdateWithWhereUniqueWithoutResidentInput[]
    updateMany?: SOSAlertUpdateManyWithWhereWithoutResidentInput | SOSAlertUpdateManyWithWhereWithoutResidentInput[]
    deleteMany?: SOSAlertScalarWhereInput | SOSAlertScalarWhereInput[]
  }

  export type EmergencyContactUpdateManyWithoutResidentNestedInput = {
    create?: XOR<EmergencyContactCreateWithoutResidentInput, EmergencyContactUncheckedCreateWithoutResidentInput> | EmergencyContactCreateWithoutResidentInput[] | EmergencyContactUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutResidentInput | EmergencyContactCreateOrConnectWithoutResidentInput[]
    upsert?: EmergencyContactUpsertWithWhereUniqueWithoutResidentInput | EmergencyContactUpsertWithWhereUniqueWithoutResidentInput[]
    createMany?: EmergencyContactCreateManyResidentInputEnvelope
    set?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    disconnect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    delete?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    update?: EmergencyContactUpdateWithWhereUniqueWithoutResidentInput | EmergencyContactUpdateWithWhereUniqueWithoutResidentInput[]
    updateMany?: EmergencyContactUpdateManyWithWhereWithoutResidentInput | EmergencyContactUpdateManyWithWhereWithoutResidentInput[]
    deleteMany?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
  }

  export type MarketplaceItemUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<MarketplaceItemCreateWithoutOwnerInput, MarketplaceItemUncheckedCreateWithoutOwnerInput> | MarketplaceItemCreateWithoutOwnerInput[] | MarketplaceItemUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutOwnerInput | MarketplaceItemCreateOrConnectWithoutOwnerInput[]
    upsert?: MarketplaceItemUpsertWithWhereUniqueWithoutOwnerInput | MarketplaceItemUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: MarketplaceItemCreateManyOwnerInputEnvelope
    set?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    disconnect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    delete?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    connect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    update?: MarketplaceItemUpdateWithWhereUniqueWithoutOwnerInput | MarketplaceItemUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: MarketplaceItemUpdateManyWithWhereWithoutOwnerInput | MarketplaceItemUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: MarketplaceItemScalarWhereInput | MarketplaceItemScalarWhereInput[]
  }

  export type BuzzLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<BuzzLikeCreateWithoutUserInput, BuzzLikeUncheckedCreateWithoutUserInput> | BuzzLikeCreateWithoutUserInput[] | BuzzLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BuzzLikeCreateOrConnectWithoutUserInput | BuzzLikeCreateOrConnectWithoutUserInput[]
    upsert?: BuzzLikeUpsertWithWhereUniqueWithoutUserInput | BuzzLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BuzzLikeCreateManyUserInputEnvelope
    set?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
    disconnect?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
    delete?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
    connect?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
    update?: BuzzLikeUpdateWithWhereUniqueWithoutUserInput | BuzzLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BuzzLikeUpdateManyWithWhereWithoutUserInput | BuzzLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BuzzLikeScalarWhereInput | BuzzLikeScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput> | UnitCreateWithoutOwnerInput[] | UnitUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutOwnerInput | UnitCreateOrConnectWithoutOwnerInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutOwnerInput | UnitUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: UnitCreateManyOwnerInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutOwnerInput | UnitUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutOwnerInput | UnitUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput> | UnitCreateWithoutTenantInput[] | UnitUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutTenantInput | UnitCreateOrConnectWithoutTenantInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutTenantInput | UnitUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UnitCreateManyTenantInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutTenantInput | UnitUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutTenantInput | UnitUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type ComplaintUncheckedUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput> | ComplaintCreateWithoutReportedByInput[] | ComplaintUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutReportedByInput | ComplaintCreateOrConnectWithoutReportedByInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutReportedByInput | ComplaintUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: ComplaintCreateManyReportedByInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutReportedByInput | ComplaintUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutReportedByInput | ComplaintUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput> | ComplaintCreateWithoutAssignedToInput[] | ComplaintUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutAssignedToInput | ComplaintCreateOrConnectWithoutAssignedToInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutAssignedToInput | ComplaintUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: ComplaintCreateManyAssignedToInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutAssignedToInput | ComplaintUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutAssignedToInput | ComplaintUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type AmenityBookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput> | AmenityBookingCreateWithoutUserInput[] | AmenityBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutUserInput | AmenityBookingCreateOrConnectWithoutUserInput[]
    upsert?: AmenityBookingUpsertWithWhereUniqueWithoutUserInput | AmenityBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AmenityBookingCreateManyUserInputEnvelope
    set?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    disconnect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    delete?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    update?: AmenityBookingUpdateWithWhereUniqueWithoutUserInput | AmenityBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AmenityBookingUpdateManyWithWhereWithoutUserInput | AmenityBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
  }

  export type ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput> | ComplaintCommentCreateWithoutUserInput[] | ComplaintCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutUserInput | ComplaintCommentCreateOrConnectWithoutUserInput[]
    upsert?: ComplaintCommentUpsertWithWhereUniqueWithoutUserInput | ComplaintCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComplaintCommentCreateManyUserInputEnvelope
    set?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    disconnect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    delete?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    update?: ComplaintCommentUpdateWithWhereUniqueWithoutUserInput | ComplaintCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComplaintCommentUpdateManyWithWhereWithoutUserInput | ComplaintCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
  }

  export type PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<PurchaseRequestCreateWithoutRequestedByInput, PurchaseRequestUncheckedCreateWithoutRequestedByInput> | PurchaseRequestCreateWithoutRequestedByInput[] | PurchaseRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutRequestedByInput | PurchaseRequestCreateOrConnectWithoutRequestedByInput[]
    upsert?: PurchaseRequestUpsertWithWhereUniqueWithoutRequestedByInput | PurchaseRequestUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: PurchaseRequestCreateManyRequestedByInputEnvelope
    set?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    disconnect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    delete?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    update?: PurchaseRequestUpdateWithWhereUniqueWithoutRequestedByInput | PurchaseRequestUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: PurchaseRequestUpdateManyWithWhereWithoutRequestedByInput | PurchaseRequestUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
  }

  export type EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmergencyAlertCreateWithoutUserInput, EmergencyAlertUncheckedCreateWithoutUserInput> | EmergencyAlertCreateWithoutUserInput[] | EmergencyAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmergencyAlertCreateOrConnectWithoutUserInput | EmergencyAlertCreateOrConnectWithoutUserInput[]
    upsert?: EmergencyAlertUpsertWithWhereUniqueWithoutUserInput | EmergencyAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmergencyAlertCreateManyUserInputEnvelope
    set?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
    disconnect?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
    delete?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
    connect?: EmergencyAlertWhereUniqueInput | EmergencyAlertWhereUniqueInput[]
    update?: EmergencyAlertUpdateWithWhereUniqueWithoutUserInput | EmergencyAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmergencyAlertUpdateManyWithWhereWithoutUserInput | EmergencyAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmergencyAlertScalarWhereInput | EmergencyAlertScalarWhereInput[]
  }

  export type ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput = {
    create?: XOR<ServiceInquiryCreateWithoutResidentInput, ServiceInquiryUncheckedCreateWithoutResidentInput> | ServiceInquiryCreateWithoutResidentInput[] | ServiceInquiryUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: ServiceInquiryCreateOrConnectWithoutResidentInput | ServiceInquiryCreateOrConnectWithoutResidentInput[]
    upsert?: ServiceInquiryUpsertWithWhereUniqueWithoutResidentInput | ServiceInquiryUpsertWithWhereUniqueWithoutResidentInput[]
    createMany?: ServiceInquiryCreateManyResidentInputEnvelope
    set?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    disconnect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    delete?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    connect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    update?: ServiceInquiryUpdateWithWhereUniqueWithoutResidentInput | ServiceInquiryUpdateWithWhereUniqueWithoutResidentInput[]
    updateMany?: ServiceInquiryUpdateManyWithWhereWithoutResidentInput | ServiceInquiryUpdateManyWithWhereWithoutResidentInput[]
    deleteMany?: ServiceInquiryScalarWhereInput | ServiceInquiryScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ConversationCreateWithoutParticipantInput, ConversationUncheckedCreateWithoutParticipantInput> | ConversationCreateWithoutParticipantInput[] | ConversationUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantInput | ConversationCreateOrConnectWithoutParticipantInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutParticipantInput | ConversationUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ConversationCreateManyParticipantInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutParticipantInput | ConversationUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutParticipantInput | ConversationUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommunityBuzzCreateWithoutAuthorInput, CommunityBuzzUncheckedCreateWithoutAuthorInput> | CommunityBuzzCreateWithoutAuthorInput[] | CommunityBuzzUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommunityBuzzCreateOrConnectWithoutAuthorInput | CommunityBuzzCreateOrConnectWithoutAuthorInput[]
    upsert?: CommunityBuzzUpsertWithWhereUniqueWithoutAuthorInput | CommunityBuzzUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommunityBuzzCreateManyAuthorInputEnvelope
    set?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
    disconnect?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
    delete?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
    connect?: CommunityBuzzWhereUniqueInput | CommunityBuzzWhereUniqueInput[]
    update?: CommunityBuzzUpdateWithWhereUniqueWithoutAuthorInput | CommunityBuzzUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommunityBuzzUpdateManyWithWhereWithoutAuthorInput | CommunityBuzzUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommunityBuzzScalarWhereInput | CommunityBuzzScalarWhereInput[]
  }

  export type CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommunityCommentCreateWithoutAuthorInput, CommunityCommentUncheckedCreateWithoutAuthorInput> | CommunityCommentCreateWithoutAuthorInput[] | CommunityCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommunityCommentCreateOrConnectWithoutAuthorInput | CommunityCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommunityCommentUpsertWithWhereUniqueWithoutAuthorInput | CommunityCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommunityCommentCreateManyAuthorInputEnvelope
    set?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
    disconnect?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
    delete?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
    connect?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
    update?: CommunityCommentUpdateWithWhereUniqueWithoutAuthorInput | CommunityCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommunityCommentUpdateManyWithWhereWithoutAuthorInput | CommunityCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommunityCommentScalarWhereInput | CommunityCommentScalarWhereInput[]
  }

  export type SOSAlertUncheckedUpdateManyWithoutResidentNestedInput = {
    create?: XOR<SOSAlertCreateWithoutResidentInput, SOSAlertUncheckedCreateWithoutResidentInput> | SOSAlertCreateWithoutResidentInput[] | SOSAlertUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: SOSAlertCreateOrConnectWithoutResidentInput | SOSAlertCreateOrConnectWithoutResidentInput[]
    upsert?: SOSAlertUpsertWithWhereUniqueWithoutResidentInput | SOSAlertUpsertWithWhereUniqueWithoutResidentInput[]
    createMany?: SOSAlertCreateManyResidentInputEnvelope
    set?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
    disconnect?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
    delete?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
    connect?: SOSAlertWhereUniqueInput | SOSAlertWhereUniqueInput[]
    update?: SOSAlertUpdateWithWhereUniqueWithoutResidentInput | SOSAlertUpdateWithWhereUniqueWithoutResidentInput[]
    updateMany?: SOSAlertUpdateManyWithWhereWithoutResidentInput | SOSAlertUpdateManyWithWhereWithoutResidentInput[]
    deleteMany?: SOSAlertScalarWhereInput | SOSAlertScalarWhereInput[]
  }

  export type EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput = {
    create?: XOR<EmergencyContactCreateWithoutResidentInput, EmergencyContactUncheckedCreateWithoutResidentInput> | EmergencyContactCreateWithoutResidentInput[] | EmergencyContactUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutResidentInput | EmergencyContactCreateOrConnectWithoutResidentInput[]
    upsert?: EmergencyContactUpsertWithWhereUniqueWithoutResidentInput | EmergencyContactUpsertWithWhereUniqueWithoutResidentInput[]
    createMany?: EmergencyContactCreateManyResidentInputEnvelope
    set?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    disconnect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    delete?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    update?: EmergencyContactUpdateWithWhereUniqueWithoutResidentInput | EmergencyContactUpdateWithWhereUniqueWithoutResidentInput[]
    updateMany?: EmergencyContactUpdateManyWithWhereWithoutResidentInput | EmergencyContactUpdateManyWithWhereWithoutResidentInput[]
    deleteMany?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
  }

  export type MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<MarketplaceItemCreateWithoutOwnerInput, MarketplaceItemUncheckedCreateWithoutOwnerInput> | MarketplaceItemCreateWithoutOwnerInput[] | MarketplaceItemUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutOwnerInput | MarketplaceItemCreateOrConnectWithoutOwnerInput[]
    upsert?: MarketplaceItemUpsertWithWhereUniqueWithoutOwnerInput | MarketplaceItemUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: MarketplaceItemCreateManyOwnerInputEnvelope
    set?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    disconnect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    delete?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    connect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    update?: MarketplaceItemUpdateWithWhereUniqueWithoutOwnerInput | MarketplaceItemUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: MarketplaceItemUpdateManyWithWhereWithoutOwnerInput | MarketplaceItemUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: MarketplaceItemScalarWhereInput | MarketplaceItemScalarWhereInput[]
  }

  export type BuzzLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BuzzLikeCreateWithoutUserInput, BuzzLikeUncheckedCreateWithoutUserInput> | BuzzLikeCreateWithoutUserInput[] | BuzzLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BuzzLikeCreateOrConnectWithoutUserInput | BuzzLikeCreateOrConnectWithoutUserInput[]
    upsert?: BuzzLikeUpsertWithWhereUniqueWithoutUserInput | BuzzLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BuzzLikeCreateManyUserInputEnvelope
    set?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
    disconnect?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
    delete?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
    connect?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
    update?: BuzzLikeUpdateWithWhereUniqueWithoutUserInput | BuzzLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BuzzLikeUpdateManyWithWhereWithoutUserInput | BuzzLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BuzzLikeScalarWhereInput | BuzzLikeScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutRoleModelInput = {
    create?: XOR<UserCreateWithoutRoleModelInput, UserUncheckedCreateWithoutRoleModelInput> | UserCreateWithoutRoleModelInput[] | UserUncheckedCreateWithoutRoleModelInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleModelInput | UserCreateOrConnectWithoutRoleModelInput[]
    createMany?: UserCreateManyRoleModelInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleModelInput = {
    create?: XOR<UserCreateWithoutRoleModelInput, UserUncheckedCreateWithoutRoleModelInput> | UserCreateWithoutRoleModelInput[] | UserUncheckedCreateWithoutRoleModelInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleModelInput | UserCreateOrConnectWithoutRoleModelInput[]
    createMany?: UserCreateManyRoleModelInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutRoleModelNestedInput = {
    create?: XOR<UserCreateWithoutRoleModelInput, UserUncheckedCreateWithoutRoleModelInput> | UserCreateWithoutRoleModelInput[] | UserUncheckedCreateWithoutRoleModelInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleModelInput | UserCreateOrConnectWithoutRoleModelInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleModelInput | UserUpsertWithWhereUniqueWithoutRoleModelInput[]
    createMany?: UserCreateManyRoleModelInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleModelInput | UserUpdateWithWhereUniqueWithoutRoleModelInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleModelInput | UserUpdateManyWithWhereWithoutRoleModelInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleModelNestedInput = {
    create?: XOR<UserCreateWithoutRoleModelInput, UserUncheckedCreateWithoutRoleModelInput> | UserCreateWithoutRoleModelInput[] | UserUncheckedCreateWithoutRoleModelInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleModelInput | UserCreateOrConnectWithoutRoleModelInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleModelInput | UserUpsertWithWhereUniqueWithoutRoleModelInput[]
    createMany?: UserCreateManyRoleModelInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleModelInput | UserUpdateWithWhereUniqueWithoutRoleModelInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleModelInput | UserUpdateManyWithWhereWithoutRoleModelInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RoleModelCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleModelCreateWithoutPermissionsInput, RoleModelUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleModelCreateOrConnectWithoutPermissionsInput
    connect?: RoleModelWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleModelUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleModelCreateWithoutPermissionsInput, RoleModelUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleModelCreateOrConnectWithoutPermissionsInput
    upsert?: RoleModelUpsertWithoutPermissionsInput
    connect?: RoleModelWhereUniqueInput
    update?: XOR<XOR<RoleModelUpdateToOneWithWhereWithoutPermissionsInput, RoleModelUpdateWithoutPermissionsInput>, RoleModelUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    upsert?: PermissionUpsertWithoutRolesInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolesInput, PermissionUpdateWithoutRolesInput>, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type SocietyCreateNestedOneWithoutUnitsInput = {
    create?: XOR<SocietyCreateWithoutUnitsInput, SocietyUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutUnitsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedUnitsInput = {
    create?: XOR<UserCreateWithoutOwnedUnitsInput, UserUncheckedCreateWithoutOwnedUnitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedUnitsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRentedUnitsInput = {
    create?: XOR<UserCreateWithoutRentedUnitsInput, UserUncheckedCreateWithoutRentedUnitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRentedUnitsInput
    connect?: UserWhereUniqueInput
  }

  export type VisitorCreateNestedManyWithoutUnitInput = {
    create?: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput> | VisitorCreateWithoutUnitInput[] | VisitorUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutUnitInput | VisitorCreateOrConnectWithoutUnitInput[]
    createMany?: VisitorCreateManyUnitInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type ParkingSlotCreateNestedManyWithoutUnitInput = {
    create?: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput> | ParkingSlotCreateWithoutUnitInput[] | ParkingSlotUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutUnitInput | ParkingSlotCreateOrConnectWithoutUnitInput[]
    createMany?: ParkingSlotCreateManyUnitInputEnvelope
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
  }

  export type ParcelCreateNestedManyWithoutUnitInput = {
    create?: XOR<ParcelCreateWithoutUnitInput, ParcelUncheckedCreateWithoutUnitInput> | ParcelCreateWithoutUnitInput[] | ParcelUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ParcelCreateOrConnectWithoutUnitInput | ParcelCreateOrConnectWithoutUnitInput[]
    createMany?: ParcelCreateManyUnitInputEnvelope
    connect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
  }

  export type UnitMemberCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitMemberCreateWithoutUnitInput, UnitMemberUncheckedCreateWithoutUnitInput> | UnitMemberCreateWithoutUnitInput[] | UnitMemberUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitMemberCreateOrConnectWithoutUnitInput | UnitMemberCreateOrConnectWithoutUnitInput[]
    createMany?: UnitMemberCreateManyUnitInputEnvelope
    connect?: UnitMemberWhereUniqueInput | UnitMemberWhereUniqueInput[]
  }

  export type UnitVehicleCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitVehicleCreateWithoutUnitInput, UnitVehicleUncheckedCreateWithoutUnitInput> | UnitVehicleCreateWithoutUnitInput[] | UnitVehicleUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitVehicleCreateOrConnectWithoutUnitInput | UnitVehicleCreateOrConnectWithoutUnitInput[]
    createMany?: UnitVehicleCreateManyUnitInputEnvelope
    connect?: UnitVehicleWhereUniqueInput | UnitVehicleWhereUniqueInput[]
  }

  export type UnitPetCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitPetCreateWithoutUnitInput, UnitPetUncheckedCreateWithoutUnitInput> | UnitPetCreateWithoutUnitInput[] | UnitPetUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitPetCreateOrConnectWithoutUnitInput | UnitPetCreateOrConnectWithoutUnitInput[]
    createMany?: UnitPetCreateManyUnitInputEnvelope
    connect?: UnitPetWhereUniqueInput | UnitPetWhereUniqueInput[]
  }

  export type VisitorUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput> | VisitorCreateWithoutUnitInput[] | VisitorUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutUnitInput | VisitorCreateOrConnectWithoutUnitInput[]
    createMany?: VisitorCreateManyUnitInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type ParkingSlotUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput> | ParkingSlotCreateWithoutUnitInput[] | ParkingSlotUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutUnitInput | ParkingSlotCreateOrConnectWithoutUnitInput[]
    createMany?: ParkingSlotCreateManyUnitInputEnvelope
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
  }

  export type ParcelUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<ParcelCreateWithoutUnitInput, ParcelUncheckedCreateWithoutUnitInput> | ParcelCreateWithoutUnitInput[] | ParcelUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ParcelCreateOrConnectWithoutUnitInput | ParcelCreateOrConnectWithoutUnitInput[]
    createMany?: ParcelCreateManyUnitInputEnvelope
    connect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
  }

  export type UnitMemberUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitMemberCreateWithoutUnitInput, UnitMemberUncheckedCreateWithoutUnitInput> | UnitMemberCreateWithoutUnitInput[] | UnitMemberUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitMemberCreateOrConnectWithoutUnitInput | UnitMemberCreateOrConnectWithoutUnitInput[]
    createMany?: UnitMemberCreateManyUnitInputEnvelope
    connect?: UnitMemberWhereUniqueInput | UnitMemberWhereUniqueInput[]
  }

  export type UnitVehicleUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitVehicleCreateWithoutUnitInput, UnitVehicleUncheckedCreateWithoutUnitInput> | UnitVehicleCreateWithoutUnitInput[] | UnitVehicleUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitVehicleCreateOrConnectWithoutUnitInput | UnitVehicleCreateOrConnectWithoutUnitInput[]
    createMany?: UnitVehicleCreateManyUnitInputEnvelope
    connect?: UnitVehicleWhereUniqueInput | UnitVehicleWhereUniqueInput[]
  }

  export type UnitPetUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitPetCreateWithoutUnitInput, UnitPetUncheckedCreateWithoutUnitInput> | UnitPetCreateWithoutUnitInput[] | UnitPetUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitPetCreateOrConnectWithoutUnitInput | UnitPetCreateOrConnectWithoutUnitInput[]
    createMany?: UnitPetCreateManyUnitInputEnvelope
    connect?: UnitPetWhereUniqueInput | UnitPetWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SocietyUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<SocietyCreateWithoutUnitsInput, SocietyUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutUnitsInput
    upsert?: SocietyUpsertWithoutUnitsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutUnitsInput, SocietyUpdateWithoutUnitsInput>, SocietyUncheckedUpdateWithoutUnitsInput>
  }

  export type UserUpdateOneWithoutOwnedUnitsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedUnitsInput, UserUncheckedCreateWithoutOwnedUnitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedUnitsInput
    upsert?: UserUpsertWithoutOwnedUnitsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedUnitsInput, UserUpdateWithoutOwnedUnitsInput>, UserUncheckedUpdateWithoutOwnedUnitsInput>
  }

  export type UserUpdateOneWithoutRentedUnitsNestedInput = {
    create?: XOR<UserCreateWithoutRentedUnitsInput, UserUncheckedCreateWithoutRentedUnitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRentedUnitsInput
    upsert?: UserUpsertWithoutRentedUnitsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRentedUnitsInput, UserUpdateWithoutRentedUnitsInput>, UserUncheckedUpdateWithoutRentedUnitsInput>
  }

  export type VisitorUpdateManyWithoutUnitNestedInput = {
    create?: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput> | VisitorCreateWithoutUnitInput[] | VisitorUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutUnitInput | VisitorCreateOrConnectWithoutUnitInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutUnitInput | VisitorUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: VisitorCreateManyUnitInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutUnitInput | VisitorUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutUnitInput | VisitorUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type ParkingSlotUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput> | ParkingSlotCreateWithoutUnitInput[] | ParkingSlotUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutUnitInput | ParkingSlotCreateOrConnectWithoutUnitInput[]
    upsert?: ParkingSlotUpsertWithWhereUniqueWithoutUnitInput | ParkingSlotUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ParkingSlotCreateManyUnitInputEnvelope
    set?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    disconnect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    delete?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    update?: ParkingSlotUpdateWithWhereUniqueWithoutUnitInput | ParkingSlotUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ParkingSlotUpdateManyWithWhereWithoutUnitInput | ParkingSlotUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
  }

  export type ParcelUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ParcelCreateWithoutUnitInput, ParcelUncheckedCreateWithoutUnitInput> | ParcelCreateWithoutUnitInput[] | ParcelUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ParcelCreateOrConnectWithoutUnitInput | ParcelCreateOrConnectWithoutUnitInput[]
    upsert?: ParcelUpsertWithWhereUniqueWithoutUnitInput | ParcelUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ParcelCreateManyUnitInputEnvelope
    set?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    disconnect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    delete?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    connect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    update?: ParcelUpdateWithWhereUniqueWithoutUnitInput | ParcelUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ParcelUpdateManyWithWhereWithoutUnitInput | ParcelUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ParcelScalarWhereInput | ParcelScalarWhereInput[]
  }

  export type UnitMemberUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitMemberCreateWithoutUnitInput, UnitMemberUncheckedCreateWithoutUnitInput> | UnitMemberCreateWithoutUnitInput[] | UnitMemberUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitMemberCreateOrConnectWithoutUnitInput | UnitMemberCreateOrConnectWithoutUnitInput[]
    upsert?: UnitMemberUpsertWithWhereUniqueWithoutUnitInput | UnitMemberUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitMemberCreateManyUnitInputEnvelope
    set?: UnitMemberWhereUniqueInput | UnitMemberWhereUniqueInput[]
    disconnect?: UnitMemberWhereUniqueInput | UnitMemberWhereUniqueInput[]
    delete?: UnitMemberWhereUniqueInput | UnitMemberWhereUniqueInput[]
    connect?: UnitMemberWhereUniqueInput | UnitMemberWhereUniqueInput[]
    update?: UnitMemberUpdateWithWhereUniqueWithoutUnitInput | UnitMemberUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitMemberUpdateManyWithWhereWithoutUnitInput | UnitMemberUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitMemberScalarWhereInput | UnitMemberScalarWhereInput[]
  }

  export type UnitVehicleUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitVehicleCreateWithoutUnitInput, UnitVehicleUncheckedCreateWithoutUnitInput> | UnitVehicleCreateWithoutUnitInput[] | UnitVehicleUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitVehicleCreateOrConnectWithoutUnitInput | UnitVehicleCreateOrConnectWithoutUnitInput[]
    upsert?: UnitVehicleUpsertWithWhereUniqueWithoutUnitInput | UnitVehicleUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitVehicleCreateManyUnitInputEnvelope
    set?: UnitVehicleWhereUniqueInput | UnitVehicleWhereUniqueInput[]
    disconnect?: UnitVehicleWhereUniqueInput | UnitVehicleWhereUniqueInput[]
    delete?: UnitVehicleWhereUniqueInput | UnitVehicleWhereUniqueInput[]
    connect?: UnitVehicleWhereUniqueInput | UnitVehicleWhereUniqueInput[]
    update?: UnitVehicleUpdateWithWhereUniqueWithoutUnitInput | UnitVehicleUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitVehicleUpdateManyWithWhereWithoutUnitInput | UnitVehicleUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitVehicleScalarWhereInput | UnitVehicleScalarWhereInput[]
  }

  export type UnitPetUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitPetCreateWithoutUnitInput, UnitPetUncheckedCreateWithoutUnitInput> | UnitPetCreateWithoutUnitInput[] | UnitPetUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitPetCreateOrConnectWithoutUnitInput | UnitPetCreateOrConnectWithoutUnitInput[]
    upsert?: UnitPetUpsertWithWhereUniqueWithoutUnitInput | UnitPetUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitPetCreateManyUnitInputEnvelope
    set?: UnitPetWhereUniqueInput | UnitPetWhereUniqueInput[]
    disconnect?: UnitPetWhereUniqueInput | UnitPetWhereUniqueInput[]
    delete?: UnitPetWhereUniqueInput | UnitPetWhereUniqueInput[]
    connect?: UnitPetWhereUniqueInput | UnitPetWhereUniqueInput[]
    update?: UnitPetUpdateWithWhereUniqueWithoutUnitInput | UnitPetUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitPetUpdateManyWithWhereWithoutUnitInput | UnitPetUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitPetScalarWhereInput | UnitPetScalarWhereInput[]
  }

  export type VisitorUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput> | VisitorCreateWithoutUnitInput[] | VisitorUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutUnitInput | VisitorCreateOrConnectWithoutUnitInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutUnitInput | VisitorUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: VisitorCreateManyUnitInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutUnitInput | VisitorUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutUnitInput | VisitorUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput> | ParkingSlotCreateWithoutUnitInput[] | ParkingSlotUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutUnitInput | ParkingSlotCreateOrConnectWithoutUnitInput[]
    upsert?: ParkingSlotUpsertWithWhereUniqueWithoutUnitInput | ParkingSlotUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ParkingSlotCreateManyUnitInputEnvelope
    set?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    disconnect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    delete?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    update?: ParkingSlotUpdateWithWhereUniqueWithoutUnitInput | ParkingSlotUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ParkingSlotUpdateManyWithWhereWithoutUnitInput | ParkingSlotUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
  }

  export type ParcelUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ParcelCreateWithoutUnitInput, ParcelUncheckedCreateWithoutUnitInput> | ParcelCreateWithoutUnitInput[] | ParcelUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ParcelCreateOrConnectWithoutUnitInput | ParcelCreateOrConnectWithoutUnitInput[]
    upsert?: ParcelUpsertWithWhereUniqueWithoutUnitInput | ParcelUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ParcelCreateManyUnitInputEnvelope
    set?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    disconnect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    delete?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    connect?: ParcelWhereUniqueInput | ParcelWhereUniqueInput[]
    update?: ParcelUpdateWithWhereUniqueWithoutUnitInput | ParcelUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ParcelUpdateManyWithWhereWithoutUnitInput | ParcelUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ParcelScalarWhereInput | ParcelScalarWhereInput[]
  }

  export type UnitMemberUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitMemberCreateWithoutUnitInput, UnitMemberUncheckedCreateWithoutUnitInput> | UnitMemberCreateWithoutUnitInput[] | UnitMemberUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitMemberCreateOrConnectWithoutUnitInput | UnitMemberCreateOrConnectWithoutUnitInput[]
    upsert?: UnitMemberUpsertWithWhereUniqueWithoutUnitInput | UnitMemberUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitMemberCreateManyUnitInputEnvelope
    set?: UnitMemberWhereUniqueInput | UnitMemberWhereUniqueInput[]
    disconnect?: UnitMemberWhereUniqueInput | UnitMemberWhereUniqueInput[]
    delete?: UnitMemberWhereUniqueInput | UnitMemberWhereUniqueInput[]
    connect?: UnitMemberWhereUniqueInput | UnitMemberWhereUniqueInput[]
    update?: UnitMemberUpdateWithWhereUniqueWithoutUnitInput | UnitMemberUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitMemberUpdateManyWithWhereWithoutUnitInput | UnitMemberUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitMemberScalarWhereInput | UnitMemberScalarWhereInput[]
  }

  export type UnitVehicleUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitVehicleCreateWithoutUnitInput, UnitVehicleUncheckedCreateWithoutUnitInput> | UnitVehicleCreateWithoutUnitInput[] | UnitVehicleUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitVehicleCreateOrConnectWithoutUnitInput | UnitVehicleCreateOrConnectWithoutUnitInput[]
    upsert?: UnitVehicleUpsertWithWhereUniqueWithoutUnitInput | UnitVehicleUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitVehicleCreateManyUnitInputEnvelope
    set?: UnitVehicleWhereUniqueInput | UnitVehicleWhereUniqueInput[]
    disconnect?: UnitVehicleWhereUniqueInput | UnitVehicleWhereUniqueInput[]
    delete?: UnitVehicleWhereUniqueInput | UnitVehicleWhereUniqueInput[]
    connect?: UnitVehicleWhereUniqueInput | UnitVehicleWhereUniqueInput[]
    update?: UnitVehicleUpdateWithWhereUniqueWithoutUnitInput | UnitVehicleUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitVehicleUpdateManyWithWhereWithoutUnitInput | UnitVehicleUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitVehicleScalarWhereInput | UnitVehicleScalarWhereInput[]
  }

  export type UnitPetUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitPetCreateWithoutUnitInput, UnitPetUncheckedCreateWithoutUnitInput> | UnitPetCreateWithoutUnitInput[] | UnitPetUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitPetCreateOrConnectWithoutUnitInput | UnitPetCreateOrConnectWithoutUnitInput[]
    upsert?: UnitPetUpsertWithWhereUniqueWithoutUnitInput | UnitPetUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitPetCreateManyUnitInputEnvelope
    set?: UnitPetWhereUniqueInput | UnitPetWhereUniqueInput[]
    disconnect?: UnitPetWhereUniqueInput | UnitPetWhereUniqueInput[]
    delete?: UnitPetWhereUniqueInput | UnitPetWhereUniqueInput[]
    connect?: UnitPetWhereUniqueInput | UnitPetWhereUniqueInput[]
    update?: UnitPetUpdateWithWhereUniqueWithoutUnitInput | UnitPetUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitPetUpdateManyWithWhereWithoutUnitInput | UnitPetUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitPetScalarWhereInput | UnitPetScalarWhereInput[]
  }

  export type SocietyCreateNestedOneWithoutParkingSlotsInput = {
    create?: XOR<SocietyCreateWithoutParkingSlotsInput, SocietyUncheckedCreateWithoutParkingSlotsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutParkingSlotsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutParkingSlotsInput = {
    create?: XOR<UnitCreateWithoutParkingSlotsInput, UnitUncheckedCreateWithoutParkingSlotsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutParkingSlotsInput
    connect?: UnitWhereUniqueInput
  }

  export type SocietyUpdateOneRequiredWithoutParkingSlotsNestedInput = {
    create?: XOR<SocietyCreateWithoutParkingSlotsInput, SocietyUncheckedCreateWithoutParkingSlotsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutParkingSlotsInput
    upsert?: SocietyUpsertWithoutParkingSlotsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutParkingSlotsInput, SocietyUpdateWithoutParkingSlotsInput>, SocietyUncheckedUpdateWithoutParkingSlotsInput>
  }

  export type UnitUpdateOneWithoutParkingSlotsNestedInput = {
    create?: XOR<UnitCreateWithoutParkingSlotsInput, UnitUncheckedCreateWithoutParkingSlotsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutParkingSlotsInput
    upsert?: UnitUpsertWithoutParkingSlotsInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutParkingSlotsInput, UnitUpdateWithoutParkingSlotsInput>, UnitUncheckedUpdateWithoutParkingSlotsInput>
  }

  export type SocietyCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<SocietyCreateWithoutComplaintsInput, SocietyUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutComplaintsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportedComplaintsInput = {
    create?: XOR<UserCreateWithoutReportedComplaintsInput, UserUncheckedCreateWithoutReportedComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedComplaintsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedComplaintsInput = {
    create?: XOR<UserCreateWithoutAssignedComplaintsInput, UserUncheckedCreateWithoutAssignedComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedComplaintsInput
    connect?: UserWhereUniqueInput
  }

  export type ComplaintCommentCreateNestedManyWithoutComplaintInput = {
    create?: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput> | ComplaintCommentCreateWithoutComplaintInput[] | ComplaintCommentUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutComplaintInput | ComplaintCommentCreateOrConnectWithoutComplaintInput[]
    createMany?: ComplaintCommentCreateManyComplaintInputEnvelope
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
  }

  export type ComplaintCommentUncheckedCreateNestedManyWithoutComplaintInput = {
    create?: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput> | ComplaintCommentCreateWithoutComplaintInput[] | ComplaintCommentUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutComplaintInput | ComplaintCommentCreateOrConnectWithoutComplaintInput[]
    createMany?: ComplaintCommentCreateManyComplaintInputEnvelope
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type EnumComplaintStatusFieldUpdateOperationsInput = {
    set?: $Enums.ComplaintStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SocietyUpdateOneRequiredWithoutComplaintsNestedInput = {
    create?: XOR<SocietyCreateWithoutComplaintsInput, SocietyUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutComplaintsInput
    upsert?: SocietyUpsertWithoutComplaintsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutComplaintsInput, SocietyUpdateWithoutComplaintsInput>, SocietyUncheckedUpdateWithoutComplaintsInput>
  }

  export type UserUpdateOneRequiredWithoutReportedComplaintsNestedInput = {
    create?: XOR<UserCreateWithoutReportedComplaintsInput, UserUncheckedCreateWithoutReportedComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedComplaintsInput
    upsert?: UserUpsertWithoutReportedComplaintsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportedComplaintsInput, UserUpdateWithoutReportedComplaintsInput>, UserUncheckedUpdateWithoutReportedComplaintsInput>
  }

  export type UserUpdateOneWithoutAssignedComplaintsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedComplaintsInput, UserUncheckedCreateWithoutAssignedComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedComplaintsInput
    upsert?: UserUpsertWithoutAssignedComplaintsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedComplaintsInput, UserUpdateWithoutAssignedComplaintsInput>, UserUncheckedUpdateWithoutAssignedComplaintsInput>
  }

  export type ComplaintCommentUpdateManyWithoutComplaintNestedInput = {
    create?: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput> | ComplaintCommentCreateWithoutComplaintInput[] | ComplaintCommentUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutComplaintInput | ComplaintCommentCreateOrConnectWithoutComplaintInput[]
    upsert?: ComplaintCommentUpsertWithWhereUniqueWithoutComplaintInput | ComplaintCommentUpsertWithWhereUniqueWithoutComplaintInput[]
    createMany?: ComplaintCommentCreateManyComplaintInputEnvelope
    set?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    disconnect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    delete?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    update?: ComplaintCommentUpdateWithWhereUniqueWithoutComplaintInput | ComplaintCommentUpdateWithWhereUniqueWithoutComplaintInput[]
    updateMany?: ComplaintCommentUpdateManyWithWhereWithoutComplaintInput | ComplaintCommentUpdateManyWithWhereWithoutComplaintInput[]
    deleteMany?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
  }

  export type ComplaintCommentUncheckedUpdateManyWithoutComplaintNestedInput = {
    create?: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput> | ComplaintCommentCreateWithoutComplaintInput[] | ComplaintCommentUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutComplaintInput | ComplaintCommentCreateOrConnectWithoutComplaintInput[]
    upsert?: ComplaintCommentUpsertWithWhereUniqueWithoutComplaintInput | ComplaintCommentUpsertWithWhereUniqueWithoutComplaintInput[]
    createMany?: ComplaintCommentCreateManyComplaintInputEnvelope
    set?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    disconnect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    delete?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    update?: ComplaintCommentUpdateWithWhereUniqueWithoutComplaintInput | ComplaintCommentUpdateWithWhereUniqueWithoutComplaintInput[]
    updateMany?: ComplaintCommentUpdateManyWithWhereWithoutComplaintInput | ComplaintCommentUpdateManyWithWhereWithoutComplaintInput[]
    deleteMany?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
  }

  export type ComplaintCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ComplaintCreateWithoutCommentsInput, ComplaintUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ComplaintCreateOrConnectWithoutCommentsInput
    connect?: ComplaintWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ComplaintUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ComplaintCreateWithoutCommentsInput, ComplaintUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ComplaintCreateOrConnectWithoutCommentsInput
    upsert?: ComplaintUpsertWithoutCommentsInput
    connect?: ComplaintWhereUniqueInput
    update?: XOR<XOR<ComplaintUpdateToOneWithWhereWithoutCommentsInput, ComplaintUpdateWithoutCommentsInput>, ComplaintUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type SocietyCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<SocietyCreateWithoutVisitorsInput, SocietyUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutVisitorsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<UnitCreateWithoutVisitorsInput, UnitUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutVisitorsInput
    connect?: UnitWhereUniqueInput
  }

  export type EnumVisitorStatusFieldUpdateOperationsInput = {
    set?: $Enums.VisitorStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type SocietyUpdateOneRequiredWithoutVisitorsNestedInput = {
    create?: XOR<SocietyCreateWithoutVisitorsInput, SocietyUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutVisitorsInput
    upsert?: SocietyUpsertWithoutVisitorsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutVisitorsInput, SocietyUpdateWithoutVisitorsInput>, SocietyUncheckedUpdateWithoutVisitorsInput>
  }

  export type UnitUpdateOneRequiredWithoutVisitorsNestedInput = {
    create?: XOR<UnitCreateWithoutVisitorsInput, UnitUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutVisitorsInput
    upsert?: UnitUpsertWithoutVisitorsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutVisitorsInput, UnitUpdateWithoutVisitorsInput>, UnitUncheckedUpdateWithoutVisitorsInput>
  }

  export type SocietyCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<SocietyCreateWithoutTransactionsInput, SocietyUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutTransactionsInput
    connect?: SocietyWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type SocietyUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<SocietyCreateWithoutTransactionsInput, SocietyUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutTransactionsInput
    upsert?: SocietyUpsertWithoutTransactionsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutTransactionsInput, SocietyUpdateWithoutTransactionsInput>, SocietyUncheckedUpdateWithoutTransactionsInput>
  }

  export type SocietyCreateNestedOneWithoutVendorsInput = {
    create?: XOR<SocietyCreateWithoutVendorsInput, SocietyUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutVendorsInput
    connect?: SocietyWhereUniqueInput
  }

  export type VendorPayoutCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorPayoutCreateWithoutVendorInput, VendorPayoutUncheckedCreateWithoutVendorInput> | VendorPayoutCreateWithoutVendorInput[] | VendorPayoutUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorPayoutCreateOrConnectWithoutVendorInput | VendorPayoutCreateOrConnectWithoutVendorInput[]
    createMany?: VendorPayoutCreateManyVendorInputEnvelope
    connect?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
  }

  export type VendorPayoutUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorPayoutCreateWithoutVendorInput, VendorPayoutUncheckedCreateWithoutVendorInput> | VendorPayoutCreateWithoutVendorInput[] | VendorPayoutUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorPayoutCreateOrConnectWithoutVendorInput | VendorPayoutCreateOrConnectWithoutVendorInput[]
    createMany?: VendorPayoutCreateManyVendorInputEnvelope
    connect?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
  }

  export type EnumVendorStatusFieldUpdateOperationsInput = {
    set?: $Enums.VendorStatus
  }

  export type SocietyUpdateOneWithoutVendorsNestedInput = {
    create?: XOR<SocietyCreateWithoutVendorsInput, SocietyUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutVendorsInput
    upsert?: SocietyUpsertWithoutVendorsInput
    disconnect?: SocietyWhereInput | boolean
    delete?: SocietyWhereInput | boolean
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutVendorsInput, SocietyUpdateWithoutVendorsInput>, SocietyUncheckedUpdateWithoutVendorsInput>
  }

  export type VendorPayoutUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorPayoutCreateWithoutVendorInput, VendorPayoutUncheckedCreateWithoutVendorInput> | VendorPayoutCreateWithoutVendorInput[] | VendorPayoutUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorPayoutCreateOrConnectWithoutVendorInput | VendorPayoutCreateOrConnectWithoutVendorInput[]
    upsert?: VendorPayoutUpsertWithWhereUniqueWithoutVendorInput | VendorPayoutUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorPayoutCreateManyVendorInputEnvelope
    set?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
    disconnect?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
    delete?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
    connect?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
    update?: VendorPayoutUpdateWithWhereUniqueWithoutVendorInput | VendorPayoutUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorPayoutUpdateManyWithWhereWithoutVendorInput | VendorPayoutUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorPayoutScalarWhereInput | VendorPayoutScalarWhereInput[]
  }

  export type VendorPayoutUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorPayoutCreateWithoutVendorInput, VendorPayoutUncheckedCreateWithoutVendorInput> | VendorPayoutCreateWithoutVendorInput[] | VendorPayoutUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorPayoutCreateOrConnectWithoutVendorInput | VendorPayoutCreateOrConnectWithoutVendorInput[]
    upsert?: VendorPayoutUpsertWithWhereUniqueWithoutVendorInput | VendorPayoutUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorPayoutCreateManyVendorInputEnvelope
    set?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
    disconnect?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
    delete?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
    connect?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
    update?: VendorPayoutUpdateWithWhereUniqueWithoutVendorInput | VendorPayoutUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorPayoutUpdateManyWithWhereWithoutVendorInput | VendorPayoutUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorPayoutScalarWhereInput | VendorPayoutScalarWhereInput[]
  }

  export type VendorCreateNestedOneWithoutPayoutsInput = {
    create?: XOR<VendorCreateWithoutPayoutsInput, VendorUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPayoutsInput
    connect?: VendorWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutPayoutsNestedInput = {
    create?: XOR<VendorCreateWithoutPayoutsInput, VendorUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPayoutsInput
    upsert?: VendorUpsertWithoutPayoutsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutPayoutsInput, VendorUpdateWithoutPayoutsInput>, VendorUncheckedUpdateWithoutPayoutsInput>
  }

  export type SocietyCreateNestedOneWithoutEmergencyAlertsInput = {
    create?: XOR<SocietyCreateWithoutEmergencyAlertsInput, SocietyUncheckedCreateWithoutEmergencyAlertsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutEmergencyAlertsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmergencyAlertsInput = {
    create?: XOR<UserCreateWithoutEmergencyAlertsInput, UserUncheckedCreateWithoutEmergencyAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmergencyAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type SocietyUpdateOneRequiredWithoutEmergencyAlertsNestedInput = {
    create?: XOR<SocietyCreateWithoutEmergencyAlertsInput, SocietyUncheckedCreateWithoutEmergencyAlertsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutEmergencyAlertsInput
    upsert?: SocietyUpsertWithoutEmergencyAlertsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutEmergencyAlertsInput, SocietyUpdateWithoutEmergencyAlertsInput>, SocietyUncheckedUpdateWithoutEmergencyAlertsInput>
  }

  export type UserUpdateOneRequiredWithoutEmergencyAlertsNestedInput = {
    create?: XOR<UserCreateWithoutEmergencyAlertsInput, UserUncheckedCreateWithoutEmergencyAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmergencyAlertsInput
    upsert?: UserUpsertWithoutEmergencyAlertsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmergencyAlertsInput, UserUpdateWithoutEmergencyAlertsInput>, UserUncheckedUpdateWithoutEmergencyAlertsInput>
  }

  export type SocietyCreateNestedOneWithoutEmergencyContactsInput = {
    create?: XOR<SocietyCreateWithoutEmergencyContactsInput, SocietyUncheckedCreateWithoutEmergencyContactsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutEmergencyContactsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmergencyContactsInput = {
    create?: XOR<UserCreateWithoutEmergencyContactsInput, UserUncheckedCreateWithoutEmergencyContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmergencyContactsInput
    connect?: UserWhereUniqueInput
  }

  export type SocietyUpdateOneWithoutEmergencyContactsNestedInput = {
    create?: XOR<SocietyCreateWithoutEmergencyContactsInput, SocietyUncheckedCreateWithoutEmergencyContactsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutEmergencyContactsInput
    upsert?: SocietyUpsertWithoutEmergencyContactsInput
    disconnect?: SocietyWhereInput | boolean
    delete?: SocietyWhereInput | boolean
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutEmergencyContactsInput, SocietyUpdateWithoutEmergencyContactsInput>, SocietyUncheckedUpdateWithoutEmergencyContactsInput>
  }

  export type UserUpdateOneWithoutEmergencyContactsNestedInput = {
    create?: XOR<UserCreateWithoutEmergencyContactsInput, UserUncheckedCreateWithoutEmergencyContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmergencyContactsInput
    upsert?: UserUpsertWithoutEmergencyContactsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmergencyContactsInput, UserUpdateWithoutEmergencyContactsInput>, UserUncheckedUpdateWithoutEmergencyContactsInput>
  }

  export type SocietyCreateNestedOneWithoutNoticesInput = {
    create?: XOR<SocietyCreateWithoutNoticesInput, SocietyUncheckedCreateWithoutNoticesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutNoticesInput
    connect?: SocietyWhereUniqueInput
  }

  export type SocietyUpdateOneRequiredWithoutNoticesNestedInput = {
    create?: XOR<SocietyCreateWithoutNoticesInput, SocietyUncheckedCreateWithoutNoticesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutNoticesInput
    upsert?: SocietyUpsertWithoutNoticesInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutNoticesInput, SocietyUpdateWithoutNoticesInput>, SocietyUncheckedUpdateWithoutNoticesInput>
  }

  export type SocietyCreateNestedOneWithoutAmenitiesInput = {
    create?: XOR<SocietyCreateWithoutAmenitiesInput, SocietyUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutAmenitiesInput
    connect?: SocietyWhereUniqueInput
  }

  export type AmenityBookingCreateNestedManyWithoutAmenityInput = {
    create?: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput> | AmenityBookingCreateWithoutAmenityInput[] | AmenityBookingUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutAmenityInput | AmenityBookingCreateOrConnectWithoutAmenityInput[]
    createMany?: AmenityBookingCreateManyAmenityInputEnvelope
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
  }

  export type AmenityBookingUncheckedCreateNestedManyWithoutAmenityInput = {
    create?: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput> | AmenityBookingCreateWithoutAmenityInput[] | AmenityBookingUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutAmenityInput | AmenityBookingCreateOrConnectWithoutAmenityInput[]
    createMany?: AmenityBookingCreateManyAmenityInputEnvelope
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
  }

  export type SocietyUpdateOneRequiredWithoutAmenitiesNestedInput = {
    create?: XOR<SocietyCreateWithoutAmenitiesInput, SocietyUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutAmenitiesInput
    upsert?: SocietyUpsertWithoutAmenitiesInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutAmenitiesInput, SocietyUpdateWithoutAmenitiesInput>, SocietyUncheckedUpdateWithoutAmenitiesInput>
  }

  export type AmenityBookingUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput> | AmenityBookingCreateWithoutAmenityInput[] | AmenityBookingUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutAmenityInput | AmenityBookingCreateOrConnectWithoutAmenityInput[]
    upsert?: AmenityBookingUpsertWithWhereUniqueWithoutAmenityInput | AmenityBookingUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: AmenityBookingCreateManyAmenityInputEnvelope
    set?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    disconnect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    delete?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    update?: AmenityBookingUpdateWithWhereUniqueWithoutAmenityInput | AmenityBookingUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: AmenityBookingUpdateManyWithWhereWithoutAmenityInput | AmenityBookingUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
  }

  export type AmenityBookingUncheckedUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput> | AmenityBookingCreateWithoutAmenityInput[] | AmenityBookingUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutAmenityInput | AmenityBookingCreateOrConnectWithoutAmenityInput[]
    upsert?: AmenityBookingUpsertWithWhereUniqueWithoutAmenityInput | AmenityBookingUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: AmenityBookingCreateManyAmenityInputEnvelope
    set?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    disconnect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    delete?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    update?: AmenityBookingUpdateWithWhereUniqueWithoutAmenityInput | AmenityBookingUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: AmenityBookingUpdateManyWithWhereWithoutAmenityInput | AmenityBookingUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
  }

  export type AmenityCreateNestedOneWithoutBookingsInput = {
    create?: XOR<AmenityCreateWithoutBookingsInput, AmenityUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutBookingsInput
    connect?: AmenityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type AmenityUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<AmenityCreateWithoutBookingsInput, AmenityUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutBookingsInput
    upsert?: AmenityUpsertWithoutBookingsInput
    connect?: AmenityWhereUniqueInput
    update?: XOR<XOR<AmenityUpdateToOneWithWhereWithoutBookingsInput, AmenityUpdateWithoutBookingsInput>, AmenityUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type SocietyCreateNestedOneWithoutPlatformInvoicesInput = {
    create?: XOR<SocietyCreateWithoutPlatformInvoicesInput, SocietyUncheckedCreateWithoutPlatformInvoicesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutPlatformInvoicesInput
    connect?: SocietyWhereUniqueInput
  }

  export type SocietyUpdateOneRequiredWithoutPlatformInvoicesNestedInput = {
    create?: XOR<SocietyCreateWithoutPlatformInvoicesInput, SocietyUncheckedCreateWithoutPlatformInvoicesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutPlatformInvoicesInput
    upsert?: SocietyUpsertWithoutPlatformInvoicesInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutPlatformInvoicesInput, SocietyUpdateWithoutPlatformInvoicesInput>, SocietyUncheckedUpdateWithoutPlatformInvoicesInput>
  }

  export type UserCreateNestedOneWithoutBuzzsInput = {
    create?: XOR<UserCreateWithoutBuzzsInput, UserUncheckedCreateWithoutBuzzsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuzzsInput
    connect?: UserWhereUniqueInput
  }

  export type SocietyCreateNestedOneWithoutBuzzsInput = {
    create?: XOR<SocietyCreateWithoutBuzzsInput, SocietyUncheckedCreateWithoutBuzzsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutBuzzsInput
    connect?: SocietyWhereUniqueInput
  }

  export type CommunityCommentCreateNestedManyWithoutBuzzInput = {
    create?: XOR<CommunityCommentCreateWithoutBuzzInput, CommunityCommentUncheckedCreateWithoutBuzzInput> | CommunityCommentCreateWithoutBuzzInput[] | CommunityCommentUncheckedCreateWithoutBuzzInput[]
    connectOrCreate?: CommunityCommentCreateOrConnectWithoutBuzzInput | CommunityCommentCreateOrConnectWithoutBuzzInput[]
    createMany?: CommunityCommentCreateManyBuzzInputEnvelope
    connect?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
  }

  export type BuzzLikeCreateNestedManyWithoutBuzzInput = {
    create?: XOR<BuzzLikeCreateWithoutBuzzInput, BuzzLikeUncheckedCreateWithoutBuzzInput> | BuzzLikeCreateWithoutBuzzInput[] | BuzzLikeUncheckedCreateWithoutBuzzInput[]
    connectOrCreate?: BuzzLikeCreateOrConnectWithoutBuzzInput | BuzzLikeCreateOrConnectWithoutBuzzInput[]
    createMany?: BuzzLikeCreateManyBuzzInputEnvelope
    connect?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
  }

  export type CommunityCommentUncheckedCreateNestedManyWithoutBuzzInput = {
    create?: XOR<CommunityCommentCreateWithoutBuzzInput, CommunityCommentUncheckedCreateWithoutBuzzInput> | CommunityCommentCreateWithoutBuzzInput[] | CommunityCommentUncheckedCreateWithoutBuzzInput[]
    connectOrCreate?: CommunityCommentCreateOrConnectWithoutBuzzInput | CommunityCommentCreateOrConnectWithoutBuzzInput[]
    createMany?: CommunityCommentCreateManyBuzzInputEnvelope
    connect?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
  }

  export type BuzzLikeUncheckedCreateNestedManyWithoutBuzzInput = {
    create?: XOR<BuzzLikeCreateWithoutBuzzInput, BuzzLikeUncheckedCreateWithoutBuzzInput> | BuzzLikeCreateWithoutBuzzInput[] | BuzzLikeUncheckedCreateWithoutBuzzInput[]
    connectOrCreate?: BuzzLikeCreateOrConnectWithoutBuzzInput | BuzzLikeCreateOrConnectWithoutBuzzInput[]
    createMany?: BuzzLikeCreateManyBuzzInputEnvelope
    connect?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutBuzzsNestedInput = {
    create?: XOR<UserCreateWithoutBuzzsInput, UserUncheckedCreateWithoutBuzzsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuzzsInput
    upsert?: UserUpsertWithoutBuzzsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBuzzsInput, UserUpdateWithoutBuzzsInput>, UserUncheckedUpdateWithoutBuzzsInput>
  }

  export type SocietyUpdateOneRequiredWithoutBuzzsNestedInput = {
    create?: XOR<SocietyCreateWithoutBuzzsInput, SocietyUncheckedCreateWithoutBuzzsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutBuzzsInput
    upsert?: SocietyUpsertWithoutBuzzsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutBuzzsInput, SocietyUpdateWithoutBuzzsInput>, SocietyUncheckedUpdateWithoutBuzzsInput>
  }

  export type CommunityCommentUpdateManyWithoutBuzzNestedInput = {
    create?: XOR<CommunityCommentCreateWithoutBuzzInput, CommunityCommentUncheckedCreateWithoutBuzzInput> | CommunityCommentCreateWithoutBuzzInput[] | CommunityCommentUncheckedCreateWithoutBuzzInput[]
    connectOrCreate?: CommunityCommentCreateOrConnectWithoutBuzzInput | CommunityCommentCreateOrConnectWithoutBuzzInput[]
    upsert?: CommunityCommentUpsertWithWhereUniqueWithoutBuzzInput | CommunityCommentUpsertWithWhereUniqueWithoutBuzzInput[]
    createMany?: CommunityCommentCreateManyBuzzInputEnvelope
    set?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
    disconnect?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
    delete?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
    connect?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
    update?: CommunityCommentUpdateWithWhereUniqueWithoutBuzzInput | CommunityCommentUpdateWithWhereUniqueWithoutBuzzInput[]
    updateMany?: CommunityCommentUpdateManyWithWhereWithoutBuzzInput | CommunityCommentUpdateManyWithWhereWithoutBuzzInput[]
    deleteMany?: CommunityCommentScalarWhereInput | CommunityCommentScalarWhereInput[]
  }

  export type BuzzLikeUpdateManyWithoutBuzzNestedInput = {
    create?: XOR<BuzzLikeCreateWithoutBuzzInput, BuzzLikeUncheckedCreateWithoutBuzzInput> | BuzzLikeCreateWithoutBuzzInput[] | BuzzLikeUncheckedCreateWithoutBuzzInput[]
    connectOrCreate?: BuzzLikeCreateOrConnectWithoutBuzzInput | BuzzLikeCreateOrConnectWithoutBuzzInput[]
    upsert?: BuzzLikeUpsertWithWhereUniqueWithoutBuzzInput | BuzzLikeUpsertWithWhereUniqueWithoutBuzzInput[]
    createMany?: BuzzLikeCreateManyBuzzInputEnvelope
    set?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
    disconnect?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
    delete?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
    connect?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
    update?: BuzzLikeUpdateWithWhereUniqueWithoutBuzzInput | BuzzLikeUpdateWithWhereUniqueWithoutBuzzInput[]
    updateMany?: BuzzLikeUpdateManyWithWhereWithoutBuzzInput | BuzzLikeUpdateManyWithWhereWithoutBuzzInput[]
    deleteMany?: BuzzLikeScalarWhereInput | BuzzLikeScalarWhereInput[]
  }

  export type CommunityCommentUncheckedUpdateManyWithoutBuzzNestedInput = {
    create?: XOR<CommunityCommentCreateWithoutBuzzInput, CommunityCommentUncheckedCreateWithoutBuzzInput> | CommunityCommentCreateWithoutBuzzInput[] | CommunityCommentUncheckedCreateWithoutBuzzInput[]
    connectOrCreate?: CommunityCommentCreateOrConnectWithoutBuzzInput | CommunityCommentCreateOrConnectWithoutBuzzInput[]
    upsert?: CommunityCommentUpsertWithWhereUniqueWithoutBuzzInput | CommunityCommentUpsertWithWhereUniqueWithoutBuzzInput[]
    createMany?: CommunityCommentCreateManyBuzzInputEnvelope
    set?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
    disconnect?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
    delete?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
    connect?: CommunityCommentWhereUniqueInput | CommunityCommentWhereUniqueInput[]
    update?: CommunityCommentUpdateWithWhereUniqueWithoutBuzzInput | CommunityCommentUpdateWithWhereUniqueWithoutBuzzInput[]
    updateMany?: CommunityCommentUpdateManyWithWhereWithoutBuzzInput | CommunityCommentUpdateManyWithWhereWithoutBuzzInput[]
    deleteMany?: CommunityCommentScalarWhereInput | CommunityCommentScalarWhereInput[]
  }

  export type BuzzLikeUncheckedUpdateManyWithoutBuzzNestedInput = {
    create?: XOR<BuzzLikeCreateWithoutBuzzInput, BuzzLikeUncheckedCreateWithoutBuzzInput> | BuzzLikeCreateWithoutBuzzInput[] | BuzzLikeUncheckedCreateWithoutBuzzInput[]
    connectOrCreate?: BuzzLikeCreateOrConnectWithoutBuzzInput | BuzzLikeCreateOrConnectWithoutBuzzInput[]
    upsert?: BuzzLikeUpsertWithWhereUniqueWithoutBuzzInput | BuzzLikeUpsertWithWhereUniqueWithoutBuzzInput[]
    createMany?: BuzzLikeCreateManyBuzzInputEnvelope
    set?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
    disconnect?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
    delete?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
    connect?: BuzzLikeWhereUniqueInput | BuzzLikeWhereUniqueInput[]
    update?: BuzzLikeUpdateWithWhereUniqueWithoutBuzzInput | BuzzLikeUpdateWithWhereUniqueWithoutBuzzInput[]
    updateMany?: BuzzLikeUpdateManyWithWhereWithoutBuzzInput | BuzzLikeUpdateManyWithWhereWithoutBuzzInput[]
    deleteMany?: BuzzLikeScalarWhereInput | BuzzLikeScalarWhereInput[]
  }

  export type CommunityBuzzCreateNestedOneWithoutCommentsInput = {
    create?: XOR<CommunityBuzzCreateWithoutCommentsInput, CommunityBuzzUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: CommunityBuzzCreateOrConnectWithoutCommentsInput
    connect?: CommunityBuzzWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityCommentsInput = {
    create?: XOR<UserCreateWithoutCommunityCommentsInput, UserUncheckedCreateWithoutCommunityCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityBuzzUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<CommunityBuzzCreateWithoutCommentsInput, CommunityBuzzUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: CommunityBuzzCreateOrConnectWithoutCommentsInput
    upsert?: CommunityBuzzUpsertWithoutCommentsInput
    connect?: CommunityBuzzWhereUniqueInput
    update?: XOR<XOR<CommunityBuzzUpdateToOneWithWhereWithoutCommentsInput, CommunityBuzzUpdateWithoutCommentsInput>, CommunityBuzzUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommunityCommentsInput, UserUncheckedCreateWithoutCommunityCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityCommentsInput
    upsert?: UserUpsertWithoutCommunityCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommunityCommentsInput, UserUpdateWithoutCommunityCommentsInput>, UserUncheckedUpdateWithoutCommunityCommentsInput>
  }

  export type CommunityBuzzCreateNestedOneWithoutLikedByInput = {
    create?: XOR<CommunityBuzzCreateWithoutLikedByInput, CommunityBuzzUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: CommunityBuzzCreateOrConnectWithoutLikedByInput
    connect?: CommunityBuzzWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBuzzLikesInput = {
    create?: XOR<UserCreateWithoutBuzzLikesInput, UserUncheckedCreateWithoutBuzzLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuzzLikesInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityBuzzUpdateOneRequiredWithoutLikedByNestedInput = {
    create?: XOR<CommunityBuzzCreateWithoutLikedByInput, CommunityBuzzUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: CommunityBuzzCreateOrConnectWithoutLikedByInput
    upsert?: CommunityBuzzUpsertWithoutLikedByInput
    connect?: CommunityBuzzWhereUniqueInput
    update?: XOR<XOR<CommunityBuzzUpdateToOneWithWhereWithoutLikedByInput, CommunityBuzzUpdateWithoutLikedByInput>, CommunityBuzzUncheckedUpdateWithoutLikedByInput>
  }

  export type UserUpdateOneRequiredWithoutBuzzLikesNestedInput = {
    create?: XOR<UserCreateWithoutBuzzLikesInput, UserUncheckedCreateWithoutBuzzLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuzzLikesInput
    upsert?: UserUpsertWithoutBuzzLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBuzzLikesInput, UserUpdateWithoutBuzzLikesInput>, UserUncheckedUpdateWithoutBuzzLikesInput>
  }

  export type UnitCreateNestedOneWithoutMembersInput = {
    create?: XOR<UnitCreateWithoutMembersInput, UnitUncheckedCreateWithoutMembersInput>
    connectOrCreate?: UnitCreateOrConnectWithoutMembersInput
    connect?: UnitWhereUniqueInput
  }

  export type UnitUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<UnitCreateWithoutMembersInput, UnitUncheckedCreateWithoutMembersInput>
    connectOrCreate?: UnitCreateOrConnectWithoutMembersInput
    upsert?: UnitUpsertWithoutMembersInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutMembersInput, UnitUpdateWithoutMembersInput>, UnitUncheckedUpdateWithoutMembersInput>
  }

  export type UnitCreateNestedOneWithoutVehiclesInput = {
    create?: XOR<UnitCreateWithoutVehiclesInput, UnitUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutVehiclesInput
    connect?: UnitWhereUniqueInput
  }

  export type UnitUpdateOneRequiredWithoutVehiclesNestedInput = {
    create?: XOR<UnitCreateWithoutVehiclesInput, UnitUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutVehiclesInput
    upsert?: UnitUpsertWithoutVehiclesInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutVehiclesInput, UnitUpdateWithoutVehiclesInput>, UnitUncheckedUpdateWithoutVehiclesInput>
  }

  export type UnitCreateNestedOneWithoutPetsListInput = {
    create?: XOR<UnitCreateWithoutPetsListInput, UnitUncheckedCreateWithoutPetsListInput>
    connectOrCreate?: UnitCreateOrConnectWithoutPetsListInput
    connect?: UnitWhereUniqueInput
  }

  export type UnitUpdateOneRequiredWithoutPetsListNestedInput = {
    create?: XOR<UnitCreateWithoutPetsListInput, UnitUncheckedCreateWithoutPetsListInput>
    connectOrCreate?: UnitCreateOrConnectWithoutPetsListInput
    upsert?: UnitUpsertWithoutPetsListInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutPetsListInput, UnitUpdateWithoutPetsListInput>, UnitUncheckedUpdateWithoutPetsListInput>
  }

  export type UserCreateNestedOneWithoutSosAlertsInput = {
    create?: XOR<UserCreateWithoutSosAlertsInput, UserUncheckedCreateWithoutSosAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSosAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type SocietyCreateNestedOneWithoutSosAlertsInput = {
    create?: XOR<SocietyCreateWithoutSosAlertsInput, SocietyUncheckedCreateWithoutSosAlertsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutSosAlertsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSosAlertsNestedInput = {
    create?: XOR<UserCreateWithoutSosAlertsInput, UserUncheckedCreateWithoutSosAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSosAlertsInput
    upsert?: UserUpsertWithoutSosAlertsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSosAlertsInput, UserUpdateWithoutSosAlertsInput>, UserUncheckedUpdateWithoutSosAlertsInput>
  }

  export type SocietyUpdateOneRequiredWithoutSosAlertsNestedInput = {
    create?: XOR<SocietyCreateWithoutSosAlertsInput, SocietyUncheckedCreateWithoutSosAlertsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutSosAlertsInput
    upsert?: SocietyUpsertWithoutSosAlertsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutSosAlertsInput, SocietyUpdateWithoutSosAlertsInput>, SocietyUncheckedUpdateWithoutSosAlertsInput>
  }

  export type UserCreateNestedOneWithoutMarketplaceItemsInput = {
    create?: XOR<UserCreateWithoutMarketplaceItemsInput, UserUncheckedCreateWithoutMarketplaceItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMarketplaceItemsInput
    connect?: UserWhereUniqueInput
  }

  export type SocietyCreateNestedOneWithoutMarketplaceItemsInput = {
    create?: XOR<SocietyCreateWithoutMarketplaceItemsInput, SocietyUncheckedCreateWithoutMarketplaceItemsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutMarketplaceItemsInput
    connect?: SocietyWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutMarketplaceItemsNestedInput = {
    create?: XOR<UserCreateWithoutMarketplaceItemsInput, UserUncheckedCreateWithoutMarketplaceItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMarketplaceItemsInput
    upsert?: UserUpsertWithoutMarketplaceItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMarketplaceItemsInput, UserUpdateWithoutMarketplaceItemsInput>, UserUncheckedUpdateWithoutMarketplaceItemsInput>
  }

  export type SocietyUpdateOneRequiredWithoutMarketplaceItemsNestedInput = {
    create?: XOR<SocietyCreateWithoutMarketplaceItemsInput, SocietyUncheckedCreateWithoutMarketplaceItemsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutMarketplaceItemsInput
    upsert?: SocietyUpsertWithoutMarketplaceItemsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutMarketplaceItemsInput, SocietyUpdateWithoutMarketplaceItemsInput>, SocietyUncheckedUpdateWithoutMarketplaceItemsInput>
  }

  export type SocietyCreateNestedOneWithoutMeetingsInput = {
    create?: XOR<SocietyCreateWithoutMeetingsInput, SocietyUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutMeetingsInput
    connect?: SocietyWhereUniqueInput
  }

  export type SocietyUpdateOneRequiredWithoutMeetingsNestedInput = {
    create?: XOR<SocietyCreateWithoutMeetingsInput, SocietyUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutMeetingsInput
    upsert?: SocietyUpsertWithoutMeetingsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutMeetingsInput, SocietyUpdateWithoutMeetingsInput>, SocietyUncheckedUpdateWithoutMeetingsInput>
  }

  export type SocietyCreateNestedOneWithoutGuidelinesInput = {
    create?: XOR<SocietyCreateWithoutGuidelinesInput, SocietyUncheckedCreateWithoutGuidelinesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutGuidelinesInput
    connect?: SocietyWhereUniqueInput
  }

  export type SocietyUpdateOneRequiredWithoutGuidelinesNestedInput = {
    create?: XOR<SocietyCreateWithoutGuidelinesInput, SocietyUncheckedCreateWithoutGuidelinesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutGuidelinesInput
    upsert?: SocietyUpsertWithoutGuidelinesInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutGuidelinesInput, SocietyUpdateWithoutGuidelinesInput>, SocietyUncheckedUpdateWithoutGuidelinesInput>
  }

  export type SocietyCreateNestedOneWithoutAssetsInput = {
    create?: XOR<SocietyCreateWithoutAssetsInput, SocietyUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutAssetsInput
    connect?: SocietyWhereUniqueInput
  }

  export type SocietyUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<SocietyCreateWithoutAssetsInput, SocietyUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutAssetsInput
    upsert?: SocietyUpsertWithoutAssetsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutAssetsInput, SocietyUpdateWithoutAssetsInput>, SocietyUncheckedUpdateWithoutAssetsInput>
  }

  export type SocietyCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<SocietyCreateWithoutDocumentsInput, SocietyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutDocumentsInput
    connect?: SocietyWhereUniqueInput
  }

  export type SocietyUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<SocietyCreateWithoutDocumentsInput, SocietyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutDocumentsInput
    upsert?: SocietyUpsertWithoutDocumentsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutDocumentsInput, SocietyUpdateWithoutDocumentsInput>, SocietyUncheckedUpdateWithoutDocumentsInput>
  }

  export type UnitCreateNestedOneWithoutParcelsInput = {
    create?: XOR<UnitCreateWithoutParcelsInput, UnitUncheckedCreateWithoutParcelsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutParcelsInput
    connect?: UnitWhereUniqueInput
  }

  export type SocietyCreateNestedOneWithoutParcelsInput = {
    create?: XOR<SocietyCreateWithoutParcelsInput, SocietyUncheckedCreateWithoutParcelsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutParcelsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UnitUpdateOneRequiredWithoutParcelsNestedInput = {
    create?: XOR<UnitCreateWithoutParcelsInput, UnitUncheckedCreateWithoutParcelsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutParcelsInput
    upsert?: UnitUpsertWithoutParcelsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutParcelsInput, UnitUpdateWithoutParcelsInput>, UnitUncheckedUpdateWithoutParcelsInput>
  }

  export type SocietyUpdateOneRequiredWithoutParcelsNestedInput = {
    create?: XOR<SocietyCreateWithoutParcelsInput, SocietyUncheckedCreateWithoutParcelsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutParcelsInput
    upsert?: SocietyUpsertWithoutParcelsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutParcelsInput, SocietyUpdateWithoutParcelsInput>, SocietyUncheckedUpdateWithoutParcelsInput>
  }

  export type SocietyCreateNestedOneWithoutEventsInput = {
    create?: XOR<SocietyCreateWithoutEventsInput, SocietyUncheckedCreateWithoutEventsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutEventsInput
    connect?: SocietyWhereUniqueInput
  }

  export type SocietyUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<SocietyCreateWithoutEventsInput, SocietyUncheckedCreateWithoutEventsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutEventsInput
    upsert?: SocietyUpsertWithoutEventsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutEventsInput, SocietyUpdateWithoutEventsInput>, SocietyUncheckedUpdateWithoutEventsInput>
  }

  export type SocietyCreateNestedOneWithoutPurchaseRequestsInput = {
    create?: XOR<SocietyCreateWithoutPurchaseRequestsInput, SocietyUncheckedCreateWithoutPurchaseRequestsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutPurchaseRequestsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPurchaseRequestsInput = {
    create?: XOR<UserCreateWithoutPurchaseRequestsInput, UserUncheckedCreateWithoutPurchaseRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type SocietyUpdateOneRequiredWithoutPurchaseRequestsNestedInput = {
    create?: XOR<SocietyCreateWithoutPurchaseRequestsInput, SocietyUncheckedCreateWithoutPurchaseRequestsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutPurchaseRequestsInput
    upsert?: SocietyUpsertWithoutPurchaseRequestsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutPurchaseRequestsInput, SocietyUpdateWithoutPurchaseRequestsInput>, SocietyUncheckedUpdateWithoutPurchaseRequestsInput>
  }

  export type UserUpdateOneRequiredWithoutPurchaseRequestsNestedInput = {
    create?: XOR<UserCreateWithoutPurchaseRequestsInput, UserUncheckedCreateWithoutPurchaseRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseRequestsInput
    upsert?: UserUpsertWithoutPurchaseRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchaseRequestsInput, UserUpdateWithoutPurchaseRequestsInput>, UserUncheckedUpdateWithoutPurchaseRequestsInput>
  }

  export type SocietyCreateNestedOneWithoutConversationsInput = {
    create?: XOR<SocietyCreateWithoutConversationsInput, SocietyUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutConversationsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type ChatMessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<ChatMessageCreateWithoutConversationInput, ChatMessageUncheckedCreateWithoutConversationInput> | ChatMessageCreateWithoutConversationInput[] | ChatMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutConversationInput | ChatMessageCreateOrConnectWithoutConversationInput[]
    createMany?: ChatMessageCreateManyConversationInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ChatMessageCreateWithoutConversationInput, ChatMessageUncheckedCreateWithoutConversationInput> | ChatMessageCreateWithoutConversationInput[] | ChatMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutConversationInput | ChatMessageCreateOrConnectWithoutConversationInput[]
    createMany?: ChatMessageCreateManyConversationInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type SocietyUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<SocietyCreateWithoutConversationsInput, SocietyUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutConversationsInput
    upsert?: SocietyUpsertWithoutConversationsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutConversationsInput, SocietyUpdateWithoutConversationsInput>, SocietyUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    upsert?: UserUpsertWithoutConversationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationsInput, UserUpdateWithoutConversationsInput>, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type ChatMessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ChatMessageCreateWithoutConversationInput, ChatMessageUncheckedCreateWithoutConversationInput> | ChatMessageCreateWithoutConversationInput[] | ChatMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutConversationInput | ChatMessageCreateOrConnectWithoutConversationInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutConversationInput | ChatMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ChatMessageCreateManyConversationInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutConversationInput | ChatMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutConversationInput | ChatMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ChatMessageCreateWithoutConversationInput, ChatMessageUncheckedCreateWithoutConversationInput> | ChatMessageCreateWithoutConversationInput[] | ChatMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutConversationInput | ChatMessageCreateOrConnectWithoutConversationInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutConversationInput | ChatMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ChatMessageCreateManyConversationInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutConversationInput | ChatMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutConversationInput | ChatMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type ServiceVariantCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceVariantCreateWithoutCategoryInput, ServiceVariantUncheckedCreateWithoutCategoryInput> | ServiceVariantCreateWithoutCategoryInput[] | ServiceVariantUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceVariantCreateOrConnectWithoutCategoryInput | ServiceVariantCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceVariantCreateManyCategoryInputEnvelope
    connect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
  }

  export type ServiceInquiryCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceInquiryCreateWithoutServiceInput, ServiceInquiryUncheckedCreateWithoutServiceInput> | ServiceInquiryCreateWithoutServiceInput[] | ServiceInquiryUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceInquiryCreateOrConnectWithoutServiceInput | ServiceInquiryCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceInquiryCreateManyServiceInputEnvelope
    connect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
  }

  export type ServiceVariantUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceVariantCreateWithoutCategoryInput, ServiceVariantUncheckedCreateWithoutCategoryInput> | ServiceVariantCreateWithoutCategoryInput[] | ServiceVariantUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceVariantCreateOrConnectWithoutCategoryInput | ServiceVariantCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceVariantCreateManyCategoryInputEnvelope
    connect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
  }

  export type ServiceInquiryUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceInquiryCreateWithoutServiceInput, ServiceInquiryUncheckedCreateWithoutServiceInput> | ServiceInquiryCreateWithoutServiceInput[] | ServiceInquiryUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceInquiryCreateOrConnectWithoutServiceInput | ServiceInquiryCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceInquiryCreateManyServiceInputEnvelope
    connect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
  }

  export type ServiceVariantUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceVariantCreateWithoutCategoryInput, ServiceVariantUncheckedCreateWithoutCategoryInput> | ServiceVariantCreateWithoutCategoryInput[] | ServiceVariantUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceVariantCreateOrConnectWithoutCategoryInput | ServiceVariantCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceVariantUpsertWithWhereUniqueWithoutCategoryInput | ServiceVariantUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceVariantCreateManyCategoryInputEnvelope
    set?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
    disconnect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
    delete?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
    connect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
    update?: ServiceVariantUpdateWithWhereUniqueWithoutCategoryInput | ServiceVariantUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceVariantUpdateManyWithWhereWithoutCategoryInput | ServiceVariantUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceVariantScalarWhereInput | ServiceVariantScalarWhereInput[]
  }

  export type ServiceInquiryUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceInquiryCreateWithoutServiceInput, ServiceInquiryUncheckedCreateWithoutServiceInput> | ServiceInquiryCreateWithoutServiceInput[] | ServiceInquiryUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceInquiryCreateOrConnectWithoutServiceInput | ServiceInquiryCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceInquiryUpsertWithWhereUniqueWithoutServiceInput | ServiceInquiryUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceInquiryCreateManyServiceInputEnvelope
    set?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    disconnect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    delete?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    connect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    update?: ServiceInquiryUpdateWithWhereUniqueWithoutServiceInput | ServiceInquiryUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceInquiryUpdateManyWithWhereWithoutServiceInput | ServiceInquiryUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceInquiryScalarWhereInput | ServiceInquiryScalarWhereInput[]
  }

  export type ServiceVariantUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceVariantCreateWithoutCategoryInput, ServiceVariantUncheckedCreateWithoutCategoryInput> | ServiceVariantCreateWithoutCategoryInput[] | ServiceVariantUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceVariantCreateOrConnectWithoutCategoryInput | ServiceVariantCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceVariantUpsertWithWhereUniqueWithoutCategoryInput | ServiceVariantUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceVariantCreateManyCategoryInputEnvelope
    set?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
    disconnect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
    delete?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
    connect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
    update?: ServiceVariantUpdateWithWhereUniqueWithoutCategoryInput | ServiceVariantUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceVariantUpdateManyWithWhereWithoutCategoryInput | ServiceVariantUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceVariantScalarWhereInput | ServiceVariantScalarWhereInput[]
  }

  export type ServiceInquiryUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceInquiryCreateWithoutServiceInput, ServiceInquiryUncheckedCreateWithoutServiceInput> | ServiceInquiryCreateWithoutServiceInput[] | ServiceInquiryUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceInquiryCreateOrConnectWithoutServiceInput | ServiceInquiryCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceInquiryUpsertWithWhereUniqueWithoutServiceInput | ServiceInquiryUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceInquiryCreateManyServiceInputEnvelope
    set?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    disconnect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    delete?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    connect?: ServiceInquiryWhereUniqueInput | ServiceInquiryWhereUniqueInput[]
    update?: ServiceInquiryUpdateWithWhereUniqueWithoutServiceInput | ServiceInquiryUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceInquiryUpdateManyWithWhereWithoutServiceInput | ServiceInquiryUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceInquiryScalarWhereInput | ServiceInquiryScalarWhereInput[]
  }

  export type ServiceCategoryCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ServiceCategoryCreateWithoutVariantsInput, ServiceCategoryUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutVariantsInput
    connect?: ServiceCategoryWhereUniqueInput
  }

  export type ServiceCategoryUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<ServiceCategoryCreateWithoutVariantsInput, ServiceCategoryUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutVariantsInput
    upsert?: ServiceCategoryUpsertWithoutVariantsInput
    connect?: ServiceCategoryWhereUniqueInput
    update?: XOR<XOR<ServiceCategoryUpdateToOneWithWhereWithoutVariantsInput, ServiceCategoryUpdateWithoutVariantsInput>, ServiceCategoryUncheckedUpdateWithoutVariantsInput>
  }

  export type UserCreateNestedOneWithoutServiceInquiriesInput = {
    create?: XOR<UserCreateWithoutServiceInquiriesInput, UserUncheckedCreateWithoutServiceInquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceInquiriesInput
    connect?: UserWhereUniqueInput
  }

  export type SocietyCreateNestedOneWithoutServiceInquiriesInput = {
    create?: XOR<SocietyCreateWithoutServiceInquiriesInput, SocietyUncheckedCreateWithoutServiceInquiriesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutServiceInquiriesInput
    connect?: SocietyWhereUniqueInput
  }

  export type ServiceCategoryCreateNestedOneWithoutInquiriesInput = {
    create?: XOR<ServiceCategoryCreateWithoutInquiriesInput, ServiceCategoryUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutInquiriesInput
    connect?: ServiceCategoryWhereUniqueInput
  }

  export type UserUpdateOneWithoutServiceInquiriesNestedInput = {
    create?: XOR<UserCreateWithoutServiceInquiriesInput, UserUncheckedCreateWithoutServiceInquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceInquiriesInput
    upsert?: UserUpsertWithoutServiceInquiriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServiceInquiriesInput, UserUpdateWithoutServiceInquiriesInput>, UserUncheckedUpdateWithoutServiceInquiriesInput>
  }

  export type SocietyUpdateOneWithoutServiceInquiriesNestedInput = {
    create?: XOR<SocietyCreateWithoutServiceInquiriesInput, SocietyUncheckedCreateWithoutServiceInquiriesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutServiceInquiriesInput
    upsert?: SocietyUpsertWithoutServiceInquiriesInput
    disconnect?: SocietyWhereInput | boolean
    delete?: SocietyWhereInput | boolean
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutServiceInquiriesInput, SocietyUpdateWithoutServiceInquiriesInput>, SocietyUncheckedUpdateWithoutServiceInquiriesInput>
  }

  export type ServiceCategoryUpdateOneWithoutInquiriesNestedInput = {
    create?: XOR<ServiceCategoryCreateWithoutInquiriesInput, ServiceCategoryUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutInquiriesInput
    upsert?: ServiceCategoryUpsertWithoutInquiriesInput
    disconnect?: ServiceCategoryWhereInput | boolean
    delete?: ServiceCategoryWhereInput | boolean
    connect?: ServiceCategoryWhereUniqueInput
    update?: XOR<XOR<ServiceCategoryUpdateToOneWithWhereWithoutInquiriesInput, ServiceCategoryUpdateWithoutInquiriesInput>, ServiceCategoryUncheckedUpdateWithoutInquiriesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumSocietyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SocietyStatus | EnumSocietyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SocietyStatus[]
    notIn?: $Enums.SocietyStatus[]
    not?: NestedEnumSocietyStatusFilter<$PrismaModel> | $Enums.SocietyStatus
  }

  export type NestedEnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSocietyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocietyStatus | EnumSocietyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SocietyStatus[]
    notIn?: $Enums.SocietyStatus[]
    not?: NestedEnumSocietyStatusWithAggregatesFilter<$PrismaModel> | $Enums.SocietyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocietyStatusFilter<$PrismaModel>
    _max?: NestedEnumSocietyStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[]
    notIn?: $Enums.UserStatus[]
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[]
    notIn?: $Enums.UserStatus[]
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[]
    notIn?: $Enums.Priority[]
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumComplaintStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[]
    notIn?: $Enums.ComplaintStatus[]
    not?: NestedEnumComplaintStatusFilter<$PrismaModel> | $Enums.ComplaintStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[]
    notIn?: $Enums.Priority[]
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[]
    notIn?: $Enums.ComplaintStatus[]
    not?: NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintStatusFilter<$PrismaModel>
    _max?: NestedEnumComplaintStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumVisitorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitorStatus | EnumVisitorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitorStatus[]
    notIn?: $Enums.VisitorStatus[]
    not?: NestedEnumVisitorStatusFilter<$PrismaModel> | $Enums.VisitorStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumVisitorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitorStatus | EnumVisitorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitorStatus[]
    notIn?: $Enums.VisitorStatus[]
    not?: NestedEnumVisitorStatusWithAggregatesFilter<$PrismaModel> | $Enums.VisitorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitorStatusFilter<$PrismaModel>
    _max?: NestedEnumVisitorStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumVendorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorStatus | EnumVendorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorStatus[]
    notIn?: $Enums.VendorStatus[]
    not?: NestedEnumVendorStatusFilter<$PrismaModel> | $Enums.VendorStatus
  }

  export type NestedEnumVendorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorStatus | EnumVendorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorStatus[]
    notIn?: $Enums.VendorStatus[]
    not?: NestedEnumVendorStatusWithAggregatesFilter<$PrismaModel> | $Enums.VendorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVendorStatusFilter<$PrismaModel>
    _max?: NestedEnumVendorStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UserCreateWithoutSocietyInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSocietyInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSocietyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput>
  }

  export type UserCreateManySocietyInputEnvelope = {
    data: UserCreateManySocietyInput | UserCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type UnitCreateWithoutSocietyInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
    parcels?: ParcelCreateNestedManyWithoutUnitInput
    members?: UnitMemberCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleCreateNestedManyWithoutUnitInput
    petsList?: UnitPetCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutSocietyInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutUnitInput
    members?: UnitMemberUncheckedCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleUncheckedCreateNestedManyWithoutUnitInput
    petsList?: UnitPetUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutSocietyInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput>
  }

  export type UnitCreateManySocietyInputEnvelope = {
    data: UnitCreateManySocietyInput | UnitCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCreateWithoutSocietyInput = {
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    isPrivate?: boolean
    escalatedToTech?: boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    reportedBy: UserCreateNestedOneWithoutReportedComplaintsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedComplaintsInput
    comments?: ComplaintCommentCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintUncheckedCreateWithoutSocietyInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    isPrivate?: boolean
    escalatedToTech?: boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    reportedById: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintCreateOrConnectWithoutSocietyInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput>
  }

  export type ComplaintCreateManySocietyInputEnvelope = {
    data: ComplaintCreateManySocietyInput | ComplaintCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type VisitorCreateWithoutSocietyInput = {
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateWithoutSocietyInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    visitingUnitId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorCreateOrConnectWithoutSocietyInput = {
    where: VisitorWhereUniqueInput
    create: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput>
  }

  export type VisitorCreateManySocietyInputEnvelope = {
    data: VisitorCreateManySocietyInput | VisitorCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutSocietyInput = {
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUncheckedCreateWithoutSocietyInput = {
    id?: number
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutSocietyInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput>
  }

  export type TransactionCreateManySocietyInputEnvelope = {
    data: TransactionCreateManySocietyInput | TransactionCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type NoticeCreateWithoutSocietyInput = {
    title: string
    content: string
    audience: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NoticeUncheckedCreateWithoutSocietyInput = {
    id?: number
    title: string
    content: string
    audience: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NoticeCreateOrConnectWithoutSocietyInput = {
    where: NoticeWhereUniqueInput
    create: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput>
  }

  export type NoticeCreateManySocietyInputEnvelope = {
    data: NoticeCreateManySocietyInput | NoticeCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type VendorCreateWithoutSocietyInput = {
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    status?: $Enums.VendorStatus
    createdAt?: Date | string
    payouts?: VendorPayoutCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutSocietyInput = {
    id?: number
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    status?: $Enums.VendorStatus
    createdAt?: Date | string
    payouts?: VendorPayoutUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutSocietyInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput>
  }

  export type VendorCreateManySocietyInputEnvelope = {
    data: VendorCreateManySocietyInput | VendorCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type AmenityCreateWithoutSocietyInput = {
    name: string
    type?: string
    description?: string | null
    capacity?: number
    chargesPerHour?: number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: AmenityBookingCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUncheckedCreateWithoutSocietyInput = {
    id?: number
    name: string
    type?: string
    description?: string | null
    capacity?: number
    chargesPerHour?: number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutAmenityInput
  }

  export type AmenityCreateOrConnectWithoutSocietyInput = {
    where: AmenityWhereUniqueInput
    create: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput>
  }

  export type AmenityCreateManySocietyInputEnvelope = {
    data: AmenityCreateManySocietyInput | AmenityCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type ParkingSlotCreateWithoutSocietyInput = {
    number: string
    type: string
    status: string
    vehicleNumber?: string | null
    createdAt?: Date | string
    unit?: UnitCreateNestedOneWithoutParkingSlotsInput
  }

  export type ParkingSlotUncheckedCreateWithoutSocietyInput = {
    id?: number
    number: string
    type: string
    status: string
    allocatedToUnitId?: number | null
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type ParkingSlotCreateOrConnectWithoutSocietyInput = {
    where: ParkingSlotWhereUniqueInput
    create: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput>
  }

  export type ParkingSlotCreateManySocietyInputEnvelope = {
    data: ParkingSlotCreateManySocietyInput | ParkingSlotCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type PlatformInvoiceCreateWithoutSocietyInput = {
    invoiceNo: string
    amount: number
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformInvoiceUncheckedCreateWithoutSocietyInput = {
    id?: number
    invoiceNo: string
    amount: number
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformInvoiceCreateOrConnectWithoutSocietyInput = {
    where: PlatformInvoiceWhereUniqueInput
    create: XOR<PlatformInvoiceCreateWithoutSocietyInput, PlatformInvoiceUncheckedCreateWithoutSocietyInput>
  }

  export type PlatformInvoiceCreateManySocietyInputEnvelope = {
    data: PlatformInvoiceCreateManySocietyInput | PlatformInvoiceCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type MeetingCreateWithoutSocietyInput = {
    title: string
    description?: string | null
    date: Date | string
    time: string
    location: string
    attendees?: NullableJsonNullValueInput | InputJsonValue
    status?: string
  }

  export type MeetingUncheckedCreateWithoutSocietyInput = {
    id?: number
    title: string
    description?: string | null
    date: Date | string
    time: string
    location: string
    attendees?: NullableJsonNullValueInput | InputJsonValue
    status?: string
  }

  export type MeetingCreateOrConnectWithoutSocietyInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutSocietyInput, MeetingUncheckedCreateWithoutSocietyInput>
  }

  export type MeetingCreateManySocietyInputEnvelope = {
    data: MeetingCreateManySocietyInput | MeetingCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type AssetCreateWithoutSocietyInput = {
    name: string
    category: string
    value: number
    purchaseDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUncheckedCreateWithoutSocietyInput = {
    id?: number
    name: string
    category: string
    value: number
    purchaseDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetCreateOrConnectWithoutSocietyInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutSocietyInput, AssetUncheckedCreateWithoutSocietyInput>
  }

  export type AssetCreateManySocietyInputEnvelope = {
    data: AssetCreateManySocietyInput | AssetCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutSocietyInput = {
    title: string
    category: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type DocumentUncheckedCreateWithoutSocietyInput = {
    id?: number
    title: string
    category: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutSocietyInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutSocietyInput, DocumentUncheckedCreateWithoutSocietyInput>
  }

  export type DocumentCreateManySocietyInputEnvelope = {
    data: DocumentCreateManySocietyInput | DocumentCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type ParcelCreateWithoutSocietyInput = {
    courierName: string
    trackingNumber?: string | null
    description?: string | null
    receivedBy?: string | null
    status?: string
    collectedBy?: string | null
    collectedAt?: Date | string | null
    createdAt?: Date | string
    unit: UnitCreateNestedOneWithoutParcelsInput
  }

  export type ParcelUncheckedCreateWithoutSocietyInput = {
    id?: number
    unitId: number
    courierName: string
    trackingNumber?: string | null
    description?: string | null
    receivedBy?: string | null
    status?: string
    collectedBy?: string | null
    collectedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ParcelCreateOrConnectWithoutSocietyInput = {
    where: ParcelWhereUniqueInput
    create: XOR<ParcelCreateWithoutSocietyInput, ParcelUncheckedCreateWithoutSocietyInput>
  }

  export type ParcelCreateManySocietyInputEnvelope = {
    data: ParcelCreateManySocietyInput | ParcelCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutSocietyInput = {
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    category?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUncheckedCreateWithoutSocietyInput = {
    id?: number
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    category?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateOrConnectWithoutSocietyInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutSocietyInput, EventUncheckedCreateWithoutSocietyInput>
  }

  export type EventCreateManySocietyInputEnvelope = {
    data: EventCreateManySocietyInput | EventCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseRequestCreateWithoutSocietyInput = {
    title: string
    description?: string | null
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requestedBy: UserCreateNestedOneWithoutPurchaseRequestsInput
  }

  export type PurchaseRequestUncheckedCreateWithoutSocietyInput = {
    id?: number
    title: string
    description?: string | null
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requestedById: number
  }

  export type PurchaseRequestCreateOrConnectWithoutSocietyInput = {
    where: PurchaseRequestWhereUniqueInput
    create: XOR<PurchaseRequestCreateWithoutSocietyInput, PurchaseRequestUncheckedCreateWithoutSocietyInput>
  }

  export type PurchaseRequestCreateManySocietyInputEnvelope = {
    data: PurchaseRequestCreateManySocietyInput | PurchaseRequestCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type EmergencyAlertCreateWithoutSocietyInput = {
    type: string
    unit?: string | null
    description?: string | null
    status?: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmergencyAlertsInput
  }

  export type EmergencyAlertUncheckedCreateWithoutSocietyInput = {
    id?: number
    type: string
    unit?: string | null
    description?: string | null
    status?: string
    resolution?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyAlertCreateOrConnectWithoutSocietyInput = {
    where: EmergencyAlertWhereUniqueInput
    create: XOR<EmergencyAlertCreateWithoutSocietyInput, EmergencyAlertUncheckedCreateWithoutSocietyInput>
  }

  export type EmergencyAlertCreateManySocietyInputEnvelope = {
    data: EmergencyAlertCreateManySocietyInput | EmergencyAlertCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type EmergencyContactCreateWithoutSocietyInput = {
    name: string
    phone: string
    category?: string
    available?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resident?: UserCreateNestedOneWithoutEmergencyContactsInput
  }

  export type EmergencyContactUncheckedCreateWithoutSocietyInput = {
    id?: number
    name: string
    phone: string
    category?: string
    available?: boolean
    residentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyContactCreateOrConnectWithoutSocietyInput = {
    where: EmergencyContactWhereUniqueInput
    create: XOR<EmergencyContactCreateWithoutSocietyInput, EmergencyContactUncheckedCreateWithoutSocietyInput>
  }

  export type EmergencyContactCreateManySocietyInputEnvelope = {
    data: EmergencyContactCreateManySocietyInput | EmergencyContactCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type ServiceInquiryCreateWithoutSocietyInput = {
    serviceName?: string | null
    type: string
    status?: string
    preferredDate?: string | null
    preferredTime?: string | null
    phone?: string | null
    notes?: string | null
    vendorName?: string | null
    vendorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resident?: UserCreateNestedOneWithoutServiceInquiriesInput
    service?: ServiceCategoryCreateNestedOneWithoutInquiriesInput
  }

  export type ServiceInquiryUncheckedCreateWithoutSocietyInput = {
    id?: number
    residentId?: number | null
    serviceId?: string | null
    serviceName?: string | null
    type: string
    status?: string
    preferredDate?: string | null
    preferredTime?: string | null
    phone?: string | null
    notes?: string | null
    vendorName?: string | null
    vendorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceInquiryCreateOrConnectWithoutSocietyInput = {
    where: ServiceInquiryWhereUniqueInput
    create: XOR<ServiceInquiryCreateWithoutSocietyInput, ServiceInquiryUncheckedCreateWithoutSocietyInput>
  }

  export type ServiceInquiryCreateManySocietyInputEnvelope = {
    data: ServiceInquiryCreateManySocietyInput | ServiceInquiryCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutSocietyInput = {
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participant?: UserCreateNestedOneWithoutConversationsInput
    messages?: ChatMessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutSocietyInput = {
    id?: number
    type: string
    participantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutSocietyInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutSocietyInput, ConversationUncheckedCreateWithoutSocietyInput>
  }

  export type ConversationCreateManySocietyInputEnvelope = {
    data: ConversationCreateManySocietyInput | ConversationCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type CommunityBuzzCreateWithoutSocietyInput = {
    type: string
    title: string
    content?: string | null
    hasResult?: boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutBuzzsInput
    comments?: CommunityCommentCreateNestedManyWithoutBuzzInput
    likedBy?: BuzzLikeCreateNestedManyWithoutBuzzInput
  }

  export type CommunityBuzzUncheckedCreateWithoutSocietyInput = {
    id?: number
    type: string
    title: string
    content?: string | null
    authorId: number
    hasResult?: boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    createdAt?: Date | string
    comments?: CommunityCommentUncheckedCreateNestedManyWithoutBuzzInput
    likedBy?: BuzzLikeUncheckedCreateNestedManyWithoutBuzzInput
  }

  export type CommunityBuzzCreateOrConnectWithoutSocietyInput = {
    where: CommunityBuzzWhereUniqueInput
    create: XOR<CommunityBuzzCreateWithoutSocietyInput, CommunityBuzzUncheckedCreateWithoutSocietyInput>
  }

  export type CommunityBuzzCreateManySocietyInputEnvelope = {
    data: CommunityBuzzCreateManySocietyInput | CommunityBuzzCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type MarketplaceItemCreateWithoutSocietyInput = {
    title: string
    description: string
    price?: number | null
    originalPrice?: number | null
    condition?: string | null
    type?: string
    priceType?: string | null
    category?: string | null
    status?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: number
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutMarketplaceItemsInput
  }

  export type MarketplaceItemUncheckedCreateWithoutSocietyInput = {
    id?: number
    title: string
    description: string
    price?: number | null
    originalPrice?: number | null
    condition?: string | null
    type?: string
    priceType?: string | null
    category?: string | null
    status?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: number
    likes?: number
    ownerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceItemCreateOrConnectWithoutSocietyInput = {
    where: MarketplaceItemWhereUniqueInput
    create: XOR<MarketplaceItemCreateWithoutSocietyInput, MarketplaceItemUncheckedCreateWithoutSocietyInput>
  }

  export type MarketplaceItemCreateManySocietyInputEnvelope = {
    data: MarketplaceItemCreateManySocietyInput | MarketplaceItemCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type CommunityGuidelineCreateWithoutSocietyInput = {
    title: string
    content: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityGuidelineUncheckedCreateWithoutSocietyInput = {
    id?: number
    title: string
    content: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityGuidelineCreateOrConnectWithoutSocietyInput = {
    where: CommunityGuidelineWhereUniqueInput
    create: XOR<CommunityGuidelineCreateWithoutSocietyInput, CommunityGuidelineUncheckedCreateWithoutSocietyInput>
  }

  export type CommunityGuidelineCreateManySocietyInputEnvelope = {
    data: CommunityGuidelineCreateManySocietyInput | CommunityGuidelineCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type SOSAlertCreateWithoutSocietyInput = {
    type: string
    status?: string
    location?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
    resident: UserCreateNestedOneWithoutSosAlertsInput
  }

  export type SOSAlertUncheckedCreateWithoutSocietyInput = {
    id?: number
    residentId: number
    type: string
    status?: string
    location?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SOSAlertCreateOrConnectWithoutSocietyInput = {
    where: SOSAlertWhereUniqueInput
    create: XOR<SOSAlertCreateWithoutSocietyInput, SOSAlertUncheckedCreateWithoutSocietyInput>
  }

  export type SOSAlertCreateManySocietyInputEnvelope = {
    data: SOSAlertCreateManySocietyInput | SOSAlertCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutSocietyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSocietyInput, UserUncheckedUpdateWithoutSocietyInput>
    create: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSocietyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSocietyInput, UserUncheckedUpdateWithoutSocietyInput>
  }

  export type UserUpdateManyWithWhereWithoutSocietyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSocietyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    profileImg?: StringNullableFilter<"User"> | string | null
    roleId?: IntNullableFilter<"User"> | number | null
    societyId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UnitUpsertWithWhereUniqueWithoutSocietyInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutSocietyInput, UnitUncheckedUpdateWithoutSocietyInput>
    create: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutSocietyInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutSocietyInput, UnitUncheckedUpdateWithoutSocietyInput>
  }

  export type UnitUpdateManyWithWhereWithoutSocietyInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutSocietyInput>
  }

  export type UnitScalarWhereInput = {
    AND?: UnitScalarWhereInput | UnitScalarWhereInput[]
    OR?: UnitScalarWhereInput[]
    NOT?: UnitScalarWhereInput | UnitScalarWhereInput[]
    id?: IntFilter<"Unit"> | number
    block?: StringFilter<"Unit"> | string
    number?: StringFilter<"Unit"> | string
    floor?: IntFilter<"Unit"> | number
    type?: StringFilter<"Unit"> | string
    areaSqFt?: FloatFilter<"Unit"> | number
    status?: StringFilter<"Unit"> | string
    pets?: IntFilter<"Unit"> | number
    membersCount?: IntFilter<"Unit"> | number
    societyId?: IntFilter<"Unit"> | number
    ownerId?: IntNullableFilter<"Unit"> | number | null
    tenantId?: IntNullableFilter<"Unit"> | number | null
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
  }

  export type ComplaintUpsertWithWhereUniqueWithoutSocietyInput = {
    where: ComplaintWhereUniqueInput
    update: XOR<ComplaintUpdateWithoutSocietyInput, ComplaintUncheckedUpdateWithoutSocietyInput>
    create: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput>
  }

  export type ComplaintUpdateWithWhereUniqueWithoutSocietyInput = {
    where: ComplaintWhereUniqueInput
    data: XOR<ComplaintUpdateWithoutSocietyInput, ComplaintUncheckedUpdateWithoutSocietyInput>
  }

  export type ComplaintUpdateManyWithWhereWithoutSocietyInput = {
    where: ComplaintScalarWhereInput
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyWithoutSocietyInput>
  }

  export type ComplaintScalarWhereInput = {
    AND?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
    OR?: ComplaintScalarWhereInput[]
    NOT?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
    id?: IntFilter<"Complaint"> | number
    title?: StringFilter<"Complaint"> | string
    description?: StringFilter<"Complaint"> | string
    category?: StringFilter<"Complaint"> | string
    priority?: EnumPriorityFilter<"Complaint"> | $Enums.Priority
    status?: EnumComplaintStatusFilter<"Complaint"> | $Enums.ComplaintStatus
    isPrivate?: BoolFilter<"Complaint"> | boolean
    escalatedToTech?: BoolFilter<"Complaint"> | boolean
    images?: JsonNullableFilter<"Complaint">
    societyId?: IntFilter<"Complaint"> | number
    reportedById?: IntFilter<"Complaint"> | number
    assignedToId?: IntNullableFilter<"Complaint"> | number | null
    timeline?: JsonNullableFilter<"Complaint">
    createdAt?: DateTimeFilter<"Complaint"> | Date | string
    updatedAt?: DateTimeFilter<"Complaint"> | Date | string
  }

  export type VisitorUpsertWithWhereUniqueWithoutSocietyInput = {
    where: VisitorWhereUniqueInput
    update: XOR<VisitorUpdateWithoutSocietyInput, VisitorUncheckedUpdateWithoutSocietyInput>
    create: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput>
  }

  export type VisitorUpdateWithWhereUniqueWithoutSocietyInput = {
    where: VisitorWhereUniqueInput
    data: XOR<VisitorUpdateWithoutSocietyInput, VisitorUncheckedUpdateWithoutSocietyInput>
  }

  export type VisitorUpdateManyWithWhereWithoutSocietyInput = {
    where: VisitorScalarWhereInput
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyWithoutSocietyInput>
  }

  export type VisitorScalarWhereInput = {
    AND?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
    OR?: VisitorScalarWhereInput[]
    NOT?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
    id?: IntFilter<"Visitor"> | number
    name?: StringFilter<"Visitor"> | string
    phone?: StringFilter<"Visitor"> | string
    vehicleNo?: StringNullableFilter<"Visitor"> | string | null
    purpose?: StringFilter<"Visitor"> | string
    photo?: StringNullableFilter<"Visitor"> | string | null
    status?: EnumVisitorStatusFilter<"Visitor"> | $Enums.VisitorStatus
    entryTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    exitTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    societyId?: IntFilter<"Visitor"> | number
    visitingUnitId?: IntFilter<"Visitor"> | number
    idType?: StringNullableFilter<"Visitor"> | string | null
    idNumber?: StringNullableFilter<"Visitor"> | string | null
    createdAt?: DateTimeFilter<"Visitor"> | Date | string
    updatedAt?: DateTimeFilter<"Visitor"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutSocietyInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutSocietyInput, TransactionUncheckedUpdateWithoutSocietyInput>
    create: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutSocietyInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutSocietyInput, TransactionUncheckedUpdateWithoutSocietyInput>
  }

  export type TransactionUpdateManyWithWhereWithoutSocietyInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutSocietyInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    category?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    status?: StringFilter<"Transaction"> | string
    societyId?: IntFilter<"Transaction"> | number
    invoiceNo?: StringNullableFilter<"Transaction"> | string | null
    paidTo?: StringNullableFilter<"Transaction"> | string | null
    receivedFrom?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type NoticeUpsertWithWhereUniqueWithoutSocietyInput = {
    where: NoticeWhereUniqueInput
    update: XOR<NoticeUpdateWithoutSocietyInput, NoticeUncheckedUpdateWithoutSocietyInput>
    create: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput>
  }

  export type NoticeUpdateWithWhereUniqueWithoutSocietyInput = {
    where: NoticeWhereUniqueInput
    data: XOR<NoticeUpdateWithoutSocietyInput, NoticeUncheckedUpdateWithoutSocietyInput>
  }

  export type NoticeUpdateManyWithWhereWithoutSocietyInput = {
    where: NoticeScalarWhereInput
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyWithoutSocietyInput>
  }

  export type NoticeScalarWhereInput = {
    AND?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
    OR?: NoticeScalarWhereInput[]
    NOT?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
    id?: IntFilter<"Notice"> | number
    title?: StringFilter<"Notice"> | string
    content?: StringFilter<"Notice"> | string
    audience?: StringFilter<"Notice"> | string
    societyId?: IntFilter<"Notice"> | number
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notice"> | Date | string | null
  }

  export type VendorUpsertWithWhereUniqueWithoutSocietyInput = {
    where: VendorWhereUniqueInput
    update: XOR<VendorUpdateWithoutSocietyInput, VendorUncheckedUpdateWithoutSocietyInput>
    create: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput>
  }

  export type VendorUpdateWithWhereUniqueWithoutSocietyInput = {
    where: VendorWhereUniqueInput
    data: XOR<VendorUpdateWithoutSocietyInput, VendorUncheckedUpdateWithoutSocietyInput>
  }

  export type VendorUpdateManyWithWhereWithoutSocietyInput = {
    where: VendorScalarWhereInput
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyWithoutSocietyInput>
  }

  export type VendorScalarWhereInput = {
    AND?: VendorScalarWhereInput | VendorScalarWhereInput[]
    OR?: VendorScalarWhereInput[]
    NOT?: VendorScalarWhereInput | VendorScalarWhereInput[]
    id?: IntFilter<"Vendor"> | number
    name?: StringFilter<"Vendor"> | string
    serviceType?: StringFilter<"Vendor"> | string
    contact?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    status?: EnumVendorStatusFilter<"Vendor"> | $Enums.VendorStatus
    societyId?: IntNullableFilter<"Vendor"> | number | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
  }

  export type AmenityUpsertWithWhereUniqueWithoutSocietyInput = {
    where: AmenityWhereUniqueInput
    update: XOR<AmenityUpdateWithoutSocietyInput, AmenityUncheckedUpdateWithoutSocietyInput>
    create: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput>
  }

  export type AmenityUpdateWithWhereUniqueWithoutSocietyInput = {
    where: AmenityWhereUniqueInput
    data: XOR<AmenityUpdateWithoutSocietyInput, AmenityUncheckedUpdateWithoutSocietyInput>
  }

  export type AmenityUpdateManyWithWhereWithoutSocietyInput = {
    where: AmenityScalarWhereInput
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyWithoutSocietyInput>
  }

  export type AmenityScalarWhereInput = {
    AND?: AmenityScalarWhereInput | AmenityScalarWhereInput[]
    OR?: AmenityScalarWhereInput[]
    NOT?: AmenityScalarWhereInput | AmenityScalarWhereInput[]
    id?: IntFilter<"Amenity"> | number
    name?: StringFilter<"Amenity"> | string
    type?: StringFilter<"Amenity"> | string
    description?: StringNullableFilter<"Amenity"> | string | null
    capacity?: IntFilter<"Amenity"> | number
    chargesPerHour?: FloatFilter<"Amenity"> | number
    availableDays?: JsonNullableFilter<"Amenity">
    timings?: JsonNullableFilter<"Amenity">
    status?: StringFilter<"Amenity"> | string
    societyId?: IntFilter<"Amenity"> | number
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
    updatedAt?: DateTimeFilter<"Amenity"> | Date | string
  }

  export type ParkingSlotUpsertWithWhereUniqueWithoutSocietyInput = {
    where: ParkingSlotWhereUniqueInput
    update: XOR<ParkingSlotUpdateWithoutSocietyInput, ParkingSlotUncheckedUpdateWithoutSocietyInput>
    create: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput>
  }

  export type ParkingSlotUpdateWithWhereUniqueWithoutSocietyInput = {
    where: ParkingSlotWhereUniqueInput
    data: XOR<ParkingSlotUpdateWithoutSocietyInput, ParkingSlotUncheckedUpdateWithoutSocietyInput>
  }

  export type ParkingSlotUpdateManyWithWhereWithoutSocietyInput = {
    where: ParkingSlotScalarWhereInput
    data: XOR<ParkingSlotUpdateManyMutationInput, ParkingSlotUncheckedUpdateManyWithoutSocietyInput>
  }

  export type ParkingSlotScalarWhereInput = {
    AND?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
    OR?: ParkingSlotScalarWhereInput[]
    NOT?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
    id?: IntFilter<"ParkingSlot"> | number
    number?: StringFilter<"ParkingSlot"> | string
    type?: StringFilter<"ParkingSlot"> | string
    status?: StringFilter<"ParkingSlot"> | string
    societyId?: IntFilter<"ParkingSlot"> | number
    allocatedToUnitId?: IntNullableFilter<"ParkingSlot"> | number | null
    vehicleNumber?: StringNullableFilter<"ParkingSlot"> | string | null
    createdAt?: DateTimeFilter<"ParkingSlot"> | Date | string
  }

  export type PlatformInvoiceUpsertWithWhereUniqueWithoutSocietyInput = {
    where: PlatformInvoiceWhereUniqueInput
    update: XOR<PlatformInvoiceUpdateWithoutSocietyInput, PlatformInvoiceUncheckedUpdateWithoutSocietyInput>
    create: XOR<PlatformInvoiceCreateWithoutSocietyInput, PlatformInvoiceUncheckedCreateWithoutSocietyInput>
  }

  export type PlatformInvoiceUpdateWithWhereUniqueWithoutSocietyInput = {
    where: PlatformInvoiceWhereUniqueInput
    data: XOR<PlatformInvoiceUpdateWithoutSocietyInput, PlatformInvoiceUncheckedUpdateWithoutSocietyInput>
  }

  export type PlatformInvoiceUpdateManyWithWhereWithoutSocietyInput = {
    where: PlatformInvoiceScalarWhereInput
    data: XOR<PlatformInvoiceUpdateManyMutationInput, PlatformInvoiceUncheckedUpdateManyWithoutSocietyInput>
  }

  export type PlatformInvoiceScalarWhereInput = {
    AND?: PlatformInvoiceScalarWhereInput | PlatformInvoiceScalarWhereInput[]
    OR?: PlatformInvoiceScalarWhereInput[]
    NOT?: PlatformInvoiceScalarWhereInput | PlatformInvoiceScalarWhereInput[]
    id?: IntFilter<"PlatformInvoice"> | number
    invoiceNo?: StringFilter<"PlatformInvoice"> | string
    societyId?: IntFilter<"PlatformInvoice"> | number
    amount?: FloatFilter<"PlatformInvoice"> | number
    status?: StringFilter<"PlatformInvoice"> | string
    issueDate?: DateTimeFilter<"PlatformInvoice"> | Date | string
    dueDate?: DateTimeFilter<"PlatformInvoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"PlatformInvoice"> | Date | string | null
    createdAt?: DateTimeFilter<"PlatformInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformInvoice"> | Date | string
  }

  export type MeetingUpsertWithWhereUniqueWithoutSocietyInput = {
    where: MeetingWhereUniqueInput
    update: XOR<MeetingUpdateWithoutSocietyInput, MeetingUncheckedUpdateWithoutSocietyInput>
    create: XOR<MeetingCreateWithoutSocietyInput, MeetingUncheckedCreateWithoutSocietyInput>
  }

  export type MeetingUpdateWithWhereUniqueWithoutSocietyInput = {
    where: MeetingWhereUniqueInput
    data: XOR<MeetingUpdateWithoutSocietyInput, MeetingUncheckedUpdateWithoutSocietyInput>
  }

  export type MeetingUpdateManyWithWhereWithoutSocietyInput = {
    where: MeetingScalarWhereInput
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyWithoutSocietyInput>
  }

  export type MeetingScalarWhereInput = {
    AND?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    OR?: MeetingScalarWhereInput[]
    NOT?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    id?: IntFilter<"Meeting"> | number
    title?: StringFilter<"Meeting"> | string
    description?: StringNullableFilter<"Meeting"> | string | null
    date?: DateTimeFilter<"Meeting"> | Date | string
    time?: StringFilter<"Meeting"> | string
    location?: StringFilter<"Meeting"> | string
    attendees?: JsonNullableFilter<"Meeting">
    status?: StringFilter<"Meeting"> | string
    societyId?: IntFilter<"Meeting"> | number
  }

  export type AssetUpsertWithWhereUniqueWithoutSocietyInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutSocietyInput, AssetUncheckedUpdateWithoutSocietyInput>
    create: XOR<AssetCreateWithoutSocietyInput, AssetUncheckedCreateWithoutSocietyInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutSocietyInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutSocietyInput, AssetUncheckedUpdateWithoutSocietyInput>
  }

  export type AssetUpdateManyWithWhereWithoutSocietyInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutSocietyInput>
  }

  export type AssetScalarWhereInput = {
    AND?: AssetScalarWhereInput | AssetScalarWhereInput[]
    OR?: AssetScalarWhereInput[]
    NOT?: AssetScalarWhereInput | AssetScalarWhereInput[]
    id?: IntFilter<"Asset"> | number
    name?: StringFilter<"Asset"> | string
    category?: StringFilter<"Asset"> | string
    value?: FloatFilter<"Asset"> | number
    purchaseDate?: DateTimeFilter<"Asset"> | Date | string
    status?: StringFilter<"Asset"> | string
    societyId?: IntFilter<"Asset"> | number
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutSocietyInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutSocietyInput, DocumentUncheckedUpdateWithoutSocietyInput>
    create: XOR<DocumentCreateWithoutSocietyInput, DocumentUncheckedCreateWithoutSocietyInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutSocietyInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutSocietyInput, DocumentUncheckedUpdateWithoutSocietyInput>
  }

  export type DocumentUpdateManyWithWhereWithoutSocietyInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutSocietyInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: IntFilter<"Document"> | number
    title?: StringFilter<"Document"> | string
    category?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    societyId?: IntFilter<"Document"> | number
    createdAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type ParcelUpsertWithWhereUniqueWithoutSocietyInput = {
    where: ParcelWhereUniqueInput
    update: XOR<ParcelUpdateWithoutSocietyInput, ParcelUncheckedUpdateWithoutSocietyInput>
    create: XOR<ParcelCreateWithoutSocietyInput, ParcelUncheckedCreateWithoutSocietyInput>
  }

  export type ParcelUpdateWithWhereUniqueWithoutSocietyInput = {
    where: ParcelWhereUniqueInput
    data: XOR<ParcelUpdateWithoutSocietyInput, ParcelUncheckedUpdateWithoutSocietyInput>
  }

  export type ParcelUpdateManyWithWhereWithoutSocietyInput = {
    where: ParcelScalarWhereInput
    data: XOR<ParcelUpdateManyMutationInput, ParcelUncheckedUpdateManyWithoutSocietyInput>
  }

  export type ParcelScalarWhereInput = {
    AND?: ParcelScalarWhereInput | ParcelScalarWhereInput[]
    OR?: ParcelScalarWhereInput[]
    NOT?: ParcelScalarWhereInput | ParcelScalarWhereInput[]
    id?: IntFilter<"Parcel"> | number
    unitId?: IntFilter<"Parcel"> | number
    courierName?: StringFilter<"Parcel"> | string
    trackingNumber?: StringNullableFilter<"Parcel"> | string | null
    description?: StringNullableFilter<"Parcel"> | string | null
    receivedBy?: StringNullableFilter<"Parcel"> | string | null
    status?: StringFilter<"Parcel"> | string
    collectedBy?: StringNullableFilter<"Parcel"> | string | null
    collectedAt?: DateTimeNullableFilter<"Parcel"> | Date | string | null
    societyId?: IntFilter<"Parcel"> | number
    createdAt?: DateTimeFilter<"Parcel"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutSocietyInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutSocietyInput, EventUncheckedUpdateWithoutSocietyInput>
    create: XOR<EventCreateWithoutSocietyInput, EventUncheckedCreateWithoutSocietyInput>
  }

  export type EventUpdateWithWhereUniqueWithoutSocietyInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutSocietyInput, EventUncheckedUpdateWithoutSocietyInput>
  }

  export type EventUpdateManyWithWhereWithoutSocietyInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutSocietyInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: IntFilter<"Event"> | number
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    date?: DateTimeFilter<"Event"> | Date | string
    time?: StringNullableFilter<"Event"> | string | null
    location?: StringNullableFilter<"Event"> | string | null
    category?: StringNullableFilter<"Event"> | string | null
    status?: StringFilter<"Event"> | string
    societyId?: IntFilter<"Event"> | number
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type PurchaseRequestUpsertWithWhereUniqueWithoutSocietyInput = {
    where: PurchaseRequestWhereUniqueInput
    update: XOR<PurchaseRequestUpdateWithoutSocietyInput, PurchaseRequestUncheckedUpdateWithoutSocietyInput>
    create: XOR<PurchaseRequestCreateWithoutSocietyInput, PurchaseRequestUncheckedCreateWithoutSocietyInput>
  }

  export type PurchaseRequestUpdateWithWhereUniqueWithoutSocietyInput = {
    where: PurchaseRequestWhereUniqueInput
    data: XOR<PurchaseRequestUpdateWithoutSocietyInput, PurchaseRequestUncheckedUpdateWithoutSocietyInput>
  }

  export type PurchaseRequestUpdateManyWithWhereWithoutSocietyInput = {
    where: PurchaseRequestScalarWhereInput
    data: XOR<PurchaseRequestUpdateManyMutationInput, PurchaseRequestUncheckedUpdateManyWithoutSocietyInput>
  }

  export type PurchaseRequestScalarWhereInput = {
    AND?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
    OR?: PurchaseRequestScalarWhereInput[]
    NOT?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
    id?: IntFilter<"PurchaseRequest"> | number
    title?: StringFilter<"PurchaseRequest"> | string
    description?: StringNullableFilter<"PurchaseRequest"> | string | null
    amount?: FloatFilter<"PurchaseRequest"> | number
    status?: StringFilter<"PurchaseRequest"> | string
    createdAt?: DateTimeFilter<"PurchaseRequest"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseRequest"> | Date | string
    societyId?: IntFilter<"PurchaseRequest"> | number
    requestedById?: IntFilter<"PurchaseRequest"> | number
  }

  export type EmergencyAlertUpsertWithWhereUniqueWithoutSocietyInput = {
    where: EmergencyAlertWhereUniqueInput
    update: XOR<EmergencyAlertUpdateWithoutSocietyInput, EmergencyAlertUncheckedUpdateWithoutSocietyInput>
    create: XOR<EmergencyAlertCreateWithoutSocietyInput, EmergencyAlertUncheckedCreateWithoutSocietyInput>
  }

  export type EmergencyAlertUpdateWithWhereUniqueWithoutSocietyInput = {
    where: EmergencyAlertWhereUniqueInput
    data: XOR<EmergencyAlertUpdateWithoutSocietyInput, EmergencyAlertUncheckedUpdateWithoutSocietyInput>
  }

  export type EmergencyAlertUpdateManyWithWhereWithoutSocietyInput = {
    where: EmergencyAlertScalarWhereInput
    data: XOR<EmergencyAlertUpdateManyMutationInput, EmergencyAlertUncheckedUpdateManyWithoutSocietyInput>
  }

  export type EmergencyAlertScalarWhereInput = {
    AND?: EmergencyAlertScalarWhereInput | EmergencyAlertScalarWhereInput[]
    OR?: EmergencyAlertScalarWhereInput[]
    NOT?: EmergencyAlertScalarWhereInput | EmergencyAlertScalarWhereInput[]
    id?: IntFilter<"EmergencyAlert"> | number
    type?: StringFilter<"EmergencyAlert"> | string
    unit?: StringNullableFilter<"EmergencyAlert"> | string | null
    description?: StringNullableFilter<"EmergencyAlert"> | string | null
    status?: StringFilter<"EmergencyAlert"> | string
    resolution?: StringNullableFilter<"EmergencyAlert"> | string | null
    societyId?: IntFilter<"EmergencyAlert"> | number
    userId?: IntFilter<"EmergencyAlert"> | number
    createdAt?: DateTimeFilter<"EmergencyAlert"> | Date | string
    updatedAt?: DateTimeFilter<"EmergencyAlert"> | Date | string
  }

  export type EmergencyContactUpsertWithWhereUniqueWithoutSocietyInput = {
    where: EmergencyContactWhereUniqueInput
    update: XOR<EmergencyContactUpdateWithoutSocietyInput, EmergencyContactUncheckedUpdateWithoutSocietyInput>
    create: XOR<EmergencyContactCreateWithoutSocietyInput, EmergencyContactUncheckedCreateWithoutSocietyInput>
  }

  export type EmergencyContactUpdateWithWhereUniqueWithoutSocietyInput = {
    where: EmergencyContactWhereUniqueInput
    data: XOR<EmergencyContactUpdateWithoutSocietyInput, EmergencyContactUncheckedUpdateWithoutSocietyInput>
  }

  export type EmergencyContactUpdateManyWithWhereWithoutSocietyInput = {
    where: EmergencyContactScalarWhereInput
    data: XOR<EmergencyContactUpdateManyMutationInput, EmergencyContactUncheckedUpdateManyWithoutSocietyInput>
  }

  export type EmergencyContactScalarWhereInput = {
    AND?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
    OR?: EmergencyContactScalarWhereInput[]
    NOT?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
    id?: IntFilter<"EmergencyContact"> | number
    name?: StringFilter<"EmergencyContact"> | string
    phone?: StringFilter<"EmergencyContact"> | string
    category?: StringFilter<"EmergencyContact"> | string
    available?: BoolFilter<"EmergencyContact"> | boolean
    societyId?: IntNullableFilter<"EmergencyContact"> | number | null
    residentId?: IntNullableFilter<"EmergencyContact"> | number | null
    createdAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"EmergencyContact"> | Date | string
  }

  export type ServiceInquiryUpsertWithWhereUniqueWithoutSocietyInput = {
    where: ServiceInquiryWhereUniqueInput
    update: XOR<ServiceInquiryUpdateWithoutSocietyInput, ServiceInquiryUncheckedUpdateWithoutSocietyInput>
    create: XOR<ServiceInquiryCreateWithoutSocietyInput, ServiceInquiryUncheckedCreateWithoutSocietyInput>
  }

  export type ServiceInquiryUpdateWithWhereUniqueWithoutSocietyInput = {
    where: ServiceInquiryWhereUniqueInput
    data: XOR<ServiceInquiryUpdateWithoutSocietyInput, ServiceInquiryUncheckedUpdateWithoutSocietyInput>
  }

  export type ServiceInquiryUpdateManyWithWhereWithoutSocietyInput = {
    where: ServiceInquiryScalarWhereInput
    data: XOR<ServiceInquiryUpdateManyMutationInput, ServiceInquiryUncheckedUpdateManyWithoutSocietyInput>
  }

  export type ServiceInquiryScalarWhereInput = {
    AND?: ServiceInquiryScalarWhereInput | ServiceInquiryScalarWhereInput[]
    OR?: ServiceInquiryScalarWhereInput[]
    NOT?: ServiceInquiryScalarWhereInput | ServiceInquiryScalarWhereInput[]
    id?: IntFilter<"ServiceInquiry"> | number
    residentId?: IntNullableFilter<"ServiceInquiry"> | number | null
    societyId?: IntNullableFilter<"ServiceInquiry"> | number | null
    serviceId?: StringNullableFilter<"ServiceInquiry"> | string | null
    serviceName?: StringNullableFilter<"ServiceInquiry"> | string | null
    type?: StringFilter<"ServiceInquiry"> | string
    status?: StringFilter<"ServiceInquiry"> | string
    preferredDate?: StringNullableFilter<"ServiceInquiry"> | string | null
    preferredTime?: StringNullableFilter<"ServiceInquiry"> | string | null
    phone?: StringNullableFilter<"ServiceInquiry"> | string | null
    notes?: StringNullableFilter<"ServiceInquiry"> | string | null
    vendorName?: StringNullableFilter<"ServiceInquiry"> | string | null
    vendorId?: IntNullableFilter<"ServiceInquiry"> | number | null
    createdAt?: DateTimeFilter<"ServiceInquiry"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceInquiry"> | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutSocietyInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutSocietyInput, ConversationUncheckedUpdateWithoutSocietyInput>
    create: XOR<ConversationCreateWithoutSocietyInput, ConversationUncheckedCreateWithoutSocietyInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutSocietyInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutSocietyInput, ConversationUncheckedUpdateWithoutSocietyInput>
  }

  export type ConversationUpdateManyWithWhereWithoutSocietyInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutSocietyInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: IntFilter<"Conversation"> | number
    societyId?: IntFilter<"Conversation"> | number
    type?: StringFilter<"Conversation"> | string
    participantId?: IntNullableFilter<"Conversation"> | number | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type CommunityBuzzUpsertWithWhereUniqueWithoutSocietyInput = {
    where: CommunityBuzzWhereUniqueInput
    update: XOR<CommunityBuzzUpdateWithoutSocietyInput, CommunityBuzzUncheckedUpdateWithoutSocietyInput>
    create: XOR<CommunityBuzzCreateWithoutSocietyInput, CommunityBuzzUncheckedCreateWithoutSocietyInput>
  }

  export type CommunityBuzzUpdateWithWhereUniqueWithoutSocietyInput = {
    where: CommunityBuzzWhereUniqueInput
    data: XOR<CommunityBuzzUpdateWithoutSocietyInput, CommunityBuzzUncheckedUpdateWithoutSocietyInput>
  }

  export type CommunityBuzzUpdateManyWithWhereWithoutSocietyInput = {
    where: CommunityBuzzScalarWhereInput
    data: XOR<CommunityBuzzUpdateManyMutationInput, CommunityBuzzUncheckedUpdateManyWithoutSocietyInput>
  }

  export type CommunityBuzzScalarWhereInput = {
    AND?: CommunityBuzzScalarWhereInput | CommunityBuzzScalarWhereInput[]
    OR?: CommunityBuzzScalarWhereInput[]
    NOT?: CommunityBuzzScalarWhereInput | CommunityBuzzScalarWhereInput[]
    id?: IntFilter<"CommunityBuzz"> | number
    type?: StringFilter<"CommunityBuzz"> | string
    title?: StringFilter<"CommunityBuzz"> | string
    content?: StringNullableFilter<"CommunityBuzz"> | string | null
    authorId?: IntFilter<"CommunityBuzz"> | number
    societyId?: IntFilter<"CommunityBuzz"> | number
    hasResult?: BoolFilter<"CommunityBuzz"> | boolean
    imageUrls?: JsonNullableFilter<"CommunityBuzz">
    likes?: IntFilter<"CommunityBuzz"> | number
    createdAt?: DateTimeFilter<"CommunityBuzz"> | Date | string
  }

  export type MarketplaceItemUpsertWithWhereUniqueWithoutSocietyInput = {
    where: MarketplaceItemWhereUniqueInput
    update: XOR<MarketplaceItemUpdateWithoutSocietyInput, MarketplaceItemUncheckedUpdateWithoutSocietyInput>
    create: XOR<MarketplaceItemCreateWithoutSocietyInput, MarketplaceItemUncheckedCreateWithoutSocietyInput>
  }

  export type MarketplaceItemUpdateWithWhereUniqueWithoutSocietyInput = {
    where: MarketplaceItemWhereUniqueInput
    data: XOR<MarketplaceItemUpdateWithoutSocietyInput, MarketplaceItemUncheckedUpdateWithoutSocietyInput>
  }

  export type MarketplaceItemUpdateManyWithWhereWithoutSocietyInput = {
    where: MarketplaceItemScalarWhereInput
    data: XOR<MarketplaceItemUpdateManyMutationInput, MarketplaceItemUncheckedUpdateManyWithoutSocietyInput>
  }

  export type MarketplaceItemScalarWhereInput = {
    AND?: MarketplaceItemScalarWhereInput | MarketplaceItemScalarWhereInput[]
    OR?: MarketplaceItemScalarWhereInput[]
    NOT?: MarketplaceItemScalarWhereInput | MarketplaceItemScalarWhereInput[]
    id?: IntFilter<"MarketplaceItem"> | number
    title?: StringFilter<"MarketplaceItem"> | string
    description?: StringFilter<"MarketplaceItem"> | string
    price?: FloatNullableFilter<"MarketplaceItem"> | number | null
    originalPrice?: FloatNullableFilter<"MarketplaceItem"> | number | null
    condition?: StringNullableFilter<"MarketplaceItem"> | string | null
    type?: StringFilter<"MarketplaceItem"> | string
    priceType?: StringNullableFilter<"MarketplaceItem"> | string | null
    category?: StringNullableFilter<"MarketplaceItem"> | string | null
    status?: StringFilter<"MarketplaceItem"> | string
    images?: JsonNullableFilter<"MarketplaceItem">
    views?: IntFilter<"MarketplaceItem"> | number
    likes?: IntFilter<"MarketplaceItem"> | number
    ownerId?: IntFilter<"MarketplaceItem"> | number
    societyId?: IntFilter<"MarketplaceItem"> | number
    createdAt?: DateTimeFilter<"MarketplaceItem"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceItem"> | Date | string
  }

  export type CommunityGuidelineUpsertWithWhereUniqueWithoutSocietyInput = {
    where: CommunityGuidelineWhereUniqueInput
    update: XOR<CommunityGuidelineUpdateWithoutSocietyInput, CommunityGuidelineUncheckedUpdateWithoutSocietyInput>
    create: XOR<CommunityGuidelineCreateWithoutSocietyInput, CommunityGuidelineUncheckedCreateWithoutSocietyInput>
  }

  export type CommunityGuidelineUpdateWithWhereUniqueWithoutSocietyInput = {
    where: CommunityGuidelineWhereUniqueInput
    data: XOR<CommunityGuidelineUpdateWithoutSocietyInput, CommunityGuidelineUncheckedUpdateWithoutSocietyInput>
  }

  export type CommunityGuidelineUpdateManyWithWhereWithoutSocietyInput = {
    where: CommunityGuidelineScalarWhereInput
    data: XOR<CommunityGuidelineUpdateManyMutationInput, CommunityGuidelineUncheckedUpdateManyWithoutSocietyInput>
  }

  export type CommunityGuidelineScalarWhereInput = {
    AND?: CommunityGuidelineScalarWhereInput | CommunityGuidelineScalarWhereInput[]
    OR?: CommunityGuidelineScalarWhereInput[]
    NOT?: CommunityGuidelineScalarWhereInput | CommunityGuidelineScalarWhereInput[]
    id?: IntFilter<"CommunityGuideline"> | number
    societyId?: IntFilter<"CommunityGuideline"> | number
    title?: StringFilter<"CommunityGuideline"> | string
    content?: StringFilter<"CommunityGuideline"> | string
    category?: StringFilter<"CommunityGuideline"> | string
    createdAt?: DateTimeFilter<"CommunityGuideline"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityGuideline"> | Date | string
  }

  export type SOSAlertUpsertWithWhereUniqueWithoutSocietyInput = {
    where: SOSAlertWhereUniqueInput
    update: XOR<SOSAlertUpdateWithoutSocietyInput, SOSAlertUncheckedUpdateWithoutSocietyInput>
    create: XOR<SOSAlertCreateWithoutSocietyInput, SOSAlertUncheckedCreateWithoutSocietyInput>
  }

  export type SOSAlertUpdateWithWhereUniqueWithoutSocietyInput = {
    where: SOSAlertWhereUniqueInput
    data: XOR<SOSAlertUpdateWithoutSocietyInput, SOSAlertUncheckedUpdateWithoutSocietyInput>
  }

  export type SOSAlertUpdateManyWithWhereWithoutSocietyInput = {
    where: SOSAlertScalarWhereInput
    data: XOR<SOSAlertUpdateManyMutationInput, SOSAlertUncheckedUpdateManyWithoutSocietyInput>
  }

  export type SOSAlertScalarWhereInput = {
    AND?: SOSAlertScalarWhereInput | SOSAlertScalarWhereInput[]
    OR?: SOSAlertScalarWhereInput[]
    NOT?: SOSAlertScalarWhereInput | SOSAlertScalarWhereInput[]
    id?: IntFilter<"SOSAlert"> | number
    residentId?: IntFilter<"SOSAlert"> | number
    societyId?: IntFilter<"SOSAlert"> | number
    type?: StringFilter<"SOSAlert"> | string
    status?: StringFilter<"SOSAlert"> | string
    location?: StringNullableFilter<"SOSAlert"> | string | null
    createdAt?: DateTimeFilter<"SOSAlert"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"SOSAlert"> | Date | string | null
  }

  export type RoleModelCreateWithoutUsersInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleModelUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleModelCreateOrConnectWithoutUsersInput = {
    where: RoleModelWhereUniqueInput
    create: XOR<RoleModelCreateWithoutUsersInput, RoleModelUncheckedCreateWithoutUsersInput>
  }

  export type UserSessionCreateWithoutUserInput = {
    device?: string | null
    ipAddress?: string | null
    lastActive?: Date | string
    token: string
    createdAt?: Date | string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: number
    device?: string | null
    ipAddress?: string | null
    lastActive?: Date | string
    token: string
    createdAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SocietyCreateWithoutUsersInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutUsersInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutUsersInput, SocietyUncheckedCreateWithoutUsersInput>
  }

  export type UnitCreateWithoutOwnerInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
    parcels?: ParcelCreateNestedManyWithoutUnitInput
    members?: UnitMemberCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleCreateNestedManyWithoutUnitInput
    petsList?: UnitPetCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutOwnerInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    societyId: number
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutUnitInput
    members?: UnitMemberUncheckedCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleUncheckedCreateNestedManyWithoutUnitInput
    petsList?: UnitPetUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutOwnerInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput>
  }

  export type UnitCreateManyOwnerInputEnvelope = {
    data: UnitCreateManyOwnerInput | UnitCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type UnitCreateWithoutTenantInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
    parcels?: ParcelCreateNestedManyWithoutUnitInput
    members?: UnitMemberCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleCreateNestedManyWithoutUnitInput
    petsList?: UnitPetCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutTenantInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    societyId: number
    ownerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutUnitInput
    members?: UnitMemberUncheckedCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleUncheckedCreateNestedManyWithoutUnitInput
    petsList?: UnitPetUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutTenantInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput>
  }

  export type UnitCreateManyTenantInputEnvelope = {
    data: UnitCreateManyTenantInput | UnitCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCreateWithoutReportedByInput = {
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    isPrivate?: boolean
    escalatedToTech?: boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutComplaintsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedComplaintsInput
    comments?: ComplaintCommentCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintUncheckedCreateWithoutReportedByInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    isPrivate?: boolean
    escalatedToTech?: boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintCreateOrConnectWithoutReportedByInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput>
  }

  export type ComplaintCreateManyReportedByInputEnvelope = {
    data: ComplaintCreateManyReportedByInput | ComplaintCreateManyReportedByInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCreateWithoutAssignedToInput = {
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    isPrivate?: boolean
    escalatedToTech?: boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutComplaintsInput
    reportedBy: UserCreateNestedOneWithoutReportedComplaintsInput
    comments?: ComplaintCommentCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintUncheckedCreateWithoutAssignedToInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    isPrivate?: boolean
    escalatedToTech?: boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    reportedById: number
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintCreateOrConnectWithoutAssignedToInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput>
  }

  export type ComplaintCreateManyAssignedToInputEnvelope = {
    data: ComplaintCreateManyAssignedToInput | ComplaintCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type AmenityBookingCreateWithoutUserInput = {
    date: Date | string
    startTime: string
    endTime: string
    purpose?: string | null
    status?: string
    amountPaid?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    amenity: AmenityCreateNestedOneWithoutBookingsInput
  }

  export type AmenityBookingUncheckedCreateWithoutUserInput = {
    id?: number
    amenityId: number
    date: Date | string
    startTime: string
    endTime: string
    purpose?: string | null
    status?: string
    amountPaid?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenityBookingCreateOrConnectWithoutUserInput = {
    where: AmenityBookingWhereUniqueInput
    create: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput>
  }

  export type AmenityBookingCreateManyUserInputEnvelope = {
    data: AmenityBookingCreateManyUserInput | AmenityBookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCommentCreateWithoutUserInput = {
    message: string
    createdAt?: Date | string
    complaint: ComplaintCreateNestedOneWithoutCommentsInput
  }

  export type ComplaintCommentUncheckedCreateWithoutUserInput = {
    id?: number
    complaintId: number
    message: string
    createdAt?: Date | string
  }

  export type ComplaintCommentCreateOrConnectWithoutUserInput = {
    where: ComplaintCommentWhereUniqueInput
    create: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput>
  }

  export type ComplaintCommentCreateManyUserInputEnvelope = {
    data: ComplaintCommentCreateManyUserInput | ComplaintCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseRequestCreateWithoutRequestedByInput = {
    title: string
    description?: string | null
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutPurchaseRequestsInput
  }

  export type PurchaseRequestUncheckedCreateWithoutRequestedByInput = {
    id?: number
    title: string
    description?: string | null
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    societyId: number
  }

  export type PurchaseRequestCreateOrConnectWithoutRequestedByInput = {
    where: PurchaseRequestWhereUniqueInput
    create: XOR<PurchaseRequestCreateWithoutRequestedByInput, PurchaseRequestUncheckedCreateWithoutRequestedByInput>
  }

  export type PurchaseRequestCreateManyRequestedByInputEnvelope = {
    data: PurchaseRequestCreateManyRequestedByInput | PurchaseRequestCreateManyRequestedByInput[]
    skipDuplicates?: boolean
  }

  export type EmergencyAlertCreateWithoutUserInput = {
    type: string
    unit?: string | null
    description?: string | null
    status?: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutEmergencyAlertsInput
  }

  export type EmergencyAlertUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    unit?: string | null
    description?: string | null
    status?: string
    resolution?: string | null
    societyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyAlertCreateOrConnectWithoutUserInput = {
    where: EmergencyAlertWhereUniqueInput
    create: XOR<EmergencyAlertCreateWithoutUserInput, EmergencyAlertUncheckedCreateWithoutUserInput>
  }

  export type EmergencyAlertCreateManyUserInputEnvelope = {
    data: EmergencyAlertCreateManyUserInput | EmergencyAlertCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ServiceInquiryCreateWithoutResidentInput = {
    serviceName?: string | null
    type: string
    status?: string
    preferredDate?: string | null
    preferredTime?: string | null
    phone?: string | null
    notes?: string | null
    vendorName?: string | null
    vendorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutServiceInquiriesInput
    service?: ServiceCategoryCreateNestedOneWithoutInquiriesInput
  }

  export type ServiceInquiryUncheckedCreateWithoutResidentInput = {
    id?: number
    societyId?: number | null
    serviceId?: string | null
    serviceName?: string | null
    type: string
    status?: string
    preferredDate?: string | null
    preferredTime?: string | null
    phone?: string | null
    notes?: string | null
    vendorName?: string | null
    vendorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceInquiryCreateOrConnectWithoutResidentInput = {
    where: ServiceInquiryWhereUniqueInput
    create: XOR<ServiceInquiryCreateWithoutResidentInput, ServiceInquiryUncheckedCreateWithoutResidentInput>
  }

  export type ServiceInquiryCreateManyResidentInputEnvelope = {
    data: ServiceInquiryCreateManyResidentInput | ServiceInquiryCreateManyResidentInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutParticipantInput = {
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutConversationsInput
    messages?: ChatMessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutParticipantInput = {
    id?: number
    societyId: number
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutParticipantInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutParticipantInput, ConversationUncheckedCreateWithoutParticipantInput>
  }

  export type ConversationCreateManyParticipantInputEnvelope = {
    data: ConversationCreateManyParticipantInput | ConversationCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type ChatMessageCreateWithoutSenderInput = {
    content: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutSenderInput = {
    id?: number
    conversationId: number
    content: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageCreateManySenderInputEnvelope = {
    data: ChatMessageCreateManySenderInput | ChatMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type CommunityBuzzCreateWithoutAuthorInput = {
    type: string
    title: string
    content?: string | null
    hasResult?: boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    createdAt?: Date | string
    society: SocietyCreateNestedOneWithoutBuzzsInput
    comments?: CommunityCommentCreateNestedManyWithoutBuzzInput
    likedBy?: BuzzLikeCreateNestedManyWithoutBuzzInput
  }

  export type CommunityBuzzUncheckedCreateWithoutAuthorInput = {
    id?: number
    type: string
    title: string
    content?: string | null
    societyId: number
    hasResult?: boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    createdAt?: Date | string
    comments?: CommunityCommentUncheckedCreateNestedManyWithoutBuzzInput
    likedBy?: BuzzLikeUncheckedCreateNestedManyWithoutBuzzInput
  }

  export type CommunityBuzzCreateOrConnectWithoutAuthorInput = {
    where: CommunityBuzzWhereUniqueInput
    create: XOR<CommunityBuzzCreateWithoutAuthorInput, CommunityBuzzUncheckedCreateWithoutAuthorInput>
  }

  export type CommunityBuzzCreateManyAuthorInputEnvelope = {
    data: CommunityBuzzCreateManyAuthorInput | CommunityBuzzCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommunityCommentCreateWithoutAuthorInput = {
    content: string
    createdAt?: Date | string
    buzz: CommunityBuzzCreateNestedOneWithoutCommentsInput
  }

  export type CommunityCommentUncheckedCreateWithoutAuthorInput = {
    id?: number
    buzzId: number
    content: string
    createdAt?: Date | string
  }

  export type CommunityCommentCreateOrConnectWithoutAuthorInput = {
    where: CommunityCommentWhereUniqueInput
    create: XOR<CommunityCommentCreateWithoutAuthorInput, CommunityCommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommunityCommentCreateManyAuthorInputEnvelope = {
    data: CommunityCommentCreateManyAuthorInput | CommunityCommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type SOSAlertCreateWithoutResidentInput = {
    type: string
    status?: string
    location?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
    society: SocietyCreateNestedOneWithoutSosAlertsInput
  }

  export type SOSAlertUncheckedCreateWithoutResidentInput = {
    id?: number
    societyId: number
    type: string
    status?: string
    location?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SOSAlertCreateOrConnectWithoutResidentInput = {
    where: SOSAlertWhereUniqueInput
    create: XOR<SOSAlertCreateWithoutResidentInput, SOSAlertUncheckedCreateWithoutResidentInput>
  }

  export type SOSAlertCreateManyResidentInputEnvelope = {
    data: SOSAlertCreateManyResidentInput | SOSAlertCreateManyResidentInput[]
    skipDuplicates?: boolean
  }

  export type EmergencyContactCreateWithoutResidentInput = {
    name: string
    phone: string
    category?: string
    available?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutEmergencyContactsInput
  }

  export type EmergencyContactUncheckedCreateWithoutResidentInput = {
    id?: number
    name: string
    phone: string
    category?: string
    available?: boolean
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyContactCreateOrConnectWithoutResidentInput = {
    where: EmergencyContactWhereUniqueInput
    create: XOR<EmergencyContactCreateWithoutResidentInput, EmergencyContactUncheckedCreateWithoutResidentInput>
  }

  export type EmergencyContactCreateManyResidentInputEnvelope = {
    data: EmergencyContactCreateManyResidentInput | EmergencyContactCreateManyResidentInput[]
    skipDuplicates?: boolean
  }

  export type MarketplaceItemCreateWithoutOwnerInput = {
    title: string
    description: string
    price?: number | null
    originalPrice?: number | null
    condition?: string | null
    type?: string
    priceType?: string | null
    category?: string | null
    status?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: number
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutMarketplaceItemsInput
  }

  export type MarketplaceItemUncheckedCreateWithoutOwnerInput = {
    id?: number
    title: string
    description: string
    price?: number | null
    originalPrice?: number | null
    condition?: string | null
    type?: string
    priceType?: string | null
    category?: string | null
    status?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: number
    likes?: number
    societyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceItemCreateOrConnectWithoutOwnerInput = {
    where: MarketplaceItemWhereUniqueInput
    create: XOR<MarketplaceItemCreateWithoutOwnerInput, MarketplaceItemUncheckedCreateWithoutOwnerInput>
  }

  export type MarketplaceItemCreateManyOwnerInputEnvelope = {
    data: MarketplaceItemCreateManyOwnerInput | MarketplaceItemCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type BuzzLikeCreateWithoutUserInput = {
    createdAt?: Date | string
    buzz: CommunityBuzzCreateNestedOneWithoutLikedByInput
  }

  export type BuzzLikeUncheckedCreateWithoutUserInput = {
    id?: number
    buzzId: number
    createdAt?: Date | string
  }

  export type BuzzLikeCreateOrConnectWithoutUserInput = {
    where: BuzzLikeWhereUniqueInput
    create: XOR<BuzzLikeCreateWithoutUserInput, BuzzLikeUncheckedCreateWithoutUserInput>
  }

  export type BuzzLikeCreateManyUserInputEnvelope = {
    data: BuzzLikeCreateManyUserInput | BuzzLikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleModelUpsertWithoutUsersInput = {
    update: XOR<RoleModelUpdateWithoutUsersInput, RoleModelUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleModelCreateWithoutUsersInput, RoleModelUncheckedCreateWithoutUsersInput>
    where?: RoleModelWhereInput
  }

  export type RoleModelUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleModelWhereInput
    data: XOR<RoleModelUpdateWithoutUsersInput, RoleModelUncheckedUpdateWithoutUsersInput>
  }

  export type RoleModelUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleModelUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: IntFilter<"UserSession"> | number
    userId?: IntFilter<"UserSession"> | number
    device?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    lastActive?: DateTimeFilter<"UserSession"> | Date | string
    token?: StringFilter<"UserSession"> | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type SocietyUpsertWithoutUsersInput = {
    update: XOR<SocietyUpdateWithoutUsersInput, SocietyUncheckedUpdateWithoutUsersInput>
    create: XOR<SocietyCreateWithoutUsersInput, SocietyUncheckedCreateWithoutUsersInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutUsersInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutUsersInput, SocietyUncheckedUpdateWithoutUsersInput>
  }

  export type SocietyUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UnitUpsertWithWhereUniqueWithoutOwnerInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutOwnerInput, UnitUncheckedUpdateWithoutOwnerInput>
    create: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutOwnerInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutOwnerInput, UnitUncheckedUpdateWithoutOwnerInput>
  }

  export type UnitUpdateManyWithWhereWithoutOwnerInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutOwnerInput>
  }

  export type UnitUpsertWithWhereUniqueWithoutTenantInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutTenantInput, UnitUncheckedUpdateWithoutTenantInput>
    create: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutTenantInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutTenantInput, UnitUncheckedUpdateWithoutTenantInput>
  }

  export type UnitUpdateManyWithWhereWithoutTenantInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutTenantInput>
  }

  export type ComplaintUpsertWithWhereUniqueWithoutReportedByInput = {
    where: ComplaintWhereUniqueInput
    update: XOR<ComplaintUpdateWithoutReportedByInput, ComplaintUncheckedUpdateWithoutReportedByInput>
    create: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput>
  }

  export type ComplaintUpdateWithWhereUniqueWithoutReportedByInput = {
    where: ComplaintWhereUniqueInput
    data: XOR<ComplaintUpdateWithoutReportedByInput, ComplaintUncheckedUpdateWithoutReportedByInput>
  }

  export type ComplaintUpdateManyWithWhereWithoutReportedByInput = {
    where: ComplaintScalarWhereInput
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyWithoutReportedByInput>
  }

  export type ComplaintUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: ComplaintWhereUniqueInput
    update: XOR<ComplaintUpdateWithoutAssignedToInput, ComplaintUncheckedUpdateWithoutAssignedToInput>
    create: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput>
  }

  export type ComplaintUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: ComplaintWhereUniqueInput
    data: XOR<ComplaintUpdateWithoutAssignedToInput, ComplaintUncheckedUpdateWithoutAssignedToInput>
  }

  export type ComplaintUpdateManyWithWhereWithoutAssignedToInput = {
    where: ComplaintScalarWhereInput
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type AmenityBookingUpsertWithWhereUniqueWithoutUserInput = {
    where: AmenityBookingWhereUniqueInput
    update: XOR<AmenityBookingUpdateWithoutUserInput, AmenityBookingUncheckedUpdateWithoutUserInput>
    create: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput>
  }

  export type AmenityBookingUpdateWithWhereUniqueWithoutUserInput = {
    where: AmenityBookingWhereUniqueInput
    data: XOR<AmenityBookingUpdateWithoutUserInput, AmenityBookingUncheckedUpdateWithoutUserInput>
  }

  export type AmenityBookingUpdateManyWithWhereWithoutUserInput = {
    where: AmenityBookingScalarWhereInput
    data: XOR<AmenityBookingUpdateManyMutationInput, AmenityBookingUncheckedUpdateManyWithoutUserInput>
  }

  export type AmenityBookingScalarWhereInput = {
    AND?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
    OR?: AmenityBookingScalarWhereInput[]
    NOT?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
    id?: IntFilter<"AmenityBooking"> | number
    amenityId?: IntFilter<"AmenityBooking"> | number
    userId?: IntFilter<"AmenityBooking"> | number
    date?: DateTimeFilter<"AmenityBooking"> | Date | string
    startTime?: StringFilter<"AmenityBooking"> | string
    endTime?: StringFilter<"AmenityBooking"> | string
    purpose?: StringNullableFilter<"AmenityBooking"> | string | null
    status?: StringFilter<"AmenityBooking"> | string
    amountPaid?: FloatFilter<"AmenityBooking"> | number
    createdAt?: DateTimeFilter<"AmenityBooking"> | Date | string
    updatedAt?: DateTimeFilter<"AmenityBooking"> | Date | string
  }

  export type ComplaintCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: ComplaintCommentWhereUniqueInput
    update: XOR<ComplaintCommentUpdateWithoutUserInput, ComplaintCommentUncheckedUpdateWithoutUserInput>
    create: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput>
  }

  export type ComplaintCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: ComplaintCommentWhereUniqueInput
    data: XOR<ComplaintCommentUpdateWithoutUserInput, ComplaintCommentUncheckedUpdateWithoutUserInput>
  }

  export type ComplaintCommentUpdateManyWithWhereWithoutUserInput = {
    where: ComplaintCommentScalarWhereInput
    data: XOR<ComplaintCommentUpdateManyMutationInput, ComplaintCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type ComplaintCommentScalarWhereInput = {
    AND?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
    OR?: ComplaintCommentScalarWhereInput[]
    NOT?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
    id?: IntFilter<"ComplaintComment"> | number
    complaintId?: IntFilter<"ComplaintComment"> | number
    userId?: IntFilter<"ComplaintComment"> | number
    message?: StringFilter<"ComplaintComment"> | string
    createdAt?: DateTimeFilter<"ComplaintComment"> | Date | string
  }

  export type PurchaseRequestUpsertWithWhereUniqueWithoutRequestedByInput = {
    where: PurchaseRequestWhereUniqueInput
    update: XOR<PurchaseRequestUpdateWithoutRequestedByInput, PurchaseRequestUncheckedUpdateWithoutRequestedByInput>
    create: XOR<PurchaseRequestCreateWithoutRequestedByInput, PurchaseRequestUncheckedCreateWithoutRequestedByInput>
  }

  export type PurchaseRequestUpdateWithWhereUniqueWithoutRequestedByInput = {
    where: PurchaseRequestWhereUniqueInput
    data: XOR<PurchaseRequestUpdateWithoutRequestedByInput, PurchaseRequestUncheckedUpdateWithoutRequestedByInput>
  }

  export type PurchaseRequestUpdateManyWithWhereWithoutRequestedByInput = {
    where: PurchaseRequestScalarWhereInput
    data: XOR<PurchaseRequestUpdateManyMutationInput, PurchaseRequestUncheckedUpdateManyWithoutRequestedByInput>
  }

  export type EmergencyAlertUpsertWithWhereUniqueWithoutUserInput = {
    where: EmergencyAlertWhereUniqueInput
    update: XOR<EmergencyAlertUpdateWithoutUserInput, EmergencyAlertUncheckedUpdateWithoutUserInput>
    create: XOR<EmergencyAlertCreateWithoutUserInput, EmergencyAlertUncheckedCreateWithoutUserInput>
  }

  export type EmergencyAlertUpdateWithWhereUniqueWithoutUserInput = {
    where: EmergencyAlertWhereUniqueInput
    data: XOR<EmergencyAlertUpdateWithoutUserInput, EmergencyAlertUncheckedUpdateWithoutUserInput>
  }

  export type EmergencyAlertUpdateManyWithWhereWithoutUserInput = {
    where: EmergencyAlertScalarWhereInput
    data: XOR<EmergencyAlertUpdateManyMutationInput, EmergencyAlertUncheckedUpdateManyWithoutUserInput>
  }

  export type ServiceInquiryUpsertWithWhereUniqueWithoutResidentInput = {
    where: ServiceInquiryWhereUniqueInput
    update: XOR<ServiceInquiryUpdateWithoutResidentInput, ServiceInquiryUncheckedUpdateWithoutResidentInput>
    create: XOR<ServiceInquiryCreateWithoutResidentInput, ServiceInquiryUncheckedCreateWithoutResidentInput>
  }

  export type ServiceInquiryUpdateWithWhereUniqueWithoutResidentInput = {
    where: ServiceInquiryWhereUniqueInput
    data: XOR<ServiceInquiryUpdateWithoutResidentInput, ServiceInquiryUncheckedUpdateWithoutResidentInput>
  }

  export type ServiceInquiryUpdateManyWithWhereWithoutResidentInput = {
    where: ServiceInquiryScalarWhereInput
    data: XOR<ServiceInquiryUpdateManyMutationInput, ServiceInquiryUncheckedUpdateManyWithoutResidentInput>
  }

  export type ConversationUpsertWithWhereUniqueWithoutParticipantInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutParticipantInput, ConversationUncheckedUpdateWithoutParticipantInput>
    create: XOR<ConversationCreateWithoutParticipantInput, ConversationUncheckedCreateWithoutParticipantInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutParticipantInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutParticipantInput, ConversationUncheckedUpdateWithoutParticipantInput>
  }

  export type ConversationUpdateManyWithWhereWithoutParticipantInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutParticipantInput>
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutSenderInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: IntFilter<"ChatMessage"> | number
    conversationId?: IntFilter<"ChatMessage"> | number
    senderId?: IntFilter<"ChatMessage"> | number
    content?: StringFilter<"ChatMessage"> | string
    attachments?: JsonNullableFilter<"ChatMessage">
    status?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type CommunityBuzzUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommunityBuzzWhereUniqueInput
    update: XOR<CommunityBuzzUpdateWithoutAuthorInput, CommunityBuzzUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommunityBuzzCreateWithoutAuthorInput, CommunityBuzzUncheckedCreateWithoutAuthorInput>
  }

  export type CommunityBuzzUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommunityBuzzWhereUniqueInput
    data: XOR<CommunityBuzzUpdateWithoutAuthorInput, CommunityBuzzUncheckedUpdateWithoutAuthorInput>
  }

  export type CommunityBuzzUpdateManyWithWhereWithoutAuthorInput = {
    where: CommunityBuzzScalarWhereInput
    data: XOR<CommunityBuzzUpdateManyMutationInput, CommunityBuzzUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommunityCommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommunityCommentWhereUniqueInput
    update: XOR<CommunityCommentUpdateWithoutAuthorInput, CommunityCommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommunityCommentCreateWithoutAuthorInput, CommunityCommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommunityCommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommunityCommentWhereUniqueInput
    data: XOR<CommunityCommentUpdateWithoutAuthorInput, CommunityCommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommunityCommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommunityCommentScalarWhereInput
    data: XOR<CommunityCommentUpdateManyMutationInput, CommunityCommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommunityCommentScalarWhereInput = {
    AND?: CommunityCommentScalarWhereInput | CommunityCommentScalarWhereInput[]
    OR?: CommunityCommentScalarWhereInput[]
    NOT?: CommunityCommentScalarWhereInput | CommunityCommentScalarWhereInput[]
    id?: IntFilter<"CommunityComment"> | number
    buzzId?: IntFilter<"CommunityComment"> | number
    authorId?: IntFilter<"CommunityComment"> | number
    content?: StringFilter<"CommunityComment"> | string
    createdAt?: DateTimeFilter<"CommunityComment"> | Date | string
  }

  export type SOSAlertUpsertWithWhereUniqueWithoutResidentInput = {
    where: SOSAlertWhereUniqueInput
    update: XOR<SOSAlertUpdateWithoutResidentInput, SOSAlertUncheckedUpdateWithoutResidentInput>
    create: XOR<SOSAlertCreateWithoutResidentInput, SOSAlertUncheckedCreateWithoutResidentInput>
  }

  export type SOSAlertUpdateWithWhereUniqueWithoutResidentInput = {
    where: SOSAlertWhereUniqueInput
    data: XOR<SOSAlertUpdateWithoutResidentInput, SOSAlertUncheckedUpdateWithoutResidentInput>
  }

  export type SOSAlertUpdateManyWithWhereWithoutResidentInput = {
    where: SOSAlertScalarWhereInput
    data: XOR<SOSAlertUpdateManyMutationInput, SOSAlertUncheckedUpdateManyWithoutResidentInput>
  }

  export type EmergencyContactUpsertWithWhereUniqueWithoutResidentInput = {
    where: EmergencyContactWhereUniqueInput
    update: XOR<EmergencyContactUpdateWithoutResidentInput, EmergencyContactUncheckedUpdateWithoutResidentInput>
    create: XOR<EmergencyContactCreateWithoutResidentInput, EmergencyContactUncheckedCreateWithoutResidentInput>
  }

  export type EmergencyContactUpdateWithWhereUniqueWithoutResidentInput = {
    where: EmergencyContactWhereUniqueInput
    data: XOR<EmergencyContactUpdateWithoutResidentInput, EmergencyContactUncheckedUpdateWithoutResidentInput>
  }

  export type EmergencyContactUpdateManyWithWhereWithoutResidentInput = {
    where: EmergencyContactScalarWhereInput
    data: XOR<EmergencyContactUpdateManyMutationInput, EmergencyContactUncheckedUpdateManyWithoutResidentInput>
  }

  export type MarketplaceItemUpsertWithWhereUniqueWithoutOwnerInput = {
    where: MarketplaceItemWhereUniqueInput
    update: XOR<MarketplaceItemUpdateWithoutOwnerInput, MarketplaceItemUncheckedUpdateWithoutOwnerInput>
    create: XOR<MarketplaceItemCreateWithoutOwnerInput, MarketplaceItemUncheckedCreateWithoutOwnerInput>
  }

  export type MarketplaceItemUpdateWithWhereUniqueWithoutOwnerInput = {
    where: MarketplaceItemWhereUniqueInput
    data: XOR<MarketplaceItemUpdateWithoutOwnerInput, MarketplaceItemUncheckedUpdateWithoutOwnerInput>
  }

  export type MarketplaceItemUpdateManyWithWhereWithoutOwnerInput = {
    where: MarketplaceItemScalarWhereInput
    data: XOR<MarketplaceItemUpdateManyMutationInput, MarketplaceItemUncheckedUpdateManyWithoutOwnerInput>
  }

  export type BuzzLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: BuzzLikeWhereUniqueInput
    update: XOR<BuzzLikeUpdateWithoutUserInput, BuzzLikeUncheckedUpdateWithoutUserInput>
    create: XOR<BuzzLikeCreateWithoutUserInput, BuzzLikeUncheckedCreateWithoutUserInput>
  }

  export type BuzzLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: BuzzLikeWhereUniqueInput
    data: XOR<BuzzLikeUpdateWithoutUserInput, BuzzLikeUncheckedUpdateWithoutUserInput>
  }

  export type BuzzLikeUpdateManyWithWhereWithoutUserInput = {
    where: BuzzLikeScalarWhereInput
    data: XOR<BuzzLikeUpdateManyMutationInput, BuzzLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type BuzzLikeScalarWhereInput = {
    AND?: BuzzLikeScalarWhereInput | BuzzLikeScalarWhereInput[]
    OR?: BuzzLikeScalarWhereInput[]
    NOT?: BuzzLikeScalarWhereInput | BuzzLikeScalarWhereInput[]
    id?: IntFilter<"BuzzLike"> | number
    buzzId?: IntFilter<"BuzzLike"> | number
    userId?: IntFilter<"BuzzLike"> | number
    createdAt?: DateTimeFilter<"BuzzLike"> | Date | string
  }

  export type RolePermissionCreateWithoutRoleInput = {
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    permissionId: string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRoleModelInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleModelInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleModelInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleModelInput, UserUncheckedCreateWithoutRoleModelInput>
  }

  export type UserCreateManyRoleModelInputEnvelope = {
    data: UserCreateManyRoleModelInput | UserCreateManyRoleModelInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: StringFilter<"RolePermission"> | string
  }

  export type UserUpsertWithWhereUniqueWithoutRoleModelInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleModelInput, UserUncheckedUpdateWithoutRoleModelInput>
    create: XOR<UserCreateWithoutRoleModelInput, UserUncheckedCreateWithoutRoleModelInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleModelInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleModelInput, UserUncheckedUpdateWithoutRoleModelInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleModelInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleModelInput>
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    role: RoleModelCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    roleId: number
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RoleModelCreateWithoutPermissionsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleModelInput
  }

  export type RoleModelUncheckedCreateWithoutPermissionsInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleModelInput
  }

  export type RoleModelCreateOrConnectWithoutPermissionsInput = {
    where: RoleModelWhereUniqueInput
    create: XOR<RoleModelCreateWithoutPermissionsInput, RoleModelUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionCreateWithoutRolesInput = {
    id: string
    label: string
    description?: string | null
  }

  export type PermissionUncheckedCreateWithoutRolesInput = {
    id: string
    label: string
    description?: string | null
  }

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type RoleModelUpsertWithoutPermissionsInput = {
    update: XOR<RoleModelUpdateWithoutPermissionsInput, RoleModelUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleModelCreateWithoutPermissionsInput, RoleModelUncheckedCreateWithoutPermissionsInput>
    where?: RoleModelWhereInput
  }

  export type RoleModelUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleModelWhereInput
    data: XOR<RoleModelUpdateWithoutPermissionsInput, RoleModelUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleModelUpdateWithoutPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleModelNestedInput
  }

  export type RoleModelUncheckedUpdateWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleModelNestedInput
  }

  export type PermissionUpsertWithoutRolesInput = {
    update: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolesInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type PermissionUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutSessionsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SocietyCreateWithoutUnitsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutUnitsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutUnitsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutUnitsInput, SocietyUncheckedCreateWithoutUnitsInput>
  }

  export type UserCreateWithoutOwnedUnitsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedUnitsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedUnitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedUnitsInput, UserUncheckedCreateWithoutOwnedUnitsInput>
  }

  export type UserCreateWithoutRentedUnitsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRentedUnitsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRentedUnitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRentedUnitsInput, UserUncheckedCreateWithoutRentedUnitsInput>
  }

  export type VisitorCreateWithoutUnitInput = {
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateWithoutUnitInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    societyId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorCreateOrConnectWithoutUnitInput = {
    where: VisitorWhereUniqueInput
    create: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput>
  }

  export type VisitorCreateManyUnitInputEnvelope = {
    data: VisitorCreateManyUnitInput | VisitorCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ParkingSlotCreateWithoutUnitInput = {
    number: string
    type: string
    status: string
    vehicleNumber?: string | null
    createdAt?: Date | string
    society: SocietyCreateNestedOneWithoutParkingSlotsInput
  }

  export type ParkingSlotUncheckedCreateWithoutUnitInput = {
    id?: number
    number: string
    type: string
    status: string
    societyId: number
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type ParkingSlotCreateOrConnectWithoutUnitInput = {
    where: ParkingSlotWhereUniqueInput
    create: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput>
  }

  export type ParkingSlotCreateManyUnitInputEnvelope = {
    data: ParkingSlotCreateManyUnitInput | ParkingSlotCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ParcelCreateWithoutUnitInput = {
    courierName: string
    trackingNumber?: string | null
    description?: string | null
    receivedBy?: string | null
    status?: string
    collectedBy?: string | null
    collectedAt?: Date | string | null
    createdAt?: Date | string
    society: SocietyCreateNestedOneWithoutParcelsInput
  }

  export type ParcelUncheckedCreateWithoutUnitInput = {
    id?: number
    courierName: string
    trackingNumber?: string | null
    description?: string | null
    receivedBy?: string | null
    status?: string
    collectedBy?: string | null
    collectedAt?: Date | string | null
    societyId: number
    createdAt?: Date | string
  }

  export type ParcelCreateOrConnectWithoutUnitInput = {
    where: ParcelWhereUniqueInput
    create: XOR<ParcelCreateWithoutUnitInput, ParcelUncheckedCreateWithoutUnitInput>
  }

  export type ParcelCreateManyUnitInputEnvelope = {
    data: ParcelCreateManyUnitInput | ParcelCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type UnitMemberCreateWithoutUnitInput = {
    name: string
    relation: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    email?: string | null
    profileImg?: string | null
    createdAt?: Date | string
  }

  export type UnitMemberUncheckedCreateWithoutUnitInput = {
    id?: number
    name: string
    relation: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    email?: string | null
    profileImg?: string | null
    createdAt?: Date | string
  }

  export type UnitMemberCreateOrConnectWithoutUnitInput = {
    where: UnitMemberWhereUniqueInput
    create: XOR<UnitMemberCreateWithoutUnitInput, UnitMemberUncheckedCreateWithoutUnitInput>
  }

  export type UnitMemberCreateManyUnitInputEnvelope = {
    data: UnitMemberCreateManyUnitInput | UnitMemberCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type UnitVehicleCreateWithoutUnitInput = {
    name: string
    number: string
    type: string
    color?: string | null
    parkingSlot?: string | null
    createdAt?: Date | string
  }

  export type UnitVehicleUncheckedCreateWithoutUnitInput = {
    id?: number
    name: string
    number: string
    type: string
    color?: string | null
    parkingSlot?: string | null
    createdAt?: Date | string
  }

  export type UnitVehicleCreateOrConnectWithoutUnitInput = {
    where: UnitVehicleWhereUniqueInput
    create: XOR<UnitVehicleCreateWithoutUnitInput, UnitVehicleUncheckedCreateWithoutUnitInput>
  }

  export type UnitVehicleCreateManyUnitInputEnvelope = {
    data: UnitVehicleCreateManyUnitInput | UnitVehicleCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type UnitPetCreateWithoutUnitInput = {
    name: string
    type: string
    breed?: string | null
    vaccinationStatus?: string
    lastVaccinationDate?: Date | string | null
    createdAt?: Date | string
  }

  export type UnitPetUncheckedCreateWithoutUnitInput = {
    id?: number
    name: string
    type: string
    breed?: string | null
    vaccinationStatus?: string
    lastVaccinationDate?: Date | string | null
    createdAt?: Date | string
  }

  export type UnitPetCreateOrConnectWithoutUnitInput = {
    where: UnitPetWhereUniqueInput
    create: XOR<UnitPetCreateWithoutUnitInput, UnitPetUncheckedCreateWithoutUnitInput>
  }

  export type UnitPetCreateManyUnitInputEnvelope = {
    data: UnitPetCreateManyUnitInput | UnitPetCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type SocietyUpsertWithoutUnitsInput = {
    update: XOR<SocietyUpdateWithoutUnitsInput, SocietyUncheckedUpdateWithoutUnitsInput>
    create: XOR<SocietyCreateWithoutUnitsInput, SocietyUncheckedCreateWithoutUnitsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutUnitsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutUnitsInput, SocietyUncheckedUpdateWithoutUnitsInput>
  }

  export type SocietyUpdateWithoutUnitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UserUpsertWithoutOwnedUnitsInput = {
    update: XOR<UserUpdateWithoutOwnedUnitsInput, UserUncheckedUpdateWithoutOwnedUnitsInput>
    create: XOR<UserCreateWithoutOwnedUnitsInput, UserUncheckedCreateWithoutOwnedUnitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedUnitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedUnitsInput, UserUncheckedUpdateWithoutOwnedUnitsInput>
  }

  export type UserUpdateWithoutOwnedUnitsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutRentedUnitsInput = {
    update: XOR<UserUpdateWithoutRentedUnitsInput, UserUncheckedUpdateWithoutRentedUnitsInput>
    create: XOR<UserCreateWithoutRentedUnitsInput, UserUncheckedCreateWithoutRentedUnitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRentedUnitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRentedUnitsInput, UserUncheckedUpdateWithoutRentedUnitsInput>
  }

  export type UserUpdateWithoutRentedUnitsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRentedUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VisitorUpsertWithWhereUniqueWithoutUnitInput = {
    where: VisitorWhereUniqueInput
    update: XOR<VisitorUpdateWithoutUnitInput, VisitorUncheckedUpdateWithoutUnitInput>
    create: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput>
  }

  export type VisitorUpdateWithWhereUniqueWithoutUnitInput = {
    where: VisitorWhereUniqueInput
    data: XOR<VisitorUpdateWithoutUnitInput, VisitorUncheckedUpdateWithoutUnitInput>
  }

  export type VisitorUpdateManyWithWhereWithoutUnitInput = {
    where: VisitorScalarWhereInput
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyWithoutUnitInput>
  }

  export type ParkingSlotUpsertWithWhereUniqueWithoutUnitInput = {
    where: ParkingSlotWhereUniqueInput
    update: XOR<ParkingSlotUpdateWithoutUnitInput, ParkingSlotUncheckedUpdateWithoutUnitInput>
    create: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput>
  }

  export type ParkingSlotUpdateWithWhereUniqueWithoutUnitInput = {
    where: ParkingSlotWhereUniqueInput
    data: XOR<ParkingSlotUpdateWithoutUnitInput, ParkingSlotUncheckedUpdateWithoutUnitInput>
  }

  export type ParkingSlotUpdateManyWithWhereWithoutUnitInput = {
    where: ParkingSlotScalarWhereInput
    data: XOR<ParkingSlotUpdateManyMutationInput, ParkingSlotUncheckedUpdateManyWithoutUnitInput>
  }

  export type ParcelUpsertWithWhereUniqueWithoutUnitInput = {
    where: ParcelWhereUniqueInput
    update: XOR<ParcelUpdateWithoutUnitInput, ParcelUncheckedUpdateWithoutUnitInput>
    create: XOR<ParcelCreateWithoutUnitInput, ParcelUncheckedCreateWithoutUnitInput>
  }

  export type ParcelUpdateWithWhereUniqueWithoutUnitInput = {
    where: ParcelWhereUniqueInput
    data: XOR<ParcelUpdateWithoutUnitInput, ParcelUncheckedUpdateWithoutUnitInput>
  }

  export type ParcelUpdateManyWithWhereWithoutUnitInput = {
    where: ParcelScalarWhereInput
    data: XOR<ParcelUpdateManyMutationInput, ParcelUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitMemberUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitMemberWhereUniqueInput
    update: XOR<UnitMemberUpdateWithoutUnitInput, UnitMemberUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitMemberCreateWithoutUnitInput, UnitMemberUncheckedCreateWithoutUnitInput>
  }

  export type UnitMemberUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitMemberWhereUniqueInput
    data: XOR<UnitMemberUpdateWithoutUnitInput, UnitMemberUncheckedUpdateWithoutUnitInput>
  }

  export type UnitMemberUpdateManyWithWhereWithoutUnitInput = {
    where: UnitMemberScalarWhereInput
    data: XOR<UnitMemberUpdateManyMutationInput, UnitMemberUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitMemberScalarWhereInput = {
    AND?: UnitMemberScalarWhereInput | UnitMemberScalarWhereInput[]
    OR?: UnitMemberScalarWhereInput[]
    NOT?: UnitMemberScalarWhereInput | UnitMemberScalarWhereInput[]
    id?: IntFilter<"UnitMember"> | number
    unitId?: IntFilter<"UnitMember"> | number
    name?: StringFilter<"UnitMember"> | string
    relation?: StringFilter<"UnitMember"> | string
    age?: IntNullableFilter<"UnitMember"> | number | null
    gender?: StringNullableFilter<"UnitMember"> | string | null
    phone?: StringNullableFilter<"UnitMember"> | string | null
    email?: StringNullableFilter<"UnitMember"> | string | null
    profileImg?: StringNullableFilter<"UnitMember"> | string | null
    createdAt?: DateTimeFilter<"UnitMember"> | Date | string
  }

  export type UnitVehicleUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitVehicleWhereUniqueInput
    update: XOR<UnitVehicleUpdateWithoutUnitInput, UnitVehicleUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitVehicleCreateWithoutUnitInput, UnitVehicleUncheckedCreateWithoutUnitInput>
  }

  export type UnitVehicleUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitVehicleWhereUniqueInput
    data: XOR<UnitVehicleUpdateWithoutUnitInput, UnitVehicleUncheckedUpdateWithoutUnitInput>
  }

  export type UnitVehicleUpdateManyWithWhereWithoutUnitInput = {
    where: UnitVehicleScalarWhereInput
    data: XOR<UnitVehicleUpdateManyMutationInput, UnitVehicleUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitVehicleScalarWhereInput = {
    AND?: UnitVehicleScalarWhereInput | UnitVehicleScalarWhereInput[]
    OR?: UnitVehicleScalarWhereInput[]
    NOT?: UnitVehicleScalarWhereInput | UnitVehicleScalarWhereInput[]
    id?: IntFilter<"UnitVehicle"> | number
    unitId?: IntFilter<"UnitVehicle"> | number
    name?: StringFilter<"UnitVehicle"> | string
    number?: StringFilter<"UnitVehicle"> | string
    type?: StringFilter<"UnitVehicle"> | string
    color?: StringNullableFilter<"UnitVehicle"> | string | null
    parkingSlot?: StringNullableFilter<"UnitVehicle"> | string | null
    createdAt?: DateTimeFilter<"UnitVehicle"> | Date | string
  }

  export type UnitPetUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitPetWhereUniqueInput
    update: XOR<UnitPetUpdateWithoutUnitInput, UnitPetUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitPetCreateWithoutUnitInput, UnitPetUncheckedCreateWithoutUnitInput>
  }

  export type UnitPetUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitPetWhereUniqueInput
    data: XOR<UnitPetUpdateWithoutUnitInput, UnitPetUncheckedUpdateWithoutUnitInput>
  }

  export type UnitPetUpdateManyWithWhereWithoutUnitInput = {
    where: UnitPetScalarWhereInput
    data: XOR<UnitPetUpdateManyMutationInput, UnitPetUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitPetScalarWhereInput = {
    AND?: UnitPetScalarWhereInput | UnitPetScalarWhereInput[]
    OR?: UnitPetScalarWhereInput[]
    NOT?: UnitPetScalarWhereInput | UnitPetScalarWhereInput[]
    id?: IntFilter<"UnitPet"> | number
    unitId?: IntFilter<"UnitPet"> | number
    name?: StringFilter<"UnitPet"> | string
    type?: StringFilter<"UnitPet"> | string
    breed?: StringNullableFilter<"UnitPet"> | string | null
    vaccinationStatus?: StringFilter<"UnitPet"> | string
    lastVaccinationDate?: DateTimeNullableFilter<"UnitPet"> | Date | string | null
    createdAt?: DateTimeFilter<"UnitPet"> | Date | string
  }

  export type SocietyCreateWithoutParkingSlotsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutParkingSlotsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutParkingSlotsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutParkingSlotsInput, SocietyUncheckedCreateWithoutParkingSlotsInput>
  }

  export type UnitCreateWithoutParkingSlotsInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parcels?: ParcelCreateNestedManyWithoutUnitInput
    members?: UnitMemberCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleCreateNestedManyWithoutUnitInput
    petsList?: UnitPetCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutParkingSlotsInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    societyId: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutUnitInput
    members?: UnitMemberUncheckedCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleUncheckedCreateNestedManyWithoutUnitInput
    petsList?: UnitPetUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutParkingSlotsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutParkingSlotsInput, UnitUncheckedCreateWithoutParkingSlotsInput>
  }

  export type SocietyUpsertWithoutParkingSlotsInput = {
    update: XOR<SocietyUpdateWithoutParkingSlotsInput, SocietyUncheckedUpdateWithoutParkingSlotsInput>
    create: XOR<SocietyCreateWithoutParkingSlotsInput, SocietyUncheckedCreateWithoutParkingSlotsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutParkingSlotsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutParkingSlotsInput, SocietyUncheckedUpdateWithoutParkingSlotsInput>
  }

  export type SocietyUpdateWithoutParkingSlotsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutParkingSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UnitUpsertWithoutParkingSlotsInput = {
    update: XOR<UnitUpdateWithoutParkingSlotsInput, UnitUncheckedUpdateWithoutParkingSlotsInput>
    create: XOR<UnitCreateWithoutParkingSlotsInput, UnitUncheckedCreateWithoutParkingSlotsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutParkingSlotsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutParkingSlotsInput, UnitUncheckedUpdateWithoutParkingSlotsInput>
  }

  export type UnitUpdateWithoutParkingSlotsInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutParkingSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUncheckedUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUncheckedUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type SocietyCreateWithoutComplaintsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutComplaintsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutComplaintsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutComplaintsInput, SocietyUncheckedCreateWithoutComplaintsInput>
  }

  export type UserCreateWithoutReportedComplaintsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportedComplaintsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportedComplaintsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportedComplaintsInput, UserUncheckedCreateWithoutReportedComplaintsInput>
  }

  export type UserCreateWithoutAssignedComplaintsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedComplaintsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedComplaintsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedComplaintsInput, UserUncheckedCreateWithoutAssignedComplaintsInput>
  }

  export type ComplaintCommentCreateWithoutComplaintInput = {
    message: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type ComplaintCommentUncheckedCreateWithoutComplaintInput = {
    id?: number
    userId: number
    message: string
    createdAt?: Date | string
  }

  export type ComplaintCommentCreateOrConnectWithoutComplaintInput = {
    where: ComplaintCommentWhereUniqueInput
    create: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput>
  }

  export type ComplaintCommentCreateManyComplaintInputEnvelope = {
    data: ComplaintCommentCreateManyComplaintInput | ComplaintCommentCreateManyComplaintInput[]
    skipDuplicates?: boolean
  }

  export type SocietyUpsertWithoutComplaintsInput = {
    update: XOR<SocietyUpdateWithoutComplaintsInput, SocietyUncheckedUpdateWithoutComplaintsInput>
    create: XOR<SocietyCreateWithoutComplaintsInput, SocietyUncheckedCreateWithoutComplaintsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutComplaintsInput, SocietyUncheckedUpdateWithoutComplaintsInput>
  }

  export type SocietyUpdateWithoutComplaintsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UserUpsertWithoutReportedComplaintsInput = {
    update: XOR<UserUpdateWithoutReportedComplaintsInput, UserUncheckedUpdateWithoutReportedComplaintsInput>
    create: XOR<UserCreateWithoutReportedComplaintsInput, UserUncheckedCreateWithoutReportedComplaintsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportedComplaintsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportedComplaintsInput, UserUncheckedUpdateWithoutReportedComplaintsInput>
  }

  export type UserUpdateWithoutReportedComplaintsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportedComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutAssignedComplaintsInput = {
    update: XOR<UserUpdateWithoutAssignedComplaintsInput, UserUncheckedUpdateWithoutAssignedComplaintsInput>
    create: XOR<UserCreateWithoutAssignedComplaintsInput, UserUncheckedCreateWithoutAssignedComplaintsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedComplaintsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedComplaintsInput, UserUncheckedUpdateWithoutAssignedComplaintsInput>
  }

  export type UserUpdateWithoutAssignedComplaintsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ComplaintCommentUpsertWithWhereUniqueWithoutComplaintInput = {
    where: ComplaintCommentWhereUniqueInput
    update: XOR<ComplaintCommentUpdateWithoutComplaintInput, ComplaintCommentUncheckedUpdateWithoutComplaintInput>
    create: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput>
  }

  export type ComplaintCommentUpdateWithWhereUniqueWithoutComplaintInput = {
    where: ComplaintCommentWhereUniqueInput
    data: XOR<ComplaintCommentUpdateWithoutComplaintInput, ComplaintCommentUncheckedUpdateWithoutComplaintInput>
  }

  export type ComplaintCommentUpdateManyWithWhereWithoutComplaintInput = {
    where: ComplaintCommentScalarWhereInput
    data: XOR<ComplaintCommentUpdateManyMutationInput, ComplaintCommentUncheckedUpdateManyWithoutComplaintInput>
  }

  export type ComplaintCreateWithoutCommentsInput = {
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    isPrivate?: boolean
    escalatedToTech?: boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutComplaintsInput
    reportedBy: UserCreateNestedOneWithoutReportedComplaintsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedComplaintsInput
  }

  export type ComplaintUncheckedCreateWithoutCommentsInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    isPrivate?: boolean
    escalatedToTech?: boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    reportedById: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintCreateOrConnectWithoutCommentsInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutCommentsInput, ComplaintUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type ComplaintUpsertWithoutCommentsInput = {
    update: XOR<ComplaintUpdateWithoutCommentsInput, ComplaintUncheckedUpdateWithoutCommentsInput>
    create: XOR<ComplaintCreateWithoutCommentsInput, ComplaintUncheckedCreateWithoutCommentsInput>
    where?: ComplaintWhereInput
  }

  export type ComplaintUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ComplaintWhereInput
    data: XOR<ComplaintUpdateWithoutCommentsInput, ComplaintUncheckedUpdateWithoutCommentsInput>
  }

  export type ComplaintUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    escalatedToTech?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutComplaintsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutReportedComplaintsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedComplaintsNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    escalatedToTech?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SocietyCreateWithoutVisitorsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutVisitorsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutVisitorsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutVisitorsInput, SocietyUncheckedCreateWithoutVisitorsInput>
  }

  export type UnitCreateWithoutVisitorsInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
    parcels?: ParcelCreateNestedManyWithoutUnitInput
    members?: UnitMemberCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleCreateNestedManyWithoutUnitInput
    petsList?: UnitPetCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutVisitorsInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    societyId: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutUnitInput
    members?: UnitMemberUncheckedCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleUncheckedCreateNestedManyWithoutUnitInput
    petsList?: UnitPetUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutVisitorsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutVisitorsInput, UnitUncheckedCreateWithoutVisitorsInput>
  }

  export type SocietyUpsertWithoutVisitorsInput = {
    update: XOR<SocietyUpdateWithoutVisitorsInput, SocietyUncheckedUpdateWithoutVisitorsInput>
    create: XOR<SocietyCreateWithoutVisitorsInput, SocietyUncheckedCreateWithoutVisitorsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutVisitorsInput, SocietyUncheckedUpdateWithoutVisitorsInput>
  }

  export type SocietyUpdateWithoutVisitorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutVisitorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UnitUpsertWithoutVisitorsInput = {
    update: XOR<UnitUpdateWithoutVisitorsInput, UnitUncheckedUpdateWithoutVisitorsInput>
    create: XOR<UnitCreateWithoutVisitorsInput, UnitUncheckedCreateWithoutVisitorsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutVisitorsInput, UnitUncheckedUpdateWithoutVisitorsInput>
  }

  export type UnitUpdateWithoutVisitorsInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutVisitorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUncheckedUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUncheckedUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type SocietyCreateWithoutTransactionsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutTransactionsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutTransactionsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutTransactionsInput, SocietyUncheckedCreateWithoutTransactionsInput>
  }

  export type SocietyUpsertWithoutTransactionsInput = {
    update: XOR<SocietyUpdateWithoutTransactionsInput, SocietyUncheckedUpdateWithoutTransactionsInput>
    create: XOR<SocietyCreateWithoutTransactionsInput, SocietyUncheckedCreateWithoutTransactionsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutTransactionsInput, SocietyUncheckedUpdateWithoutTransactionsInput>
  }

  export type SocietyUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyCreateWithoutVendorsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutVendorsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutVendorsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutVendorsInput, SocietyUncheckedCreateWithoutVendorsInput>
  }

  export type VendorPayoutCreateWithoutVendorInput = {
    vendorName: string
    societyId?: number | null
    societyName?: string | null
    dealValue: number
    commissionPercent: number
    payableAmount: number
    status?: string
    remarks?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorPayoutUncheckedCreateWithoutVendorInput = {
    id?: number
    vendorName: string
    societyId?: number | null
    societyName?: string | null
    dealValue: number
    commissionPercent: number
    payableAmount: number
    status?: string
    remarks?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorPayoutCreateOrConnectWithoutVendorInput = {
    where: VendorPayoutWhereUniqueInput
    create: XOR<VendorPayoutCreateWithoutVendorInput, VendorPayoutUncheckedCreateWithoutVendorInput>
  }

  export type VendorPayoutCreateManyVendorInputEnvelope = {
    data: VendorPayoutCreateManyVendorInput | VendorPayoutCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type SocietyUpsertWithoutVendorsInput = {
    update: XOR<SocietyUpdateWithoutVendorsInput, SocietyUncheckedUpdateWithoutVendorsInput>
    create: XOR<SocietyCreateWithoutVendorsInput, SocietyUncheckedCreateWithoutVendorsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutVendorsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutVendorsInput, SocietyUncheckedUpdateWithoutVendorsInput>
  }

  export type SocietyUpdateWithoutVendorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutVendorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type VendorPayoutUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorPayoutWhereUniqueInput
    update: XOR<VendorPayoutUpdateWithoutVendorInput, VendorPayoutUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorPayoutCreateWithoutVendorInput, VendorPayoutUncheckedCreateWithoutVendorInput>
  }

  export type VendorPayoutUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorPayoutWhereUniqueInput
    data: XOR<VendorPayoutUpdateWithoutVendorInput, VendorPayoutUncheckedUpdateWithoutVendorInput>
  }

  export type VendorPayoutUpdateManyWithWhereWithoutVendorInput = {
    where: VendorPayoutScalarWhereInput
    data: XOR<VendorPayoutUpdateManyMutationInput, VendorPayoutUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorPayoutScalarWhereInput = {
    AND?: VendorPayoutScalarWhereInput | VendorPayoutScalarWhereInput[]
    OR?: VendorPayoutScalarWhereInput[]
    NOT?: VendorPayoutScalarWhereInput | VendorPayoutScalarWhereInput[]
    id?: IntFilter<"VendorPayout"> | number
    vendorId?: IntFilter<"VendorPayout"> | number
    vendorName?: StringFilter<"VendorPayout"> | string
    societyId?: IntNullableFilter<"VendorPayout"> | number | null
    societyName?: StringNullableFilter<"VendorPayout"> | string | null
    dealValue?: FloatFilter<"VendorPayout"> | number
    commissionPercent?: FloatFilter<"VendorPayout"> | number
    payableAmount?: FloatFilter<"VendorPayout"> | number
    status?: StringFilter<"VendorPayout"> | string
    remarks?: StringNullableFilter<"VendorPayout"> | string | null
    date?: DateTimeFilter<"VendorPayout"> | Date | string
    createdAt?: DateTimeFilter<"VendorPayout"> | Date | string
    updatedAt?: DateTimeFilter<"VendorPayout"> | Date | string
  }

  export type VendorCreateWithoutPayoutsInput = {
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    status?: $Enums.VendorStatus
    createdAt?: Date | string
    society?: SocietyCreateNestedOneWithoutVendorsInput
  }

  export type VendorUncheckedCreateWithoutPayoutsInput = {
    id?: number
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    status?: $Enums.VendorStatus
    societyId?: number | null
    createdAt?: Date | string
  }

  export type VendorCreateOrConnectWithoutPayoutsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPayoutsInput, VendorUncheckedCreateWithoutPayoutsInput>
  }

  export type VendorUpsertWithoutPayoutsInput = {
    update: XOR<VendorUpdateWithoutPayoutsInput, VendorUncheckedUpdateWithoutPayoutsInput>
    create: XOR<VendorCreateWithoutPayoutsInput, VendorUncheckedCreateWithoutPayoutsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutPayoutsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutPayoutsInput, VendorUncheckedUpdateWithoutPayoutsInput>
  }

  export type VendorUpdateWithoutPayoutsInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutVendorsNestedInput
  }

  export type VendorUncheckedUpdateWithoutPayoutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocietyCreateWithoutEmergencyAlertsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutEmergencyAlertsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutEmergencyAlertsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutEmergencyAlertsInput, SocietyUncheckedCreateWithoutEmergencyAlertsInput>
  }

  export type UserCreateWithoutEmergencyAlertsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmergencyAlertsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmergencyAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmergencyAlertsInput, UserUncheckedCreateWithoutEmergencyAlertsInput>
  }

  export type SocietyUpsertWithoutEmergencyAlertsInput = {
    update: XOR<SocietyUpdateWithoutEmergencyAlertsInput, SocietyUncheckedUpdateWithoutEmergencyAlertsInput>
    create: XOR<SocietyCreateWithoutEmergencyAlertsInput, SocietyUncheckedCreateWithoutEmergencyAlertsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutEmergencyAlertsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutEmergencyAlertsInput, SocietyUncheckedUpdateWithoutEmergencyAlertsInput>
  }

  export type SocietyUpdateWithoutEmergencyAlertsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutEmergencyAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UserUpsertWithoutEmergencyAlertsInput = {
    update: XOR<UserUpdateWithoutEmergencyAlertsInput, UserUncheckedUpdateWithoutEmergencyAlertsInput>
    create: XOR<UserCreateWithoutEmergencyAlertsInput, UserUncheckedCreateWithoutEmergencyAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmergencyAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmergencyAlertsInput, UserUncheckedUpdateWithoutEmergencyAlertsInput>
  }

  export type UserUpdateWithoutEmergencyAlertsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmergencyAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SocietyCreateWithoutEmergencyContactsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutEmergencyContactsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutEmergencyContactsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutEmergencyContactsInput, SocietyUncheckedCreateWithoutEmergencyContactsInput>
  }

  export type UserCreateWithoutEmergencyContactsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmergencyContactsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmergencyContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmergencyContactsInput, UserUncheckedCreateWithoutEmergencyContactsInput>
  }

  export type SocietyUpsertWithoutEmergencyContactsInput = {
    update: XOR<SocietyUpdateWithoutEmergencyContactsInput, SocietyUncheckedUpdateWithoutEmergencyContactsInput>
    create: XOR<SocietyCreateWithoutEmergencyContactsInput, SocietyUncheckedCreateWithoutEmergencyContactsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutEmergencyContactsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutEmergencyContactsInput, SocietyUncheckedUpdateWithoutEmergencyContactsInput>
  }

  export type SocietyUpdateWithoutEmergencyContactsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutEmergencyContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UserUpsertWithoutEmergencyContactsInput = {
    update: XOR<UserUpdateWithoutEmergencyContactsInput, UserUncheckedUpdateWithoutEmergencyContactsInput>
    create: XOR<UserCreateWithoutEmergencyContactsInput, UserUncheckedCreateWithoutEmergencyContactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmergencyContactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmergencyContactsInput, UserUncheckedUpdateWithoutEmergencyContactsInput>
  }

  export type UserUpdateWithoutEmergencyContactsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmergencyContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SocietyCreateWithoutNoticesInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutNoticesInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutNoticesInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutNoticesInput, SocietyUncheckedCreateWithoutNoticesInput>
  }

  export type SocietyUpsertWithoutNoticesInput = {
    update: XOR<SocietyUpdateWithoutNoticesInput, SocietyUncheckedUpdateWithoutNoticesInput>
    create: XOR<SocietyCreateWithoutNoticesInput, SocietyUncheckedCreateWithoutNoticesInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutNoticesInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutNoticesInput, SocietyUncheckedUpdateWithoutNoticesInput>
  }

  export type SocietyUpdateWithoutNoticesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutNoticesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyCreateWithoutAmenitiesInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutAmenitiesInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutAmenitiesInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutAmenitiesInput, SocietyUncheckedCreateWithoutAmenitiesInput>
  }

  export type AmenityBookingCreateWithoutAmenityInput = {
    date: Date | string
    startTime: string
    endTime: string
    purpose?: string | null
    status?: string
    amountPaid?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
  }

  export type AmenityBookingUncheckedCreateWithoutAmenityInput = {
    id?: number
    userId: number
    date: Date | string
    startTime: string
    endTime: string
    purpose?: string | null
    status?: string
    amountPaid?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenityBookingCreateOrConnectWithoutAmenityInput = {
    where: AmenityBookingWhereUniqueInput
    create: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput>
  }

  export type AmenityBookingCreateManyAmenityInputEnvelope = {
    data: AmenityBookingCreateManyAmenityInput | AmenityBookingCreateManyAmenityInput[]
    skipDuplicates?: boolean
  }

  export type SocietyUpsertWithoutAmenitiesInput = {
    update: XOR<SocietyUpdateWithoutAmenitiesInput, SocietyUncheckedUpdateWithoutAmenitiesInput>
    create: XOR<SocietyCreateWithoutAmenitiesInput, SocietyUncheckedCreateWithoutAmenitiesInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutAmenitiesInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutAmenitiesInput, SocietyUncheckedUpdateWithoutAmenitiesInput>
  }

  export type SocietyUpdateWithoutAmenitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutAmenitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type AmenityBookingUpsertWithWhereUniqueWithoutAmenityInput = {
    where: AmenityBookingWhereUniqueInput
    update: XOR<AmenityBookingUpdateWithoutAmenityInput, AmenityBookingUncheckedUpdateWithoutAmenityInput>
    create: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput>
  }

  export type AmenityBookingUpdateWithWhereUniqueWithoutAmenityInput = {
    where: AmenityBookingWhereUniqueInput
    data: XOR<AmenityBookingUpdateWithoutAmenityInput, AmenityBookingUncheckedUpdateWithoutAmenityInput>
  }

  export type AmenityBookingUpdateManyWithWhereWithoutAmenityInput = {
    where: AmenityBookingScalarWhereInput
    data: XOR<AmenityBookingUpdateManyMutationInput, AmenityBookingUncheckedUpdateManyWithoutAmenityInput>
  }

  export type AmenityCreateWithoutBookingsInput = {
    name: string
    type?: string
    description?: string | null
    capacity?: number
    chargesPerHour?: number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutAmenitiesInput
  }

  export type AmenityUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    type?: string
    description?: string | null
    capacity?: number
    chargesPerHour?: number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    societyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenityCreateOrConnectWithoutBookingsInput = {
    where: AmenityWhereUniqueInput
    create: XOR<AmenityCreateWithoutBookingsInput, AmenityUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutBookingsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type AmenityUpsertWithoutBookingsInput = {
    update: XOR<AmenityUpdateWithoutBookingsInput, AmenityUncheckedUpdateWithoutBookingsInput>
    create: XOR<AmenityCreateWithoutBookingsInput, AmenityUncheckedCreateWithoutBookingsInput>
    where?: AmenityWhereInput
  }

  export type AmenityUpdateToOneWithWhereWithoutBookingsInput = {
    where?: AmenityWhereInput
    data: XOR<AmenityUpdateWithoutBookingsInput, AmenityUncheckedUpdateWithoutBookingsInput>
  }

  export type AmenityUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutAmenitiesNestedInput
  }

  export type AmenityUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SocietyCreateWithoutPlatformInvoicesInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutPlatformInvoicesInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutPlatformInvoicesInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutPlatformInvoicesInput, SocietyUncheckedCreateWithoutPlatformInvoicesInput>
  }

  export type SocietyUpsertWithoutPlatformInvoicesInput = {
    update: XOR<SocietyUpdateWithoutPlatformInvoicesInput, SocietyUncheckedUpdateWithoutPlatformInvoicesInput>
    create: XOR<SocietyCreateWithoutPlatformInvoicesInput, SocietyUncheckedCreateWithoutPlatformInvoicesInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutPlatformInvoicesInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutPlatformInvoicesInput, SocietyUncheckedUpdateWithoutPlatformInvoicesInput>
  }

  export type SocietyUpdateWithoutPlatformInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutPlatformInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UserCreateWithoutBuzzsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBuzzsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBuzzsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuzzsInput, UserUncheckedCreateWithoutBuzzsInput>
  }

  export type SocietyCreateWithoutBuzzsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutBuzzsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutBuzzsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutBuzzsInput, SocietyUncheckedCreateWithoutBuzzsInput>
  }

  export type CommunityCommentCreateWithoutBuzzInput = {
    content: string
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutCommunityCommentsInput
  }

  export type CommunityCommentUncheckedCreateWithoutBuzzInput = {
    id?: number
    authorId: number
    content: string
    createdAt?: Date | string
  }

  export type CommunityCommentCreateOrConnectWithoutBuzzInput = {
    where: CommunityCommentWhereUniqueInput
    create: XOR<CommunityCommentCreateWithoutBuzzInput, CommunityCommentUncheckedCreateWithoutBuzzInput>
  }

  export type CommunityCommentCreateManyBuzzInputEnvelope = {
    data: CommunityCommentCreateManyBuzzInput | CommunityCommentCreateManyBuzzInput[]
    skipDuplicates?: boolean
  }

  export type BuzzLikeCreateWithoutBuzzInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBuzzLikesInput
  }

  export type BuzzLikeUncheckedCreateWithoutBuzzInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type BuzzLikeCreateOrConnectWithoutBuzzInput = {
    where: BuzzLikeWhereUniqueInput
    create: XOR<BuzzLikeCreateWithoutBuzzInput, BuzzLikeUncheckedCreateWithoutBuzzInput>
  }

  export type BuzzLikeCreateManyBuzzInputEnvelope = {
    data: BuzzLikeCreateManyBuzzInput | BuzzLikeCreateManyBuzzInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBuzzsInput = {
    update: XOR<UserUpdateWithoutBuzzsInput, UserUncheckedUpdateWithoutBuzzsInput>
    create: XOR<UserCreateWithoutBuzzsInput, UserUncheckedCreateWithoutBuzzsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBuzzsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBuzzsInput, UserUncheckedUpdateWithoutBuzzsInput>
  }

  export type UserUpdateWithoutBuzzsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBuzzsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SocietyUpsertWithoutBuzzsInput = {
    update: XOR<SocietyUpdateWithoutBuzzsInput, SocietyUncheckedUpdateWithoutBuzzsInput>
    create: XOR<SocietyCreateWithoutBuzzsInput, SocietyUncheckedCreateWithoutBuzzsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutBuzzsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutBuzzsInput, SocietyUncheckedUpdateWithoutBuzzsInput>
  }

  export type SocietyUpdateWithoutBuzzsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutBuzzsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type CommunityCommentUpsertWithWhereUniqueWithoutBuzzInput = {
    where: CommunityCommentWhereUniqueInput
    update: XOR<CommunityCommentUpdateWithoutBuzzInput, CommunityCommentUncheckedUpdateWithoutBuzzInput>
    create: XOR<CommunityCommentCreateWithoutBuzzInput, CommunityCommentUncheckedCreateWithoutBuzzInput>
  }

  export type CommunityCommentUpdateWithWhereUniqueWithoutBuzzInput = {
    where: CommunityCommentWhereUniqueInput
    data: XOR<CommunityCommentUpdateWithoutBuzzInput, CommunityCommentUncheckedUpdateWithoutBuzzInput>
  }

  export type CommunityCommentUpdateManyWithWhereWithoutBuzzInput = {
    where: CommunityCommentScalarWhereInput
    data: XOR<CommunityCommentUpdateManyMutationInput, CommunityCommentUncheckedUpdateManyWithoutBuzzInput>
  }

  export type BuzzLikeUpsertWithWhereUniqueWithoutBuzzInput = {
    where: BuzzLikeWhereUniqueInput
    update: XOR<BuzzLikeUpdateWithoutBuzzInput, BuzzLikeUncheckedUpdateWithoutBuzzInput>
    create: XOR<BuzzLikeCreateWithoutBuzzInput, BuzzLikeUncheckedCreateWithoutBuzzInput>
  }

  export type BuzzLikeUpdateWithWhereUniqueWithoutBuzzInput = {
    where: BuzzLikeWhereUniqueInput
    data: XOR<BuzzLikeUpdateWithoutBuzzInput, BuzzLikeUncheckedUpdateWithoutBuzzInput>
  }

  export type BuzzLikeUpdateManyWithWhereWithoutBuzzInput = {
    where: BuzzLikeScalarWhereInput
    data: XOR<BuzzLikeUpdateManyMutationInput, BuzzLikeUncheckedUpdateManyWithoutBuzzInput>
  }

  export type CommunityBuzzCreateWithoutCommentsInput = {
    type: string
    title: string
    content?: string | null
    hasResult?: boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutBuzzsInput
    society: SocietyCreateNestedOneWithoutBuzzsInput
    likedBy?: BuzzLikeCreateNestedManyWithoutBuzzInput
  }

  export type CommunityBuzzUncheckedCreateWithoutCommentsInput = {
    id?: number
    type: string
    title: string
    content?: string | null
    authorId: number
    societyId: number
    hasResult?: boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    createdAt?: Date | string
    likedBy?: BuzzLikeUncheckedCreateNestedManyWithoutBuzzInput
  }

  export type CommunityBuzzCreateOrConnectWithoutCommentsInput = {
    where: CommunityBuzzWhereUniqueInput
    create: XOR<CommunityBuzzCreateWithoutCommentsInput, CommunityBuzzUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommunityCommentsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityCommentsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunityCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunityCommentsInput, UserUncheckedCreateWithoutCommunityCommentsInput>
  }

  export type CommunityBuzzUpsertWithoutCommentsInput = {
    update: XOR<CommunityBuzzUpdateWithoutCommentsInput, CommunityBuzzUncheckedUpdateWithoutCommentsInput>
    create: XOR<CommunityBuzzCreateWithoutCommentsInput, CommunityBuzzUncheckedCreateWithoutCommentsInput>
    where?: CommunityBuzzWhereInput
  }

  export type CommunityBuzzUpdateToOneWithWhereWithoutCommentsInput = {
    where?: CommunityBuzzWhereInput
    data: XOR<CommunityBuzzUpdateWithoutCommentsInput, CommunityBuzzUncheckedUpdateWithoutCommentsInput>
  }

  export type CommunityBuzzUpdateWithoutCommentsInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    hasResult?: BoolFieldUpdateOperationsInput | boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutBuzzsNestedInput
    society?: SocietyUpdateOneRequiredWithoutBuzzsNestedInput
    likedBy?: BuzzLikeUpdateManyWithoutBuzzNestedInput
  }

  export type CommunityBuzzUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    hasResult?: BoolFieldUpdateOperationsInput | boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likedBy?: BuzzLikeUncheckedUpdateManyWithoutBuzzNestedInput
  }

  export type UserUpsertWithoutCommunityCommentsInput = {
    update: XOR<UserUpdateWithoutCommunityCommentsInput, UserUncheckedUpdateWithoutCommunityCommentsInput>
    create: XOR<UserCreateWithoutCommunityCommentsInput, UserUncheckedCreateWithoutCommunityCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommunityCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommunityCommentsInput, UserUncheckedUpdateWithoutCommunityCommentsInput>
  }

  export type UserUpdateWithoutCommunityCommentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommunityCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommunityBuzzCreateWithoutLikedByInput = {
    type: string
    title: string
    content?: string | null
    hasResult?: boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutBuzzsInput
    society: SocietyCreateNestedOneWithoutBuzzsInput
    comments?: CommunityCommentCreateNestedManyWithoutBuzzInput
  }

  export type CommunityBuzzUncheckedCreateWithoutLikedByInput = {
    id?: number
    type: string
    title: string
    content?: string | null
    authorId: number
    societyId: number
    hasResult?: boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    createdAt?: Date | string
    comments?: CommunityCommentUncheckedCreateNestedManyWithoutBuzzInput
  }

  export type CommunityBuzzCreateOrConnectWithoutLikedByInput = {
    where: CommunityBuzzWhereUniqueInput
    create: XOR<CommunityBuzzCreateWithoutLikedByInput, CommunityBuzzUncheckedCreateWithoutLikedByInput>
  }

  export type UserCreateWithoutBuzzLikesInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutBuzzLikesInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutBuzzLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuzzLikesInput, UserUncheckedCreateWithoutBuzzLikesInput>
  }

  export type CommunityBuzzUpsertWithoutLikedByInput = {
    update: XOR<CommunityBuzzUpdateWithoutLikedByInput, CommunityBuzzUncheckedUpdateWithoutLikedByInput>
    create: XOR<CommunityBuzzCreateWithoutLikedByInput, CommunityBuzzUncheckedCreateWithoutLikedByInput>
    where?: CommunityBuzzWhereInput
  }

  export type CommunityBuzzUpdateToOneWithWhereWithoutLikedByInput = {
    where?: CommunityBuzzWhereInput
    data: XOR<CommunityBuzzUpdateWithoutLikedByInput, CommunityBuzzUncheckedUpdateWithoutLikedByInput>
  }

  export type CommunityBuzzUpdateWithoutLikedByInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    hasResult?: BoolFieldUpdateOperationsInput | boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutBuzzsNestedInput
    society?: SocietyUpdateOneRequiredWithoutBuzzsNestedInput
    comments?: CommunityCommentUpdateManyWithoutBuzzNestedInput
  }

  export type CommunityBuzzUncheckedUpdateWithoutLikedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    hasResult?: BoolFieldUpdateOperationsInput | boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommunityCommentUncheckedUpdateManyWithoutBuzzNestedInput
  }

  export type UserUpsertWithoutBuzzLikesInput = {
    update: XOR<UserUpdateWithoutBuzzLikesInput, UserUncheckedUpdateWithoutBuzzLikesInput>
    create: XOR<UserCreateWithoutBuzzLikesInput, UserUncheckedCreateWithoutBuzzLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBuzzLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBuzzLikesInput, UserUncheckedUpdateWithoutBuzzLikesInput>
  }

  export type UserUpdateWithoutBuzzLikesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutBuzzLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UnitCreateWithoutMembersInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
    parcels?: ParcelCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleCreateNestedManyWithoutUnitInput
    petsList?: UnitPetCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutMembersInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    societyId: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleUncheckedCreateNestedManyWithoutUnitInput
    petsList?: UnitPetUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutMembersInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutMembersInput, UnitUncheckedCreateWithoutMembersInput>
  }

  export type UnitUpsertWithoutMembersInput = {
    update: XOR<UnitUpdateWithoutMembersInput, UnitUncheckedUpdateWithoutMembersInput>
    create: XOR<UnitCreateWithoutMembersInput, UnitUncheckedCreateWithoutMembersInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutMembersInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutMembersInput, UnitUncheckedUpdateWithoutMembersInput>
  }

  export type UnitUpdateWithoutMembersInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUncheckedUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateWithoutVehiclesInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
    parcels?: ParcelCreateNestedManyWithoutUnitInput
    members?: UnitMemberCreateNestedManyWithoutUnitInput
    petsList?: UnitPetCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutVehiclesInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    societyId: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutUnitInput
    members?: UnitMemberUncheckedCreateNestedManyWithoutUnitInput
    petsList?: UnitPetUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutVehiclesInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutVehiclesInput, UnitUncheckedCreateWithoutVehiclesInput>
  }

  export type UnitUpsertWithoutVehiclesInput = {
    update: XOR<UnitUpdateWithoutVehiclesInput, UnitUncheckedUpdateWithoutVehiclesInput>
    create: XOR<UnitCreateWithoutVehiclesInput, UnitUncheckedCreateWithoutVehiclesInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutVehiclesInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutVehiclesInput, UnitUncheckedUpdateWithoutVehiclesInput>
  }

  export type UnitUpdateWithoutVehiclesInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutVehiclesInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUncheckedUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateWithoutPetsListInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
    parcels?: ParcelCreateNestedManyWithoutUnitInput
    members?: UnitMemberCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutPetsListInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    societyId: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutUnitInput
    members?: UnitMemberUncheckedCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutPetsListInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutPetsListInput, UnitUncheckedCreateWithoutPetsListInput>
  }

  export type UnitUpsertWithoutPetsListInput = {
    update: XOR<UnitUpdateWithoutPetsListInput, UnitUncheckedUpdateWithoutPetsListInput>
    create: XOR<UnitCreateWithoutPetsListInput, UnitUncheckedCreateWithoutPetsListInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutPetsListInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutPetsListInput, UnitUncheckedUpdateWithoutPetsListInput>
  }

  export type UnitUpdateWithoutPetsListInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutPetsListInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUncheckedUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UserCreateWithoutSosAlertsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSosAlertsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSosAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSosAlertsInput, UserUncheckedCreateWithoutSosAlertsInput>
  }

  export type SocietyCreateWithoutSosAlertsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutSosAlertsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutSosAlertsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutSosAlertsInput, SocietyUncheckedCreateWithoutSosAlertsInput>
  }

  export type UserUpsertWithoutSosAlertsInput = {
    update: XOR<UserUpdateWithoutSosAlertsInput, UserUncheckedUpdateWithoutSosAlertsInput>
    create: XOR<UserCreateWithoutSosAlertsInput, UserUncheckedCreateWithoutSosAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSosAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSosAlertsInput, UserUncheckedUpdateWithoutSosAlertsInput>
  }

  export type UserUpdateWithoutSosAlertsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSosAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SocietyUpsertWithoutSosAlertsInput = {
    update: XOR<SocietyUpdateWithoutSosAlertsInput, SocietyUncheckedUpdateWithoutSosAlertsInput>
    create: XOR<SocietyCreateWithoutSosAlertsInput, SocietyUncheckedCreateWithoutSosAlertsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutSosAlertsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutSosAlertsInput, SocietyUncheckedUpdateWithoutSosAlertsInput>
  }

  export type SocietyUpdateWithoutSosAlertsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutSosAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UserCreateWithoutMarketplaceItemsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMarketplaceItemsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMarketplaceItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMarketplaceItemsInput, UserUncheckedCreateWithoutMarketplaceItemsInput>
  }

  export type SocietyCreateWithoutMarketplaceItemsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutMarketplaceItemsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutMarketplaceItemsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutMarketplaceItemsInput, SocietyUncheckedCreateWithoutMarketplaceItemsInput>
  }

  export type UserUpsertWithoutMarketplaceItemsInput = {
    update: XOR<UserUpdateWithoutMarketplaceItemsInput, UserUncheckedUpdateWithoutMarketplaceItemsInput>
    create: XOR<UserCreateWithoutMarketplaceItemsInput, UserUncheckedCreateWithoutMarketplaceItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMarketplaceItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMarketplaceItemsInput, UserUncheckedUpdateWithoutMarketplaceItemsInput>
  }

  export type UserUpdateWithoutMarketplaceItemsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMarketplaceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SocietyUpsertWithoutMarketplaceItemsInput = {
    update: XOR<SocietyUpdateWithoutMarketplaceItemsInput, SocietyUncheckedUpdateWithoutMarketplaceItemsInput>
    create: XOR<SocietyCreateWithoutMarketplaceItemsInput, SocietyUncheckedCreateWithoutMarketplaceItemsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutMarketplaceItemsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutMarketplaceItemsInput, SocietyUncheckedUpdateWithoutMarketplaceItemsInput>
  }

  export type SocietyUpdateWithoutMarketplaceItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutMarketplaceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyCreateWithoutMeetingsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutMeetingsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutMeetingsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutMeetingsInput, SocietyUncheckedCreateWithoutMeetingsInput>
  }

  export type SocietyUpsertWithoutMeetingsInput = {
    update: XOR<SocietyUpdateWithoutMeetingsInput, SocietyUncheckedUpdateWithoutMeetingsInput>
    create: XOR<SocietyCreateWithoutMeetingsInput, SocietyUncheckedCreateWithoutMeetingsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutMeetingsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutMeetingsInput, SocietyUncheckedUpdateWithoutMeetingsInput>
  }

  export type SocietyUpdateWithoutMeetingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutMeetingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyCreateWithoutGuidelinesInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutGuidelinesInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutGuidelinesInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutGuidelinesInput, SocietyUncheckedCreateWithoutGuidelinesInput>
  }

  export type SocietyUpsertWithoutGuidelinesInput = {
    update: XOR<SocietyUpdateWithoutGuidelinesInput, SocietyUncheckedUpdateWithoutGuidelinesInput>
    create: XOR<SocietyCreateWithoutGuidelinesInput, SocietyUncheckedCreateWithoutGuidelinesInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutGuidelinesInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutGuidelinesInput, SocietyUncheckedUpdateWithoutGuidelinesInput>
  }

  export type SocietyUpdateWithoutGuidelinesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutGuidelinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyCreateWithoutAssetsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutAssetsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutAssetsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutAssetsInput, SocietyUncheckedCreateWithoutAssetsInput>
  }

  export type SocietyUpsertWithoutAssetsInput = {
    update: XOR<SocietyUpdateWithoutAssetsInput, SocietyUncheckedUpdateWithoutAssetsInput>
    create: XOR<SocietyCreateWithoutAssetsInput, SocietyUncheckedCreateWithoutAssetsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutAssetsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutAssetsInput, SocietyUncheckedUpdateWithoutAssetsInput>
  }

  export type SocietyUpdateWithoutAssetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyCreateWithoutDocumentsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutDocumentsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutDocumentsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutDocumentsInput, SocietyUncheckedCreateWithoutDocumentsInput>
  }

  export type SocietyUpsertWithoutDocumentsInput = {
    update: XOR<SocietyUpdateWithoutDocumentsInput, SocietyUncheckedUpdateWithoutDocumentsInput>
    create: XOR<SocietyCreateWithoutDocumentsInput, SocietyUncheckedCreateWithoutDocumentsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutDocumentsInput, SocietyUncheckedUpdateWithoutDocumentsInput>
  }

  export type SocietyUpdateWithoutDocumentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UnitCreateWithoutParcelsInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
    members?: UnitMemberCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleCreateNestedManyWithoutUnitInput
    petsList?: UnitPetCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutParcelsInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    societyId: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
    members?: UnitMemberUncheckedCreateNestedManyWithoutUnitInput
    vehicles?: UnitVehicleUncheckedCreateNestedManyWithoutUnitInput
    petsList?: UnitPetUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutParcelsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutParcelsInput, UnitUncheckedCreateWithoutParcelsInput>
  }

  export type SocietyCreateWithoutParcelsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutParcelsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutParcelsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutParcelsInput, SocietyUncheckedCreateWithoutParcelsInput>
  }

  export type UnitUpsertWithoutParcelsInput = {
    update: XOR<UnitUpdateWithoutParcelsInput, UnitUncheckedUpdateWithoutParcelsInput>
    create: XOR<UnitCreateWithoutParcelsInput, UnitUncheckedCreateWithoutParcelsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutParcelsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutParcelsInput, UnitUncheckedUpdateWithoutParcelsInput>
  }

  export type UnitUpdateWithoutParcelsInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutParcelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUncheckedUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUncheckedUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type SocietyUpsertWithoutParcelsInput = {
    update: XOR<SocietyUpdateWithoutParcelsInput, SocietyUncheckedUpdateWithoutParcelsInput>
    create: XOR<SocietyCreateWithoutParcelsInput, SocietyUncheckedCreateWithoutParcelsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutParcelsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutParcelsInput, SocietyUncheckedUpdateWithoutParcelsInput>
  }

  export type SocietyUpdateWithoutParcelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutParcelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyCreateWithoutEventsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutEventsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutEventsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutEventsInput, SocietyUncheckedCreateWithoutEventsInput>
  }

  export type SocietyUpsertWithoutEventsInput = {
    update: XOR<SocietyUpdateWithoutEventsInput, SocietyUncheckedUpdateWithoutEventsInput>
    create: XOR<SocietyCreateWithoutEventsInput, SocietyUncheckedCreateWithoutEventsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutEventsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutEventsInput, SocietyUncheckedUpdateWithoutEventsInput>
  }

  export type SocietyUpdateWithoutEventsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyCreateWithoutPurchaseRequestsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutPurchaseRequestsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutPurchaseRequestsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutPurchaseRequestsInput, SocietyUncheckedCreateWithoutPurchaseRequestsInput>
  }

  export type UserCreateWithoutPurchaseRequestsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPurchaseRequestsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPurchaseRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchaseRequestsInput, UserUncheckedCreateWithoutPurchaseRequestsInput>
  }

  export type SocietyUpsertWithoutPurchaseRequestsInput = {
    update: XOR<SocietyUpdateWithoutPurchaseRequestsInput, SocietyUncheckedUpdateWithoutPurchaseRequestsInput>
    create: XOR<SocietyCreateWithoutPurchaseRequestsInput, SocietyUncheckedCreateWithoutPurchaseRequestsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutPurchaseRequestsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutPurchaseRequestsInput, SocietyUncheckedUpdateWithoutPurchaseRequestsInput>
  }

  export type SocietyUpdateWithoutPurchaseRequestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutPurchaseRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UserUpsertWithoutPurchaseRequestsInput = {
    update: XOR<UserUpdateWithoutPurchaseRequestsInput, UserUncheckedUpdateWithoutPurchaseRequestsInput>
    create: XOR<UserCreateWithoutPurchaseRequestsInput, UserUncheckedCreateWithoutPurchaseRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchaseRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchaseRequestsInput, UserUncheckedUpdateWithoutPurchaseRequestsInput>
  }

  export type UserUpdateWithoutPurchaseRequestsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchaseRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SocietyCreateWithoutConversationsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutConversationsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutConversationsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutConversationsInput, SocietyUncheckedCreateWithoutConversationsInput>
  }

  export type UserCreateWithoutConversationsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type ChatMessageCreateWithoutConversationInput = {
    content: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutConversationInput = {
    id?: number
    senderId: number
    content: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutConversationInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutConversationInput, ChatMessageUncheckedCreateWithoutConversationInput>
  }

  export type ChatMessageCreateManyConversationInputEnvelope = {
    data: ChatMessageCreateManyConversationInput | ChatMessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type SocietyUpsertWithoutConversationsInput = {
    update: XOR<SocietyUpdateWithoutConversationsInput, SocietyUncheckedUpdateWithoutConversationsInput>
    create: XOR<SocietyCreateWithoutConversationsInput, SocietyUncheckedCreateWithoutConversationsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutConversationsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutConversationsInput, SocietyUncheckedUpdateWithoutConversationsInput>
  }

  export type SocietyUpdateWithoutConversationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutConversationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UserUpsertWithoutConversationsInput = {
    update: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateWithoutConversationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutConversationInput, ChatMessageUncheckedUpdateWithoutConversationInput>
    create: XOR<ChatMessageCreateWithoutConversationInput, ChatMessageUncheckedCreateWithoutConversationInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutConversationInput, ChatMessageUncheckedUpdateWithoutConversationInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutConversationInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutMessagesInput = {
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutConversationsInput
    participant?: UserCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: number
    societyId: number
    type: string
    participantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryCreateNestedManyWithoutResidentInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    serviceInquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutResidentInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutConversationsNestedInput
    participant?: UserUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceVariantCreateWithoutCategoryInput = {
    name: string
    price?: number | null
    createdAt?: Date | string
  }

  export type ServiceVariantUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    price?: number | null
    createdAt?: Date | string
  }

  export type ServiceVariantCreateOrConnectWithoutCategoryInput = {
    where: ServiceVariantWhereUniqueInput
    create: XOR<ServiceVariantCreateWithoutCategoryInput, ServiceVariantUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceVariantCreateManyCategoryInputEnvelope = {
    data: ServiceVariantCreateManyCategoryInput | ServiceVariantCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ServiceInquiryCreateWithoutServiceInput = {
    serviceName?: string | null
    type: string
    status?: string
    preferredDate?: string | null
    preferredTime?: string | null
    phone?: string | null
    notes?: string | null
    vendorName?: string | null
    vendorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resident?: UserCreateNestedOneWithoutServiceInquiriesInput
    society?: SocietyCreateNestedOneWithoutServiceInquiriesInput
  }

  export type ServiceInquiryUncheckedCreateWithoutServiceInput = {
    id?: number
    residentId?: number | null
    societyId?: number | null
    serviceName?: string | null
    type: string
    status?: string
    preferredDate?: string | null
    preferredTime?: string | null
    phone?: string | null
    notes?: string | null
    vendorName?: string | null
    vendorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceInquiryCreateOrConnectWithoutServiceInput = {
    where: ServiceInquiryWhereUniqueInput
    create: XOR<ServiceInquiryCreateWithoutServiceInput, ServiceInquiryUncheckedCreateWithoutServiceInput>
  }

  export type ServiceInquiryCreateManyServiceInputEnvelope = {
    data: ServiceInquiryCreateManyServiceInput | ServiceInquiryCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceVariantUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ServiceVariantWhereUniqueInput
    update: XOR<ServiceVariantUpdateWithoutCategoryInput, ServiceVariantUncheckedUpdateWithoutCategoryInput>
    create: XOR<ServiceVariantCreateWithoutCategoryInput, ServiceVariantUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceVariantUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ServiceVariantWhereUniqueInput
    data: XOR<ServiceVariantUpdateWithoutCategoryInput, ServiceVariantUncheckedUpdateWithoutCategoryInput>
  }

  export type ServiceVariantUpdateManyWithWhereWithoutCategoryInput = {
    where: ServiceVariantScalarWhereInput
    data: XOR<ServiceVariantUpdateManyMutationInput, ServiceVariantUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ServiceVariantScalarWhereInput = {
    AND?: ServiceVariantScalarWhereInput | ServiceVariantScalarWhereInput[]
    OR?: ServiceVariantScalarWhereInput[]
    NOT?: ServiceVariantScalarWhereInput | ServiceVariantScalarWhereInput[]
    id?: IntFilter<"ServiceVariant"> | number
    categoryId?: StringFilter<"ServiceVariant"> | string
    name?: StringFilter<"ServiceVariant"> | string
    price?: FloatNullableFilter<"ServiceVariant"> | number | null
    createdAt?: DateTimeFilter<"ServiceVariant"> | Date | string
  }

  export type ServiceInquiryUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceInquiryWhereUniqueInput
    update: XOR<ServiceInquiryUpdateWithoutServiceInput, ServiceInquiryUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceInquiryCreateWithoutServiceInput, ServiceInquiryUncheckedCreateWithoutServiceInput>
  }

  export type ServiceInquiryUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceInquiryWhereUniqueInput
    data: XOR<ServiceInquiryUpdateWithoutServiceInput, ServiceInquiryUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceInquiryUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceInquiryScalarWhereInput
    data: XOR<ServiceInquiryUpdateManyMutationInput, ServiceInquiryUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceCategoryCreateWithoutVariantsInput = {
    id: string
    name: string
    description?: string | null
    icon: string
    color?: string
    createdAt?: Date | string
    inquiries?: ServiceInquiryCreateNestedManyWithoutServiceInput
  }

  export type ServiceCategoryUncheckedCreateWithoutVariantsInput = {
    id: string
    name: string
    description?: string | null
    icon: string
    color?: string
    createdAt?: Date | string
    inquiries?: ServiceInquiryUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCategoryCreateOrConnectWithoutVariantsInput = {
    where: ServiceCategoryWhereUniqueInput
    create: XOR<ServiceCategoryCreateWithoutVariantsInput, ServiceCategoryUncheckedCreateWithoutVariantsInput>
  }

  export type ServiceCategoryUpsertWithoutVariantsInput = {
    update: XOR<ServiceCategoryUpdateWithoutVariantsInput, ServiceCategoryUncheckedUpdateWithoutVariantsInput>
    create: XOR<ServiceCategoryCreateWithoutVariantsInput, ServiceCategoryUncheckedCreateWithoutVariantsInput>
    where?: ServiceCategoryWhereInput
  }

  export type ServiceCategoryUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ServiceCategoryWhereInput
    data: XOR<ServiceCategoryUpdateWithoutVariantsInput, ServiceCategoryUncheckedUpdateWithoutVariantsInput>
  }

  export type ServiceCategoryUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inquiries?: ServiceInquiryUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCategoryUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inquiries?: ServiceInquiryUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserCreateWithoutServiceInquiriesInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleModel?: RoleModelCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutServiceInquiriesInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequestedByInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutAuthorInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutAuthorInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutResidentInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutResidentInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutOwnerInput
    buzzLikes?: BuzzLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutServiceInquiriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServiceInquiriesInput, UserUncheckedCreateWithoutServiceInquiriesInput>
  }

  export type SocietyCreateWithoutServiceInquiriesInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
    meetings?: MeetingCreateNestedManyWithoutSocietyInput
    assets?: AssetCreateNestedManyWithoutSocietyInput
    documents?: DocumentCreateNestedManyWithoutSocietyInput
    parcels?: ParcelCreateNestedManyWithoutSocietyInput
    events?: EventCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutSocietyInput
    conversations?: ConversationCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutServiceInquiriesInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutSocietyInput
    assets?: AssetUncheckedCreateNestedManyWithoutSocietyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSocietyInput
    parcels?: ParcelUncheckedCreateNestedManyWithoutSocietyInput
    events?: EventUncheckedCreateNestedManyWithoutSocietyInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutSocietyInput
    emergencyAlerts?: EmergencyAlertUncheckedCreateNestedManyWithoutSocietyInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutSocietyInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSocietyInput
    buzzs?: CommunityBuzzUncheckedCreateNestedManyWithoutSocietyInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSocietyInput
    guidelines?: CommunityGuidelineUncheckedCreateNestedManyWithoutSocietyInput
    sosAlerts?: SOSAlertUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutServiceInquiriesInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutServiceInquiriesInput, SocietyUncheckedCreateWithoutServiceInquiriesInput>
  }

  export type ServiceCategoryCreateWithoutInquiriesInput = {
    id: string
    name: string
    description?: string | null
    icon: string
    color?: string
    createdAt?: Date | string
    variants?: ServiceVariantCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUncheckedCreateWithoutInquiriesInput = {
    id: string
    name: string
    description?: string | null
    icon: string
    color?: string
    createdAt?: Date | string
    variants?: ServiceVariantUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryCreateOrConnectWithoutInquiriesInput = {
    where: ServiceCategoryWhereUniqueInput
    create: XOR<ServiceCategoryCreateWithoutInquiriesInput, ServiceCategoryUncheckedCreateWithoutInquiriesInput>
  }

  export type UserUpsertWithoutServiceInquiriesInput = {
    update: XOR<UserUpdateWithoutServiceInquiriesInput, UserUncheckedUpdateWithoutServiceInquiriesInput>
    create: XOR<UserCreateWithoutServiceInquiriesInput, UserUncheckedCreateWithoutServiceInquiriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServiceInquiriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServiceInquiriesInput, UserUncheckedUpdateWithoutServiceInquiriesInput>
  }

  export type UserUpdateWithoutServiceInquiriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServiceInquiriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SocietyUpsertWithoutServiceInquiriesInput = {
    update: XOR<SocietyUpdateWithoutServiceInquiriesInput, SocietyUncheckedUpdateWithoutServiceInquiriesInput>
    create: XOR<SocietyCreateWithoutServiceInquiriesInput, SocietyUncheckedCreateWithoutServiceInquiriesInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutServiceInquiriesInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutServiceInquiriesInput, SocietyUncheckedUpdateWithoutServiceInquiriesInput>
  }

  export type SocietyUpdateWithoutServiceInquiriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUpdateManyWithoutSocietyNestedInput
    assets?: AssetUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUpdateManyWithoutSocietyNestedInput
    events?: EventUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutServiceInquiriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutSocietyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutSocietyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSocietyNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutSocietyNestedInput
    events?: EventUncheckedUpdateManyWithoutSocietyNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutSocietyNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutSocietyNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSocietyNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutSocietyNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSocietyNestedInput
    guidelines?: CommunityGuidelineUncheckedUpdateManyWithoutSocietyNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type ServiceCategoryUpsertWithoutInquiriesInput = {
    update: XOR<ServiceCategoryUpdateWithoutInquiriesInput, ServiceCategoryUncheckedUpdateWithoutInquiriesInput>
    create: XOR<ServiceCategoryCreateWithoutInquiriesInput, ServiceCategoryUncheckedCreateWithoutInquiriesInput>
    where?: ServiceCategoryWhereInput
  }

  export type ServiceCategoryUpdateToOneWithWhereWithoutInquiriesInput = {
    where?: ServiceCategoryWhereInput
    data: XOR<ServiceCategoryUpdateWithoutInquiriesInput, ServiceCategoryUncheckedUpdateWithoutInquiriesInput>
  }

  export type ServiceCategoryUpdateWithoutInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ServiceVariantUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryUncheckedUpdateWithoutInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ServiceVariantUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type UserCreateManySocietyInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    roleId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitCreateManySocietyInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintCreateManySocietyInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    isPrivate?: boolean
    escalatedToTech?: boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    reportedById: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorCreateManySocietyInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    visitingUnitId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManySocietyInput = {
    id?: number
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoticeCreateManySocietyInput = {
    id?: number
    title: string
    content: string
    audience: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type VendorCreateManySocietyInput = {
    id?: number
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    status?: $Enums.VendorStatus
    createdAt?: Date | string
  }

  export type AmenityCreateManySocietyInput = {
    id?: number
    name: string
    type?: string
    description?: string | null
    capacity?: number
    chargesPerHour?: number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParkingSlotCreateManySocietyInput = {
    id?: number
    number: string
    type: string
    status: string
    allocatedToUnitId?: number | null
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type PlatformInvoiceCreateManySocietyInput = {
    id?: number
    invoiceNo: string
    amount: number
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingCreateManySocietyInput = {
    id?: number
    title: string
    description?: string | null
    date: Date | string
    time: string
    location: string
    attendees?: NullableJsonNullValueInput | InputJsonValue
    status?: string
  }

  export type AssetCreateManySocietyInput = {
    id?: number
    name: string
    category: string
    value: number
    purchaseDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManySocietyInput = {
    id?: number
    title: string
    category: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type ParcelCreateManySocietyInput = {
    id?: number
    unitId: number
    courierName: string
    trackingNumber?: string | null
    description?: string | null
    receivedBy?: string | null
    status?: string
    collectedBy?: string | null
    collectedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type EventCreateManySocietyInput = {
    id?: number
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    category?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseRequestCreateManySocietyInput = {
    id?: number
    title: string
    description?: string | null
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requestedById: number
  }

  export type EmergencyAlertCreateManySocietyInput = {
    id?: number
    type: string
    unit?: string | null
    description?: string | null
    status?: string
    resolution?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyContactCreateManySocietyInput = {
    id?: number
    name: string
    phone: string
    category?: string
    available?: boolean
    residentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceInquiryCreateManySocietyInput = {
    id?: number
    residentId?: number | null
    serviceId?: string | null
    serviceName?: string | null
    type: string
    status?: string
    preferredDate?: string | null
    preferredTime?: string | null
    phone?: string | null
    notes?: string | null
    vendorName?: string | null
    vendorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManySocietyInput = {
    id?: number
    type: string
    participantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityBuzzCreateManySocietyInput = {
    id?: number
    type: string
    title: string
    content?: string | null
    authorId: number
    hasResult?: boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    createdAt?: Date | string
  }

  export type MarketplaceItemCreateManySocietyInput = {
    id?: number
    title: string
    description: string
    price?: number | null
    originalPrice?: number | null
    condition?: string | null
    type?: string
    priceType?: string | null
    category?: string | null
    status?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: number
    likes?: number
    ownerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityGuidelineCreateManySocietyInput = {
    id?: number
    title: string
    content: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SOSAlertCreateManySocietyInput = {
    id?: number
    residentId: number
    type: string
    status?: string
    location?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type UserUpdateWithoutSocietyInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleModel?: RoleModelUpdateOneWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpdateWithoutSocietyInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUncheckedUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUncheckedUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUpdateWithoutSocietyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    escalatedToTech?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: UserUpdateOneRequiredWithoutReportedComplaintsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedComplaintsNestedInput
    comments?: ComplaintCommentUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    escalatedToTech?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    reportedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ComplaintCommentUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    escalatedToTech?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    reportedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUpdateWithoutSocietyInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitingUnitId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitingUnitId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutSocietyInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeUpdateWithoutSocietyInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoticeUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoticeUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VendorUpdateWithoutSocietyInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payouts?: VendorPayoutUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payouts?: VendorPayoutUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityUpdateWithoutSocietyInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: AmenityBookingUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: AmenityBookingUncheckedUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    availableDays?: NullableJsonNullValueInput | InputJsonValue
    timings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotUpdateWithoutSocietyInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneWithoutParkingSlotsNestedInput
  }

  export type ParkingSlotUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    allocatedToUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    allocatedToUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformInvoiceUpdateWithoutSocietyInput = {
    invoiceNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformInvoiceUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformInvoiceUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUpdateWithoutSocietyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    attendees?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MeetingUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    attendees?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MeetingUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    attendees?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AssetUpdateWithoutSocietyInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutSocietyInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParcelUpdateWithoutSocietyInput = {
    courierName?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutParcelsNestedInput
  }

  export type ParcelUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    courierName?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParcelUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    courierName?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutSocietyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseRequestUpdateWithoutSocietyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: UserUpdateOneRequiredWithoutPurchaseRequestsNestedInput
  }

  export type PurchaseRequestUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedById?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseRequestUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedById?: IntFieldUpdateOperationsInput | number
  }

  export type EmergencyAlertUpdateWithoutSocietyInput = {
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmergencyAlertsNestedInput
  }

  export type EmergencyAlertUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyAlertUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactUpdateWithoutSocietyInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: UserUpdateOneWithoutEmergencyContactsNestedInput
  }

  export type EmergencyContactUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    available?: BoolFieldUpdateOperationsInput | boolean
    residentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    available?: BoolFieldUpdateOperationsInput | boolean
    residentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceInquiryUpdateWithoutSocietyInput = {
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    preferredDate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: UserUpdateOneWithoutServiceInquiriesNestedInput
    service?: ServiceCategoryUpdateOneWithoutInquiriesNestedInput
  }

  export type ServiceInquiryUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    residentId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    preferredDate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceInquiryUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    residentId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    preferredDate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutSocietyInput = {
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: UserUpdateOneWithoutConversationsNestedInput
    messages?: ChatMessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBuzzUpdateWithoutSocietyInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    hasResult?: BoolFieldUpdateOperationsInput | boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutBuzzsNestedInput
    comments?: CommunityCommentUpdateManyWithoutBuzzNestedInput
    likedBy?: BuzzLikeUpdateManyWithoutBuzzNestedInput
  }

  export type CommunityBuzzUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: IntFieldUpdateOperationsInput | number
    hasResult?: BoolFieldUpdateOperationsInput | boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommunityCommentUncheckedUpdateManyWithoutBuzzNestedInput
    likedBy?: BuzzLikeUncheckedUpdateManyWithoutBuzzNestedInput
  }

  export type CommunityBuzzUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: IntFieldUpdateOperationsInput | number
    hasResult?: BoolFieldUpdateOperationsInput | boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceItemUpdateWithoutSocietyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutMarketplaceItemsNestedInput
  }

  export type MarketplaceItemUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceItemUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityGuidelineUpdateWithoutSocietyInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityGuidelineUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityGuidelineUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SOSAlertUpdateWithoutSocietyInput = {
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resident?: UserUpdateOneRequiredWithoutSosAlertsNestedInput
  }

  export type SOSAlertUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    residentId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SOSAlertUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    residentId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionCreateManyUserInput = {
    id?: number
    device?: string | null
    ipAddress?: string | null
    lastActive?: Date | string
    token: string
    createdAt?: Date | string
  }

  export type UnitCreateManyOwnerInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    societyId: number
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitCreateManyTenantInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    status?: string
    pets?: number
    membersCount?: number
    societyId: number
    ownerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintCreateManyReportedByInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    isPrivate?: boolean
    escalatedToTech?: boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintCreateManyAssignedToInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    isPrivate?: boolean
    escalatedToTech?: boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    reportedById: number
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenityBookingCreateManyUserInput = {
    id?: number
    amenityId: number
    date: Date | string
    startTime: string
    endTime: string
    purpose?: string | null
    status?: string
    amountPaid?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintCommentCreateManyUserInput = {
    id?: number
    complaintId: number
    message: string
    createdAt?: Date | string
  }

  export type PurchaseRequestCreateManyRequestedByInput = {
    id?: number
    title: string
    description?: string | null
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    societyId: number
  }

  export type EmergencyAlertCreateManyUserInput = {
    id?: number
    type: string
    unit?: string | null
    description?: string | null
    status?: string
    resolution?: string | null
    societyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceInquiryCreateManyResidentInput = {
    id?: number
    societyId?: number | null
    serviceId?: string | null
    serviceName?: string | null
    type: string
    status?: string
    preferredDate?: string | null
    preferredTime?: string | null
    phone?: string | null
    notes?: string | null
    vendorName?: string | null
    vendorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManyParticipantInput = {
    id?: number
    societyId: number
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatMessageCreateManySenderInput = {
    id?: number
    conversationId: number
    content: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
  }

  export type CommunityBuzzCreateManyAuthorInput = {
    id?: number
    type: string
    title: string
    content?: string | null
    societyId: number
    hasResult?: boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: number
    createdAt?: Date | string
  }

  export type CommunityCommentCreateManyAuthorInput = {
    id?: number
    buzzId: number
    content: string
    createdAt?: Date | string
  }

  export type SOSAlertCreateManyResidentInput = {
    id?: number
    societyId: number
    type: string
    status?: string
    location?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type EmergencyContactCreateManyResidentInput = {
    id?: number
    name: string
    phone: string
    category?: string
    available?: boolean
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceItemCreateManyOwnerInput = {
    id?: number
    title: string
    description: string
    price?: number | null
    originalPrice?: number | null
    condition?: string | null
    type?: string
    priceType?: string | null
    category?: string | null
    status?: string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: number
    likes?: number
    societyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuzzLikeCreateManyUserInput = {
    id?: number
    buzzId: number
    createdAt?: Date | string
  }

  export type UserSessionUpdateWithoutUserInput = {
    device?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    device?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    device?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpdateWithoutOwnerInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUncheckedUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUncheckedUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpdateWithoutTenantInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
    parcels?: ParcelUncheckedUpdateManyWithoutUnitNestedInput
    members?: UnitMemberUncheckedUpdateManyWithoutUnitNestedInput
    vehicles?: UnitVehicleUncheckedUpdateManyWithoutUnitNestedInput
    petsList?: UnitPetUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pets?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUpdateWithoutReportedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    escalatedToTech?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutComplaintsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedComplaintsNestedInput
    comments?: ComplaintCommentUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutReportedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    escalatedToTech?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ComplaintCommentUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateManyWithoutReportedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    escalatedToTech?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUpdateWithoutAssignedToInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    escalatedToTech?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutComplaintsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutReportedComplaintsNestedInput
    comments?: ComplaintCommentUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    escalatedToTech?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ComplaintCommentUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateManyWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    escalatedToTech?: BoolFieldUpdateOperationsInput | boolean
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenity?: AmenityUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type AmenityBookingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentUpdateWithoutUserInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint?: ComplaintUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ComplaintCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaintId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaintId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseRequestUpdateWithoutRequestedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutPurchaseRequestsNestedInput
  }

  export type PurchaseRequestUncheckedUpdateWithoutRequestedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    societyId?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseRequestUncheckedUpdateManyWithoutRequestedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    societyId?: IntFieldUpdateOperationsInput | number
  }

  export type EmergencyAlertUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutEmergencyAlertsNestedInput
  }

  export type EmergencyAlertUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyAlertUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceInquiryUpdateWithoutResidentInput = {
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    preferredDate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutServiceInquiriesNestedInput
    service?: ServiceCategoryUpdateOneWithoutInquiriesNestedInput
  }

  export type ServiceInquiryUncheckedUpdateWithoutResidentInput = {
    id?: IntFieldUpdateOperationsInput | number
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    preferredDate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceInquiryUncheckedUpdateManyWithoutResidentInput = {
    id?: IntFieldUpdateOperationsInput | number
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    preferredDate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutParticipantInput = {
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutConversationsNestedInput
    messages?: ChatMessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutParticipantInput = {
    id?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutParticipantInput = {
    id?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUpdateWithoutSenderInput = {
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversationId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversationId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBuzzUpdateWithoutAuthorInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    hasResult?: BoolFieldUpdateOperationsInput | boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutBuzzsNestedInput
    comments?: CommunityCommentUpdateManyWithoutBuzzNestedInput
    likedBy?: BuzzLikeUpdateManyWithoutBuzzNestedInput
  }

  export type CommunityBuzzUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    hasResult?: BoolFieldUpdateOperationsInput | boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommunityCommentUncheckedUpdateManyWithoutBuzzNestedInput
    likedBy?: BuzzLikeUncheckedUpdateManyWithoutBuzzNestedInput
  }

  export type CommunityBuzzUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    hasResult?: BoolFieldUpdateOperationsInput | boolean
    imageUrls?: NullableJsonNullValueInput | InputJsonValue
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityCommentUpdateWithoutAuthorInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buzz?: CommunityBuzzUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommunityCommentUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    buzzId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityCommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    buzzId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SOSAlertUpdateWithoutResidentInput = {
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    society?: SocietyUpdateOneRequiredWithoutSosAlertsNestedInput
  }

  export type SOSAlertUncheckedUpdateWithoutResidentInput = {
    id?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SOSAlertUncheckedUpdateManyWithoutResidentInput = {
    id?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyContactUpdateWithoutResidentInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutEmergencyContactsNestedInput
  }

  export type EmergencyContactUncheckedUpdateWithoutResidentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    available?: BoolFieldUpdateOperationsInput | boolean
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactUncheckedUpdateManyWithoutResidentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    available?: BoolFieldUpdateOperationsInput | boolean
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceItemUpdateWithoutOwnerInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutMarketplaceItemsNestedInput
  }

  export type MarketplaceItemUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceItemUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuzzLikeUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buzz?: CommunityBuzzUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type BuzzLikeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    buzzId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuzzLikeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    buzzId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyRoleInput = {
    permissionId: string
  }

  export type UserCreateManyRoleModelInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutRoleModelInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    emergencyAlerts?: EmergencyAlertUncheckedUpdateManyWithoutUserNestedInput
    serviceInquiries?: ServiceInquiryUncheckedUpdateManyWithoutResidentNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    buzzs?: CommunityBuzzUncheckedUpdateManyWithoutAuthorNestedInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sosAlerts?: SOSAlertUncheckedUpdateManyWithoutResidentNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutResidentNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutOwnerNestedInput
    buzzLikes?: BuzzLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyPermissionInput = {
    roleId: number
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    role?: RoleModelUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type VisitorCreateManyUnitInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    societyId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParkingSlotCreateManyUnitInput = {
    id?: number
    number: string
    type: string
    status: string
    societyId: number
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type ParcelCreateManyUnitInput = {
    id?: number
    courierName: string
    trackingNumber?: string | null
    description?: string | null
    receivedBy?: string | null
    status?: string
    collectedBy?: string | null
    collectedAt?: Date | string | null
    societyId: number
    createdAt?: Date | string
  }

  export type UnitMemberCreateManyUnitInput = {
    id?: number
    name: string
    relation: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    email?: string | null
    profileImg?: string | null
    createdAt?: Date | string
  }

  export type UnitVehicleCreateManyUnitInput = {
    id?: number
    name: string
    number: string
    type: string
    color?: string | null
    parkingSlot?: string | null
    createdAt?: Date | string
  }

  export type UnitPetCreateManyUnitInput = {
    id?: number
    name: string
    type: string
    breed?: string | null
    vaccinationStatus?: string
    lastVaccinationDate?: Date | string | null
    createdAt?: Date | string
  }

  export type VisitorUpdateWithoutUnitInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotUpdateWithoutUnitInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutParkingSlotsNestedInput
  }

  export type ParkingSlotUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParcelUpdateWithoutUnitInput = {
    courierName?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutParcelsNestedInput
  }

  export type ParcelUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    courierName?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParcelUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    courierName?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitMemberUpdateWithoutUnitInput = {
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitMemberUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitMemberUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitVehicleUpdateWithoutUnitInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingSlot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitVehicleUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingSlot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitVehicleUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingSlot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitPetUpdateWithoutUnitInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    vaccinationStatus?: StringFieldUpdateOperationsInput | string
    lastVaccinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitPetUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    vaccinationStatus?: StringFieldUpdateOperationsInput | string
    lastVaccinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitPetUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    vaccinationStatus?: StringFieldUpdateOperationsInput | string
    lastVaccinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentCreateManyComplaintInput = {
    id?: number
    userId: number
    message: string
    createdAt?: Date | string
  }

  export type ComplaintCommentUpdateWithoutComplaintInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ComplaintCommentUncheckedUpdateWithoutComplaintInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentUncheckedUpdateManyWithoutComplaintInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPayoutCreateManyVendorInput = {
    id?: number
    vendorName: string
    societyId?: number | null
    societyName?: string | null
    dealValue: number
    commissionPercent: number
    payableAmount: number
    status?: string
    remarks?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorPayoutUpdateWithoutVendorInput = {
    vendorName?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    societyName?: NullableStringFieldUpdateOperationsInput | string | null
    dealValue?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    payableAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPayoutUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorName?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    societyName?: NullableStringFieldUpdateOperationsInput | string | null
    dealValue?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    payableAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPayoutUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorName?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    societyName?: NullableStringFieldUpdateOperationsInput | string | null
    dealValue?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    payableAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingCreateManyAmenityInput = {
    id?: number
    userId: number
    date: Date | string
    startTime: string
    endTime: string
    purpose?: string | null
    status?: string
    amountPaid?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenityBookingUpdateWithoutAmenityInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type AmenityBookingUncheckedUpdateWithoutAmenityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingUncheckedUpdateManyWithoutAmenityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityCommentCreateManyBuzzInput = {
    id?: number
    authorId: number
    content: string
    createdAt?: Date | string
  }

  export type BuzzLikeCreateManyBuzzInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type CommunityCommentUpdateWithoutBuzzInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommunityCommentsNestedInput
  }

  export type CommunityCommentUncheckedUpdateWithoutBuzzInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityCommentUncheckedUpdateManyWithoutBuzzInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuzzLikeUpdateWithoutBuzzInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBuzzLikesNestedInput
  }

  export type BuzzLikeUncheckedUpdateWithoutBuzzInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuzzLikeUncheckedUpdateManyWithoutBuzzInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyConversationInput = {
    id?: number
    senderId: number
    content: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateWithoutConversationInput = {
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutConversationInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutConversationInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceVariantCreateManyCategoryInput = {
    id?: number
    name: string
    price?: number | null
    createdAt?: Date | string
  }

  export type ServiceInquiryCreateManyServiceInput = {
    id?: number
    residentId?: number | null
    societyId?: number | null
    serviceName?: string | null
    type: string
    status?: string
    preferredDate?: string | null
    preferredTime?: string | null
    phone?: string | null
    notes?: string | null
    vendorName?: string | null
    vendorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceVariantUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceVariantUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceVariantUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceInquiryUpdateWithoutServiceInput = {
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    preferredDate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: UserUpdateOneWithoutServiceInquiriesNestedInput
    society?: SocietyUpdateOneWithoutServiceInquiriesNestedInput
  }

  export type ServiceInquiryUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    residentId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    preferredDate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceInquiryUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    residentId?: NullableIntFieldUpdateOperationsInput | number | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    preferredDate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}