
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Society
 * 
 */
export type Society = $Result.DefaultSelection<Prisma.$SocietyPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model ParkingSlot
 * 
 */
export type ParkingSlot = $Result.DefaultSelection<Prisma.$ParkingSlotPayload>
/**
 * Model Complaint
 * 
 */
export type Complaint = $Result.DefaultSelection<Prisma.$ComplaintPayload>
/**
 * Model ComplaintComment
 * 
 */
export type ComplaintComment = $Result.DefaultSelection<Prisma.$ComplaintCommentPayload>
/**
 * Model Visitor
 * 
 */
export type Visitor = $Result.DefaultSelection<Prisma.$VisitorPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model Notice
 * 
 */
export type Notice = $Result.DefaultSelection<Prisma.$NoticePayload>
/**
 * Model Amenity
 * 
 */
export type Amenity = $Result.DefaultSelection<Prisma.$AmenityPayload>
/**
 * Model AmenityBooking
 * 
 */
export type AmenityBooking = $Result.DefaultSelection<Prisma.$AmenityBookingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  RESIDENT: 'RESIDENT',
  GUARD: 'GUARD',
  VENDOR: 'VENDOR',
  ACCOUNTANT: 'ACCOUNTANT'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ComplaintStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type ComplaintStatus = (typeof ComplaintStatus)[keyof typeof ComplaintStatus]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const VisitorStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  CHECKED_IN: 'CHECKED_IN',
  CHECKED_OUT: 'CHECKED_OUT',
  REJECTED: 'REJECTED'
};

export type VisitorStatus = (typeof VisitorStatus)[keyof typeof VisitorStatus]


export const TransactionType: {
  INCOME: 'INCOME',
  EXPENSE: 'EXPENSE'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const PaymentMethod: {
  CASH: 'CASH',
  ONLINE: 'ONLINE',
  UPI: 'UPI',
  CHEQUE: 'CHEQUE'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const SocietyStatus: {
  ACTIVE: 'ACTIVE',
  PENDING: 'PENDING',
  INACTIVE: 'INACTIVE'
};

export type SocietyStatus = (typeof SocietyStatus)[keyof typeof SocietyStatus]


export const SubscriptionPlan: {
  BASIC: 'BASIC',
  PROFESSIONAL: 'PROFESSIONAL',
  ENTERPRISE: 'ENTERPRISE'
};

export type SubscriptionPlan = (typeof SubscriptionPlan)[keyof typeof SubscriptionPlan]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ComplaintStatus = $Enums.ComplaintStatus

export const ComplaintStatus: typeof $Enums.ComplaintStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type VisitorStatus = $Enums.VisitorStatus

export const VisitorStatus: typeof $Enums.VisitorStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type SocietyStatus = $Enums.SocietyStatus

export const SocietyStatus: typeof $Enums.SocietyStatus

export type SubscriptionPlan = $Enums.SubscriptionPlan

export const SubscriptionPlan: typeof $Enums.SubscriptionPlan

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Societies
 * const societies = await prisma.society.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Societies
   * const societies = await prisma.society.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.society`: Exposes CRUD operations for the **Society** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Societies
    * const societies = await prisma.society.findMany()
    * ```
    */
  get society(): Prisma.SocietyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parkingSlot`: Exposes CRUD operations for the **ParkingSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParkingSlots
    * const parkingSlots = await prisma.parkingSlot.findMany()
    * ```
    */
  get parkingSlot(): Prisma.ParkingSlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complaint`: Exposes CRUD operations for the **Complaint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Complaints
    * const complaints = await prisma.complaint.findMany()
    * ```
    */
  get complaint(): Prisma.ComplaintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complaintComment`: Exposes CRUD operations for the **ComplaintComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplaintComments
    * const complaintComments = await prisma.complaintComment.findMany()
    * ```
    */
  get complaintComment(): Prisma.ComplaintCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visitor`: Exposes CRUD operations for the **Visitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visitors
    * const visitors = await prisma.visitor.findMany()
    * ```
    */
  get visitor(): Prisma.VisitorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notice`: Exposes CRUD operations for the **Notice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notices
    * const notices = await prisma.notice.findMany()
    * ```
    */
  get notice(): Prisma.NoticeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amenity`: Exposes CRUD operations for the **Amenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amenities
    * const amenities = await prisma.amenity.findMany()
    * ```
    */
  get amenity(): Prisma.AmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amenityBooking`: Exposes CRUD operations for the **AmenityBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AmenityBookings
    * const amenityBookings = await prisma.amenityBooking.findMany()
    * ```
    */
  get amenityBooking(): Prisma.AmenityBookingDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Society: 'Society',
    User: 'User',
    Unit: 'Unit',
    ParkingSlot: 'ParkingSlot',
    Complaint: 'Complaint',
    ComplaintComment: 'ComplaintComment',
    Visitor: 'Visitor',
    Transaction: 'Transaction',
    Vendor: 'Vendor',
    Notice: 'Notice',
    Amenity: 'Amenity',
    AmenityBooking: 'AmenityBooking'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "society" | "user" | "unit" | "parkingSlot" | "complaint" | "complaintComment" | "visitor" | "transaction" | "vendor" | "notice" | "amenity" | "amenityBooking"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Society: {
        payload: Prisma.$SocietyPayload<ExtArgs>
        fields: Prisma.SocietyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocietyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocietyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          findFirst: {
            args: Prisma.SocietyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocietyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          findMany: {
            args: Prisma.SocietyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>[]
          }
          create: {
            args: Prisma.SocietyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          createMany: {
            args: Prisma.SocietyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SocietyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          update: {
            args: Prisma.SocietyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          deleteMany: {
            args: Prisma.SocietyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocietyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SocietyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          aggregate: {
            args: Prisma.SocietyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSociety>
          }
          groupBy: {
            args: Prisma.SocietyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocietyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocietyCountArgs<ExtArgs>
            result: $Utils.Optional<SocietyCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      ParkingSlot: {
        payload: Prisma.$ParkingSlotPayload<ExtArgs>
        fields: Prisma.ParkingSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParkingSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParkingSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          findFirst: {
            args: Prisma.ParkingSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParkingSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          findMany: {
            args: Prisma.ParkingSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>[]
          }
          create: {
            args: Prisma.ParkingSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          createMany: {
            args: Prisma.ParkingSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ParkingSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          update: {
            args: Prisma.ParkingSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          deleteMany: {
            args: Prisma.ParkingSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParkingSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParkingSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          aggregate: {
            args: Prisma.ParkingSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParkingSlot>
          }
          groupBy: {
            args: Prisma.ParkingSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParkingSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParkingSlotCountArgs<ExtArgs>
            result: $Utils.Optional<ParkingSlotCountAggregateOutputType> | number
          }
        }
      }
      Complaint: {
        payload: Prisma.$ComplaintPayload<ExtArgs>
        fields: Prisma.ComplaintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          findFirst: {
            args: Prisma.ComplaintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          findMany: {
            args: Prisma.ComplaintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>[]
          }
          create: {
            args: Prisma.ComplaintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          createMany: {
            args: Prisma.ComplaintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComplaintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          update: {
            args: Prisma.ComplaintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          deleteMany: {
            args: Prisma.ComplaintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplaintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          aggregate: {
            args: Prisma.ComplaintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaint>
          }
          groupBy: {
            args: Prisma.ComplaintGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintCountAggregateOutputType> | number
          }
        }
      }
      ComplaintComment: {
        payload: Prisma.$ComplaintCommentPayload<ExtArgs>
        fields: Prisma.ComplaintCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          findFirst: {
            args: Prisma.ComplaintCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          findMany: {
            args: Prisma.ComplaintCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>[]
          }
          create: {
            args: Prisma.ComplaintCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          createMany: {
            args: Prisma.ComplaintCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComplaintCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          update: {
            args: Prisma.ComplaintCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          deleteMany: {
            args: Prisma.ComplaintCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplaintCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          aggregate: {
            args: Prisma.ComplaintCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaintComment>
          }
          groupBy: {
            args: Prisma.ComplaintCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintCommentCountAggregateOutputType> | number
          }
        }
      }
      Visitor: {
        payload: Prisma.$VisitorPayload<ExtArgs>
        fields: Prisma.VisitorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          findFirst: {
            args: Prisma.VisitorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          findMany: {
            args: Prisma.VisitorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>[]
          }
          create: {
            args: Prisma.VisitorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          createMany: {
            args: Prisma.VisitorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VisitorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          update: {
            args: Prisma.VisitorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          deleteMany: {
            args: Prisma.VisitorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          aggregate: {
            args: Prisma.VisitorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitor>
          }
          groupBy: {
            args: Prisma.VisitorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitorCountArgs<ExtArgs>
            result: $Utils.Optional<VisitorCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      Notice: {
        payload: Prisma.$NoticePayload<ExtArgs>
        fields: Prisma.NoticeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoticeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoticeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          findFirst: {
            args: Prisma.NoticeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoticeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          findMany: {
            args: Prisma.NoticeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>[]
          }
          create: {
            args: Prisma.NoticeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          createMany: {
            args: Prisma.NoticeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NoticeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          update: {
            args: Prisma.NoticeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          deleteMany: {
            args: Prisma.NoticeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoticeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoticeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          aggregate: {
            args: Prisma.NoticeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotice>
          }
          groupBy: {
            args: Prisma.NoticeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoticeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoticeCountArgs<ExtArgs>
            result: $Utils.Optional<NoticeCountAggregateOutputType> | number
          }
        }
      }
      Amenity: {
        payload: Prisma.$AmenityPayload<ExtArgs>
        fields: Prisma.AmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findFirst: {
            args: Prisma.AmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findMany: {
            args: Prisma.AmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          create: {
            args: Prisma.AmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          createMany: {
            args: Prisma.AmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          update: {
            args: Prisma.AmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          deleteMany: {
            args: Prisma.AmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          aggregate: {
            args: Prisma.AmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmenity>
          }
          groupBy: {
            args: Prisma.AmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmenityCountArgs<ExtArgs>
            result: $Utils.Optional<AmenityCountAggregateOutputType> | number
          }
        }
      }
      AmenityBooking: {
        payload: Prisma.$AmenityBookingPayload<ExtArgs>
        fields: Prisma.AmenityBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmenityBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmenityBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          findFirst: {
            args: Prisma.AmenityBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmenityBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          findMany: {
            args: Prisma.AmenityBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>[]
          }
          create: {
            args: Prisma.AmenityBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          createMany: {
            args: Prisma.AmenityBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AmenityBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          update: {
            args: Prisma.AmenityBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          deleteMany: {
            args: Prisma.AmenityBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmenityBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AmenityBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          aggregate: {
            args: Prisma.AmenityBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmenityBooking>
          }
          groupBy: {
            args: Prisma.AmenityBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmenityBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmenityBookingCountArgs<ExtArgs>
            result: $Utils.Optional<AmenityBookingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    society?: SocietyOmit
    user?: UserOmit
    unit?: UnitOmit
    parkingSlot?: ParkingSlotOmit
    complaint?: ComplaintOmit
    complaintComment?: ComplaintCommentOmit
    visitor?: VisitorOmit
    transaction?: TransactionOmit
    vendor?: VendorOmit
    notice?: NoticeOmit
    amenity?: AmenityOmit
    amenityBooking?: AmenityBookingOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SocietyCountOutputType
   */

  export type SocietyCountOutputType = {
    users: number
    units: number
    complaints: number
    visitors: number
    transactions: number
    notices: number
    vendors: number
    amenities: number
    parkingSlots: number
  }

  export type SocietyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SocietyCountOutputTypeCountUsersArgs
    units?: boolean | SocietyCountOutputTypeCountUnitsArgs
    complaints?: boolean | SocietyCountOutputTypeCountComplaintsArgs
    visitors?: boolean | SocietyCountOutputTypeCountVisitorsArgs
    transactions?: boolean | SocietyCountOutputTypeCountTransactionsArgs
    notices?: boolean | SocietyCountOutputTypeCountNoticesArgs
    vendors?: boolean | SocietyCountOutputTypeCountVendorsArgs
    amenities?: boolean | SocietyCountOutputTypeCountAmenitiesArgs
    parkingSlots?: boolean | SocietyCountOutputTypeCountParkingSlotsArgs
  }

  // Custom InputTypes
  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocietyCountOutputType
     */
    select?: SocietyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountNoticesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoticeWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountAmenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountParkingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingSlotWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ownedUnits: number
    rentedUnits: number
    reportedComplaints: number
    assignedComplaints: number
    bookings: number
    comments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedUnits?: boolean | UserCountOutputTypeCountOwnedUnitsArgs
    rentedUnits?: boolean | UserCountOutputTypeCountRentedUnitsArgs
    reportedComplaints?: boolean | UserCountOutputTypeCountReportedComplaintsArgs
    assignedComplaints?: boolean | UserCountOutputTypeCountAssignedComplaintsArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRentedUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportedComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityBookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintCommentWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    visitors: number
    parkingSlots: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visitors?: boolean | UnitCountOutputTypeCountVisitorsArgs
    parkingSlots?: boolean | UnitCountOutputTypeCountParkingSlotsArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountParkingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingSlotWhereInput
  }


  /**
   * Count Type ComplaintCountOutputType
   */

  export type ComplaintCountOutputType = {
    comments: number
  }

  export type ComplaintCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | ComplaintCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ComplaintCountOutputType without action
   */
  export type ComplaintCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintCountOutputType
     */
    select?: ComplaintCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComplaintCountOutputType without action
   */
  export type ComplaintCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintCommentWhereInput
  }


  /**
   * Count Type AmenityCountOutputType
   */

  export type AmenityCountOutputType = {
    bookings: number
  }

  export type AmenityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | AmenityCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityCountOutputType
     */
    select?: AmenityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityBookingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Society
   */

  export type AggregateSociety = {
    _count: SocietyCountAggregateOutputType | null
    _avg: SocietyAvgAggregateOutputType | null
    _sum: SocietySumAggregateOutputType | null
    _min: SocietyMinAggregateOutputType | null
    _max: SocietyMaxAggregateOutputType | null
  }

  export type SocietyAvgAggregateOutputType = {
    id: number | null
  }

  export type SocietySumAggregateOutputType = {
    id: number | null
  }

  export type SocietyMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    code: string | null
    status: $Enums.SocietyStatus | null
    subscriptionPlan: $Enums.SubscriptionPlan | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocietyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    code: string | null
    status: $Enums.SocietyStatus | null
    subscriptionPlan: $Enums.SubscriptionPlan | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocietyCountAggregateOutputType = {
    id: number
    name: number
    address: number
    code: number
    status: number
    subscriptionPlan: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocietyAvgAggregateInputType = {
    id?: true
  }

  export type SocietySumAggregateInputType = {
    id?: true
  }

  export type SocietyMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    code?: true
    status?: true
    subscriptionPlan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocietyMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    code?: true
    status?: true
    subscriptionPlan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocietyCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    code?: true
    status?: true
    subscriptionPlan?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocietyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Society to aggregate.
     */
    where?: SocietyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Societies to fetch.
     */
    orderBy?: SocietyOrderByWithRelationInput | SocietyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocietyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Societies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Societies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Societies
    **/
    _count?: true | SocietyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SocietyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SocietySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocietyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocietyMaxAggregateInputType
  }

  export type GetSocietyAggregateType<T extends SocietyAggregateArgs> = {
        [P in keyof T & keyof AggregateSociety]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSociety[P]>
      : GetScalarType<T[P], AggregateSociety[P]>
  }




  export type SocietyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocietyWhereInput
    orderBy?: SocietyOrderByWithAggregationInput | SocietyOrderByWithAggregationInput[]
    by: SocietyScalarFieldEnum[] | SocietyScalarFieldEnum
    having?: SocietyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocietyCountAggregateInputType | true
    _avg?: SocietyAvgAggregateInputType
    _sum?: SocietySumAggregateInputType
    _min?: SocietyMinAggregateInputType
    _max?: SocietyMaxAggregateInputType
  }

  export type SocietyGroupByOutputType = {
    id: number
    name: string
    address: string | null
    code: string
    status: $Enums.SocietyStatus
    subscriptionPlan: $Enums.SubscriptionPlan
    createdAt: Date
    updatedAt: Date
    _count: SocietyCountAggregateOutputType | null
    _avg: SocietyAvgAggregateOutputType | null
    _sum: SocietySumAggregateOutputType | null
    _min: SocietyMinAggregateOutputType | null
    _max: SocietyMaxAggregateOutputType | null
  }

  type GetSocietyGroupByPayload<T extends SocietyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocietyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocietyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocietyGroupByOutputType[P]>
            : GetScalarType<T[P], SocietyGroupByOutputType[P]>
        }
      >
    >


  export type SocietySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    code?: boolean
    status?: boolean
    subscriptionPlan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Society$usersArgs<ExtArgs>
    units?: boolean | Society$unitsArgs<ExtArgs>
    complaints?: boolean | Society$complaintsArgs<ExtArgs>
    visitors?: boolean | Society$visitorsArgs<ExtArgs>
    transactions?: boolean | Society$transactionsArgs<ExtArgs>
    notices?: boolean | Society$noticesArgs<ExtArgs>
    vendors?: boolean | Society$vendorsArgs<ExtArgs>
    amenities?: boolean | Society$amenitiesArgs<ExtArgs>
    parkingSlots?: boolean | Society$parkingSlotsArgs<ExtArgs>
    _count?: boolean | SocietyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["society"]>



  export type SocietySelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    code?: boolean
    status?: boolean
    subscriptionPlan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocietyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "code" | "status" | "subscriptionPlan" | "createdAt" | "updatedAt", ExtArgs["result"]["society"]>
  export type SocietyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Society$usersArgs<ExtArgs>
    units?: boolean | Society$unitsArgs<ExtArgs>
    complaints?: boolean | Society$complaintsArgs<ExtArgs>
    visitors?: boolean | Society$visitorsArgs<ExtArgs>
    transactions?: boolean | Society$transactionsArgs<ExtArgs>
    notices?: boolean | Society$noticesArgs<ExtArgs>
    vendors?: boolean | Society$vendorsArgs<ExtArgs>
    amenities?: boolean | Society$amenitiesArgs<ExtArgs>
    parkingSlots?: boolean | Society$parkingSlotsArgs<ExtArgs>
    _count?: boolean | SocietyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SocietyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Society"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      units: Prisma.$UnitPayload<ExtArgs>[]
      complaints: Prisma.$ComplaintPayload<ExtArgs>[]
      visitors: Prisma.$VisitorPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      notices: Prisma.$NoticePayload<ExtArgs>[]
      vendors: Prisma.$VendorPayload<ExtArgs>[]
      amenities: Prisma.$AmenityPayload<ExtArgs>[]
      parkingSlots: Prisma.$ParkingSlotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string | null
      code: string
      status: $Enums.SocietyStatus
      subscriptionPlan: $Enums.SubscriptionPlan
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["society"]>
    composites: {}
  }

  type SocietyGetPayload<S extends boolean | null | undefined | SocietyDefaultArgs> = $Result.GetResult<Prisma.$SocietyPayload, S>

  type SocietyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocietyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocietyCountAggregateInputType | true
    }

  export interface SocietyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Society'], meta: { name: 'Society' } }
    /**
     * Find zero or one Society that matches the filter.
     * @param {SocietyFindUniqueArgs} args - Arguments to find a Society
     * @example
     * // Get one Society
     * const society = await prisma.society.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocietyFindUniqueArgs>(args: SelectSubset<T, SocietyFindUniqueArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Society that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocietyFindUniqueOrThrowArgs} args - Arguments to find a Society
     * @example
     * // Get one Society
     * const society = await prisma.society.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocietyFindUniqueOrThrowArgs>(args: SelectSubset<T, SocietyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Society that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyFindFirstArgs} args - Arguments to find a Society
     * @example
     * // Get one Society
     * const society = await prisma.society.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocietyFindFirstArgs>(args?: SelectSubset<T, SocietyFindFirstArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Society that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyFindFirstOrThrowArgs} args - Arguments to find a Society
     * @example
     * // Get one Society
     * const society = await prisma.society.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocietyFindFirstOrThrowArgs>(args?: SelectSubset<T, SocietyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Societies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Societies
     * const societies = await prisma.society.findMany()
     * 
     * // Get first 10 Societies
     * const societies = await prisma.society.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const societyWithIdOnly = await prisma.society.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocietyFindManyArgs>(args?: SelectSubset<T, SocietyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Society.
     * @param {SocietyCreateArgs} args - Arguments to create a Society.
     * @example
     * // Create one Society
     * const Society = await prisma.society.create({
     *   data: {
     *     // ... data to create a Society
     *   }
     * })
     * 
     */
    create<T extends SocietyCreateArgs>(args: SelectSubset<T, SocietyCreateArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Societies.
     * @param {SocietyCreateManyArgs} args - Arguments to create many Societies.
     * @example
     * // Create many Societies
     * const society = await prisma.society.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocietyCreateManyArgs>(args?: SelectSubset<T, SocietyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Society.
     * @param {SocietyDeleteArgs} args - Arguments to delete one Society.
     * @example
     * // Delete one Society
     * const Society = await prisma.society.delete({
     *   where: {
     *     // ... filter to delete one Society
     *   }
     * })
     * 
     */
    delete<T extends SocietyDeleteArgs>(args: SelectSubset<T, SocietyDeleteArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Society.
     * @param {SocietyUpdateArgs} args - Arguments to update one Society.
     * @example
     * // Update one Society
     * const society = await prisma.society.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocietyUpdateArgs>(args: SelectSubset<T, SocietyUpdateArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Societies.
     * @param {SocietyDeleteManyArgs} args - Arguments to filter Societies to delete.
     * @example
     * // Delete a few Societies
     * const { count } = await prisma.society.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocietyDeleteManyArgs>(args?: SelectSubset<T, SocietyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Societies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Societies
     * const society = await prisma.society.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocietyUpdateManyArgs>(args: SelectSubset<T, SocietyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Society.
     * @param {SocietyUpsertArgs} args - Arguments to update or create a Society.
     * @example
     * // Update or create a Society
     * const society = await prisma.society.upsert({
     *   create: {
     *     // ... data to create a Society
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Society we want to update
     *   }
     * })
     */
    upsert<T extends SocietyUpsertArgs>(args: SelectSubset<T, SocietyUpsertArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Societies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyCountArgs} args - Arguments to filter Societies to count.
     * @example
     * // Count the number of Societies
     * const count = await prisma.society.count({
     *   where: {
     *     // ... the filter for the Societies we want to count
     *   }
     * })
    **/
    count<T extends SocietyCountArgs>(
      args?: Subset<T, SocietyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocietyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Society.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocietyAggregateArgs>(args: Subset<T, SocietyAggregateArgs>): Prisma.PrismaPromise<GetSocietyAggregateType<T>>

    /**
     * Group by Society.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocietyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocietyGroupByArgs['orderBy'] }
        : { orderBy?: SocietyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocietyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocietyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Society model
   */
  readonly fields: SocietyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Society.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocietyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Society$usersArgs<ExtArgs> = {}>(args?: Subset<T, Society$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    units<T extends Society$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Society$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    complaints<T extends Society$complaintsArgs<ExtArgs> = {}>(args?: Subset<T, Society$complaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visitors<T extends Society$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, Society$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Society$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Society$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notices<T extends Society$noticesArgs<ExtArgs> = {}>(args?: Subset<T, Society$noticesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendors<T extends Society$vendorsArgs<ExtArgs> = {}>(args?: Subset<T, Society$vendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    amenities<T extends Society$amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Society$amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parkingSlots<T extends Society$parkingSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Society$parkingSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Society model
   */
  interface SocietyFieldRefs {
    readonly id: FieldRef<"Society", 'Int'>
    readonly name: FieldRef<"Society", 'String'>
    readonly address: FieldRef<"Society", 'String'>
    readonly code: FieldRef<"Society", 'String'>
    readonly status: FieldRef<"Society", 'SocietyStatus'>
    readonly subscriptionPlan: FieldRef<"Society", 'SubscriptionPlan'>
    readonly createdAt: FieldRef<"Society", 'DateTime'>
    readonly updatedAt: FieldRef<"Society", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Society findUnique
   */
  export type SocietyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter, which Society to fetch.
     */
    where: SocietyWhereUniqueInput
  }

  /**
   * Society findUniqueOrThrow
   */
  export type SocietyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter, which Society to fetch.
     */
    where: SocietyWhereUniqueInput
  }

  /**
   * Society findFirst
   */
  export type SocietyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter, which Society to fetch.
     */
    where?: SocietyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Societies to fetch.
     */
    orderBy?: SocietyOrderByWithRelationInput | SocietyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Societies.
     */
    cursor?: SocietyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Societies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Societies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Societies.
     */
    distinct?: SocietyScalarFieldEnum | SocietyScalarFieldEnum[]
  }

  /**
   * Society findFirstOrThrow
   */
  export type SocietyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter, which Society to fetch.
     */
    where?: SocietyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Societies to fetch.
     */
    orderBy?: SocietyOrderByWithRelationInput | SocietyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Societies.
     */
    cursor?: SocietyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Societies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Societies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Societies.
     */
    distinct?: SocietyScalarFieldEnum | SocietyScalarFieldEnum[]
  }

  /**
   * Society findMany
   */
  export type SocietyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter, which Societies to fetch.
     */
    where?: SocietyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Societies to fetch.
     */
    orderBy?: SocietyOrderByWithRelationInput | SocietyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Societies.
     */
    cursor?: SocietyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Societies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Societies.
     */
    skip?: number
    distinct?: SocietyScalarFieldEnum | SocietyScalarFieldEnum[]
  }

  /**
   * Society create
   */
  export type SocietyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * The data needed to create a Society.
     */
    data: XOR<SocietyCreateInput, SocietyUncheckedCreateInput>
  }

  /**
   * Society createMany
   */
  export type SocietyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Societies.
     */
    data: SocietyCreateManyInput | SocietyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Society update
   */
  export type SocietyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * The data needed to update a Society.
     */
    data: XOR<SocietyUpdateInput, SocietyUncheckedUpdateInput>
    /**
     * Choose, which Society to update.
     */
    where: SocietyWhereUniqueInput
  }

  /**
   * Society updateMany
   */
  export type SocietyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Societies.
     */
    data: XOR<SocietyUpdateManyMutationInput, SocietyUncheckedUpdateManyInput>
    /**
     * Filter which Societies to update
     */
    where?: SocietyWhereInput
    /**
     * Limit how many Societies to update.
     */
    limit?: number
  }

  /**
   * Society upsert
   */
  export type SocietyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * The filter to search for the Society to update in case it exists.
     */
    where: SocietyWhereUniqueInput
    /**
     * In case the Society found by the `where` argument doesn't exist, create a new Society with this data.
     */
    create: XOR<SocietyCreateInput, SocietyUncheckedCreateInput>
    /**
     * In case the Society was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocietyUpdateInput, SocietyUncheckedUpdateInput>
  }

  /**
   * Society delete
   */
  export type SocietyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter which Society to delete.
     */
    where: SocietyWhereUniqueInput
  }

  /**
   * Society deleteMany
   */
  export type SocietyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Societies to delete
     */
    where?: SocietyWhereInput
    /**
     * Limit how many Societies to delete.
     */
    limit?: number
  }

  /**
   * Society.users
   */
  export type Society$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Society.units
   */
  export type Society$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Society.complaints
   */
  export type Society$complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    cursor?: ComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Society.visitors
   */
  export type Society$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    cursor?: VisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Society.transactions
   */
  export type Society$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Society.notices
   */
  export type Society$noticesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    where?: NoticeWhereInput
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    cursor?: NoticeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Society.vendors
   */
  export type Society$vendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    cursor?: VendorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Society.amenities
   */
  export type Society$amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    where?: AmenityWhereInput
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    cursor?: AmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Society.parkingSlots
   */
  export type Society$parkingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    where?: ParkingSlotWhereInput
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    cursor?: ParkingSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * Society without action
   */
  export type SocietyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    role: $Enums.Role | null
    profileImg: string | null
    societyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    role: $Enums.Role | null
    profileImg: string | null
    societyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    phone: number
    role: number
    profileImg: number
    societyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    role?: true
    profileImg?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    role?: true
    profileImg?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    role?: true
    profileImg?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string
    phone: string | null
    role: $Enums.Role
    profileImg: string | null
    societyId: number | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    profileImg?: boolean
    societyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | User$societyArgs<ExtArgs>
    ownedUnits?: boolean | User$ownedUnitsArgs<ExtArgs>
    rentedUnits?: boolean | User$rentedUnitsArgs<ExtArgs>
    reportedComplaints?: boolean | User$reportedComplaintsArgs<ExtArgs>
    assignedComplaints?: boolean | User$assignedComplaintsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    profileImg?: boolean
    societyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "phone" | "role" | "profileImg" | "societyId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | User$societyArgs<ExtArgs>
    ownedUnits?: boolean | User$ownedUnitsArgs<ExtArgs>
    rentedUnits?: boolean | User$rentedUnitsArgs<ExtArgs>
    reportedComplaints?: boolean | User$reportedComplaintsArgs<ExtArgs>
    assignedComplaints?: boolean | User$assignedComplaintsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs> | null
      ownedUnits: Prisma.$UnitPayload<ExtArgs>[]
      rentedUnits: Prisma.$UnitPayload<ExtArgs>[]
      reportedComplaints: Prisma.$ComplaintPayload<ExtArgs>[]
      assignedComplaints: Prisma.$ComplaintPayload<ExtArgs>[]
      bookings: Prisma.$AmenityBookingPayload<ExtArgs>[]
      comments: Prisma.$ComplaintCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string
      phone: string | null
      role: $Enums.Role
      profileImg: string | null
      societyId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends User$societyArgs<ExtArgs> = {}>(args?: Subset<T, User$societyArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ownedUnits<T extends User$ownedUnitsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedUnitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rentedUnits<T extends User$rentedUnitsArgs<ExtArgs> = {}>(args?: Subset<T, User$rentedUnitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportedComplaints<T extends User$reportedComplaintsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportedComplaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedComplaints<T extends User$assignedComplaintsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedComplaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly profileImg: FieldRef<"User", 'String'>
    readonly societyId: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.society
   */
  export type User$societyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    where?: SocietyWhereInput
  }

  /**
   * User.ownedUnits
   */
  export type User$ownedUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * User.rentedUnits
   */
  export type User$rentedUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * User.reportedComplaints
   */
  export type User$reportedComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    cursor?: ComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * User.assignedComplaints
   */
  export type User$assignedComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    cursor?: ComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    where?: AmenityBookingWhereInput
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    cursor?: AmenityBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmenityBookingScalarFieldEnum | AmenityBookingScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    where?: ComplaintCommentWhereInput
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    cursor?: ComplaintCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintCommentScalarFieldEnum | ComplaintCommentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    id: number | null
    floor: number | null
    areaSqFt: number | null
    societyId: number | null
    ownerId: number | null
    tenantId: number | null
  }

  export type UnitSumAggregateOutputType = {
    id: number | null
    floor: number | null
    areaSqFt: number | null
    societyId: number | null
    ownerId: number | null
    tenantId: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: number | null
    block: string | null
    number: string | null
    floor: number | null
    type: string | null
    areaSqFt: number | null
    societyId: number | null
    ownerId: number | null
    tenantId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    id: number | null
    block: string | null
    number: string | null
    floor: number | null
    type: string | null
    areaSqFt: number | null
    societyId: number | null
    ownerId: number | null
    tenantId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    block: number
    number: number
    floor: number
    type: number
    areaSqFt: number
    societyId: number
    ownerId: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    id?: true
    floor?: true
    areaSqFt?: true
    societyId?: true
    ownerId?: true
    tenantId?: true
  }

  export type UnitSumAggregateInputType = {
    id?: true
    floor?: true
    areaSqFt?: true
    societyId?: true
    ownerId?: true
    tenantId?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    block?: true
    number?: true
    floor?: true
    type?: true
    areaSqFt?: true
    societyId?: true
    ownerId?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    block?: true
    number?: true
    floor?: true
    type?: true
    areaSqFt?: true
    societyId?: true
    ownerId?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    block?: true
    number?: true
    floor?: true
    type?: true
    areaSqFt?: true
    societyId?: true
    ownerId?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    ownerId: number | null
    tenantId: number | null
    createdAt: Date
    updatedAt: Date
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    block?: boolean
    number?: boolean
    floor?: boolean
    type?: boolean
    areaSqFt?: boolean
    societyId?: boolean
    ownerId?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    owner?: boolean | Unit$ownerArgs<ExtArgs>
    tenant?: boolean | Unit$tenantArgs<ExtArgs>
    visitors?: boolean | Unit$visitorsArgs<ExtArgs>
    parkingSlots?: boolean | Unit$parkingSlotsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>



  export type UnitSelectScalar = {
    id?: boolean
    block?: boolean
    number?: boolean
    floor?: boolean
    type?: boolean
    areaSqFt?: boolean
    societyId?: boolean
    ownerId?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "block" | "number" | "floor" | "type" | "areaSqFt" | "societyId" | "ownerId" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    owner?: boolean | Unit$ownerArgs<ExtArgs>
    tenant?: boolean | Unit$tenantArgs<ExtArgs>
    visitors?: boolean | Unit$visitorsArgs<ExtArgs>
    parkingSlots?: boolean | Unit$parkingSlotsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs> | null
      tenant: Prisma.$UserPayload<ExtArgs> | null
      visitors: Prisma.$VisitorPayload<ExtArgs>[]
      parkingSlots: Prisma.$ParkingSlotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      block: string
      number: string
      floor: number
      type: string
      areaSqFt: number
      societyId: number
      ownerId: number | null
      tenantId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends Unit$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Unit$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenant<T extends Unit$tenantArgs<ExtArgs> = {}>(args?: Subset<T, Unit$tenantArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    visitors<T extends Unit$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parkingSlots<T extends Unit$parkingSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$parkingSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'Int'>
    readonly block: FieldRef<"Unit", 'String'>
    readonly number: FieldRef<"Unit", 'String'>
    readonly floor: FieldRef<"Unit", 'Int'>
    readonly type: FieldRef<"Unit", 'String'>
    readonly areaSqFt: FieldRef<"Unit", 'Float'>
    readonly societyId: FieldRef<"Unit", 'Int'>
    readonly ownerId: FieldRef<"Unit", 'Int'>
    readonly tenantId: FieldRef<"Unit", 'Int'>
    readonly createdAt: FieldRef<"Unit", 'DateTime'>
    readonly updatedAt: FieldRef<"Unit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.owner
   */
  export type Unit$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Unit.tenant
   */
  export type Unit$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Unit.visitors
   */
  export type Unit$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    cursor?: VisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Unit.parkingSlots
   */
  export type Unit$parkingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    where?: ParkingSlotWhereInput
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    cursor?: ParkingSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model ParkingSlot
   */

  export type AggregateParkingSlot = {
    _count: ParkingSlotCountAggregateOutputType | null
    _avg: ParkingSlotAvgAggregateOutputType | null
    _sum: ParkingSlotSumAggregateOutputType | null
    _min: ParkingSlotMinAggregateOutputType | null
    _max: ParkingSlotMaxAggregateOutputType | null
  }

  export type ParkingSlotAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
    allocatedToUnitId: number | null
  }

  export type ParkingSlotSumAggregateOutputType = {
    id: number | null
    societyId: number | null
    allocatedToUnitId: number | null
  }

  export type ParkingSlotMinAggregateOutputType = {
    id: number | null
    number: string | null
    type: string | null
    status: string | null
    societyId: number | null
    allocatedToUnitId: number | null
    vehicleNumber: string | null
    createdAt: Date | null
  }

  export type ParkingSlotMaxAggregateOutputType = {
    id: number | null
    number: string | null
    type: string | null
    status: string | null
    societyId: number | null
    allocatedToUnitId: number | null
    vehicleNumber: string | null
    createdAt: Date | null
  }

  export type ParkingSlotCountAggregateOutputType = {
    id: number
    number: number
    type: number
    status: number
    societyId: number
    allocatedToUnitId: number
    vehicleNumber: number
    createdAt: number
    _all: number
  }


  export type ParkingSlotAvgAggregateInputType = {
    id?: true
    societyId?: true
    allocatedToUnitId?: true
  }

  export type ParkingSlotSumAggregateInputType = {
    id?: true
    societyId?: true
    allocatedToUnitId?: true
  }

  export type ParkingSlotMinAggregateInputType = {
    id?: true
    number?: true
    type?: true
    status?: true
    societyId?: true
    allocatedToUnitId?: true
    vehicleNumber?: true
    createdAt?: true
  }

  export type ParkingSlotMaxAggregateInputType = {
    id?: true
    number?: true
    type?: true
    status?: true
    societyId?: true
    allocatedToUnitId?: true
    vehicleNumber?: true
    createdAt?: true
  }

  export type ParkingSlotCountAggregateInputType = {
    id?: true
    number?: true
    type?: true
    status?: true
    societyId?: true
    allocatedToUnitId?: true
    vehicleNumber?: true
    createdAt?: true
    _all?: true
  }

  export type ParkingSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParkingSlot to aggregate.
     */
    where?: ParkingSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingSlots to fetch.
     */
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParkingSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParkingSlots
    **/
    _count?: true | ParkingSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParkingSlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParkingSlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParkingSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParkingSlotMaxAggregateInputType
  }

  export type GetParkingSlotAggregateType<T extends ParkingSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateParkingSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParkingSlot[P]>
      : GetScalarType<T[P], AggregateParkingSlot[P]>
  }




  export type ParkingSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingSlotWhereInput
    orderBy?: ParkingSlotOrderByWithAggregationInput | ParkingSlotOrderByWithAggregationInput[]
    by: ParkingSlotScalarFieldEnum[] | ParkingSlotScalarFieldEnum
    having?: ParkingSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParkingSlotCountAggregateInputType | true
    _avg?: ParkingSlotAvgAggregateInputType
    _sum?: ParkingSlotSumAggregateInputType
    _min?: ParkingSlotMinAggregateInputType
    _max?: ParkingSlotMaxAggregateInputType
  }

  export type ParkingSlotGroupByOutputType = {
    id: number
    number: string
    type: string
    status: string
    societyId: number
    allocatedToUnitId: number | null
    vehicleNumber: string | null
    createdAt: Date
    _count: ParkingSlotCountAggregateOutputType | null
    _avg: ParkingSlotAvgAggregateOutputType | null
    _sum: ParkingSlotSumAggregateOutputType | null
    _min: ParkingSlotMinAggregateOutputType | null
    _max: ParkingSlotMaxAggregateOutputType | null
  }

  type GetParkingSlotGroupByPayload<T extends ParkingSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParkingSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParkingSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParkingSlotGroupByOutputType[P]>
            : GetScalarType<T[P], ParkingSlotGroupByOutputType[P]>
        }
      >
    >


  export type ParkingSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    type?: boolean
    status?: boolean
    societyId?: boolean
    allocatedToUnitId?: boolean
    vehicleNumber?: boolean
    createdAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    unit?: boolean | ParkingSlot$unitArgs<ExtArgs>
  }, ExtArgs["result"]["parkingSlot"]>



  export type ParkingSlotSelectScalar = {
    id?: boolean
    number?: boolean
    type?: boolean
    status?: boolean
    societyId?: boolean
    allocatedToUnitId?: boolean
    vehicleNumber?: boolean
    createdAt?: boolean
  }

  export type ParkingSlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "type" | "status" | "societyId" | "allocatedToUnitId" | "vehicleNumber" | "createdAt", ExtArgs["result"]["parkingSlot"]>
  export type ParkingSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    unit?: boolean | ParkingSlot$unitArgs<ExtArgs>
  }

  export type $ParkingSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParkingSlot"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: string
      type: string
      status: string
      societyId: number
      allocatedToUnitId: number | null
      vehicleNumber: string | null
      createdAt: Date
    }, ExtArgs["result"]["parkingSlot"]>
    composites: {}
  }

  type ParkingSlotGetPayload<S extends boolean | null | undefined | ParkingSlotDefaultArgs> = $Result.GetResult<Prisma.$ParkingSlotPayload, S>

  type ParkingSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParkingSlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParkingSlotCountAggregateInputType | true
    }

  export interface ParkingSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParkingSlot'], meta: { name: 'ParkingSlot' } }
    /**
     * Find zero or one ParkingSlot that matches the filter.
     * @param {ParkingSlotFindUniqueArgs} args - Arguments to find a ParkingSlot
     * @example
     * // Get one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParkingSlotFindUniqueArgs>(args: SelectSubset<T, ParkingSlotFindUniqueArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParkingSlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParkingSlotFindUniqueOrThrowArgs} args - Arguments to find a ParkingSlot
     * @example
     * // Get one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParkingSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, ParkingSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParkingSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotFindFirstArgs} args - Arguments to find a ParkingSlot
     * @example
     * // Get one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParkingSlotFindFirstArgs>(args?: SelectSubset<T, ParkingSlotFindFirstArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParkingSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotFindFirstOrThrowArgs} args - Arguments to find a ParkingSlot
     * @example
     * // Get one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParkingSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, ParkingSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParkingSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParkingSlots
     * const parkingSlots = await prisma.parkingSlot.findMany()
     * 
     * // Get first 10 ParkingSlots
     * const parkingSlots = await prisma.parkingSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parkingSlotWithIdOnly = await prisma.parkingSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParkingSlotFindManyArgs>(args?: SelectSubset<T, ParkingSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParkingSlot.
     * @param {ParkingSlotCreateArgs} args - Arguments to create a ParkingSlot.
     * @example
     * // Create one ParkingSlot
     * const ParkingSlot = await prisma.parkingSlot.create({
     *   data: {
     *     // ... data to create a ParkingSlot
     *   }
     * })
     * 
     */
    create<T extends ParkingSlotCreateArgs>(args: SelectSubset<T, ParkingSlotCreateArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParkingSlots.
     * @param {ParkingSlotCreateManyArgs} args - Arguments to create many ParkingSlots.
     * @example
     * // Create many ParkingSlots
     * const parkingSlot = await prisma.parkingSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParkingSlotCreateManyArgs>(args?: SelectSubset<T, ParkingSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ParkingSlot.
     * @param {ParkingSlotDeleteArgs} args - Arguments to delete one ParkingSlot.
     * @example
     * // Delete one ParkingSlot
     * const ParkingSlot = await prisma.parkingSlot.delete({
     *   where: {
     *     // ... filter to delete one ParkingSlot
     *   }
     * })
     * 
     */
    delete<T extends ParkingSlotDeleteArgs>(args: SelectSubset<T, ParkingSlotDeleteArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParkingSlot.
     * @param {ParkingSlotUpdateArgs} args - Arguments to update one ParkingSlot.
     * @example
     * // Update one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParkingSlotUpdateArgs>(args: SelectSubset<T, ParkingSlotUpdateArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParkingSlots.
     * @param {ParkingSlotDeleteManyArgs} args - Arguments to filter ParkingSlots to delete.
     * @example
     * // Delete a few ParkingSlots
     * const { count } = await prisma.parkingSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParkingSlotDeleteManyArgs>(args?: SelectSubset<T, ParkingSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParkingSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParkingSlots
     * const parkingSlot = await prisma.parkingSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParkingSlotUpdateManyArgs>(args: SelectSubset<T, ParkingSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ParkingSlot.
     * @param {ParkingSlotUpsertArgs} args - Arguments to update or create a ParkingSlot.
     * @example
     * // Update or create a ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.upsert({
     *   create: {
     *     // ... data to create a ParkingSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParkingSlot we want to update
     *   }
     * })
     */
    upsert<T extends ParkingSlotUpsertArgs>(args: SelectSubset<T, ParkingSlotUpsertArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParkingSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotCountArgs} args - Arguments to filter ParkingSlots to count.
     * @example
     * // Count the number of ParkingSlots
     * const count = await prisma.parkingSlot.count({
     *   where: {
     *     // ... the filter for the ParkingSlots we want to count
     *   }
     * })
    **/
    count<T extends ParkingSlotCountArgs>(
      args?: Subset<T, ParkingSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParkingSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParkingSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParkingSlotAggregateArgs>(args: Subset<T, ParkingSlotAggregateArgs>): Prisma.PrismaPromise<GetParkingSlotAggregateType<T>>

    /**
     * Group by ParkingSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParkingSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParkingSlotGroupByArgs['orderBy'] }
        : { orderBy?: ParkingSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParkingSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParkingSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParkingSlot model
   */
  readonly fields: ParkingSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParkingSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParkingSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends ParkingSlot$unitArgs<ExtArgs> = {}>(args?: Subset<T, ParkingSlot$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParkingSlot model
   */
  interface ParkingSlotFieldRefs {
    readonly id: FieldRef<"ParkingSlot", 'Int'>
    readonly number: FieldRef<"ParkingSlot", 'String'>
    readonly type: FieldRef<"ParkingSlot", 'String'>
    readonly status: FieldRef<"ParkingSlot", 'String'>
    readonly societyId: FieldRef<"ParkingSlot", 'Int'>
    readonly allocatedToUnitId: FieldRef<"ParkingSlot", 'Int'>
    readonly vehicleNumber: FieldRef<"ParkingSlot", 'String'>
    readonly createdAt: FieldRef<"ParkingSlot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParkingSlot findUnique
   */
  export type ParkingSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlot to fetch.
     */
    where: ParkingSlotWhereUniqueInput
  }

  /**
   * ParkingSlot findUniqueOrThrow
   */
  export type ParkingSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlot to fetch.
     */
    where: ParkingSlotWhereUniqueInput
  }

  /**
   * ParkingSlot findFirst
   */
  export type ParkingSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlot to fetch.
     */
    where?: ParkingSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingSlots to fetch.
     */
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParkingSlots.
     */
    cursor?: ParkingSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParkingSlots.
     */
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * ParkingSlot findFirstOrThrow
   */
  export type ParkingSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlot to fetch.
     */
    where?: ParkingSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingSlots to fetch.
     */
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParkingSlots.
     */
    cursor?: ParkingSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParkingSlots.
     */
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * ParkingSlot findMany
   */
  export type ParkingSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlots to fetch.
     */
    where?: ParkingSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingSlots to fetch.
     */
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParkingSlots.
     */
    cursor?: ParkingSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingSlots.
     */
    skip?: number
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * ParkingSlot create
   */
  export type ParkingSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a ParkingSlot.
     */
    data: XOR<ParkingSlotCreateInput, ParkingSlotUncheckedCreateInput>
  }

  /**
   * ParkingSlot createMany
   */
  export type ParkingSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParkingSlots.
     */
    data: ParkingSlotCreateManyInput | ParkingSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParkingSlot update
   */
  export type ParkingSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a ParkingSlot.
     */
    data: XOR<ParkingSlotUpdateInput, ParkingSlotUncheckedUpdateInput>
    /**
     * Choose, which ParkingSlot to update.
     */
    where: ParkingSlotWhereUniqueInput
  }

  /**
   * ParkingSlot updateMany
   */
  export type ParkingSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParkingSlots.
     */
    data: XOR<ParkingSlotUpdateManyMutationInput, ParkingSlotUncheckedUpdateManyInput>
    /**
     * Filter which ParkingSlots to update
     */
    where?: ParkingSlotWhereInput
    /**
     * Limit how many ParkingSlots to update.
     */
    limit?: number
  }

  /**
   * ParkingSlot upsert
   */
  export type ParkingSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the ParkingSlot to update in case it exists.
     */
    where: ParkingSlotWhereUniqueInput
    /**
     * In case the ParkingSlot found by the `where` argument doesn't exist, create a new ParkingSlot with this data.
     */
    create: XOR<ParkingSlotCreateInput, ParkingSlotUncheckedCreateInput>
    /**
     * In case the ParkingSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParkingSlotUpdateInput, ParkingSlotUncheckedUpdateInput>
  }

  /**
   * ParkingSlot delete
   */
  export type ParkingSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter which ParkingSlot to delete.
     */
    where: ParkingSlotWhereUniqueInput
  }

  /**
   * ParkingSlot deleteMany
   */
  export type ParkingSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParkingSlots to delete
     */
    where?: ParkingSlotWhereInput
    /**
     * Limit how many ParkingSlots to delete.
     */
    limit?: number
  }

  /**
   * ParkingSlot.unit
   */
  export type ParkingSlot$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * ParkingSlot without action
   */
  export type ParkingSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
  }


  /**
   * Model Complaint
   */

  export type AggregateComplaint = {
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  export type ComplaintAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
    reportedById: number | null
    assignedToId: number | null
  }

  export type ComplaintSumAggregateOutputType = {
    id: number | null
    societyId: number | null
    reportedById: number | null
    assignedToId: number | null
  }

  export type ComplaintMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    category: string | null
    priority: $Enums.Priority | null
    status: $Enums.ComplaintStatus | null
    societyId: number | null
    reportedById: number | null
    assignedToId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplaintMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    category: string | null
    priority: $Enums.Priority | null
    status: $Enums.ComplaintStatus | null
    societyId: number | null
    reportedById: number | null
    assignedToId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplaintCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    priority: number
    status: number
    images: number
    societyId: number
    reportedById: number
    assignedToId: number
    timeline: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComplaintAvgAggregateInputType = {
    id?: true
    societyId?: true
    reportedById?: true
    assignedToId?: true
  }

  export type ComplaintSumAggregateInputType = {
    id?: true
    societyId?: true
    reportedById?: true
    assignedToId?: true
  }

  export type ComplaintMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    societyId?: true
    reportedById?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplaintMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    societyId?: true
    reportedById?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplaintCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    images?: true
    societyId?: true
    reportedById?: true
    assignedToId?: true
    timeline?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComplaintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaint to aggregate.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Complaints
    **/
    _count?: true | ComplaintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintMaxAggregateInputType
  }

  export type GetComplaintAggregateType<T extends ComplaintAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaint[P]>
      : GetScalarType<T[P], AggregateComplaint[P]>
  }




  export type ComplaintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithAggregationInput | ComplaintOrderByWithAggregationInput[]
    by: ComplaintScalarFieldEnum[] | ComplaintScalarFieldEnum
    having?: ComplaintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintCountAggregateInputType | true
    _avg?: ComplaintAvgAggregateInputType
    _sum?: ComplaintSumAggregateInputType
    _min?: ComplaintMinAggregateInputType
    _max?: ComplaintMaxAggregateInputType
  }

  export type ComplaintGroupByOutputType = {
    id: number
    title: string
    description: string
    category: string
    priority: $Enums.Priority
    status: $Enums.ComplaintStatus
    images: JsonValue | null
    societyId: number
    reportedById: number
    assignedToId: number | null
    timeline: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  type GetComplaintGroupByPayload<T extends ComplaintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    images?: boolean
    societyId?: boolean
    reportedById?: boolean
    assignedToId?: boolean
    timeline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Complaint$assignedToArgs<ExtArgs>
    comments?: boolean | Complaint$commentsArgs<ExtArgs>
    _count?: boolean | ComplaintCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaint"]>



  export type ComplaintSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    images?: boolean
    societyId?: boolean
    reportedById?: boolean
    assignedToId?: boolean
    timeline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComplaintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "category" | "priority" | "status" | "images" | "societyId" | "reportedById" | "assignedToId" | "timeline" | "createdAt" | "updatedAt", ExtArgs["result"]["complaint"]>
  export type ComplaintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Complaint$assignedToArgs<ExtArgs>
    comments?: boolean | Complaint$commentsArgs<ExtArgs>
    _count?: boolean | ComplaintCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ComplaintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Complaint"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      reportedBy: Prisma.$UserPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      comments: Prisma.$ComplaintCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      category: string
      priority: $Enums.Priority
      status: $Enums.ComplaintStatus
      images: Prisma.JsonValue | null
      societyId: number
      reportedById: number
      assignedToId: number | null
      timeline: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["complaint"]>
    composites: {}
  }

  type ComplaintGetPayload<S extends boolean | null | undefined | ComplaintDefaultArgs> = $Result.GetResult<Prisma.$ComplaintPayload, S>

  type ComplaintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplaintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplaintCountAggregateInputType | true
    }

  export interface ComplaintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Complaint'], meta: { name: 'Complaint' } }
    /**
     * Find zero or one Complaint that matches the filter.
     * @param {ComplaintFindUniqueArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintFindUniqueArgs>(args: SelectSubset<T, ComplaintFindUniqueArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Complaint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplaintFindUniqueOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintFindFirstArgs>(args?: SelectSubset<T, ComplaintFindFirstArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complaints
     * const complaints = await prisma.complaint.findMany()
     * 
     * // Get first 10 Complaints
     * const complaints = await prisma.complaint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintWithIdOnly = await prisma.complaint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplaintFindManyArgs>(args?: SelectSubset<T, ComplaintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Complaint.
     * @param {ComplaintCreateArgs} args - Arguments to create a Complaint.
     * @example
     * // Create one Complaint
     * const Complaint = await prisma.complaint.create({
     *   data: {
     *     // ... data to create a Complaint
     *   }
     * })
     * 
     */
    create<T extends ComplaintCreateArgs>(args: SelectSubset<T, ComplaintCreateArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Complaints.
     * @param {ComplaintCreateManyArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaint = await prisma.complaint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintCreateManyArgs>(args?: SelectSubset<T, ComplaintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Complaint.
     * @param {ComplaintDeleteArgs} args - Arguments to delete one Complaint.
     * @example
     * // Delete one Complaint
     * const Complaint = await prisma.complaint.delete({
     *   where: {
     *     // ... filter to delete one Complaint
     *   }
     * })
     * 
     */
    delete<T extends ComplaintDeleteArgs>(args: SelectSubset<T, ComplaintDeleteArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Complaint.
     * @param {ComplaintUpdateArgs} args - Arguments to update one Complaint.
     * @example
     * // Update one Complaint
     * const complaint = await prisma.complaint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintUpdateArgs>(args: SelectSubset<T, ComplaintUpdateArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Complaints.
     * @param {ComplaintDeleteManyArgs} args - Arguments to filter Complaints to delete.
     * @example
     * // Delete a few Complaints
     * const { count } = await prisma.complaint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintDeleteManyArgs>(args?: SelectSubset<T, ComplaintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complaints
     * const complaint = await prisma.complaint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintUpdateManyArgs>(args: SelectSubset<T, ComplaintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Complaint.
     * @param {ComplaintUpsertArgs} args - Arguments to update or create a Complaint.
     * @example
     * // Update or create a Complaint
     * const complaint = await prisma.complaint.upsert({
     *   create: {
     *     // ... data to create a Complaint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complaint we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintUpsertArgs>(args: SelectSubset<T, ComplaintUpsertArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCountArgs} args - Arguments to filter Complaints to count.
     * @example
     * // Count the number of Complaints
     * const count = await prisma.complaint.count({
     *   where: {
     *     // ... the filter for the Complaints we want to count
     *   }
     * })
    **/
    count<T extends ComplaintCountArgs>(
      args?: Subset<T, ComplaintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintAggregateArgs>(args: Subset<T, ComplaintAggregateArgs>): Prisma.PrismaPromise<GetComplaintAggregateType<T>>

    /**
     * Group by Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Complaint model
   */
  readonly fields: ComplaintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Complaint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reportedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends Complaint$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Complaint$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comments<T extends Complaint$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Complaint$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Complaint model
   */
  interface ComplaintFieldRefs {
    readonly id: FieldRef<"Complaint", 'Int'>
    readonly title: FieldRef<"Complaint", 'String'>
    readonly description: FieldRef<"Complaint", 'String'>
    readonly category: FieldRef<"Complaint", 'String'>
    readonly priority: FieldRef<"Complaint", 'Priority'>
    readonly status: FieldRef<"Complaint", 'ComplaintStatus'>
    readonly images: FieldRef<"Complaint", 'Json'>
    readonly societyId: FieldRef<"Complaint", 'Int'>
    readonly reportedById: FieldRef<"Complaint", 'Int'>
    readonly assignedToId: FieldRef<"Complaint", 'Int'>
    readonly timeline: FieldRef<"Complaint", 'Json'>
    readonly createdAt: FieldRef<"Complaint", 'DateTime'>
    readonly updatedAt: FieldRef<"Complaint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Complaint findUnique
   */
  export type ComplaintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint findUniqueOrThrow
   */
  export type ComplaintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint findFirst
   */
  export type ComplaintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint findFirstOrThrow
   */
  export type ComplaintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint findMany
   */
  export type ComplaintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaints to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint create
   */
  export type ComplaintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The data needed to create a Complaint.
     */
    data: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>
  }

  /**
   * Complaint createMany
   */
  export type ComplaintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Complaints.
     */
    data: ComplaintCreateManyInput | ComplaintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Complaint update
   */
  export type ComplaintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The data needed to update a Complaint.
     */
    data: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>
    /**
     * Choose, which Complaint to update.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint updateMany
   */
  export type ComplaintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Complaints.
     */
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyInput>
    /**
     * Filter which Complaints to update
     */
    where?: ComplaintWhereInput
    /**
     * Limit how many Complaints to update.
     */
    limit?: number
  }

  /**
   * Complaint upsert
   */
  export type ComplaintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The filter to search for the Complaint to update in case it exists.
     */
    where: ComplaintWhereUniqueInput
    /**
     * In case the Complaint found by the `where` argument doesn't exist, create a new Complaint with this data.
     */
    create: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>
    /**
     * In case the Complaint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>
  }

  /**
   * Complaint delete
   */
  export type ComplaintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter which Complaint to delete.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint deleteMany
   */
  export type ComplaintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaints to delete
     */
    where?: ComplaintWhereInput
    /**
     * Limit how many Complaints to delete.
     */
    limit?: number
  }

  /**
   * Complaint.assignedTo
   */
  export type Complaint$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Complaint.comments
   */
  export type Complaint$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    where?: ComplaintCommentWhereInput
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    cursor?: ComplaintCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintCommentScalarFieldEnum | ComplaintCommentScalarFieldEnum[]
  }

  /**
   * Complaint without action
   */
  export type ComplaintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
  }


  /**
   * Model ComplaintComment
   */

  export type AggregateComplaintComment = {
    _count: ComplaintCommentCountAggregateOutputType | null
    _avg: ComplaintCommentAvgAggregateOutputType | null
    _sum: ComplaintCommentSumAggregateOutputType | null
    _min: ComplaintCommentMinAggregateOutputType | null
    _max: ComplaintCommentMaxAggregateOutputType | null
  }

  export type ComplaintCommentAvgAggregateOutputType = {
    id: number | null
    complaintId: number | null
    userId: number | null
  }

  export type ComplaintCommentSumAggregateOutputType = {
    id: number | null
    complaintId: number | null
    userId: number | null
  }

  export type ComplaintCommentMinAggregateOutputType = {
    id: number | null
    complaintId: number | null
    userId: number | null
    message: string | null
    createdAt: Date | null
  }

  export type ComplaintCommentMaxAggregateOutputType = {
    id: number | null
    complaintId: number | null
    userId: number | null
    message: string | null
    createdAt: Date | null
  }

  export type ComplaintCommentCountAggregateOutputType = {
    id: number
    complaintId: number
    userId: number
    message: number
    createdAt: number
    _all: number
  }


  export type ComplaintCommentAvgAggregateInputType = {
    id?: true
    complaintId?: true
    userId?: true
  }

  export type ComplaintCommentSumAggregateInputType = {
    id?: true
    complaintId?: true
    userId?: true
  }

  export type ComplaintCommentMinAggregateInputType = {
    id?: true
    complaintId?: true
    userId?: true
    message?: true
    createdAt?: true
  }

  export type ComplaintCommentMaxAggregateInputType = {
    id?: true
    complaintId?: true
    userId?: true
    message?: true
    createdAt?: true
  }

  export type ComplaintCommentCountAggregateInputType = {
    id?: true
    complaintId?: true
    userId?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type ComplaintCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplaintComment to aggregate.
     */
    where?: ComplaintCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintComments to fetch.
     */
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplaintComments
    **/
    _count?: true | ComplaintCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintCommentMaxAggregateInputType
  }

  export type GetComplaintCommentAggregateType<T extends ComplaintCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaintComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaintComment[P]>
      : GetScalarType<T[P], AggregateComplaintComment[P]>
  }




  export type ComplaintCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintCommentWhereInput
    orderBy?: ComplaintCommentOrderByWithAggregationInput | ComplaintCommentOrderByWithAggregationInput[]
    by: ComplaintCommentScalarFieldEnum[] | ComplaintCommentScalarFieldEnum
    having?: ComplaintCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintCommentCountAggregateInputType | true
    _avg?: ComplaintCommentAvgAggregateInputType
    _sum?: ComplaintCommentSumAggregateInputType
    _min?: ComplaintCommentMinAggregateInputType
    _max?: ComplaintCommentMaxAggregateInputType
  }

  export type ComplaintCommentGroupByOutputType = {
    id: number
    complaintId: number
    userId: number
    message: string
    createdAt: Date
    _count: ComplaintCommentCountAggregateOutputType | null
    _avg: ComplaintCommentAvgAggregateOutputType | null
    _sum: ComplaintCommentSumAggregateOutputType | null
    _min: ComplaintCommentMinAggregateOutputType | null
    _max: ComplaintCommentMaxAggregateOutputType | null
  }

  type GetComplaintCommentGroupByPayload<T extends ComplaintCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintCommentGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    complaintId?: boolean
    userId?: boolean
    message?: boolean
    createdAt?: boolean
    complaint?: boolean | ComplaintDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaintComment"]>



  export type ComplaintCommentSelectScalar = {
    id?: boolean
    complaintId?: boolean
    userId?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type ComplaintCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "complaintId" | "userId" | "message" | "createdAt", ExtArgs["result"]["complaintComment"]>
  export type ComplaintCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaint?: boolean | ComplaintDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ComplaintCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplaintComment"
    objects: {
      complaint: Prisma.$ComplaintPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      complaintId: number
      userId: number
      message: string
      createdAt: Date
    }, ExtArgs["result"]["complaintComment"]>
    composites: {}
  }

  type ComplaintCommentGetPayload<S extends boolean | null | undefined | ComplaintCommentDefaultArgs> = $Result.GetResult<Prisma.$ComplaintCommentPayload, S>

  type ComplaintCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplaintCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplaintCommentCountAggregateInputType | true
    }

  export interface ComplaintCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplaintComment'], meta: { name: 'ComplaintComment' } }
    /**
     * Find zero or one ComplaintComment that matches the filter.
     * @param {ComplaintCommentFindUniqueArgs} args - Arguments to find a ComplaintComment
     * @example
     * // Get one ComplaintComment
     * const complaintComment = await prisma.complaintComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintCommentFindUniqueArgs>(args: SelectSubset<T, ComplaintCommentFindUniqueArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComplaintComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplaintCommentFindUniqueOrThrowArgs} args - Arguments to find a ComplaintComment
     * @example
     * // Get one ComplaintComment
     * const complaintComment = await prisma.complaintComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplaintComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentFindFirstArgs} args - Arguments to find a ComplaintComment
     * @example
     * // Get one ComplaintComment
     * const complaintComment = await prisma.complaintComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintCommentFindFirstArgs>(args?: SelectSubset<T, ComplaintCommentFindFirstArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplaintComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentFindFirstOrThrowArgs} args - Arguments to find a ComplaintComment
     * @example
     * // Get one ComplaintComment
     * const complaintComment = await prisma.complaintComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComplaintComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplaintComments
     * const complaintComments = await prisma.complaintComment.findMany()
     * 
     * // Get first 10 ComplaintComments
     * const complaintComments = await prisma.complaintComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintCommentWithIdOnly = await prisma.complaintComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplaintCommentFindManyArgs>(args?: SelectSubset<T, ComplaintCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComplaintComment.
     * @param {ComplaintCommentCreateArgs} args - Arguments to create a ComplaintComment.
     * @example
     * // Create one ComplaintComment
     * const ComplaintComment = await prisma.complaintComment.create({
     *   data: {
     *     // ... data to create a ComplaintComment
     *   }
     * })
     * 
     */
    create<T extends ComplaintCommentCreateArgs>(args: SelectSubset<T, ComplaintCommentCreateArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComplaintComments.
     * @param {ComplaintCommentCreateManyArgs} args - Arguments to create many ComplaintComments.
     * @example
     * // Create many ComplaintComments
     * const complaintComment = await prisma.complaintComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintCommentCreateManyArgs>(args?: SelectSubset<T, ComplaintCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ComplaintComment.
     * @param {ComplaintCommentDeleteArgs} args - Arguments to delete one ComplaintComment.
     * @example
     * // Delete one ComplaintComment
     * const ComplaintComment = await prisma.complaintComment.delete({
     *   where: {
     *     // ... filter to delete one ComplaintComment
     *   }
     * })
     * 
     */
    delete<T extends ComplaintCommentDeleteArgs>(args: SelectSubset<T, ComplaintCommentDeleteArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComplaintComment.
     * @param {ComplaintCommentUpdateArgs} args - Arguments to update one ComplaintComment.
     * @example
     * // Update one ComplaintComment
     * const complaintComment = await prisma.complaintComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintCommentUpdateArgs>(args: SelectSubset<T, ComplaintCommentUpdateArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComplaintComments.
     * @param {ComplaintCommentDeleteManyArgs} args - Arguments to filter ComplaintComments to delete.
     * @example
     * // Delete a few ComplaintComments
     * const { count } = await prisma.complaintComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintCommentDeleteManyArgs>(args?: SelectSubset<T, ComplaintCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplaintComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplaintComments
     * const complaintComment = await prisma.complaintComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintCommentUpdateManyArgs>(args: SelectSubset<T, ComplaintCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComplaintComment.
     * @param {ComplaintCommentUpsertArgs} args - Arguments to update or create a ComplaintComment.
     * @example
     * // Update or create a ComplaintComment
     * const complaintComment = await prisma.complaintComment.upsert({
     *   create: {
     *     // ... data to create a ComplaintComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplaintComment we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintCommentUpsertArgs>(args: SelectSubset<T, ComplaintCommentUpsertArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComplaintComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentCountArgs} args - Arguments to filter ComplaintComments to count.
     * @example
     * // Count the number of ComplaintComments
     * const count = await prisma.complaintComment.count({
     *   where: {
     *     // ... the filter for the ComplaintComments we want to count
     *   }
     * })
    **/
    count<T extends ComplaintCommentCountArgs>(
      args?: Subset<T, ComplaintCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplaintComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintCommentAggregateArgs>(args: Subset<T, ComplaintCommentAggregateArgs>): Prisma.PrismaPromise<GetComplaintCommentAggregateType<T>>

    /**
     * Group by ComplaintComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintCommentGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplaintComment model
   */
  readonly fields: ComplaintCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplaintComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    complaint<T extends ComplaintDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComplaintDefaultArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplaintComment model
   */
  interface ComplaintCommentFieldRefs {
    readonly id: FieldRef<"ComplaintComment", 'Int'>
    readonly complaintId: FieldRef<"ComplaintComment", 'Int'>
    readonly userId: FieldRef<"ComplaintComment", 'Int'>
    readonly message: FieldRef<"ComplaintComment", 'String'>
    readonly createdAt: FieldRef<"ComplaintComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplaintComment findUnique
   */
  export type ComplaintCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintComment to fetch.
     */
    where: ComplaintCommentWhereUniqueInput
  }

  /**
   * ComplaintComment findUniqueOrThrow
   */
  export type ComplaintCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintComment to fetch.
     */
    where: ComplaintCommentWhereUniqueInput
  }

  /**
   * ComplaintComment findFirst
   */
  export type ComplaintCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintComment to fetch.
     */
    where?: ComplaintCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintComments to fetch.
     */
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplaintComments.
     */
    cursor?: ComplaintCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplaintComments.
     */
    distinct?: ComplaintCommentScalarFieldEnum | ComplaintCommentScalarFieldEnum[]
  }

  /**
   * ComplaintComment findFirstOrThrow
   */
  export type ComplaintCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintComment to fetch.
     */
    where?: ComplaintCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintComments to fetch.
     */
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplaintComments.
     */
    cursor?: ComplaintCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplaintComments.
     */
    distinct?: ComplaintCommentScalarFieldEnum | ComplaintCommentScalarFieldEnum[]
  }

  /**
   * ComplaintComment findMany
   */
  export type ComplaintCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintComments to fetch.
     */
    where?: ComplaintCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintComments to fetch.
     */
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplaintComments.
     */
    cursor?: ComplaintCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintComments.
     */
    skip?: number
    distinct?: ComplaintCommentScalarFieldEnum | ComplaintCommentScalarFieldEnum[]
  }

  /**
   * ComplaintComment create
   */
  export type ComplaintCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ComplaintComment.
     */
    data: XOR<ComplaintCommentCreateInput, ComplaintCommentUncheckedCreateInput>
  }

  /**
   * ComplaintComment createMany
   */
  export type ComplaintCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplaintComments.
     */
    data: ComplaintCommentCreateManyInput | ComplaintCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplaintComment update
   */
  export type ComplaintCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ComplaintComment.
     */
    data: XOR<ComplaintCommentUpdateInput, ComplaintCommentUncheckedUpdateInput>
    /**
     * Choose, which ComplaintComment to update.
     */
    where: ComplaintCommentWhereUniqueInput
  }

  /**
   * ComplaintComment updateMany
   */
  export type ComplaintCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplaintComments.
     */
    data: XOR<ComplaintCommentUpdateManyMutationInput, ComplaintCommentUncheckedUpdateManyInput>
    /**
     * Filter which ComplaintComments to update
     */
    where?: ComplaintCommentWhereInput
    /**
     * Limit how many ComplaintComments to update.
     */
    limit?: number
  }

  /**
   * ComplaintComment upsert
   */
  export type ComplaintCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ComplaintComment to update in case it exists.
     */
    where: ComplaintCommentWhereUniqueInput
    /**
     * In case the ComplaintComment found by the `where` argument doesn't exist, create a new ComplaintComment with this data.
     */
    create: XOR<ComplaintCommentCreateInput, ComplaintCommentUncheckedCreateInput>
    /**
     * In case the ComplaintComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintCommentUpdateInput, ComplaintCommentUncheckedUpdateInput>
  }

  /**
   * ComplaintComment delete
   */
  export type ComplaintCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter which ComplaintComment to delete.
     */
    where: ComplaintCommentWhereUniqueInput
  }

  /**
   * ComplaintComment deleteMany
   */
  export type ComplaintCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplaintComments to delete
     */
    where?: ComplaintCommentWhereInput
    /**
     * Limit how many ComplaintComments to delete.
     */
    limit?: number
  }

  /**
   * ComplaintComment without action
   */
  export type ComplaintCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
  }


  /**
   * Model Visitor
   */

  export type AggregateVisitor = {
    _count: VisitorCountAggregateOutputType | null
    _avg: VisitorAvgAggregateOutputType | null
    _sum: VisitorSumAggregateOutputType | null
    _min: VisitorMinAggregateOutputType | null
    _max: VisitorMaxAggregateOutputType | null
  }

  export type VisitorAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
    visitingUnitId: number | null
  }

  export type VisitorSumAggregateOutputType = {
    id: number | null
    societyId: number | null
    visitingUnitId: number | null
  }

  export type VisitorMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    vehicleNo: string | null
    purpose: string | null
    photo: string | null
    status: $Enums.VisitorStatus | null
    entryTime: Date | null
    exitTime: Date | null
    societyId: number | null
    visitingUnitId: number | null
    idType: string | null
    idNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    vehicleNo: string | null
    purpose: string | null
    photo: string | null
    status: $Enums.VisitorStatus | null
    entryTime: Date | null
    exitTime: Date | null
    societyId: number | null
    visitingUnitId: number | null
    idType: string | null
    idNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitorCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    vehicleNo: number
    purpose: number
    photo: number
    status: number
    entryTime: number
    exitTime: number
    societyId: number
    visitingUnitId: number
    idType: number
    idNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VisitorAvgAggregateInputType = {
    id?: true
    societyId?: true
    visitingUnitId?: true
  }

  export type VisitorSumAggregateInputType = {
    id?: true
    societyId?: true
    visitingUnitId?: true
  }

  export type VisitorMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    vehicleNo?: true
    purpose?: true
    photo?: true
    status?: true
    entryTime?: true
    exitTime?: true
    societyId?: true
    visitingUnitId?: true
    idType?: true
    idNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitorMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    vehicleNo?: true
    purpose?: true
    photo?: true
    status?: true
    entryTime?: true
    exitTime?: true
    societyId?: true
    visitingUnitId?: true
    idType?: true
    idNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitorCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    vehicleNo?: true
    purpose?: true
    photo?: true
    status?: true
    entryTime?: true
    exitTime?: true
    societyId?: true
    visitingUnitId?: true
    idType?: true
    idNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VisitorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visitor to aggregate.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Visitors
    **/
    _count?: true | VisitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitorMaxAggregateInputType
  }

  export type GetVisitorAggregateType<T extends VisitorAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitor[P]>
      : GetScalarType<T[P], AggregateVisitor[P]>
  }




  export type VisitorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithAggregationInput | VisitorOrderByWithAggregationInput[]
    by: VisitorScalarFieldEnum[] | VisitorScalarFieldEnum
    having?: VisitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitorCountAggregateInputType | true
    _avg?: VisitorAvgAggregateInputType
    _sum?: VisitorSumAggregateInputType
    _min?: VisitorMinAggregateInputType
    _max?: VisitorMaxAggregateInputType
  }

  export type VisitorGroupByOutputType = {
    id: number
    name: string
    phone: string
    vehicleNo: string | null
    purpose: string
    photo: string | null
    status: $Enums.VisitorStatus
    entryTime: Date | null
    exitTime: Date | null
    societyId: number
    visitingUnitId: number
    idType: string | null
    idNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: VisitorCountAggregateOutputType | null
    _avg: VisitorAvgAggregateOutputType | null
    _sum: VisitorSumAggregateOutputType | null
    _min: VisitorMinAggregateOutputType | null
    _max: VisitorMaxAggregateOutputType | null
  }

  type GetVisitorGroupByPayload<T extends VisitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitorGroupByOutputType[P]>
            : GetScalarType<T[P], VisitorGroupByOutputType[P]>
        }
      >
    >


  export type VisitorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    vehicleNo?: boolean
    purpose?: boolean
    photo?: boolean
    status?: boolean
    entryTime?: boolean
    exitTime?: boolean
    societyId?: boolean
    visitingUnitId?: boolean
    idType?: boolean
    idNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitor"]>



  export type VisitorSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    vehicleNo?: boolean
    purpose?: boolean
    photo?: boolean
    status?: boolean
    entryTime?: boolean
    exitTime?: boolean
    societyId?: boolean
    visitingUnitId?: boolean
    idType?: boolean
    idNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VisitorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "vehicleNo" | "purpose" | "photo" | "status" | "entryTime" | "exitTime" | "societyId" | "visitingUnitId" | "idType" | "idNumber" | "createdAt" | "updatedAt", ExtArgs["result"]["visitor"]>
  export type VisitorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $VisitorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Visitor"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string
      vehicleNo: string | null
      purpose: string
      photo: string | null
      status: $Enums.VisitorStatus
      entryTime: Date | null
      exitTime: Date | null
      societyId: number
      visitingUnitId: number
      idType: string | null
      idNumber: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["visitor"]>
    composites: {}
  }

  type VisitorGetPayload<S extends boolean | null | undefined | VisitorDefaultArgs> = $Result.GetResult<Prisma.$VisitorPayload, S>

  type VisitorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisitorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisitorCountAggregateInputType | true
    }

  export interface VisitorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Visitor'], meta: { name: 'Visitor' } }
    /**
     * Find zero or one Visitor that matches the filter.
     * @param {VisitorFindUniqueArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitorFindUniqueArgs>(args: SelectSubset<T, VisitorFindUniqueArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Visitor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisitorFindUniqueOrThrowArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitorFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindFirstArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitorFindFirstArgs>(args?: SelectSubset<T, VisitorFindFirstArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visitor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindFirstOrThrowArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitorFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Visitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visitors
     * const visitors = await prisma.visitor.findMany()
     * 
     * // Get first 10 Visitors
     * const visitors = await prisma.visitor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitorWithIdOnly = await prisma.visitor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitorFindManyArgs>(args?: SelectSubset<T, VisitorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Visitor.
     * @param {VisitorCreateArgs} args - Arguments to create a Visitor.
     * @example
     * // Create one Visitor
     * const Visitor = await prisma.visitor.create({
     *   data: {
     *     // ... data to create a Visitor
     *   }
     * })
     * 
     */
    create<T extends VisitorCreateArgs>(args: SelectSubset<T, VisitorCreateArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Visitors.
     * @param {VisitorCreateManyArgs} args - Arguments to create many Visitors.
     * @example
     * // Create many Visitors
     * const visitor = await prisma.visitor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitorCreateManyArgs>(args?: SelectSubset<T, VisitorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Visitor.
     * @param {VisitorDeleteArgs} args - Arguments to delete one Visitor.
     * @example
     * // Delete one Visitor
     * const Visitor = await prisma.visitor.delete({
     *   where: {
     *     // ... filter to delete one Visitor
     *   }
     * })
     * 
     */
    delete<T extends VisitorDeleteArgs>(args: SelectSubset<T, VisitorDeleteArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Visitor.
     * @param {VisitorUpdateArgs} args - Arguments to update one Visitor.
     * @example
     * // Update one Visitor
     * const visitor = await prisma.visitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitorUpdateArgs>(args: SelectSubset<T, VisitorUpdateArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Visitors.
     * @param {VisitorDeleteManyArgs} args - Arguments to filter Visitors to delete.
     * @example
     * // Delete a few Visitors
     * const { count } = await prisma.visitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitorDeleteManyArgs>(args?: SelectSubset<T, VisitorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visitors
     * const visitor = await prisma.visitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitorUpdateManyArgs>(args: SelectSubset<T, VisitorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Visitor.
     * @param {VisitorUpsertArgs} args - Arguments to update or create a Visitor.
     * @example
     * // Update or create a Visitor
     * const visitor = await prisma.visitor.upsert({
     *   create: {
     *     // ... data to create a Visitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visitor we want to update
     *   }
     * })
     */
    upsert<T extends VisitorUpsertArgs>(args: SelectSubset<T, VisitorUpsertArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorCountArgs} args - Arguments to filter Visitors to count.
     * @example
     * // Count the number of Visitors
     * const count = await prisma.visitor.count({
     *   where: {
     *     // ... the filter for the Visitors we want to count
     *   }
     * })
    **/
    count<T extends VisitorCountArgs>(
      args?: Subset<T, VisitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitorAggregateArgs>(args: Subset<T, VisitorAggregateArgs>): Prisma.PrismaPromise<GetVisitorAggregateType<T>>

    /**
     * Group by Visitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitorGroupByArgs['orderBy'] }
        : { orderBy?: VisitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Visitor model
   */
  readonly fields: VisitorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Visitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Visitor model
   */
  interface VisitorFieldRefs {
    readonly id: FieldRef<"Visitor", 'Int'>
    readonly name: FieldRef<"Visitor", 'String'>
    readonly phone: FieldRef<"Visitor", 'String'>
    readonly vehicleNo: FieldRef<"Visitor", 'String'>
    readonly purpose: FieldRef<"Visitor", 'String'>
    readonly photo: FieldRef<"Visitor", 'String'>
    readonly status: FieldRef<"Visitor", 'VisitorStatus'>
    readonly entryTime: FieldRef<"Visitor", 'DateTime'>
    readonly exitTime: FieldRef<"Visitor", 'DateTime'>
    readonly societyId: FieldRef<"Visitor", 'Int'>
    readonly visitingUnitId: FieldRef<"Visitor", 'Int'>
    readonly idType: FieldRef<"Visitor", 'String'>
    readonly idNumber: FieldRef<"Visitor", 'String'>
    readonly createdAt: FieldRef<"Visitor", 'DateTime'>
    readonly updatedAt: FieldRef<"Visitor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Visitor findUnique
   */
  export type VisitorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor findUniqueOrThrow
   */
  export type VisitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor findFirst
   */
  export type VisitorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visitors.
     */
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor findFirstOrThrow
   */
  export type VisitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visitors.
     */
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor findMany
   */
  export type VisitorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitors to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor create
   */
  export type VisitorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * The data needed to create a Visitor.
     */
    data: XOR<VisitorCreateInput, VisitorUncheckedCreateInput>
  }

  /**
   * Visitor createMany
   */
  export type VisitorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Visitors.
     */
    data: VisitorCreateManyInput | VisitorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Visitor update
   */
  export type VisitorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * The data needed to update a Visitor.
     */
    data: XOR<VisitorUpdateInput, VisitorUncheckedUpdateInput>
    /**
     * Choose, which Visitor to update.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor updateMany
   */
  export type VisitorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Visitors.
     */
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyInput>
    /**
     * Filter which Visitors to update
     */
    where?: VisitorWhereInput
    /**
     * Limit how many Visitors to update.
     */
    limit?: number
  }

  /**
   * Visitor upsert
   */
  export type VisitorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * The filter to search for the Visitor to update in case it exists.
     */
    where: VisitorWhereUniqueInput
    /**
     * In case the Visitor found by the `where` argument doesn't exist, create a new Visitor with this data.
     */
    create: XOR<VisitorCreateInput, VisitorUncheckedCreateInput>
    /**
     * In case the Visitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitorUpdateInput, VisitorUncheckedUpdateInput>
  }

  /**
   * Visitor delete
   */
  export type VisitorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter which Visitor to delete.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor deleteMany
   */
  export type VisitorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visitors to delete
     */
    where?: VisitorWhereInput
    /**
     * Limit how many Visitors to delete.
     */
    limit?: number
  }

  /**
   * Visitor without action
   */
  export type VisitorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    societyId: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    amount: number | null
    societyId: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    type: $Enums.TransactionType | null
    category: string | null
    amount: number | null
    date: Date | null
    description: string | null
    paymentMethod: $Enums.PaymentMethod | null
    status: string | null
    societyId: number | null
    invoiceNo: string | null
    paidTo: string | null
    receivedFrom: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    type: $Enums.TransactionType | null
    category: string | null
    amount: number | null
    date: Date | null
    description: string | null
    paymentMethod: $Enums.PaymentMethod | null
    status: string | null
    societyId: number | null
    invoiceNo: string | null
    paidTo: string | null
    receivedFrom: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    type: number
    category: number
    amount: number
    date: number
    description: number
    paymentMethod: number
    status: number
    societyId: number
    invoiceNo: number
    paidTo: number
    receivedFrom: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    amount?: true
    societyId?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    amount?: true
    societyId?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    type?: true
    category?: true
    amount?: true
    date?: true
    description?: true
    paymentMethod?: true
    status?: true
    societyId?: true
    invoiceNo?: true
    paidTo?: true
    receivedFrom?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    type?: true
    category?: true
    amount?: true
    date?: true
    description?: true
    paymentMethod?: true
    status?: true
    societyId?: true
    invoiceNo?: true
    paidTo?: true
    receivedFrom?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    type?: true
    category?: true
    amount?: true
    date?: true
    description?: true
    paymentMethod?: true
    status?: true
    societyId?: true
    invoiceNo?: true
    paidTo?: true
    receivedFrom?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date
    description: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    societyId: number
    invoiceNo: string | null
    paidTo: string | null
    receivedFrom: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    paymentMethod?: boolean
    status?: boolean
    societyId?: boolean
    invoiceNo?: boolean
    paidTo?: boolean
    receivedFrom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>



  export type TransactionSelectScalar = {
    id?: boolean
    type?: boolean
    category?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    paymentMethod?: boolean
    status?: boolean
    societyId?: boolean
    invoiceNo?: boolean
    paidTo?: boolean
    receivedFrom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "category" | "amount" | "date" | "description" | "paymentMethod" | "status" | "societyId" | "invoiceNo" | "paidTo" | "receivedFrom" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.TransactionType
      category: string
      amount: number
      date: Date
      description: string | null
      paymentMethod: $Enums.PaymentMethod
      status: string
      societyId: number
      invoiceNo: string | null
      paidTo: string | null
      receivedFrom: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly category: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly date: FieldRef<"Transaction", 'DateTime'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly paymentMethod: FieldRef<"Transaction", 'PaymentMethod'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly societyId: FieldRef<"Transaction", 'Int'>
    readonly invoiceNo: FieldRef<"Transaction", 'String'>
    readonly paidTo: FieldRef<"Transaction", 'String'>
    readonly receivedFrom: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type VendorSumAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: number | null
    name: string | null
    serviceType: string | null
    contact: string | null
    email: string | null
    address: string | null
    active: boolean | null
    societyId: number | null
    createdAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    serviceType: string | null
    contact: string | null
    email: string | null
    address: string | null
    active: boolean | null
    societyId: number | null
    createdAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    name: number
    serviceType: number
    contact: number
    email: number
    address: number
    active: number
    societyId: number
    createdAt: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type VendorSumAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    name?: true
    serviceType?: true
    contact?: true
    email?: true
    address?: true
    active?: true
    societyId?: true
    createdAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    name?: true
    serviceType?: true
    contact?: true
    email?: true
    address?: true
    active?: true
    societyId?: true
    createdAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    name?: true
    serviceType?: true
    contact?: true
    email?: true
    address?: true
    active?: true
    societyId?: true
    createdAt?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: number
    name: string
    serviceType: string
    contact: string
    email: string | null
    address: string | null
    active: boolean
    societyId: number
    createdAt: Date
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    serviceType?: boolean
    contact?: boolean
    email?: boolean
    address?: boolean
    active?: boolean
    societyId?: boolean
    createdAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>



  export type VendorSelectScalar = {
    id?: boolean
    name?: boolean
    serviceType?: boolean
    contact?: boolean
    email?: boolean
    address?: boolean
    active?: boolean
    societyId?: boolean
    createdAt?: boolean
  }

  export type VendorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "serviceType" | "contact" | "email" | "address" | "active" | "societyId" | "createdAt", ExtArgs["result"]["vendor"]>
  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      serviceType: string
      contact: string
      email: string | null
      address: string | null
      active: boolean
      societyId: number
      createdAt: Date
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'Int'>
    readonly name: FieldRef<"Vendor", 'String'>
    readonly serviceType: FieldRef<"Vendor", 'String'>
    readonly contact: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly address: FieldRef<"Vendor", 'String'>
    readonly active: FieldRef<"Vendor", 'Boolean'>
    readonly societyId: FieldRef<"Vendor", 'Int'>
    readonly createdAt: FieldRef<"Vendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to delete.
     */
    limit?: number
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model Notice
   */

  export type AggregateNotice = {
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  export type NoticeAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type NoticeSumAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type NoticeMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    audience: string | null
    societyId: number | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type NoticeMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    audience: string | null
    societyId: number | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type NoticeCountAggregateOutputType = {
    id: number
    title: number
    content: number
    audience: number
    societyId: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type NoticeAvgAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type NoticeSumAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type NoticeMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    audience?: true
    societyId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type NoticeMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    audience?: true
    societyId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type NoticeCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    audience?: true
    societyId?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type NoticeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notice to aggregate.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notices
    **/
    _count?: true | NoticeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoticeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoticeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoticeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoticeMaxAggregateInputType
  }

  export type GetNoticeAggregateType<T extends NoticeAggregateArgs> = {
        [P in keyof T & keyof AggregateNotice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotice[P]>
      : GetScalarType<T[P], AggregateNotice[P]>
  }




  export type NoticeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoticeWhereInput
    orderBy?: NoticeOrderByWithAggregationInput | NoticeOrderByWithAggregationInput[]
    by: NoticeScalarFieldEnum[] | NoticeScalarFieldEnum
    having?: NoticeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoticeCountAggregateInputType | true
    _avg?: NoticeAvgAggregateInputType
    _sum?: NoticeSumAggregateInputType
    _min?: NoticeMinAggregateInputType
    _max?: NoticeMaxAggregateInputType
  }

  export type NoticeGroupByOutputType = {
    id: number
    title: string
    content: string
    audience: string
    societyId: number
    createdAt: Date
    expiresAt: Date | null
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  type GetNoticeGroupByPayload<T extends NoticeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoticeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoticeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoticeGroupByOutputType[P]>
            : GetScalarType<T[P], NoticeGroupByOutputType[P]>
        }
      >
    >


  export type NoticeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    audience?: boolean
    societyId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notice"]>



  export type NoticeSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    audience?: boolean
    societyId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type NoticeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "audience" | "societyId" | "createdAt" | "expiresAt", ExtArgs["result"]["notice"]>
  export type NoticeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $NoticePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notice"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      audience: string
      societyId: number
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["notice"]>
    composites: {}
  }

  type NoticeGetPayload<S extends boolean | null | undefined | NoticeDefaultArgs> = $Result.GetResult<Prisma.$NoticePayload, S>

  type NoticeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoticeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoticeCountAggregateInputType | true
    }

  export interface NoticeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notice'], meta: { name: 'Notice' } }
    /**
     * Find zero or one Notice that matches the filter.
     * @param {NoticeFindUniqueArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoticeFindUniqueArgs>(args: SelectSubset<T, NoticeFindUniqueArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoticeFindUniqueOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoticeFindUniqueOrThrowArgs>(args: SelectSubset<T, NoticeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoticeFindFirstArgs>(args?: SelectSubset<T, NoticeFindFirstArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoticeFindFirstOrThrowArgs>(args?: SelectSubset<T, NoticeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notices
     * const notices = await prisma.notice.findMany()
     * 
     * // Get first 10 Notices
     * const notices = await prisma.notice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noticeWithIdOnly = await prisma.notice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoticeFindManyArgs>(args?: SelectSubset<T, NoticeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notice.
     * @param {NoticeCreateArgs} args - Arguments to create a Notice.
     * @example
     * // Create one Notice
     * const Notice = await prisma.notice.create({
     *   data: {
     *     // ... data to create a Notice
     *   }
     * })
     * 
     */
    create<T extends NoticeCreateArgs>(args: SelectSubset<T, NoticeCreateArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notices.
     * @param {NoticeCreateManyArgs} args - Arguments to create many Notices.
     * @example
     * // Create many Notices
     * const notice = await prisma.notice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoticeCreateManyArgs>(args?: SelectSubset<T, NoticeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notice.
     * @param {NoticeDeleteArgs} args - Arguments to delete one Notice.
     * @example
     * // Delete one Notice
     * const Notice = await prisma.notice.delete({
     *   where: {
     *     // ... filter to delete one Notice
     *   }
     * })
     * 
     */
    delete<T extends NoticeDeleteArgs>(args: SelectSubset<T, NoticeDeleteArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notice.
     * @param {NoticeUpdateArgs} args - Arguments to update one Notice.
     * @example
     * // Update one Notice
     * const notice = await prisma.notice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoticeUpdateArgs>(args: SelectSubset<T, NoticeUpdateArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notices.
     * @param {NoticeDeleteManyArgs} args - Arguments to filter Notices to delete.
     * @example
     * // Delete a few Notices
     * const { count } = await prisma.notice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoticeDeleteManyArgs>(args?: SelectSubset<T, NoticeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notices
     * const notice = await prisma.notice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoticeUpdateManyArgs>(args: SelectSubset<T, NoticeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notice.
     * @param {NoticeUpsertArgs} args - Arguments to update or create a Notice.
     * @example
     * // Update or create a Notice
     * const notice = await prisma.notice.upsert({
     *   create: {
     *     // ... data to create a Notice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notice we want to update
     *   }
     * })
     */
    upsert<T extends NoticeUpsertArgs>(args: SelectSubset<T, NoticeUpsertArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeCountArgs} args - Arguments to filter Notices to count.
     * @example
     * // Count the number of Notices
     * const count = await prisma.notice.count({
     *   where: {
     *     // ... the filter for the Notices we want to count
     *   }
     * })
    **/
    count<T extends NoticeCountArgs>(
      args?: Subset<T, NoticeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoticeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoticeAggregateArgs>(args: Subset<T, NoticeAggregateArgs>): Prisma.PrismaPromise<GetNoticeAggregateType<T>>

    /**
     * Group by Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoticeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoticeGroupByArgs['orderBy'] }
        : { orderBy?: NoticeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoticeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoticeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notice model
   */
  readonly fields: NoticeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoticeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notice model
   */
  interface NoticeFieldRefs {
    readonly id: FieldRef<"Notice", 'Int'>
    readonly title: FieldRef<"Notice", 'String'>
    readonly content: FieldRef<"Notice", 'String'>
    readonly audience: FieldRef<"Notice", 'String'>
    readonly societyId: FieldRef<"Notice", 'Int'>
    readonly createdAt: FieldRef<"Notice", 'DateTime'>
    readonly expiresAt: FieldRef<"Notice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notice findUnique
   */
  export type NoticeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice findUniqueOrThrow
   */
  export type NoticeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice findFirst
   */
  export type NoticeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     */
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice findFirstOrThrow
   */
  export type NoticeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     */
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice findMany
   */
  export type NoticeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notices to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice create
   */
  export type NoticeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The data needed to create a Notice.
     */
    data: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
  }

  /**
   * Notice createMany
   */
  export type NoticeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notices.
     */
    data: NoticeCreateManyInput | NoticeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notice update
   */
  export type NoticeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The data needed to update a Notice.
     */
    data: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
    /**
     * Choose, which Notice to update.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice updateMany
   */
  export type NoticeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notices.
     */
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyInput>
    /**
     * Filter which Notices to update
     */
    where?: NoticeWhereInput
    /**
     * Limit how many Notices to update.
     */
    limit?: number
  }

  /**
   * Notice upsert
   */
  export type NoticeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The filter to search for the Notice to update in case it exists.
     */
    where: NoticeWhereUniqueInput
    /**
     * In case the Notice found by the `where` argument doesn't exist, create a new Notice with this data.
     */
    create: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
    /**
     * In case the Notice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
  }

  /**
   * Notice delete
   */
  export type NoticeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter which Notice to delete.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice deleteMany
   */
  export type NoticeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notices to delete
     */
    where?: NoticeWhereInput
    /**
     * Limit how many Notices to delete.
     */
    limit?: number
  }

  /**
   * Notice without action
   */
  export type NoticeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
  }


  /**
   * Model Amenity
   */

  export type AggregateAmenity = {
    _count: AmenityCountAggregateOutputType | null
    _avg: AmenityAvgAggregateOutputType | null
    _sum: AmenitySumAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  export type AmenityAvgAggregateOutputType = {
    id: number | null
    chargesPerHour: number | null
    societyId: number | null
  }

  export type AmenitySumAggregateOutputType = {
    id: number | null
    chargesPerHour: number | null
    societyId: number | null
  }

  export type AmenityMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    chargesPerHour: number | null
    societyId: number | null
    createdAt: Date | null
  }

  export type AmenityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    chargesPerHour: number | null
    societyId: number | null
    createdAt: Date | null
  }

  export type AmenityCountAggregateOutputType = {
    id: number
    name: number
    description: number
    chargesPerHour: number
    societyId: number
    createdAt: number
    _all: number
  }


  export type AmenityAvgAggregateInputType = {
    id?: true
    chargesPerHour?: true
    societyId?: true
  }

  export type AmenitySumAggregateInputType = {
    id?: true
    chargesPerHour?: true
    societyId?: true
  }

  export type AmenityMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    chargesPerHour?: true
    societyId?: true
    createdAt?: true
  }

  export type AmenityMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    chargesPerHour?: true
    societyId?: true
    createdAt?: true
  }

  export type AmenityCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    chargesPerHour?: true
    societyId?: true
    createdAt?: true
    _all?: true
  }

  export type AmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenity to aggregate.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Amenities
    **/
    _count?: true | AmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmenityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmenitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenityMaxAggregateInputType
  }

  export type GetAmenityAggregateType<T extends AmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenity[P]>
      : GetScalarType<T[P], AggregateAmenity[P]>
  }




  export type AmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityWhereInput
    orderBy?: AmenityOrderByWithAggregationInput | AmenityOrderByWithAggregationInput[]
    by: AmenityScalarFieldEnum[] | AmenityScalarFieldEnum
    having?: AmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenityCountAggregateInputType | true
    _avg?: AmenityAvgAggregateInputType
    _sum?: AmenitySumAggregateInputType
    _min?: AmenityMinAggregateInputType
    _max?: AmenityMaxAggregateInputType
  }

  export type AmenityGroupByOutputType = {
    id: number
    name: string
    description: string | null
    chargesPerHour: number
    societyId: number
    createdAt: Date
    _count: AmenityCountAggregateOutputType | null
    _avg: AmenityAvgAggregateOutputType | null
    _sum: AmenitySumAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  type GetAmenityGroupByPayload<T extends AmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenityGroupByOutputType[P]>
            : GetScalarType<T[P], AmenityGroupByOutputType[P]>
        }
      >
    >


  export type AmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    chargesPerHour?: boolean
    societyId?: boolean
    createdAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    bookings?: boolean | Amenity$bookingsArgs<ExtArgs>
    _count?: boolean | AmenityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amenity"]>



  export type AmenitySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    chargesPerHour?: boolean
    societyId?: boolean
    createdAt?: boolean
  }

  export type AmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "chargesPerHour" | "societyId" | "createdAt", ExtArgs["result"]["amenity"]>
  export type AmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    bookings?: boolean | Amenity$bookingsArgs<ExtArgs>
    _count?: boolean | AmenityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Amenity"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      bookings: Prisma.$AmenityBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      chargesPerHour: number
      societyId: number
      createdAt: Date
    }, ExtArgs["result"]["amenity"]>
    composites: {}
  }

  type AmenityGetPayload<S extends boolean | null | undefined | AmenityDefaultArgs> = $Result.GetResult<Prisma.$AmenityPayload, S>

  type AmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmenityCountAggregateInputType | true
    }

  export interface AmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Amenity'], meta: { name: 'Amenity' } }
    /**
     * Find zero or one Amenity that matches the filter.
     * @param {AmenityFindUniqueArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmenityFindUniqueArgs>(args: SelectSubset<T, AmenityFindUniqueArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Amenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmenityFindUniqueOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, AmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmenityFindFirstArgs>(args?: SelectSubset<T, AmenityFindFirstArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, AmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amenities
     * const amenities = await prisma.amenity.findMany()
     * 
     * // Get first 10 Amenities
     * const amenities = await prisma.amenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amenityWithIdOnly = await prisma.amenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmenityFindManyArgs>(args?: SelectSubset<T, AmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Amenity.
     * @param {AmenityCreateArgs} args - Arguments to create a Amenity.
     * @example
     * // Create one Amenity
     * const Amenity = await prisma.amenity.create({
     *   data: {
     *     // ... data to create a Amenity
     *   }
     * })
     * 
     */
    create<T extends AmenityCreateArgs>(args: SelectSubset<T, AmenityCreateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Amenities.
     * @param {AmenityCreateManyArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenity = await prisma.amenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmenityCreateManyArgs>(args?: SelectSubset<T, AmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Amenity.
     * @param {AmenityDeleteArgs} args - Arguments to delete one Amenity.
     * @example
     * // Delete one Amenity
     * const Amenity = await prisma.amenity.delete({
     *   where: {
     *     // ... filter to delete one Amenity
     *   }
     * })
     * 
     */
    delete<T extends AmenityDeleteArgs>(args: SelectSubset<T, AmenityDeleteArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Amenity.
     * @param {AmenityUpdateArgs} args - Arguments to update one Amenity.
     * @example
     * // Update one Amenity
     * const amenity = await prisma.amenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmenityUpdateArgs>(args: SelectSubset<T, AmenityUpdateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Amenities.
     * @param {AmenityDeleteManyArgs} args - Arguments to filter Amenities to delete.
     * @example
     * // Delete a few Amenities
     * const { count } = await prisma.amenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmenityDeleteManyArgs>(args?: SelectSubset<T, AmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amenities
     * const amenity = await prisma.amenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmenityUpdateManyArgs>(args: SelectSubset<T, AmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Amenity.
     * @param {AmenityUpsertArgs} args - Arguments to update or create a Amenity.
     * @example
     * // Update or create a Amenity
     * const amenity = await prisma.amenity.upsert({
     *   create: {
     *     // ... data to create a Amenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amenity we want to update
     *   }
     * })
     */
    upsert<T extends AmenityUpsertArgs>(args: SelectSubset<T, AmenityUpsertArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityCountArgs} args - Arguments to filter Amenities to count.
     * @example
     * // Count the number of Amenities
     * const count = await prisma.amenity.count({
     *   where: {
     *     // ... the filter for the Amenities we want to count
     *   }
     * })
    **/
    count<T extends AmenityCountArgs>(
      args?: Subset<T, AmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenityAggregateArgs>(args: Subset<T, AmenityAggregateArgs>): Prisma.PrismaPromise<GetAmenityAggregateType<T>>

    /**
     * Group by Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmenityGroupByArgs['orderBy'] }
        : { orderBy?: AmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Amenity model
   */
  readonly fields: AmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Amenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookings<T extends Amenity$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Amenity$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Amenity model
   */
  interface AmenityFieldRefs {
    readonly id: FieldRef<"Amenity", 'Int'>
    readonly name: FieldRef<"Amenity", 'String'>
    readonly description: FieldRef<"Amenity", 'String'>
    readonly chargesPerHour: FieldRef<"Amenity", 'Float'>
    readonly societyId: FieldRef<"Amenity", 'Int'>
    readonly createdAt: FieldRef<"Amenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Amenity findUnique
   */
  export type AmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findUniqueOrThrow
   */
  export type AmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findFirst
   */
  export type AmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findFirstOrThrow
   */
  export type AmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findMany
   */
  export type AmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity create
   */
  export type AmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a Amenity.
     */
    data: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
  }

  /**
   * Amenity createMany
   */
  export type AmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Amenities.
     */
    data: AmenityCreateManyInput | AmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenity update
   */
  export type AmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a Amenity.
     */
    data: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
    /**
     * Choose, which Amenity to update.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity updateMany
   */
  export type AmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenity upsert
   */
  export type AmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the Amenity to update in case it exists.
     */
    where: AmenityWhereUniqueInput
    /**
     * In case the Amenity found by the `where` argument doesn't exist, create a new Amenity with this data.
     */
    create: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
    /**
     * In case the Amenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
  }

  /**
   * Amenity delete
   */
  export type AmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter which Amenity to delete.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity deleteMany
   */
  export type AmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to delete
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to delete.
     */
    limit?: number
  }

  /**
   * Amenity.bookings
   */
  export type Amenity$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    where?: AmenityBookingWhereInput
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    cursor?: AmenityBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmenityBookingScalarFieldEnum | AmenityBookingScalarFieldEnum[]
  }

  /**
   * Amenity without action
   */
  export type AmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
  }


  /**
   * Model AmenityBooking
   */

  export type AggregateAmenityBooking = {
    _count: AmenityBookingCountAggregateOutputType | null
    _avg: AmenityBookingAvgAggregateOutputType | null
    _sum: AmenityBookingSumAggregateOutputType | null
    _min: AmenityBookingMinAggregateOutputType | null
    _max: AmenityBookingMaxAggregateOutputType | null
  }

  export type AmenityBookingAvgAggregateOutputType = {
    id: number | null
    amenityId: number | null
    userId: number | null
    amountPaid: number | null
  }

  export type AmenityBookingSumAggregateOutputType = {
    id: number | null
    amenityId: number | null
    userId: number | null
    amountPaid: number | null
  }

  export type AmenityBookingMinAggregateOutputType = {
    id: number | null
    amenityId: number | null
    userId: number | null
    startTime: Date | null
    endTime: Date | null
    status: string | null
    amountPaid: number | null
    createdAt: Date | null
  }

  export type AmenityBookingMaxAggregateOutputType = {
    id: number | null
    amenityId: number | null
    userId: number | null
    startTime: Date | null
    endTime: Date | null
    status: string | null
    amountPaid: number | null
    createdAt: Date | null
  }

  export type AmenityBookingCountAggregateOutputType = {
    id: number
    amenityId: number
    userId: number
    startTime: number
    endTime: number
    status: number
    amountPaid: number
    createdAt: number
    _all: number
  }


  export type AmenityBookingAvgAggregateInputType = {
    id?: true
    amenityId?: true
    userId?: true
    amountPaid?: true
  }

  export type AmenityBookingSumAggregateInputType = {
    id?: true
    amenityId?: true
    userId?: true
    amountPaid?: true
  }

  export type AmenityBookingMinAggregateInputType = {
    id?: true
    amenityId?: true
    userId?: true
    startTime?: true
    endTime?: true
    status?: true
    amountPaid?: true
    createdAt?: true
  }

  export type AmenityBookingMaxAggregateInputType = {
    id?: true
    amenityId?: true
    userId?: true
    startTime?: true
    endTime?: true
    status?: true
    amountPaid?: true
    createdAt?: true
  }

  export type AmenityBookingCountAggregateInputType = {
    id?: true
    amenityId?: true
    userId?: true
    startTime?: true
    endTime?: true
    status?: true
    amountPaid?: true
    createdAt?: true
    _all?: true
  }

  export type AmenityBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmenityBooking to aggregate.
     */
    where?: AmenityBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmenityBookings to fetch.
     */
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmenityBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmenityBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmenityBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AmenityBookings
    **/
    _count?: true | AmenityBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmenityBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmenityBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenityBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenityBookingMaxAggregateInputType
  }

  export type GetAmenityBookingAggregateType<T extends AmenityBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenityBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenityBooking[P]>
      : GetScalarType<T[P], AggregateAmenityBooking[P]>
  }




  export type AmenityBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityBookingWhereInput
    orderBy?: AmenityBookingOrderByWithAggregationInput | AmenityBookingOrderByWithAggregationInput[]
    by: AmenityBookingScalarFieldEnum[] | AmenityBookingScalarFieldEnum
    having?: AmenityBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenityBookingCountAggregateInputType | true
    _avg?: AmenityBookingAvgAggregateInputType
    _sum?: AmenityBookingSumAggregateInputType
    _min?: AmenityBookingMinAggregateInputType
    _max?: AmenityBookingMaxAggregateInputType
  }

  export type AmenityBookingGroupByOutputType = {
    id: number
    amenityId: number
    userId: number
    startTime: Date
    endTime: Date
    status: string
    amountPaid: number
    createdAt: Date
    _count: AmenityBookingCountAggregateOutputType | null
    _avg: AmenityBookingAvgAggregateOutputType | null
    _sum: AmenityBookingSumAggregateOutputType | null
    _min: AmenityBookingMinAggregateOutputType | null
    _max: AmenityBookingMaxAggregateOutputType | null
  }

  type GetAmenityBookingGroupByPayload<T extends AmenityBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenityBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenityBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenityBookingGroupByOutputType[P]>
            : GetScalarType<T[P], AmenityBookingGroupByOutputType[P]>
        }
      >
    >


  export type AmenityBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amenityId?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    amountPaid?: boolean
    createdAt?: boolean
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amenityBooking"]>



  export type AmenityBookingSelectScalar = {
    id?: boolean
    amenityId?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    amountPaid?: boolean
    createdAt?: boolean
  }

  export type AmenityBookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amenityId" | "userId" | "startTime" | "endTime" | "status" | "amountPaid" | "createdAt", ExtArgs["result"]["amenityBooking"]>
  export type AmenityBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AmenityBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AmenityBooking"
    objects: {
      amenity: Prisma.$AmenityPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amenityId: number
      userId: number
      startTime: Date
      endTime: Date
      status: string
      amountPaid: number
      createdAt: Date
    }, ExtArgs["result"]["amenityBooking"]>
    composites: {}
  }

  type AmenityBookingGetPayload<S extends boolean | null | undefined | AmenityBookingDefaultArgs> = $Result.GetResult<Prisma.$AmenityBookingPayload, S>

  type AmenityBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmenityBookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmenityBookingCountAggregateInputType | true
    }

  export interface AmenityBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AmenityBooking'], meta: { name: 'AmenityBooking' } }
    /**
     * Find zero or one AmenityBooking that matches the filter.
     * @param {AmenityBookingFindUniqueArgs} args - Arguments to find a AmenityBooking
     * @example
     * // Get one AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmenityBookingFindUniqueArgs>(args: SelectSubset<T, AmenityBookingFindUniqueArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AmenityBooking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmenityBookingFindUniqueOrThrowArgs} args - Arguments to find a AmenityBooking
     * @example
     * // Get one AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmenityBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, AmenityBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmenityBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingFindFirstArgs} args - Arguments to find a AmenityBooking
     * @example
     * // Get one AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmenityBookingFindFirstArgs>(args?: SelectSubset<T, AmenityBookingFindFirstArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmenityBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingFindFirstOrThrowArgs} args - Arguments to find a AmenityBooking
     * @example
     * // Get one AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmenityBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, AmenityBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AmenityBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AmenityBookings
     * const amenityBookings = await prisma.amenityBooking.findMany()
     * 
     * // Get first 10 AmenityBookings
     * const amenityBookings = await prisma.amenityBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amenityBookingWithIdOnly = await prisma.amenityBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmenityBookingFindManyArgs>(args?: SelectSubset<T, AmenityBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AmenityBooking.
     * @param {AmenityBookingCreateArgs} args - Arguments to create a AmenityBooking.
     * @example
     * // Create one AmenityBooking
     * const AmenityBooking = await prisma.amenityBooking.create({
     *   data: {
     *     // ... data to create a AmenityBooking
     *   }
     * })
     * 
     */
    create<T extends AmenityBookingCreateArgs>(args: SelectSubset<T, AmenityBookingCreateArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AmenityBookings.
     * @param {AmenityBookingCreateManyArgs} args - Arguments to create many AmenityBookings.
     * @example
     * // Create many AmenityBookings
     * const amenityBooking = await prisma.amenityBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmenityBookingCreateManyArgs>(args?: SelectSubset<T, AmenityBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AmenityBooking.
     * @param {AmenityBookingDeleteArgs} args - Arguments to delete one AmenityBooking.
     * @example
     * // Delete one AmenityBooking
     * const AmenityBooking = await prisma.amenityBooking.delete({
     *   where: {
     *     // ... filter to delete one AmenityBooking
     *   }
     * })
     * 
     */
    delete<T extends AmenityBookingDeleteArgs>(args: SelectSubset<T, AmenityBookingDeleteArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AmenityBooking.
     * @param {AmenityBookingUpdateArgs} args - Arguments to update one AmenityBooking.
     * @example
     * // Update one AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmenityBookingUpdateArgs>(args: SelectSubset<T, AmenityBookingUpdateArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AmenityBookings.
     * @param {AmenityBookingDeleteManyArgs} args - Arguments to filter AmenityBookings to delete.
     * @example
     * // Delete a few AmenityBookings
     * const { count } = await prisma.amenityBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmenityBookingDeleteManyArgs>(args?: SelectSubset<T, AmenityBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmenityBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AmenityBookings
     * const amenityBooking = await prisma.amenityBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmenityBookingUpdateManyArgs>(args: SelectSubset<T, AmenityBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AmenityBooking.
     * @param {AmenityBookingUpsertArgs} args - Arguments to update or create a AmenityBooking.
     * @example
     * // Update or create a AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.upsert({
     *   create: {
     *     // ... data to create a AmenityBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AmenityBooking we want to update
     *   }
     * })
     */
    upsert<T extends AmenityBookingUpsertArgs>(args: SelectSubset<T, AmenityBookingUpsertArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AmenityBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingCountArgs} args - Arguments to filter AmenityBookings to count.
     * @example
     * // Count the number of AmenityBookings
     * const count = await prisma.amenityBooking.count({
     *   where: {
     *     // ... the filter for the AmenityBookings we want to count
     *   }
     * })
    **/
    count<T extends AmenityBookingCountArgs>(
      args?: Subset<T, AmenityBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenityBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AmenityBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenityBookingAggregateArgs>(args: Subset<T, AmenityBookingAggregateArgs>): Prisma.PrismaPromise<GetAmenityBookingAggregateType<T>>

    /**
     * Group by AmenityBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmenityBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmenityBookingGroupByArgs['orderBy'] }
        : { orderBy?: AmenityBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmenityBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenityBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AmenityBooking model
   */
  readonly fields: AmenityBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AmenityBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmenityBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    amenity<T extends AmenityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AmenityDefaultArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AmenityBooking model
   */
  interface AmenityBookingFieldRefs {
    readonly id: FieldRef<"AmenityBooking", 'Int'>
    readonly amenityId: FieldRef<"AmenityBooking", 'Int'>
    readonly userId: FieldRef<"AmenityBooking", 'Int'>
    readonly startTime: FieldRef<"AmenityBooking", 'DateTime'>
    readonly endTime: FieldRef<"AmenityBooking", 'DateTime'>
    readonly status: FieldRef<"AmenityBooking", 'String'>
    readonly amountPaid: FieldRef<"AmenityBooking", 'Float'>
    readonly createdAt: FieldRef<"AmenityBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AmenityBooking findUnique
   */
  export type AmenityBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter, which AmenityBooking to fetch.
     */
    where: AmenityBookingWhereUniqueInput
  }

  /**
   * AmenityBooking findUniqueOrThrow
   */
  export type AmenityBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter, which AmenityBooking to fetch.
     */
    where: AmenityBookingWhereUniqueInput
  }

  /**
   * AmenityBooking findFirst
   */
  export type AmenityBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter, which AmenityBooking to fetch.
     */
    where?: AmenityBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmenityBookings to fetch.
     */
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmenityBookings.
     */
    cursor?: AmenityBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmenityBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmenityBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmenityBookings.
     */
    distinct?: AmenityBookingScalarFieldEnum | AmenityBookingScalarFieldEnum[]
  }

  /**
   * AmenityBooking findFirstOrThrow
   */
  export type AmenityBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter, which AmenityBooking to fetch.
     */
    where?: AmenityBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmenityBookings to fetch.
     */
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmenityBookings.
     */
    cursor?: AmenityBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmenityBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmenityBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmenityBookings.
     */
    distinct?: AmenityBookingScalarFieldEnum | AmenityBookingScalarFieldEnum[]
  }

  /**
   * AmenityBooking findMany
   */
  export type AmenityBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter, which AmenityBookings to fetch.
     */
    where?: AmenityBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmenityBookings to fetch.
     */
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AmenityBookings.
     */
    cursor?: AmenityBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmenityBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmenityBookings.
     */
    skip?: number
    distinct?: AmenityBookingScalarFieldEnum | AmenityBookingScalarFieldEnum[]
  }

  /**
   * AmenityBooking create
   */
  export type AmenityBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a AmenityBooking.
     */
    data: XOR<AmenityBookingCreateInput, AmenityBookingUncheckedCreateInput>
  }

  /**
   * AmenityBooking createMany
   */
  export type AmenityBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AmenityBookings.
     */
    data: AmenityBookingCreateManyInput | AmenityBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AmenityBooking update
   */
  export type AmenityBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a AmenityBooking.
     */
    data: XOR<AmenityBookingUpdateInput, AmenityBookingUncheckedUpdateInput>
    /**
     * Choose, which AmenityBooking to update.
     */
    where: AmenityBookingWhereUniqueInput
  }

  /**
   * AmenityBooking updateMany
   */
  export type AmenityBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AmenityBookings.
     */
    data: XOR<AmenityBookingUpdateManyMutationInput, AmenityBookingUncheckedUpdateManyInput>
    /**
     * Filter which AmenityBookings to update
     */
    where?: AmenityBookingWhereInput
    /**
     * Limit how many AmenityBookings to update.
     */
    limit?: number
  }

  /**
   * AmenityBooking upsert
   */
  export type AmenityBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the AmenityBooking to update in case it exists.
     */
    where: AmenityBookingWhereUniqueInput
    /**
     * In case the AmenityBooking found by the `where` argument doesn't exist, create a new AmenityBooking with this data.
     */
    create: XOR<AmenityBookingCreateInput, AmenityBookingUncheckedCreateInput>
    /**
     * In case the AmenityBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmenityBookingUpdateInput, AmenityBookingUncheckedUpdateInput>
  }

  /**
   * AmenityBooking delete
   */
  export type AmenityBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter which AmenityBooking to delete.
     */
    where: AmenityBookingWhereUniqueInput
  }

  /**
   * AmenityBooking deleteMany
   */
  export type AmenityBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmenityBookings to delete
     */
    where?: AmenityBookingWhereInput
    /**
     * Limit how many AmenityBookings to delete.
     */
    limit?: number
  }

  /**
   * AmenityBooking without action
   */
  export type AmenityBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SocietyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    code: 'code',
    status: 'status',
    subscriptionPlan: 'subscriptionPlan',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocietyScalarFieldEnum = (typeof SocietyScalarFieldEnum)[keyof typeof SocietyScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    phone: 'phone',
    role: 'role',
    profileImg: 'profileImg',
    societyId: 'societyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    block: 'block',
    number: 'number',
    floor: 'floor',
    type: 'type',
    areaSqFt: 'areaSqFt',
    societyId: 'societyId',
    ownerId: 'ownerId',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const ParkingSlotScalarFieldEnum: {
    id: 'id',
    number: 'number',
    type: 'type',
    status: 'status',
    societyId: 'societyId',
    allocatedToUnitId: 'allocatedToUnitId',
    vehicleNumber: 'vehicleNumber',
    createdAt: 'createdAt'
  };

  export type ParkingSlotScalarFieldEnum = (typeof ParkingSlotScalarFieldEnum)[keyof typeof ParkingSlotScalarFieldEnum]


  export const ComplaintScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    priority: 'priority',
    status: 'status',
    images: 'images',
    societyId: 'societyId',
    reportedById: 'reportedById',
    assignedToId: 'assignedToId',
    timeline: 'timeline',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComplaintScalarFieldEnum = (typeof ComplaintScalarFieldEnum)[keyof typeof ComplaintScalarFieldEnum]


  export const ComplaintCommentScalarFieldEnum: {
    id: 'id',
    complaintId: 'complaintId',
    userId: 'userId',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type ComplaintCommentScalarFieldEnum = (typeof ComplaintCommentScalarFieldEnum)[keyof typeof ComplaintCommentScalarFieldEnum]


  export const VisitorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    vehicleNo: 'vehicleNo',
    purpose: 'purpose',
    photo: 'photo',
    status: 'status',
    entryTime: 'entryTime',
    exitTime: 'exitTime',
    societyId: 'societyId',
    visitingUnitId: 'visitingUnitId',
    idType: 'idType',
    idNumber: 'idNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VisitorScalarFieldEnum = (typeof VisitorScalarFieldEnum)[keyof typeof VisitorScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    category: 'category',
    amount: 'amount',
    date: 'date',
    description: 'description',
    paymentMethod: 'paymentMethod',
    status: 'status',
    societyId: 'societyId',
    invoiceNo: 'invoiceNo',
    paidTo: 'paidTo',
    receivedFrom: 'receivedFrom',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    serviceType: 'serviceType',
    contact: 'contact',
    email: 'email',
    address: 'address',
    active: 'active',
    societyId: 'societyId',
    createdAt: 'createdAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const NoticeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    audience: 'audience',
    societyId: 'societyId',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type NoticeScalarFieldEnum = (typeof NoticeScalarFieldEnum)[keyof typeof NoticeScalarFieldEnum]


  export const AmenityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    chargesPerHour: 'chargesPerHour',
    societyId: 'societyId',
    createdAt: 'createdAt'
  };

  export type AmenityScalarFieldEnum = (typeof AmenityScalarFieldEnum)[keyof typeof AmenityScalarFieldEnum]


  export const AmenityBookingScalarFieldEnum: {
    id: 'id',
    amenityId: 'amenityId',
    userId: 'userId',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    amountPaid: 'amountPaid',
    createdAt: 'createdAt'
  };

  export type AmenityBookingScalarFieldEnum = (typeof AmenityBookingScalarFieldEnum)[keyof typeof AmenityBookingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const SocietyOrderByRelevanceFieldEnum: {
    name: 'name',
    address: 'address',
    code: 'code'
  };

  export type SocietyOrderByRelevanceFieldEnum = (typeof SocietyOrderByRelevanceFieldEnum)[keyof typeof SocietyOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    email: 'email',
    password: 'password',
    name: 'name',
    phone: 'phone',
    profileImg: 'profileImg'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const UnitOrderByRelevanceFieldEnum: {
    block: 'block',
    number: 'number',
    type: 'type'
  };

  export type UnitOrderByRelevanceFieldEnum = (typeof UnitOrderByRelevanceFieldEnum)[keyof typeof UnitOrderByRelevanceFieldEnum]


  export const ParkingSlotOrderByRelevanceFieldEnum: {
    number: 'number',
    type: 'type',
    status: 'status',
    vehicleNumber: 'vehicleNumber'
  };

  export type ParkingSlotOrderByRelevanceFieldEnum = (typeof ParkingSlotOrderByRelevanceFieldEnum)[keyof typeof ParkingSlotOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const ComplaintOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    category: 'category'
  };

  export type ComplaintOrderByRelevanceFieldEnum = (typeof ComplaintOrderByRelevanceFieldEnum)[keyof typeof ComplaintOrderByRelevanceFieldEnum]


  export const ComplaintCommentOrderByRelevanceFieldEnum: {
    message: 'message'
  };

  export type ComplaintCommentOrderByRelevanceFieldEnum = (typeof ComplaintCommentOrderByRelevanceFieldEnum)[keyof typeof ComplaintCommentOrderByRelevanceFieldEnum]


  export const VisitorOrderByRelevanceFieldEnum: {
    name: 'name',
    phone: 'phone',
    vehicleNo: 'vehicleNo',
    purpose: 'purpose',
    photo: 'photo',
    idType: 'idType',
    idNumber: 'idNumber'
  };

  export type VisitorOrderByRelevanceFieldEnum = (typeof VisitorOrderByRelevanceFieldEnum)[keyof typeof VisitorOrderByRelevanceFieldEnum]


  export const TransactionOrderByRelevanceFieldEnum: {
    category: 'category',
    description: 'description',
    status: 'status',
    invoiceNo: 'invoiceNo',
    paidTo: 'paidTo',
    receivedFrom: 'receivedFrom'
  };

  export type TransactionOrderByRelevanceFieldEnum = (typeof TransactionOrderByRelevanceFieldEnum)[keyof typeof TransactionOrderByRelevanceFieldEnum]


  export const VendorOrderByRelevanceFieldEnum: {
    name: 'name',
    serviceType: 'serviceType',
    contact: 'contact',
    email: 'email',
    address: 'address'
  };

  export type VendorOrderByRelevanceFieldEnum = (typeof VendorOrderByRelevanceFieldEnum)[keyof typeof VendorOrderByRelevanceFieldEnum]


  export const NoticeOrderByRelevanceFieldEnum: {
    title: 'title',
    content: 'content',
    audience: 'audience'
  };

  export type NoticeOrderByRelevanceFieldEnum = (typeof NoticeOrderByRelevanceFieldEnum)[keyof typeof NoticeOrderByRelevanceFieldEnum]


  export const AmenityOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type AmenityOrderByRelevanceFieldEnum = (typeof AmenityOrderByRelevanceFieldEnum)[keyof typeof AmenityOrderByRelevanceFieldEnum]


  export const AmenityBookingOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type AmenityBookingOrderByRelevanceFieldEnum = (typeof AmenityBookingOrderByRelevanceFieldEnum)[keyof typeof AmenityBookingOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'SocietyStatus'
   */
  export type EnumSocietyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocietyStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan'
   */
  export type EnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'ComplaintStatus'
   */
  export type EnumComplaintStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintStatus'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'VisitorStatus'
   */
  export type EnumVisitorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitorStatus'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type SocietyWhereInput = {
    AND?: SocietyWhereInput | SocietyWhereInput[]
    OR?: SocietyWhereInput[]
    NOT?: SocietyWhereInput | SocietyWhereInput[]
    id?: IntFilter<"Society"> | number
    name?: StringFilter<"Society"> | string
    address?: StringNullableFilter<"Society"> | string | null
    code?: StringFilter<"Society"> | string
    status?: EnumSocietyStatusFilter<"Society"> | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFilter<"Society"> | $Enums.SubscriptionPlan
    createdAt?: DateTimeFilter<"Society"> | Date | string
    updatedAt?: DateTimeFilter<"Society"> | Date | string
    users?: UserListRelationFilter
    units?: UnitListRelationFilter
    complaints?: ComplaintListRelationFilter
    visitors?: VisitorListRelationFilter
    transactions?: TransactionListRelationFilter
    notices?: NoticeListRelationFilter
    vendors?: VendorListRelationFilter
    amenities?: AmenityListRelationFilter
    parkingSlots?: ParkingSlotListRelationFilter
  }

  export type SocietyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    code?: SortOrder
    status?: SortOrder
    subscriptionPlan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    units?: UnitOrderByRelationAggregateInput
    complaints?: ComplaintOrderByRelationAggregateInput
    visitors?: VisitorOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    notices?: NoticeOrderByRelationAggregateInput
    vendors?: VendorOrderByRelationAggregateInput
    amenities?: AmenityOrderByRelationAggregateInput
    parkingSlots?: ParkingSlotOrderByRelationAggregateInput
    _relevance?: SocietyOrderByRelevanceInput
  }

  export type SocietyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: SocietyWhereInput | SocietyWhereInput[]
    OR?: SocietyWhereInput[]
    NOT?: SocietyWhereInput | SocietyWhereInput[]
    name?: StringFilter<"Society"> | string
    address?: StringNullableFilter<"Society"> | string | null
    status?: EnumSocietyStatusFilter<"Society"> | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFilter<"Society"> | $Enums.SubscriptionPlan
    createdAt?: DateTimeFilter<"Society"> | Date | string
    updatedAt?: DateTimeFilter<"Society"> | Date | string
    users?: UserListRelationFilter
    units?: UnitListRelationFilter
    complaints?: ComplaintListRelationFilter
    visitors?: VisitorListRelationFilter
    transactions?: TransactionListRelationFilter
    notices?: NoticeListRelationFilter
    vendors?: VendorListRelationFilter
    amenities?: AmenityListRelationFilter
    parkingSlots?: ParkingSlotListRelationFilter
  }, "id" | "code">

  export type SocietyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    code?: SortOrder
    status?: SortOrder
    subscriptionPlan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SocietyCountOrderByAggregateInput
    _avg?: SocietyAvgOrderByAggregateInput
    _max?: SocietyMaxOrderByAggregateInput
    _min?: SocietyMinOrderByAggregateInput
    _sum?: SocietySumOrderByAggregateInput
  }

  export type SocietyScalarWhereWithAggregatesInput = {
    AND?: SocietyScalarWhereWithAggregatesInput | SocietyScalarWhereWithAggregatesInput[]
    OR?: SocietyScalarWhereWithAggregatesInput[]
    NOT?: SocietyScalarWhereWithAggregatesInput | SocietyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Society"> | number
    name?: StringWithAggregatesFilter<"Society"> | string
    address?: StringNullableWithAggregatesFilter<"Society"> | string | null
    code?: StringWithAggregatesFilter<"Society"> | string
    status?: EnumSocietyStatusWithAggregatesFilter<"Society"> | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanWithAggregatesFilter<"Society"> | $Enums.SubscriptionPlan
    createdAt?: DateTimeWithAggregatesFilter<"Society"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Society"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    profileImg?: StringNullableFilter<"User"> | string | null
    societyId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    society?: XOR<SocietyNullableScalarRelationFilter, SocietyWhereInput> | null
    ownedUnits?: UnitListRelationFilter
    rentedUnits?: UnitListRelationFilter
    reportedComplaints?: ComplaintListRelationFilter
    assignedComplaints?: ComplaintListRelationFilter
    bookings?: AmenityBookingListRelationFilter
    comments?: ComplaintCommentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    profileImg?: SortOrderInput | SortOrder
    societyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    ownedUnits?: UnitOrderByRelationAggregateInput
    rentedUnits?: UnitOrderByRelationAggregateInput
    reportedComplaints?: ComplaintOrderByRelationAggregateInput
    assignedComplaints?: ComplaintOrderByRelationAggregateInput
    bookings?: AmenityBookingOrderByRelationAggregateInput
    comments?: ComplaintCommentOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    profileImg?: StringNullableFilter<"User"> | string | null
    societyId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    society?: XOR<SocietyNullableScalarRelationFilter, SocietyWhereInput> | null
    ownedUnits?: UnitListRelationFilter
    rentedUnits?: UnitListRelationFilter
    reportedComplaints?: ComplaintListRelationFilter
    assignedComplaints?: ComplaintListRelationFilter
    bookings?: AmenityBookingListRelationFilter
    comments?: ComplaintCommentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    profileImg?: SortOrderInput | SortOrder
    societyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    profileImg?: StringNullableWithAggregatesFilter<"User"> | string | null
    societyId?: IntNullableWithAggregatesFilter<"User"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: IntFilter<"Unit"> | number
    block?: StringFilter<"Unit"> | string
    number?: StringFilter<"Unit"> | string
    floor?: IntFilter<"Unit"> | number
    type?: StringFilter<"Unit"> | string
    areaSqFt?: FloatFilter<"Unit"> | number
    societyId?: IntFilter<"Unit"> | number
    ownerId?: IntNullableFilter<"Unit"> | number | null
    tenantId?: IntNullableFilter<"Unit"> | number | null
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tenant?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    visitors?: VisitorListRelationFilter
    parkingSlots?: ParkingSlotListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    block?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    areaSqFt?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    tenant?: UserOrderByWithRelationInput
    visitors?: VisitorOrderByRelationAggregateInput
    parkingSlots?: ParkingSlotOrderByRelationAggregateInput
    _relevance?: UnitOrderByRelevanceInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    societyId_block_number?: UnitSocietyIdBlockNumberCompoundUniqueInput
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    block?: StringFilter<"Unit"> | string
    number?: StringFilter<"Unit"> | string
    floor?: IntFilter<"Unit"> | number
    type?: StringFilter<"Unit"> | string
    areaSqFt?: FloatFilter<"Unit"> | number
    societyId?: IntFilter<"Unit"> | number
    ownerId?: IntNullableFilter<"Unit"> | number | null
    tenantId?: IntNullableFilter<"Unit"> | number | null
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tenant?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    visitors?: VisitorListRelationFilter
    parkingSlots?: ParkingSlotListRelationFilter
  }, "id" | "societyId_block_number">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    block?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    areaSqFt?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Unit"> | number
    block?: StringWithAggregatesFilter<"Unit"> | string
    number?: StringWithAggregatesFilter<"Unit"> | string
    floor?: IntWithAggregatesFilter<"Unit"> | number
    type?: StringWithAggregatesFilter<"Unit"> | string
    areaSqFt?: FloatWithAggregatesFilter<"Unit"> | number
    societyId?: IntWithAggregatesFilter<"Unit"> | number
    ownerId?: IntNullableWithAggregatesFilter<"Unit"> | number | null
    tenantId?: IntNullableWithAggregatesFilter<"Unit"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
  }

  export type ParkingSlotWhereInput = {
    AND?: ParkingSlotWhereInput | ParkingSlotWhereInput[]
    OR?: ParkingSlotWhereInput[]
    NOT?: ParkingSlotWhereInput | ParkingSlotWhereInput[]
    id?: IntFilter<"ParkingSlot"> | number
    number?: StringFilter<"ParkingSlot"> | string
    type?: StringFilter<"ParkingSlot"> | string
    status?: StringFilter<"ParkingSlot"> | string
    societyId?: IntFilter<"ParkingSlot"> | number
    allocatedToUnitId?: IntNullableFilter<"ParkingSlot"> | number | null
    vehicleNumber?: StringNullableFilter<"ParkingSlot"> | string | null
    createdAt?: DateTimeFilter<"ParkingSlot"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
  }

  export type ParkingSlotOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrderInput | SortOrder
    vehicleNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    _relevance?: ParkingSlotOrderByRelevanceInput
  }

  export type ParkingSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ParkingSlotWhereInput | ParkingSlotWhereInput[]
    OR?: ParkingSlotWhereInput[]
    NOT?: ParkingSlotWhereInput | ParkingSlotWhereInput[]
    number?: StringFilter<"ParkingSlot"> | string
    type?: StringFilter<"ParkingSlot"> | string
    status?: StringFilter<"ParkingSlot"> | string
    societyId?: IntFilter<"ParkingSlot"> | number
    allocatedToUnitId?: IntNullableFilter<"ParkingSlot"> | number | null
    vehicleNumber?: StringNullableFilter<"ParkingSlot"> | string | null
    createdAt?: DateTimeFilter<"ParkingSlot"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
  }, "id">

  export type ParkingSlotOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrderInput | SortOrder
    vehicleNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ParkingSlotCountOrderByAggregateInput
    _avg?: ParkingSlotAvgOrderByAggregateInput
    _max?: ParkingSlotMaxOrderByAggregateInput
    _min?: ParkingSlotMinOrderByAggregateInput
    _sum?: ParkingSlotSumOrderByAggregateInput
  }

  export type ParkingSlotScalarWhereWithAggregatesInput = {
    AND?: ParkingSlotScalarWhereWithAggregatesInput | ParkingSlotScalarWhereWithAggregatesInput[]
    OR?: ParkingSlotScalarWhereWithAggregatesInput[]
    NOT?: ParkingSlotScalarWhereWithAggregatesInput | ParkingSlotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ParkingSlot"> | number
    number?: StringWithAggregatesFilter<"ParkingSlot"> | string
    type?: StringWithAggregatesFilter<"ParkingSlot"> | string
    status?: StringWithAggregatesFilter<"ParkingSlot"> | string
    societyId?: IntWithAggregatesFilter<"ParkingSlot"> | number
    allocatedToUnitId?: IntNullableWithAggregatesFilter<"ParkingSlot"> | number | null
    vehicleNumber?: StringNullableWithAggregatesFilter<"ParkingSlot"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ParkingSlot"> | Date | string
  }

  export type ComplaintWhereInput = {
    AND?: ComplaintWhereInput | ComplaintWhereInput[]
    OR?: ComplaintWhereInput[]
    NOT?: ComplaintWhereInput | ComplaintWhereInput[]
    id?: IntFilter<"Complaint"> | number
    title?: StringFilter<"Complaint"> | string
    description?: StringFilter<"Complaint"> | string
    category?: StringFilter<"Complaint"> | string
    priority?: EnumPriorityFilter<"Complaint"> | $Enums.Priority
    status?: EnumComplaintStatusFilter<"Complaint"> | $Enums.ComplaintStatus
    images?: JsonNullableFilter<"Complaint">
    societyId?: IntFilter<"Complaint"> | number
    reportedById?: IntFilter<"Complaint"> | number
    assignedToId?: IntNullableFilter<"Complaint"> | number | null
    timeline?: JsonNullableFilter<"Complaint">
    createdAt?: DateTimeFilter<"Complaint"> | Date | string
    updatedAt?: DateTimeFilter<"Complaint"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    reportedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    comments?: ComplaintCommentListRelationFilter
  }

  export type ComplaintOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    images?: SortOrderInput | SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    timeline?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    reportedBy?: UserOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    comments?: ComplaintCommentOrderByRelationAggregateInput
    _relevance?: ComplaintOrderByRelevanceInput
  }

  export type ComplaintWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComplaintWhereInput | ComplaintWhereInput[]
    OR?: ComplaintWhereInput[]
    NOT?: ComplaintWhereInput | ComplaintWhereInput[]
    title?: StringFilter<"Complaint"> | string
    description?: StringFilter<"Complaint"> | string
    category?: StringFilter<"Complaint"> | string
    priority?: EnumPriorityFilter<"Complaint"> | $Enums.Priority
    status?: EnumComplaintStatusFilter<"Complaint"> | $Enums.ComplaintStatus
    images?: JsonNullableFilter<"Complaint">
    societyId?: IntFilter<"Complaint"> | number
    reportedById?: IntFilter<"Complaint"> | number
    assignedToId?: IntNullableFilter<"Complaint"> | number | null
    timeline?: JsonNullableFilter<"Complaint">
    createdAt?: DateTimeFilter<"Complaint"> | Date | string
    updatedAt?: DateTimeFilter<"Complaint"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    reportedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    comments?: ComplaintCommentListRelationFilter
  }, "id">

  export type ComplaintOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    images?: SortOrderInput | SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    timeline?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComplaintCountOrderByAggregateInput
    _avg?: ComplaintAvgOrderByAggregateInput
    _max?: ComplaintMaxOrderByAggregateInput
    _min?: ComplaintMinOrderByAggregateInput
    _sum?: ComplaintSumOrderByAggregateInput
  }

  export type ComplaintScalarWhereWithAggregatesInput = {
    AND?: ComplaintScalarWhereWithAggregatesInput | ComplaintScalarWhereWithAggregatesInput[]
    OR?: ComplaintScalarWhereWithAggregatesInput[]
    NOT?: ComplaintScalarWhereWithAggregatesInput | ComplaintScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Complaint"> | number
    title?: StringWithAggregatesFilter<"Complaint"> | string
    description?: StringWithAggregatesFilter<"Complaint"> | string
    category?: StringWithAggregatesFilter<"Complaint"> | string
    priority?: EnumPriorityWithAggregatesFilter<"Complaint"> | $Enums.Priority
    status?: EnumComplaintStatusWithAggregatesFilter<"Complaint"> | $Enums.ComplaintStatus
    images?: JsonNullableWithAggregatesFilter<"Complaint">
    societyId?: IntWithAggregatesFilter<"Complaint"> | number
    reportedById?: IntWithAggregatesFilter<"Complaint"> | number
    assignedToId?: IntNullableWithAggregatesFilter<"Complaint"> | number | null
    timeline?: JsonNullableWithAggregatesFilter<"Complaint">
    createdAt?: DateTimeWithAggregatesFilter<"Complaint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Complaint"> | Date | string
  }

  export type ComplaintCommentWhereInput = {
    AND?: ComplaintCommentWhereInput | ComplaintCommentWhereInput[]
    OR?: ComplaintCommentWhereInput[]
    NOT?: ComplaintCommentWhereInput | ComplaintCommentWhereInput[]
    id?: IntFilter<"ComplaintComment"> | number
    complaintId?: IntFilter<"ComplaintComment"> | number
    userId?: IntFilter<"ComplaintComment"> | number
    message?: StringFilter<"ComplaintComment"> | string
    createdAt?: DateTimeFilter<"ComplaintComment"> | Date | string
    complaint?: XOR<ComplaintScalarRelationFilter, ComplaintWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ComplaintCommentOrderByWithRelationInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    complaint?: ComplaintOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: ComplaintCommentOrderByRelevanceInput
  }

  export type ComplaintCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComplaintCommentWhereInput | ComplaintCommentWhereInput[]
    OR?: ComplaintCommentWhereInput[]
    NOT?: ComplaintCommentWhereInput | ComplaintCommentWhereInput[]
    complaintId?: IntFilter<"ComplaintComment"> | number
    userId?: IntFilter<"ComplaintComment"> | number
    message?: StringFilter<"ComplaintComment"> | string
    createdAt?: DateTimeFilter<"ComplaintComment"> | Date | string
    complaint?: XOR<ComplaintScalarRelationFilter, ComplaintWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ComplaintCommentOrderByWithAggregationInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: ComplaintCommentCountOrderByAggregateInput
    _avg?: ComplaintCommentAvgOrderByAggregateInput
    _max?: ComplaintCommentMaxOrderByAggregateInput
    _min?: ComplaintCommentMinOrderByAggregateInput
    _sum?: ComplaintCommentSumOrderByAggregateInput
  }

  export type ComplaintCommentScalarWhereWithAggregatesInput = {
    AND?: ComplaintCommentScalarWhereWithAggregatesInput | ComplaintCommentScalarWhereWithAggregatesInput[]
    OR?: ComplaintCommentScalarWhereWithAggregatesInput[]
    NOT?: ComplaintCommentScalarWhereWithAggregatesInput | ComplaintCommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ComplaintComment"> | number
    complaintId?: IntWithAggregatesFilter<"ComplaintComment"> | number
    userId?: IntWithAggregatesFilter<"ComplaintComment"> | number
    message?: StringWithAggregatesFilter<"ComplaintComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ComplaintComment"> | Date | string
  }

  export type VisitorWhereInput = {
    AND?: VisitorWhereInput | VisitorWhereInput[]
    OR?: VisitorWhereInput[]
    NOT?: VisitorWhereInput | VisitorWhereInput[]
    id?: IntFilter<"Visitor"> | number
    name?: StringFilter<"Visitor"> | string
    phone?: StringFilter<"Visitor"> | string
    vehicleNo?: StringNullableFilter<"Visitor"> | string | null
    purpose?: StringFilter<"Visitor"> | string
    photo?: StringNullableFilter<"Visitor"> | string | null
    status?: EnumVisitorStatusFilter<"Visitor"> | $Enums.VisitorStatus
    entryTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    exitTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    societyId?: IntFilter<"Visitor"> | number
    visitingUnitId?: IntFilter<"Visitor"> | number
    idType?: StringNullableFilter<"Visitor"> | string | null
    idNumber?: StringNullableFilter<"Visitor"> | string | null
    createdAt?: DateTimeFilter<"Visitor"> | Date | string
    updatedAt?: DateTimeFilter<"Visitor"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type VisitorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicleNo?: SortOrderInput | SortOrder
    purpose?: SortOrder
    photo?: SortOrderInput | SortOrder
    status?: SortOrder
    entryTime?: SortOrderInput | SortOrder
    exitTime?: SortOrderInput | SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
    idType?: SortOrderInput | SortOrder
    idNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    _relevance?: VisitorOrderByRelevanceInput
  }

  export type VisitorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VisitorWhereInput | VisitorWhereInput[]
    OR?: VisitorWhereInput[]
    NOT?: VisitorWhereInput | VisitorWhereInput[]
    name?: StringFilter<"Visitor"> | string
    phone?: StringFilter<"Visitor"> | string
    vehicleNo?: StringNullableFilter<"Visitor"> | string | null
    purpose?: StringFilter<"Visitor"> | string
    photo?: StringNullableFilter<"Visitor"> | string | null
    status?: EnumVisitorStatusFilter<"Visitor"> | $Enums.VisitorStatus
    entryTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    exitTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    societyId?: IntFilter<"Visitor"> | number
    visitingUnitId?: IntFilter<"Visitor"> | number
    idType?: StringNullableFilter<"Visitor"> | string | null
    idNumber?: StringNullableFilter<"Visitor"> | string | null
    createdAt?: DateTimeFilter<"Visitor"> | Date | string
    updatedAt?: DateTimeFilter<"Visitor"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "id">

  export type VisitorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicleNo?: SortOrderInput | SortOrder
    purpose?: SortOrder
    photo?: SortOrderInput | SortOrder
    status?: SortOrder
    entryTime?: SortOrderInput | SortOrder
    exitTime?: SortOrderInput | SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
    idType?: SortOrderInput | SortOrder
    idNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VisitorCountOrderByAggregateInput
    _avg?: VisitorAvgOrderByAggregateInput
    _max?: VisitorMaxOrderByAggregateInput
    _min?: VisitorMinOrderByAggregateInput
    _sum?: VisitorSumOrderByAggregateInput
  }

  export type VisitorScalarWhereWithAggregatesInput = {
    AND?: VisitorScalarWhereWithAggregatesInput | VisitorScalarWhereWithAggregatesInput[]
    OR?: VisitorScalarWhereWithAggregatesInput[]
    NOT?: VisitorScalarWhereWithAggregatesInput | VisitorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Visitor"> | number
    name?: StringWithAggregatesFilter<"Visitor"> | string
    phone?: StringWithAggregatesFilter<"Visitor"> | string
    vehicleNo?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    purpose?: StringWithAggregatesFilter<"Visitor"> | string
    photo?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    status?: EnumVisitorStatusWithAggregatesFilter<"Visitor"> | $Enums.VisitorStatus
    entryTime?: DateTimeNullableWithAggregatesFilter<"Visitor"> | Date | string | null
    exitTime?: DateTimeNullableWithAggregatesFilter<"Visitor"> | Date | string | null
    societyId?: IntWithAggregatesFilter<"Visitor"> | number
    visitingUnitId?: IntWithAggregatesFilter<"Visitor"> | number
    idType?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    idNumber?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Visitor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Visitor"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    category?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    status?: StringFilter<"Transaction"> | string
    societyId?: IntFilter<"Transaction"> | number
    invoiceNo?: StringNullableFilter<"Transaction"> | string | null
    paidTo?: StringNullableFilter<"Transaction"> | string | null
    receivedFrom?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    invoiceNo?: SortOrderInput | SortOrder
    paidTo?: SortOrderInput | SortOrder
    receivedFrom?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    _relevance?: TransactionOrderByRelevanceInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    category?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    status?: StringFilter<"Transaction"> | string
    societyId?: IntFilter<"Transaction"> | number
    invoiceNo?: StringNullableFilter<"Transaction"> | string | null
    paidTo?: StringNullableFilter<"Transaction"> | string | null
    receivedFrom?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    invoiceNo?: SortOrderInput | SortOrder
    paidTo?: SortOrderInput | SortOrder
    receivedFrom?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    category?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    date?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Transaction"> | $Enums.PaymentMethod
    status?: StringWithAggregatesFilter<"Transaction"> | string
    societyId?: IntWithAggregatesFilter<"Transaction"> | number
    invoiceNo?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    paidTo?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    receivedFrom?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: IntFilter<"Vendor"> | number
    name?: StringFilter<"Vendor"> | string
    serviceType?: StringFilter<"Vendor"> | string
    contact?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    active?: BoolFilter<"Vendor"> | boolean
    societyId?: IntFilter<"Vendor"> | number
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    contact?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    active?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    _relevance?: VendorOrderByRelevanceInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    name?: StringFilter<"Vendor"> | string
    serviceType?: StringFilter<"Vendor"> | string
    contact?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    active?: BoolFilter<"Vendor"> | boolean
    societyId?: IntFilter<"Vendor"> | number
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    contact?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    active?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vendor"> | number
    name?: StringWithAggregatesFilter<"Vendor"> | string
    serviceType?: StringWithAggregatesFilter<"Vendor"> | string
    contact?: StringWithAggregatesFilter<"Vendor"> | string
    email?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    address?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    active?: BoolWithAggregatesFilter<"Vendor"> | boolean
    societyId?: IntWithAggregatesFilter<"Vendor"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
  }

  export type NoticeWhereInput = {
    AND?: NoticeWhereInput | NoticeWhereInput[]
    OR?: NoticeWhereInput[]
    NOT?: NoticeWhereInput | NoticeWhereInput[]
    id?: IntFilter<"Notice"> | number
    title?: StringFilter<"Notice"> | string
    content?: StringFilter<"Notice"> | string
    audience?: StringFilter<"Notice"> | string
    societyId?: IntFilter<"Notice"> | number
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notice"> | Date | string | null
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type NoticeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    society?: SocietyOrderByWithRelationInput
    _relevance?: NoticeOrderByRelevanceInput
  }

  export type NoticeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NoticeWhereInput | NoticeWhereInput[]
    OR?: NoticeWhereInput[]
    NOT?: NoticeWhereInput | NoticeWhereInput[]
    title?: StringFilter<"Notice"> | string
    content?: StringFilter<"Notice"> | string
    audience?: StringFilter<"Notice"> | string
    societyId?: IntFilter<"Notice"> | number
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notice"> | Date | string | null
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id">

  export type NoticeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: NoticeCountOrderByAggregateInput
    _avg?: NoticeAvgOrderByAggregateInput
    _max?: NoticeMaxOrderByAggregateInput
    _min?: NoticeMinOrderByAggregateInput
    _sum?: NoticeSumOrderByAggregateInput
  }

  export type NoticeScalarWhereWithAggregatesInput = {
    AND?: NoticeScalarWhereWithAggregatesInput | NoticeScalarWhereWithAggregatesInput[]
    OR?: NoticeScalarWhereWithAggregatesInput[]
    NOT?: NoticeScalarWhereWithAggregatesInput | NoticeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notice"> | number
    title?: StringWithAggregatesFilter<"Notice"> | string
    content?: StringWithAggregatesFilter<"Notice"> | string
    audience?: StringWithAggregatesFilter<"Notice"> | string
    societyId?: IntWithAggregatesFilter<"Notice"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Notice"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Notice"> | Date | string | null
  }

  export type AmenityWhereInput = {
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    id?: IntFilter<"Amenity"> | number
    name?: StringFilter<"Amenity"> | string
    description?: StringNullableFilter<"Amenity"> | string | null
    chargesPerHour?: FloatFilter<"Amenity"> | number
    societyId?: IntFilter<"Amenity"> | number
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    bookings?: AmenityBookingListRelationFilter
  }

  export type AmenityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    chargesPerHour?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    bookings?: AmenityBookingOrderByRelationAggregateInput
    _relevance?: AmenityOrderByRelevanceInput
  }

  export type AmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    name?: StringFilter<"Amenity"> | string
    description?: StringNullableFilter<"Amenity"> | string | null
    chargesPerHour?: FloatFilter<"Amenity"> | number
    societyId?: IntFilter<"Amenity"> | number
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    bookings?: AmenityBookingListRelationFilter
  }, "id">

  export type AmenityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    chargesPerHour?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    _count?: AmenityCountOrderByAggregateInput
    _avg?: AmenityAvgOrderByAggregateInput
    _max?: AmenityMaxOrderByAggregateInput
    _min?: AmenityMinOrderByAggregateInput
    _sum?: AmenitySumOrderByAggregateInput
  }

  export type AmenityScalarWhereWithAggregatesInput = {
    AND?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    OR?: AmenityScalarWhereWithAggregatesInput[]
    NOT?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Amenity"> | number
    name?: StringWithAggregatesFilter<"Amenity"> | string
    description?: StringNullableWithAggregatesFilter<"Amenity"> | string | null
    chargesPerHour?: FloatWithAggregatesFilter<"Amenity"> | number
    societyId?: IntWithAggregatesFilter<"Amenity"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Amenity"> | Date | string
  }

  export type AmenityBookingWhereInput = {
    AND?: AmenityBookingWhereInput | AmenityBookingWhereInput[]
    OR?: AmenityBookingWhereInput[]
    NOT?: AmenityBookingWhereInput | AmenityBookingWhereInput[]
    id?: IntFilter<"AmenityBooking"> | number
    amenityId?: IntFilter<"AmenityBooking"> | number
    userId?: IntFilter<"AmenityBooking"> | number
    startTime?: DateTimeFilter<"AmenityBooking"> | Date | string
    endTime?: DateTimeFilter<"AmenityBooking"> | Date | string
    status?: StringFilter<"AmenityBooking"> | string
    amountPaid?: FloatFilter<"AmenityBooking"> | number
    createdAt?: DateTimeFilter<"AmenityBooking"> | Date | string
    amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AmenityBookingOrderByWithRelationInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    amenity?: AmenityOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: AmenityBookingOrderByRelevanceInput
  }

  export type AmenityBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AmenityBookingWhereInput | AmenityBookingWhereInput[]
    OR?: AmenityBookingWhereInput[]
    NOT?: AmenityBookingWhereInput | AmenityBookingWhereInput[]
    amenityId?: IntFilter<"AmenityBooking"> | number
    userId?: IntFilter<"AmenityBooking"> | number
    startTime?: DateTimeFilter<"AmenityBooking"> | Date | string
    endTime?: DateTimeFilter<"AmenityBooking"> | Date | string
    status?: StringFilter<"AmenityBooking"> | string
    amountPaid?: FloatFilter<"AmenityBooking"> | number
    createdAt?: DateTimeFilter<"AmenityBooking"> | Date | string
    amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AmenityBookingOrderByWithAggregationInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    _count?: AmenityBookingCountOrderByAggregateInput
    _avg?: AmenityBookingAvgOrderByAggregateInput
    _max?: AmenityBookingMaxOrderByAggregateInput
    _min?: AmenityBookingMinOrderByAggregateInput
    _sum?: AmenityBookingSumOrderByAggregateInput
  }

  export type AmenityBookingScalarWhereWithAggregatesInput = {
    AND?: AmenityBookingScalarWhereWithAggregatesInput | AmenityBookingScalarWhereWithAggregatesInput[]
    OR?: AmenityBookingScalarWhereWithAggregatesInput[]
    NOT?: AmenityBookingScalarWhereWithAggregatesInput | AmenityBookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AmenityBooking"> | number
    amenityId?: IntWithAggregatesFilter<"AmenityBooking"> | number
    userId?: IntWithAggregatesFilter<"AmenityBooking"> | number
    startTime?: DateTimeWithAggregatesFilter<"AmenityBooking"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"AmenityBooking"> | Date | string
    status?: StringWithAggregatesFilter<"AmenityBooking"> | string
    amountPaid?: FloatWithAggregatesFilter<"AmenityBooking"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AmenityBooking"> | Date | string
  }

  export type SocietyCreateInput = {
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateInput = {
    id?: number
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyCreateManyInput = {
    id?: number
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocietyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocietyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitUpdateManyMutationInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotCreateInput = {
    number: string
    type: string
    status: string
    vehicleNumber?: string | null
    createdAt?: Date | string
    society: SocietyCreateNestedOneWithoutParkingSlotsInput
    unit?: UnitCreateNestedOneWithoutParkingSlotsInput
  }

  export type ParkingSlotUncheckedCreateInput = {
    id?: number
    number: string
    type: string
    status: string
    societyId: number
    allocatedToUnitId?: number | null
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type ParkingSlotUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutParkingSlotsNestedInput
    unit?: UnitUpdateOneWithoutParkingSlotsNestedInput
  }

  export type ParkingSlotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    allocatedToUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotCreateManyInput = {
    id?: number
    number: string
    type: string
    status: string
    societyId: number
    allocatedToUnitId?: number | null
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type ParkingSlotUpdateManyMutationInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    allocatedToUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCreateInput = {
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutComplaintsInput
    reportedBy: UserCreateNestedOneWithoutReportedComplaintsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedComplaintsInput
    comments?: ComplaintCommentCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    reportedById: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutComplaintsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutReportedComplaintsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedComplaintsNestedInput
    comments?: ComplaintCommentUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ComplaintCommentUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintCreateManyInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    reportedById: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentCreateInput = {
    message: string
    createdAt?: Date | string
    complaint: ComplaintCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type ComplaintCommentUncheckedCreateInput = {
    id?: number
    complaintId: number
    userId: number
    message: string
    createdAt?: Date | string
  }

  export type ComplaintCommentUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint?: ComplaintUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ComplaintCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaintId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentCreateManyInput = {
    id?: number
    complaintId: number
    userId: number
    message: string
    createdAt?: Date | string
  }

  export type ComplaintCommentUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaintId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorCreateInput = {
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutVisitorsInput
    unit: UnitCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    societyId: number
    visitingUnitId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutVisitorsNestedInput
    unit?: UnitUpdateOneRequiredWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    visitingUnitId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorCreateManyInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    societyId: number
    visitingUnitId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    visitingUnitId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    societyId: number
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: number
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    societyId: number
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateInput = {
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    active?: boolean
    createdAt?: Date | string
    society: SocietyCreateNestedOneWithoutVendorsInput
  }

  export type VendorUncheckedCreateInput = {
    id?: number
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    active?: boolean
    societyId: number
    createdAt?: Date | string
  }

  export type VendorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutVendorsNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateManyInput = {
    id?: number
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    active?: boolean
    societyId: number
    createdAt?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeCreateInput = {
    title: string
    content: string
    audience: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    society: SocietyCreateNestedOneWithoutNoticesInput
  }

  export type NoticeUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    audience: string
    societyId: number
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NoticeUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    society?: SocietyUpdateOneRequiredWithoutNoticesNestedInput
  }

  export type NoticeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoticeCreateManyInput = {
    id?: number
    title: string
    content: string
    audience: string
    societyId: number
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NoticeUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoticeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AmenityCreateInput = {
    name: string
    description?: string | null
    chargesPerHour?: number
    createdAt?: Date | string
    society: SocietyCreateNestedOneWithoutAmenitiesInput
    bookings?: AmenityBookingCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    chargesPerHour?: number
    societyId: number
    createdAt?: Date | string
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutAmenitiesNestedInput
    bookings?: AmenityBookingUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: AmenityBookingUncheckedUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    chargesPerHour?: number
    societyId: number
    createdAt?: Date | string
  }

  export type AmenityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingCreateInput = {
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
    amenity: AmenityCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
  }

  export type AmenityBookingUncheckedCreateInput = {
    id?: number
    amenityId: number
    userId: number
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
  }

  export type AmenityBookingUpdateInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenity?: AmenityUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type AmenityBookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingCreateManyInput = {
    id?: number
    amenityId: number
    userId: number
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
  }

  export type AmenityBookingUpdateManyMutationInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumSocietyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SocietyStatus | EnumSocietyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SocietyStatus[]
    notIn?: $Enums.SocietyStatus[]
    not?: NestedEnumSocietyStatusFilter<$PrismaModel> | $Enums.SocietyStatus
  }

  export type EnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UnitListRelationFilter = {
    every?: UnitWhereInput
    some?: UnitWhereInput
    none?: UnitWhereInput
  }

  export type ComplaintListRelationFilter = {
    every?: ComplaintWhereInput
    some?: ComplaintWhereInput
    none?: ComplaintWhereInput
  }

  export type VisitorListRelationFilter = {
    every?: VisitorWhereInput
    some?: VisitorWhereInput
    none?: VisitorWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type NoticeListRelationFilter = {
    every?: NoticeWhereInput
    some?: NoticeWhereInput
    none?: NoticeWhereInput
  }

  export type VendorListRelationFilter = {
    every?: VendorWhereInput
    some?: VendorWhereInput
    none?: VendorWhereInput
  }

  export type AmenityListRelationFilter = {
    every?: AmenityWhereInput
    some?: AmenityWhereInput
    none?: AmenityWhereInput
  }

  export type ParkingSlotListRelationFilter = {
    every?: ParkingSlotWhereInput
    some?: ParkingSlotWhereInput
    none?: ParkingSlotWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplaintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisitorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoticeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AmenityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParkingSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocietyOrderByRelevanceInput = {
    fields: SocietyOrderByRelevanceFieldEnum | SocietyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SocietyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    code?: SortOrder
    status?: SortOrder
    subscriptionPlan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocietyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SocietyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    code?: SortOrder
    status?: SortOrder
    subscriptionPlan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocietyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    code?: SortOrder
    status?: SortOrder
    subscriptionPlan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocietySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumSocietyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocietyStatus | EnumSocietyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SocietyStatus[]
    notIn?: $Enums.SocietyStatus[]
    not?: NestedEnumSocietyStatusWithAggregatesFilter<$PrismaModel> | $Enums.SocietyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocietyStatusFilter<$PrismaModel>
    _max?: NestedEnumSocietyStatusFilter<$PrismaModel>
  }

  export type EnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SocietyNullableScalarRelationFilter = {
    is?: SocietyWhereInput | null
    isNot?: SocietyWhereInput | null
  }

  export type AmenityBookingListRelationFilter = {
    every?: AmenityBookingWhereInput
    some?: AmenityBookingWhereInput
    none?: AmenityBookingWhereInput
  }

  export type ComplaintCommentListRelationFilter = {
    every?: ComplaintCommentWhereInput
    some?: ComplaintCommentWhereInput
    none?: ComplaintCommentWhereInput
  }

  export type AmenityBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplaintCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    profileImg?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    profileImg?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    profileImg?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SocietyScalarRelationFilter = {
    is?: SocietyWhereInput
    isNot?: SocietyWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UnitOrderByRelevanceInput = {
    fields: UnitOrderByRelevanceFieldEnum | UnitOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UnitSocietyIdBlockNumberCompoundUniqueInput = {
    societyId: number
    block: string
    number: string
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    block?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    areaSqFt?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    id?: SortOrder
    floor?: SortOrder
    areaSqFt?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    block?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    areaSqFt?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    block?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    areaSqFt?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    id?: SortOrder
    floor?: SortOrder
    areaSqFt?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UnitNullableScalarRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type ParkingSlotOrderByRelevanceInput = {
    fields: ParkingSlotOrderByRelevanceFieldEnum | ParkingSlotOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ParkingSlotCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrder
    vehicleNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type ParkingSlotAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrder
  }

  export type ParkingSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrder
    vehicleNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type ParkingSlotMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrder
    vehicleNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type ParkingSlotSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrder
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[]
    notIn?: $Enums.Priority[]
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type EnumComplaintStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[]
    notIn?: $Enums.ComplaintStatus[]
    not?: NestedEnumComplaintStatusFilter<$PrismaModel> | $Enums.ComplaintStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ComplaintOrderByRelevanceInput = {
    fields: ComplaintOrderByRelevanceFieldEnum | ComplaintOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ComplaintCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    images?: SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    timeline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplaintAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
  }

  export type ComplaintMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplaintMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplaintSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[]
    notIn?: $Enums.Priority[]
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumComplaintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[]
    notIn?: $Enums.ComplaintStatus[]
    not?: NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintStatusFilter<$PrismaModel>
    _max?: NestedEnumComplaintStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ComplaintScalarRelationFilter = {
    is?: ComplaintWhereInput
    isNot?: ComplaintWhereInput
  }

  export type ComplaintCommentOrderByRelevanceInput = {
    fields: ComplaintCommentOrderByRelevanceFieldEnum | ComplaintCommentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ComplaintCommentCountOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ComplaintCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
  }

  export type ComplaintCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ComplaintCommentMinOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ComplaintCommentSumOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
  }

  export type EnumVisitorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitorStatus | EnumVisitorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitorStatus[]
    notIn?: $Enums.VisitorStatus[]
    not?: NestedEnumVisitorStatusFilter<$PrismaModel> | $Enums.VisitorStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UnitScalarRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type VisitorOrderByRelevanceInput = {
    fields: VisitorOrderByRelevanceFieldEnum | VisitorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VisitorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicleNo?: SortOrder
    purpose?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    entryTime?: SortOrder
    exitTime?: SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitorAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
  }

  export type VisitorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicleNo?: SortOrder
    purpose?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    entryTime?: SortOrder
    exitTime?: SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicleNo?: SortOrder
    purpose?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    entryTime?: SortOrder
    exitTime?: SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitorSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
  }

  export type EnumVisitorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitorStatus | EnumVisitorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitorStatus[]
    notIn?: $Enums.VisitorStatus[]
    not?: NestedEnumVisitorStatusWithAggregatesFilter<$PrismaModel> | $Enums.VisitorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitorStatusFilter<$PrismaModel>
    _max?: NestedEnumVisitorStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type TransactionOrderByRelevanceInput = {
    fields: TransactionOrderByRelevanceFieldEnum | TransactionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    invoiceNo?: SortOrder
    paidTo?: SortOrder
    receivedFrom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    societyId?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    invoiceNo?: SortOrder
    paidTo?: SortOrder
    receivedFrom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    invoiceNo?: SortOrder
    paidTo?: SortOrder
    receivedFrom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    societyId?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type VendorOrderByRelevanceInput = {
    fields: VendorOrderByRelevanceFieldEnum | VendorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    address?: SortOrder
    active?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    address?: SortOrder
    active?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    address?: SortOrder
    active?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NoticeOrderByRelevanceInput = {
    fields: NoticeOrderByRelevanceFieldEnum | NoticeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NoticeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NoticeAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type NoticeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NoticeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NoticeSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type AmenityOrderByRelevanceInput = {
    fields: AmenityOrderByRelevanceFieldEnum | AmenityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AmenityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chargesPerHour?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenityAvgOrderByAggregateInput = {
    id?: SortOrder
    chargesPerHour?: SortOrder
    societyId?: SortOrder
  }

  export type AmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chargesPerHour?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chargesPerHour?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenitySumOrderByAggregateInput = {
    id?: SortOrder
    chargesPerHour?: SortOrder
    societyId?: SortOrder
  }

  export type AmenityScalarRelationFilter = {
    is?: AmenityWhereInput
    isNot?: AmenityWhereInput
  }

  export type AmenityBookingOrderByRelevanceInput = {
    fields: AmenityBookingOrderByRelevanceFieldEnum | AmenityBookingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AmenityBookingCountOrderByAggregateInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenityBookingAvgOrderByAggregateInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    amountPaid?: SortOrder
  }

  export type AmenityBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenityBookingMinOrderByAggregateInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenityBookingSumOrderByAggregateInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    amountPaid?: SortOrder
  }

  export type UserCreateNestedManyWithoutSocietyInput = {
    create?: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput> | UserCreateWithoutSocietyInput[] | UserUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSocietyInput | UserCreateOrConnectWithoutSocietyInput[]
    createMany?: UserCreateManySocietyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UnitCreateNestedManyWithoutSocietyInput = {
    create?: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput> | UnitCreateWithoutSocietyInput[] | UnitUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutSocietyInput | UnitCreateOrConnectWithoutSocietyInput[]
    createMany?: UnitCreateManySocietyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type ComplaintCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput> | ComplaintCreateWithoutSocietyInput[] | ComplaintUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutSocietyInput | ComplaintCreateOrConnectWithoutSocietyInput[]
    createMany?: ComplaintCreateManySocietyInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type VisitorCreateNestedManyWithoutSocietyInput = {
    create?: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput> | VisitorCreateWithoutSocietyInput[] | VisitorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutSocietyInput | VisitorCreateOrConnectWithoutSocietyInput[]
    createMany?: VisitorCreateManySocietyInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutSocietyInput = {
    create?: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput> | TransactionCreateWithoutSocietyInput[] | TransactionUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSocietyInput | TransactionCreateOrConnectWithoutSocietyInput[]
    createMany?: TransactionCreateManySocietyInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type NoticeCreateNestedManyWithoutSocietyInput = {
    create?: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput> | NoticeCreateWithoutSocietyInput[] | NoticeUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutSocietyInput | NoticeCreateOrConnectWithoutSocietyInput[]
    createMany?: NoticeCreateManySocietyInputEnvelope
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
  }

  export type VendorCreateNestedManyWithoutSocietyInput = {
    create?: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput> | VendorCreateWithoutSocietyInput[] | VendorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutSocietyInput | VendorCreateOrConnectWithoutSocietyInput[]
    createMany?: VendorCreateManySocietyInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type AmenityCreateNestedManyWithoutSocietyInput = {
    create?: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput> | AmenityCreateWithoutSocietyInput[] | AmenityUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: AmenityCreateOrConnectWithoutSocietyInput | AmenityCreateOrConnectWithoutSocietyInput[]
    createMany?: AmenityCreateManySocietyInputEnvelope
    connect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
  }

  export type ParkingSlotCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput> | ParkingSlotCreateWithoutSocietyInput[] | ParkingSlotUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutSocietyInput | ParkingSlotCreateOrConnectWithoutSocietyInput[]
    createMany?: ParkingSlotCreateManySocietyInputEnvelope
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput> | UserCreateWithoutSocietyInput[] | UserUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSocietyInput | UserCreateOrConnectWithoutSocietyInput[]
    createMany?: UserCreateManySocietyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput> | UnitCreateWithoutSocietyInput[] | UnitUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutSocietyInput | UnitCreateOrConnectWithoutSocietyInput[]
    createMany?: UnitCreateManySocietyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type ComplaintUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput> | ComplaintCreateWithoutSocietyInput[] | ComplaintUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutSocietyInput | ComplaintCreateOrConnectWithoutSocietyInput[]
    createMany?: ComplaintCreateManySocietyInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type VisitorUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput> | VisitorCreateWithoutSocietyInput[] | VisitorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutSocietyInput | VisitorCreateOrConnectWithoutSocietyInput[]
    createMany?: VisitorCreateManySocietyInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput> | TransactionCreateWithoutSocietyInput[] | TransactionUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSocietyInput | TransactionCreateOrConnectWithoutSocietyInput[]
    createMany?: TransactionCreateManySocietyInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type NoticeUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput> | NoticeCreateWithoutSocietyInput[] | NoticeUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutSocietyInput | NoticeCreateOrConnectWithoutSocietyInput[]
    createMany?: NoticeCreateManySocietyInputEnvelope
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
  }

  export type VendorUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput> | VendorCreateWithoutSocietyInput[] | VendorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutSocietyInput | VendorCreateOrConnectWithoutSocietyInput[]
    createMany?: VendorCreateManySocietyInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type AmenityUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput> | AmenityCreateWithoutSocietyInput[] | AmenityUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: AmenityCreateOrConnectWithoutSocietyInput | AmenityCreateOrConnectWithoutSocietyInput[]
    createMany?: AmenityCreateManySocietyInputEnvelope
    connect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
  }

  export type ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput> | ParkingSlotCreateWithoutSocietyInput[] | ParkingSlotUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutSocietyInput | ParkingSlotCreateOrConnectWithoutSocietyInput[]
    createMany?: ParkingSlotCreateManySocietyInputEnvelope
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumSocietyStatusFieldUpdateOperationsInput = {
    set?: $Enums.SocietyStatus
  }

  export type EnumSubscriptionPlanFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPlan
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput> | UserCreateWithoutSocietyInput[] | UserUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSocietyInput | UserCreateOrConnectWithoutSocietyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSocietyInput | UserUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: UserCreateManySocietyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSocietyInput | UserUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSocietyInput | UserUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UnitUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput> | UnitCreateWithoutSocietyInput[] | UnitUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutSocietyInput | UnitCreateOrConnectWithoutSocietyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutSocietyInput | UnitUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: UnitCreateManySocietyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutSocietyInput | UnitUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutSocietyInput | UnitUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type ComplaintUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput> | ComplaintCreateWithoutSocietyInput[] | ComplaintUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutSocietyInput | ComplaintCreateOrConnectWithoutSocietyInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutSocietyInput | ComplaintUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ComplaintCreateManySocietyInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutSocietyInput | ComplaintUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutSocietyInput | ComplaintUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type VisitorUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput> | VisitorCreateWithoutSocietyInput[] | VisitorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutSocietyInput | VisitorCreateOrConnectWithoutSocietyInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutSocietyInput | VisitorUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: VisitorCreateManySocietyInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutSocietyInput | VisitorUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutSocietyInput | VisitorUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput> | TransactionCreateWithoutSocietyInput[] | TransactionUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSocietyInput | TransactionCreateOrConnectWithoutSocietyInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSocietyInput | TransactionUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: TransactionCreateManySocietyInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSocietyInput | TransactionUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSocietyInput | TransactionUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type NoticeUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput> | NoticeCreateWithoutSocietyInput[] | NoticeUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutSocietyInput | NoticeCreateOrConnectWithoutSocietyInput[]
    upsert?: NoticeUpsertWithWhereUniqueWithoutSocietyInput | NoticeUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: NoticeCreateManySocietyInputEnvelope
    set?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    disconnect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    delete?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    update?: NoticeUpdateWithWhereUniqueWithoutSocietyInput | NoticeUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: NoticeUpdateManyWithWhereWithoutSocietyInput | NoticeUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
  }

  export type VendorUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput> | VendorCreateWithoutSocietyInput[] | VendorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutSocietyInput | VendorCreateOrConnectWithoutSocietyInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutSocietyInput | VendorUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: VendorCreateManySocietyInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutSocietyInput | VendorUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutSocietyInput | VendorUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type AmenityUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput> | AmenityCreateWithoutSocietyInput[] | AmenityUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: AmenityCreateOrConnectWithoutSocietyInput | AmenityCreateOrConnectWithoutSocietyInput[]
    upsert?: AmenityUpsertWithWhereUniqueWithoutSocietyInput | AmenityUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: AmenityCreateManySocietyInputEnvelope
    set?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    disconnect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    delete?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    connect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    update?: AmenityUpdateWithWhereUniqueWithoutSocietyInput | AmenityUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: AmenityUpdateManyWithWhereWithoutSocietyInput | AmenityUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: AmenityScalarWhereInput | AmenityScalarWhereInput[]
  }

  export type ParkingSlotUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput> | ParkingSlotCreateWithoutSocietyInput[] | ParkingSlotUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutSocietyInput | ParkingSlotCreateOrConnectWithoutSocietyInput[]
    upsert?: ParkingSlotUpsertWithWhereUniqueWithoutSocietyInput | ParkingSlotUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ParkingSlotCreateManySocietyInputEnvelope
    set?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    disconnect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    delete?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    update?: ParkingSlotUpdateWithWhereUniqueWithoutSocietyInput | ParkingSlotUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ParkingSlotUpdateManyWithWhereWithoutSocietyInput | ParkingSlotUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput> | UserCreateWithoutSocietyInput[] | UserUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSocietyInput | UserCreateOrConnectWithoutSocietyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSocietyInput | UserUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: UserCreateManySocietyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSocietyInput | UserUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSocietyInput | UserUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput> | UnitCreateWithoutSocietyInput[] | UnitUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutSocietyInput | UnitCreateOrConnectWithoutSocietyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutSocietyInput | UnitUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: UnitCreateManySocietyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutSocietyInput | UnitUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutSocietyInput | UnitUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type ComplaintUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput> | ComplaintCreateWithoutSocietyInput[] | ComplaintUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutSocietyInput | ComplaintCreateOrConnectWithoutSocietyInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutSocietyInput | ComplaintUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ComplaintCreateManySocietyInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutSocietyInput | ComplaintUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutSocietyInput | ComplaintUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type VisitorUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput> | VisitorCreateWithoutSocietyInput[] | VisitorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutSocietyInput | VisitorCreateOrConnectWithoutSocietyInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutSocietyInput | VisitorUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: VisitorCreateManySocietyInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutSocietyInput | VisitorUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutSocietyInput | VisitorUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput> | TransactionCreateWithoutSocietyInput[] | TransactionUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSocietyInput | TransactionCreateOrConnectWithoutSocietyInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSocietyInput | TransactionUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: TransactionCreateManySocietyInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSocietyInput | TransactionUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSocietyInput | TransactionUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type NoticeUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput> | NoticeCreateWithoutSocietyInput[] | NoticeUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutSocietyInput | NoticeCreateOrConnectWithoutSocietyInput[]
    upsert?: NoticeUpsertWithWhereUniqueWithoutSocietyInput | NoticeUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: NoticeCreateManySocietyInputEnvelope
    set?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    disconnect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    delete?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    update?: NoticeUpdateWithWhereUniqueWithoutSocietyInput | NoticeUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: NoticeUpdateManyWithWhereWithoutSocietyInput | NoticeUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
  }

  export type VendorUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput> | VendorCreateWithoutSocietyInput[] | VendorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutSocietyInput | VendorCreateOrConnectWithoutSocietyInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutSocietyInput | VendorUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: VendorCreateManySocietyInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutSocietyInput | VendorUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutSocietyInput | VendorUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type AmenityUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput> | AmenityCreateWithoutSocietyInput[] | AmenityUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: AmenityCreateOrConnectWithoutSocietyInput | AmenityCreateOrConnectWithoutSocietyInput[]
    upsert?: AmenityUpsertWithWhereUniqueWithoutSocietyInput | AmenityUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: AmenityCreateManySocietyInputEnvelope
    set?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    disconnect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    delete?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    connect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    update?: AmenityUpdateWithWhereUniqueWithoutSocietyInput | AmenityUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: AmenityUpdateManyWithWhereWithoutSocietyInput | AmenityUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: AmenityScalarWhereInput | AmenityScalarWhereInput[]
  }

  export type ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput> | ParkingSlotCreateWithoutSocietyInput[] | ParkingSlotUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutSocietyInput | ParkingSlotCreateOrConnectWithoutSocietyInput[]
    upsert?: ParkingSlotUpsertWithWhereUniqueWithoutSocietyInput | ParkingSlotUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ParkingSlotCreateManySocietyInputEnvelope
    set?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    disconnect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    delete?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    update?: ParkingSlotUpdateWithWhereUniqueWithoutSocietyInput | ParkingSlotUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ParkingSlotUpdateManyWithWhereWithoutSocietyInput | ParkingSlotUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
  }

  export type SocietyCreateNestedOneWithoutUsersInput = {
    create?: XOR<SocietyCreateWithoutUsersInput, SocietyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutUsersInput
    connect?: SocietyWhereUniqueInput
  }

  export type UnitCreateNestedManyWithoutOwnerInput = {
    create?: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput> | UnitCreateWithoutOwnerInput[] | UnitUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutOwnerInput | UnitCreateOrConnectWithoutOwnerInput[]
    createMany?: UnitCreateManyOwnerInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type UnitCreateNestedManyWithoutTenantInput = {
    create?: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput> | UnitCreateWithoutTenantInput[] | UnitUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutTenantInput | UnitCreateOrConnectWithoutTenantInput[]
    createMany?: UnitCreateManyTenantInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type ComplaintCreateNestedManyWithoutReportedByInput = {
    create?: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput> | ComplaintCreateWithoutReportedByInput[] | ComplaintUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutReportedByInput | ComplaintCreateOrConnectWithoutReportedByInput[]
    createMany?: ComplaintCreateManyReportedByInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type ComplaintCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput> | ComplaintCreateWithoutAssignedToInput[] | ComplaintUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutAssignedToInput | ComplaintCreateOrConnectWithoutAssignedToInput[]
    createMany?: ComplaintCreateManyAssignedToInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type AmenityBookingCreateNestedManyWithoutUserInput = {
    create?: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput> | AmenityBookingCreateWithoutUserInput[] | AmenityBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutUserInput | AmenityBookingCreateOrConnectWithoutUserInput[]
    createMany?: AmenityBookingCreateManyUserInputEnvelope
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
  }

  export type ComplaintCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput> | ComplaintCommentCreateWithoutUserInput[] | ComplaintCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutUserInput | ComplaintCommentCreateOrConnectWithoutUserInput[]
    createMany?: ComplaintCommentCreateManyUserInputEnvelope
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput> | UnitCreateWithoutOwnerInput[] | UnitUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutOwnerInput | UnitCreateOrConnectWithoutOwnerInput[]
    createMany?: UnitCreateManyOwnerInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput> | UnitCreateWithoutTenantInput[] | UnitUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutTenantInput | UnitCreateOrConnectWithoutTenantInput[]
    createMany?: UnitCreateManyTenantInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type ComplaintUncheckedCreateNestedManyWithoutReportedByInput = {
    create?: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput> | ComplaintCreateWithoutReportedByInput[] | ComplaintUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutReportedByInput | ComplaintCreateOrConnectWithoutReportedByInput[]
    createMany?: ComplaintCreateManyReportedByInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type ComplaintUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput> | ComplaintCreateWithoutAssignedToInput[] | ComplaintUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutAssignedToInput | ComplaintCreateOrConnectWithoutAssignedToInput[]
    createMany?: ComplaintCreateManyAssignedToInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type AmenityBookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput> | AmenityBookingCreateWithoutUserInput[] | AmenityBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutUserInput | AmenityBookingCreateOrConnectWithoutUserInput[]
    createMany?: AmenityBookingCreateManyUserInputEnvelope
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
  }

  export type ComplaintCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput> | ComplaintCommentCreateWithoutUserInput[] | ComplaintCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutUserInput | ComplaintCommentCreateOrConnectWithoutUserInput[]
    createMany?: ComplaintCommentCreateManyUserInputEnvelope
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type SocietyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<SocietyCreateWithoutUsersInput, SocietyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutUsersInput
    upsert?: SocietyUpsertWithoutUsersInput
    disconnect?: SocietyWhereInput | boolean
    delete?: SocietyWhereInput | boolean
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutUsersInput, SocietyUpdateWithoutUsersInput>, SocietyUncheckedUpdateWithoutUsersInput>
  }

  export type UnitUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput> | UnitCreateWithoutOwnerInput[] | UnitUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutOwnerInput | UnitCreateOrConnectWithoutOwnerInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutOwnerInput | UnitUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: UnitCreateManyOwnerInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutOwnerInput | UnitUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutOwnerInput | UnitUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type UnitUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput> | UnitCreateWithoutTenantInput[] | UnitUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutTenantInput | UnitCreateOrConnectWithoutTenantInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutTenantInput | UnitUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UnitCreateManyTenantInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutTenantInput | UnitUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutTenantInput | UnitUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type ComplaintUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput> | ComplaintCreateWithoutReportedByInput[] | ComplaintUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutReportedByInput | ComplaintCreateOrConnectWithoutReportedByInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutReportedByInput | ComplaintUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: ComplaintCreateManyReportedByInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutReportedByInput | ComplaintUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutReportedByInput | ComplaintUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type ComplaintUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput> | ComplaintCreateWithoutAssignedToInput[] | ComplaintUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutAssignedToInput | ComplaintCreateOrConnectWithoutAssignedToInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutAssignedToInput | ComplaintUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: ComplaintCreateManyAssignedToInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutAssignedToInput | ComplaintUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutAssignedToInput | ComplaintUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type AmenityBookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput> | AmenityBookingCreateWithoutUserInput[] | AmenityBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutUserInput | AmenityBookingCreateOrConnectWithoutUserInput[]
    upsert?: AmenityBookingUpsertWithWhereUniqueWithoutUserInput | AmenityBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AmenityBookingCreateManyUserInputEnvelope
    set?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    disconnect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    delete?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    update?: AmenityBookingUpdateWithWhereUniqueWithoutUserInput | AmenityBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AmenityBookingUpdateManyWithWhereWithoutUserInput | AmenityBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
  }

  export type ComplaintCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput> | ComplaintCommentCreateWithoutUserInput[] | ComplaintCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutUserInput | ComplaintCommentCreateOrConnectWithoutUserInput[]
    upsert?: ComplaintCommentUpsertWithWhereUniqueWithoutUserInput | ComplaintCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComplaintCommentCreateManyUserInputEnvelope
    set?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    disconnect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    delete?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    update?: ComplaintCommentUpdateWithWhereUniqueWithoutUserInput | ComplaintCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComplaintCommentUpdateManyWithWhereWithoutUserInput | ComplaintCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UnitUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput> | UnitCreateWithoutOwnerInput[] | UnitUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutOwnerInput | UnitCreateOrConnectWithoutOwnerInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutOwnerInput | UnitUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: UnitCreateManyOwnerInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutOwnerInput | UnitUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutOwnerInput | UnitUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput> | UnitCreateWithoutTenantInput[] | UnitUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutTenantInput | UnitCreateOrConnectWithoutTenantInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutTenantInput | UnitUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UnitCreateManyTenantInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutTenantInput | UnitUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutTenantInput | UnitUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type ComplaintUncheckedUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput> | ComplaintCreateWithoutReportedByInput[] | ComplaintUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutReportedByInput | ComplaintCreateOrConnectWithoutReportedByInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutReportedByInput | ComplaintUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: ComplaintCreateManyReportedByInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutReportedByInput | ComplaintUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutReportedByInput | ComplaintUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput> | ComplaintCreateWithoutAssignedToInput[] | ComplaintUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutAssignedToInput | ComplaintCreateOrConnectWithoutAssignedToInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutAssignedToInput | ComplaintUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: ComplaintCreateManyAssignedToInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutAssignedToInput | ComplaintUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutAssignedToInput | ComplaintUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type AmenityBookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput> | AmenityBookingCreateWithoutUserInput[] | AmenityBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutUserInput | AmenityBookingCreateOrConnectWithoutUserInput[]
    upsert?: AmenityBookingUpsertWithWhereUniqueWithoutUserInput | AmenityBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AmenityBookingCreateManyUserInputEnvelope
    set?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    disconnect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    delete?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    update?: AmenityBookingUpdateWithWhereUniqueWithoutUserInput | AmenityBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AmenityBookingUpdateManyWithWhereWithoutUserInput | AmenityBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
  }

  export type ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput> | ComplaintCommentCreateWithoutUserInput[] | ComplaintCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutUserInput | ComplaintCommentCreateOrConnectWithoutUserInput[]
    upsert?: ComplaintCommentUpsertWithWhereUniqueWithoutUserInput | ComplaintCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComplaintCommentCreateManyUserInputEnvelope
    set?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    disconnect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    delete?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    update?: ComplaintCommentUpdateWithWhereUniqueWithoutUserInput | ComplaintCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComplaintCommentUpdateManyWithWhereWithoutUserInput | ComplaintCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
  }

  export type SocietyCreateNestedOneWithoutUnitsInput = {
    create?: XOR<SocietyCreateWithoutUnitsInput, SocietyUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutUnitsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedUnitsInput = {
    create?: XOR<UserCreateWithoutOwnedUnitsInput, UserUncheckedCreateWithoutOwnedUnitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedUnitsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRentedUnitsInput = {
    create?: XOR<UserCreateWithoutRentedUnitsInput, UserUncheckedCreateWithoutRentedUnitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRentedUnitsInput
    connect?: UserWhereUniqueInput
  }

  export type VisitorCreateNestedManyWithoutUnitInput = {
    create?: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput> | VisitorCreateWithoutUnitInput[] | VisitorUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutUnitInput | VisitorCreateOrConnectWithoutUnitInput[]
    createMany?: VisitorCreateManyUnitInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type ParkingSlotCreateNestedManyWithoutUnitInput = {
    create?: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput> | ParkingSlotCreateWithoutUnitInput[] | ParkingSlotUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutUnitInput | ParkingSlotCreateOrConnectWithoutUnitInput[]
    createMany?: ParkingSlotCreateManyUnitInputEnvelope
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
  }

  export type VisitorUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput> | VisitorCreateWithoutUnitInput[] | VisitorUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutUnitInput | VisitorCreateOrConnectWithoutUnitInput[]
    createMany?: VisitorCreateManyUnitInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type ParkingSlotUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput> | ParkingSlotCreateWithoutUnitInput[] | ParkingSlotUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutUnitInput | ParkingSlotCreateOrConnectWithoutUnitInput[]
    createMany?: ParkingSlotCreateManyUnitInputEnvelope
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SocietyUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<SocietyCreateWithoutUnitsInput, SocietyUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutUnitsInput
    upsert?: SocietyUpsertWithoutUnitsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutUnitsInput, SocietyUpdateWithoutUnitsInput>, SocietyUncheckedUpdateWithoutUnitsInput>
  }

  export type UserUpdateOneWithoutOwnedUnitsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedUnitsInput, UserUncheckedCreateWithoutOwnedUnitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedUnitsInput
    upsert?: UserUpsertWithoutOwnedUnitsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedUnitsInput, UserUpdateWithoutOwnedUnitsInput>, UserUncheckedUpdateWithoutOwnedUnitsInput>
  }

  export type UserUpdateOneWithoutRentedUnitsNestedInput = {
    create?: XOR<UserCreateWithoutRentedUnitsInput, UserUncheckedCreateWithoutRentedUnitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRentedUnitsInput
    upsert?: UserUpsertWithoutRentedUnitsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRentedUnitsInput, UserUpdateWithoutRentedUnitsInput>, UserUncheckedUpdateWithoutRentedUnitsInput>
  }

  export type VisitorUpdateManyWithoutUnitNestedInput = {
    create?: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput> | VisitorCreateWithoutUnitInput[] | VisitorUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutUnitInput | VisitorCreateOrConnectWithoutUnitInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutUnitInput | VisitorUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: VisitorCreateManyUnitInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutUnitInput | VisitorUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutUnitInput | VisitorUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type ParkingSlotUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput> | ParkingSlotCreateWithoutUnitInput[] | ParkingSlotUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutUnitInput | ParkingSlotCreateOrConnectWithoutUnitInput[]
    upsert?: ParkingSlotUpsertWithWhereUniqueWithoutUnitInput | ParkingSlotUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ParkingSlotCreateManyUnitInputEnvelope
    set?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    disconnect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    delete?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    update?: ParkingSlotUpdateWithWhereUniqueWithoutUnitInput | ParkingSlotUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ParkingSlotUpdateManyWithWhereWithoutUnitInput | ParkingSlotUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
  }

  export type VisitorUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput> | VisitorCreateWithoutUnitInput[] | VisitorUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutUnitInput | VisitorCreateOrConnectWithoutUnitInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutUnitInput | VisitorUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: VisitorCreateManyUnitInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutUnitInput | VisitorUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutUnitInput | VisitorUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput> | ParkingSlotCreateWithoutUnitInput[] | ParkingSlotUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutUnitInput | ParkingSlotCreateOrConnectWithoutUnitInput[]
    upsert?: ParkingSlotUpsertWithWhereUniqueWithoutUnitInput | ParkingSlotUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ParkingSlotCreateManyUnitInputEnvelope
    set?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    disconnect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    delete?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    update?: ParkingSlotUpdateWithWhereUniqueWithoutUnitInput | ParkingSlotUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ParkingSlotUpdateManyWithWhereWithoutUnitInput | ParkingSlotUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
  }

  export type SocietyCreateNestedOneWithoutParkingSlotsInput = {
    create?: XOR<SocietyCreateWithoutParkingSlotsInput, SocietyUncheckedCreateWithoutParkingSlotsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutParkingSlotsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutParkingSlotsInput = {
    create?: XOR<UnitCreateWithoutParkingSlotsInput, UnitUncheckedCreateWithoutParkingSlotsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutParkingSlotsInput
    connect?: UnitWhereUniqueInput
  }

  export type SocietyUpdateOneRequiredWithoutParkingSlotsNestedInput = {
    create?: XOR<SocietyCreateWithoutParkingSlotsInput, SocietyUncheckedCreateWithoutParkingSlotsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutParkingSlotsInput
    upsert?: SocietyUpsertWithoutParkingSlotsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutParkingSlotsInput, SocietyUpdateWithoutParkingSlotsInput>, SocietyUncheckedUpdateWithoutParkingSlotsInput>
  }

  export type UnitUpdateOneWithoutParkingSlotsNestedInput = {
    create?: XOR<UnitCreateWithoutParkingSlotsInput, UnitUncheckedCreateWithoutParkingSlotsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutParkingSlotsInput
    upsert?: UnitUpsertWithoutParkingSlotsInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutParkingSlotsInput, UnitUpdateWithoutParkingSlotsInput>, UnitUncheckedUpdateWithoutParkingSlotsInput>
  }

  export type SocietyCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<SocietyCreateWithoutComplaintsInput, SocietyUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutComplaintsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportedComplaintsInput = {
    create?: XOR<UserCreateWithoutReportedComplaintsInput, UserUncheckedCreateWithoutReportedComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedComplaintsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedComplaintsInput = {
    create?: XOR<UserCreateWithoutAssignedComplaintsInput, UserUncheckedCreateWithoutAssignedComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedComplaintsInput
    connect?: UserWhereUniqueInput
  }

  export type ComplaintCommentCreateNestedManyWithoutComplaintInput = {
    create?: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput> | ComplaintCommentCreateWithoutComplaintInput[] | ComplaintCommentUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutComplaintInput | ComplaintCommentCreateOrConnectWithoutComplaintInput[]
    createMany?: ComplaintCommentCreateManyComplaintInputEnvelope
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
  }

  export type ComplaintCommentUncheckedCreateNestedManyWithoutComplaintInput = {
    create?: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput> | ComplaintCommentCreateWithoutComplaintInput[] | ComplaintCommentUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutComplaintInput | ComplaintCommentCreateOrConnectWithoutComplaintInput[]
    createMany?: ComplaintCommentCreateManyComplaintInputEnvelope
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type EnumComplaintStatusFieldUpdateOperationsInput = {
    set?: $Enums.ComplaintStatus
  }

  export type SocietyUpdateOneRequiredWithoutComplaintsNestedInput = {
    create?: XOR<SocietyCreateWithoutComplaintsInput, SocietyUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutComplaintsInput
    upsert?: SocietyUpsertWithoutComplaintsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutComplaintsInput, SocietyUpdateWithoutComplaintsInput>, SocietyUncheckedUpdateWithoutComplaintsInput>
  }

  export type UserUpdateOneRequiredWithoutReportedComplaintsNestedInput = {
    create?: XOR<UserCreateWithoutReportedComplaintsInput, UserUncheckedCreateWithoutReportedComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedComplaintsInput
    upsert?: UserUpsertWithoutReportedComplaintsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportedComplaintsInput, UserUpdateWithoutReportedComplaintsInput>, UserUncheckedUpdateWithoutReportedComplaintsInput>
  }

  export type UserUpdateOneWithoutAssignedComplaintsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedComplaintsInput, UserUncheckedCreateWithoutAssignedComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedComplaintsInput
    upsert?: UserUpsertWithoutAssignedComplaintsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedComplaintsInput, UserUpdateWithoutAssignedComplaintsInput>, UserUncheckedUpdateWithoutAssignedComplaintsInput>
  }

  export type ComplaintCommentUpdateManyWithoutComplaintNestedInput = {
    create?: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput> | ComplaintCommentCreateWithoutComplaintInput[] | ComplaintCommentUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutComplaintInput | ComplaintCommentCreateOrConnectWithoutComplaintInput[]
    upsert?: ComplaintCommentUpsertWithWhereUniqueWithoutComplaintInput | ComplaintCommentUpsertWithWhereUniqueWithoutComplaintInput[]
    createMany?: ComplaintCommentCreateManyComplaintInputEnvelope
    set?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    disconnect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    delete?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    update?: ComplaintCommentUpdateWithWhereUniqueWithoutComplaintInput | ComplaintCommentUpdateWithWhereUniqueWithoutComplaintInput[]
    updateMany?: ComplaintCommentUpdateManyWithWhereWithoutComplaintInput | ComplaintCommentUpdateManyWithWhereWithoutComplaintInput[]
    deleteMany?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
  }

  export type ComplaintCommentUncheckedUpdateManyWithoutComplaintNestedInput = {
    create?: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput> | ComplaintCommentCreateWithoutComplaintInput[] | ComplaintCommentUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutComplaintInput | ComplaintCommentCreateOrConnectWithoutComplaintInput[]
    upsert?: ComplaintCommentUpsertWithWhereUniqueWithoutComplaintInput | ComplaintCommentUpsertWithWhereUniqueWithoutComplaintInput[]
    createMany?: ComplaintCommentCreateManyComplaintInputEnvelope
    set?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    disconnect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    delete?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    update?: ComplaintCommentUpdateWithWhereUniqueWithoutComplaintInput | ComplaintCommentUpdateWithWhereUniqueWithoutComplaintInput[]
    updateMany?: ComplaintCommentUpdateManyWithWhereWithoutComplaintInput | ComplaintCommentUpdateManyWithWhereWithoutComplaintInput[]
    deleteMany?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
  }

  export type ComplaintCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ComplaintCreateWithoutCommentsInput, ComplaintUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ComplaintCreateOrConnectWithoutCommentsInput
    connect?: ComplaintWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ComplaintUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ComplaintCreateWithoutCommentsInput, ComplaintUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ComplaintCreateOrConnectWithoutCommentsInput
    upsert?: ComplaintUpsertWithoutCommentsInput
    connect?: ComplaintWhereUniqueInput
    update?: XOR<XOR<ComplaintUpdateToOneWithWhereWithoutCommentsInput, ComplaintUpdateWithoutCommentsInput>, ComplaintUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type SocietyCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<SocietyCreateWithoutVisitorsInput, SocietyUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutVisitorsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<UnitCreateWithoutVisitorsInput, UnitUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutVisitorsInput
    connect?: UnitWhereUniqueInput
  }

  export type EnumVisitorStatusFieldUpdateOperationsInput = {
    set?: $Enums.VisitorStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type SocietyUpdateOneRequiredWithoutVisitorsNestedInput = {
    create?: XOR<SocietyCreateWithoutVisitorsInput, SocietyUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutVisitorsInput
    upsert?: SocietyUpsertWithoutVisitorsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutVisitorsInput, SocietyUpdateWithoutVisitorsInput>, SocietyUncheckedUpdateWithoutVisitorsInput>
  }

  export type UnitUpdateOneRequiredWithoutVisitorsNestedInput = {
    create?: XOR<UnitCreateWithoutVisitorsInput, UnitUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutVisitorsInput
    upsert?: UnitUpsertWithoutVisitorsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutVisitorsInput, UnitUpdateWithoutVisitorsInput>, UnitUncheckedUpdateWithoutVisitorsInput>
  }

  export type SocietyCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<SocietyCreateWithoutTransactionsInput, SocietyUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutTransactionsInput
    connect?: SocietyWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type SocietyUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<SocietyCreateWithoutTransactionsInput, SocietyUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutTransactionsInput
    upsert?: SocietyUpsertWithoutTransactionsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutTransactionsInput, SocietyUpdateWithoutTransactionsInput>, SocietyUncheckedUpdateWithoutTransactionsInput>
  }

  export type SocietyCreateNestedOneWithoutVendorsInput = {
    create?: XOR<SocietyCreateWithoutVendorsInput, SocietyUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutVendorsInput
    connect?: SocietyWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SocietyUpdateOneRequiredWithoutVendorsNestedInput = {
    create?: XOR<SocietyCreateWithoutVendorsInput, SocietyUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutVendorsInput
    upsert?: SocietyUpsertWithoutVendorsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutVendorsInput, SocietyUpdateWithoutVendorsInput>, SocietyUncheckedUpdateWithoutVendorsInput>
  }

  export type SocietyCreateNestedOneWithoutNoticesInput = {
    create?: XOR<SocietyCreateWithoutNoticesInput, SocietyUncheckedCreateWithoutNoticesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutNoticesInput
    connect?: SocietyWhereUniqueInput
  }

  export type SocietyUpdateOneRequiredWithoutNoticesNestedInput = {
    create?: XOR<SocietyCreateWithoutNoticesInput, SocietyUncheckedCreateWithoutNoticesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutNoticesInput
    upsert?: SocietyUpsertWithoutNoticesInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutNoticesInput, SocietyUpdateWithoutNoticesInput>, SocietyUncheckedUpdateWithoutNoticesInput>
  }

  export type SocietyCreateNestedOneWithoutAmenitiesInput = {
    create?: XOR<SocietyCreateWithoutAmenitiesInput, SocietyUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutAmenitiesInput
    connect?: SocietyWhereUniqueInput
  }

  export type AmenityBookingCreateNestedManyWithoutAmenityInput = {
    create?: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput> | AmenityBookingCreateWithoutAmenityInput[] | AmenityBookingUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutAmenityInput | AmenityBookingCreateOrConnectWithoutAmenityInput[]
    createMany?: AmenityBookingCreateManyAmenityInputEnvelope
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
  }

  export type AmenityBookingUncheckedCreateNestedManyWithoutAmenityInput = {
    create?: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput> | AmenityBookingCreateWithoutAmenityInput[] | AmenityBookingUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutAmenityInput | AmenityBookingCreateOrConnectWithoutAmenityInput[]
    createMany?: AmenityBookingCreateManyAmenityInputEnvelope
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
  }

  export type SocietyUpdateOneRequiredWithoutAmenitiesNestedInput = {
    create?: XOR<SocietyCreateWithoutAmenitiesInput, SocietyUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutAmenitiesInput
    upsert?: SocietyUpsertWithoutAmenitiesInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutAmenitiesInput, SocietyUpdateWithoutAmenitiesInput>, SocietyUncheckedUpdateWithoutAmenitiesInput>
  }

  export type AmenityBookingUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput> | AmenityBookingCreateWithoutAmenityInput[] | AmenityBookingUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutAmenityInput | AmenityBookingCreateOrConnectWithoutAmenityInput[]
    upsert?: AmenityBookingUpsertWithWhereUniqueWithoutAmenityInput | AmenityBookingUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: AmenityBookingCreateManyAmenityInputEnvelope
    set?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    disconnect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    delete?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    update?: AmenityBookingUpdateWithWhereUniqueWithoutAmenityInput | AmenityBookingUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: AmenityBookingUpdateManyWithWhereWithoutAmenityInput | AmenityBookingUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
  }

  export type AmenityBookingUncheckedUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput> | AmenityBookingCreateWithoutAmenityInput[] | AmenityBookingUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutAmenityInput | AmenityBookingCreateOrConnectWithoutAmenityInput[]
    upsert?: AmenityBookingUpsertWithWhereUniqueWithoutAmenityInput | AmenityBookingUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: AmenityBookingCreateManyAmenityInputEnvelope
    set?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    disconnect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    delete?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    update?: AmenityBookingUpdateWithWhereUniqueWithoutAmenityInput | AmenityBookingUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: AmenityBookingUpdateManyWithWhereWithoutAmenityInput | AmenityBookingUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
  }

  export type AmenityCreateNestedOneWithoutBookingsInput = {
    create?: XOR<AmenityCreateWithoutBookingsInput, AmenityUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutBookingsInput
    connect?: AmenityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type AmenityUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<AmenityCreateWithoutBookingsInput, AmenityUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutBookingsInput
    upsert?: AmenityUpsertWithoutBookingsInput
    connect?: AmenityWhereUniqueInput
    update?: XOR<XOR<AmenityUpdateToOneWithWhereWithoutBookingsInput, AmenityUpdateWithoutBookingsInput>, AmenityUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumSocietyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SocietyStatus | EnumSocietyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SocietyStatus[]
    notIn?: $Enums.SocietyStatus[]
    not?: NestedEnumSocietyStatusFilter<$PrismaModel> | $Enums.SocietyStatus
  }

  export type NestedEnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSocietyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocietyStatus | EnumSocietyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SocietyStatus[]
    notIn?: $Enums.SocietyStatus[]
    not?: NestedEnumSocietyStatusWithAggregatesFilter<$PrismaModel> | $Enums.SocietyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocietyStatusFilter<$PrismaModel>
    _max?: NestedEnumSocietyStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[]
    notIn?: $Enums.Priority[]
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumComplaintStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[]
    notIn?: $Enums.ComplaintStatus[]
    not?: NestedEnumComplaintStatusFilter<$PrismaModel> | $Enums.ComplaintStatus
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[]
    notIn?: $Enums.Priority[]
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[]
    notIn?: $Enums.ComplaintStatus[]
    not?: NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintStatusFilter<$PrismaModel>
    _max?: NestedEnumComplaintStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumVisitorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitorStatus | EnumVisitorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitorStatus[]
    notIn?: $Enums.VisitorStatus[]
    not?: NestedEnumVisitorStatusFilter<$PrismaModel> | $Enums.VisitorStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumVisitorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitorStatus | EnumVisitorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitorStatus[]
    notIn?: $Enums.VisitorStatus[]
    not?: NestedEnumVisitorStatusWithAggregatesFilter<$PrismaModel> | $Enums.VisitorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitorStatusFilter<$PrismaModel>
    _max?: NestedEnumVisitorStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserCreateWithoutSocietyInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSocietyInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSocietyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput>
  }

  export type UserCreateManySocietyInputEnvelope = {
    data: UserCreateManySocietyInput | UserCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type UnitCreateWithoutSocietyInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutSocietyInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutSocietyInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput>
  }

  export type UnitCreateManySocietyInputEnvelope = {
    data: UnitCreateManySocietyInput | UnitCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCreateWithoutSocietyInput = {
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    reportedBy: UserCreateNestedOneWithoutReportedComplaintsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedComplaintsInput
    comments?: ComplaintCommentCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintUncheckedCreateWithoutSocietyInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    reportedById: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintCreateOrConnectWithoutSocietyInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput>
  }

  export type ComplaintCreateManySocietyInputEnvelope = {
    data: ComplaintCreateManySocietyInput | ComplaintCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type VisitorCreateWithoutSocietyInput = {
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateWithoutSocietyInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    visitingUnitId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorCreateOrConnectWithoutSocietyInput = {
    where: VisitorWhereUniqueInput
    create: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput>
  }

  export type VisitorCreateManySocietyInputEnvelope = {
    data: VisitorCreateManySocietyInput | VisitorCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutSocietyInput = {
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUncheckedCreateWithoutSocietyInput = {
    id?: number
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutSocietyInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput>
  }

  export type TransactionCreateManySocietyInputEnvelope = {
    data: TransactionCreateManySocietyInput | TransactionCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type NoticeCreateWithoutSocietyInput = {
    title: string
    content: string
    audience: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NoticeUncheckedCreateWithoutSocietyInput = {
    id?: number
    title: string
    content: string
    audience: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NoticeCreateOrConnectWithoutSocietyInput = {
    where: NoticeWhereUniqueInput
    create: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput>
  }

  export type NoticeCreateManySocietyInputEnvelope = {
    data: NoticeCreateManySocietyInput | NoticeCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type VendorCreateWithoutSocietyInput = {
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    active?: boolean
    createdAt?: Date | string
  }

  export type VendorUncheckedCreateWithoutSocietyInput = {
    id?: number
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    active?: boolean
    createdAt?: Date | string
  }

  export type VendorCreateOrConnectWithoutSocietyInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput>
  }

  export type VendorCreateManySocietyInputEnvelope = {
    data: VendorCreateManySocietyInput | VendorCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type AmenityCreateWithoutSocietyInput = {
    name: string
    description?: string | null
    chargesPerHour?: number
    createdAt?: Date | string
    bookings?: AmenityBookingCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUncheckedCreateWithoutSocietyInput = {
    id?: number
    name: string
    description?: string | null
    chargesPerHour?: number
    createdAt?: Date | string
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutAmenityInput
  }

  export type AmenityCreateOrConnectWithoutSocietyInput = {
    where: AmenityWhereUniqueInput
    create: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput>
  }

  export type AmenityCreateManySocietyInputEnvelope = {
    data: AmenityCreateManySocietyInput | AmenityCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type ParkingSlotCreateWithoutSocietyInput = {
    number: string
    type: string
    status: string
    vehicleNumber?: string | null
    createdAt?: Date | string
    unit?: UnitCreateNestedOneWithoutParkingSlotsInput
  }

  export type ParkingSlotUncheckedCreateWithoutSocietyInput = {
    id?: number
    number: string
    type: string
    status: string
    allocatedToUnitId?: number | null
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type ParkingSlotCreateOrConnectWithoutSocietyInput = {
    where: ParkingSlotWhereUniqueInput
    create: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput>
  }

  export type ParkingSlotCreateManySocietyInputEnvelope = {
    data: ParkingSlotCreateManySocietyInput | ParkingSlotCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutSocietyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSocietyInput, UserUncheckedUpdateWithoutSocietyInput>
    create: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSocietyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSocietyInput, UserUncheckedUpdateWithoutSocietyInput>
  }

  export type UserUpdateManyWithWhereWithoutSocietyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSocietyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    profileImg?: StringNullableFilter<"User"> | string | null
    societyId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UnitUpsertWithWhereUniqueWithoutSocietyInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutSocietyInput, UnitUncheckedUpdateWithoutSocietyInput>
    create: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutSocietyInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutSocietyInput, UnitUncheckedUpdateWithoutSocietyInput>
  }

  export type UnitUpdateManyWithWhereWithoutSocietyInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutSocietyInput>
  }

  export type UnitScalarWhereInput = {
    AND?: UnitScalarWhereInput | UnitScalarWhereInput[]
    OR?: UnitScalarWhereInput[]
    NOT?: UnitScalarWhereInput | UnitScalarWhereInput[]
    id?: IntFilter<"Unit"> | number
    block?: StringFilter<"Unit"> | string
    number?: StringFilter<"Unit"> | string
    floor?: IntFilter<"Unit"> | number
    type?: StringFilter<"Unit"> | string
    areaSqFt?: FloatFilter<"Unit"> | number
    societyId?: IntFilter<"Unit"> | number
    ownerId?: IntNullableFilter<"Unit"> | number | null
    tenantId?: IntNullableFilter<"Unit"> | number | null
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
  }

  export type ComplaintUpsertWithWhereUniqueWithoutSocietyInput = {
    where: ComplaintWhereUniqueInput
    update: XOR<ComplaintUpdateWithoutSocietyInput, ComplaintUncheckedUpdateWithoutSocietyInput>
    create: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput>
  }

  export type ComplaintUpdateWithWhereUniqueWithoutSocietyInput = {
    where: ComplaintWhereUniqueInput
    data: XOR<ComplaintUpdateWithoutSocietyInput, ComplaintUncheckedUpdateWithoutSocietyInput>
  }

  export type ComplaintUpdateManyWithWhereWithoutSocietyInput = {
    where: ComplaintScalarWhereInput
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyWithoutSocietyInput>
  }

  export type ComplaintScalarWhereInput = {
    AND?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
    OR?: ComplaintScalarWhereInput[]
    NOT?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
    id?: IntFilter<"Complaint"> | number
    title?: StringFilter<"Complaint"> | string
    description?: StringFilter<"Complaint"> | string
    category?: StringFilter<"Complaint"> | string
    priority?: EnumPriorityFilter<"Complaint"> | $Enums.Priority
    status?: EnumComplaintStatusFilter<"Complaint"> | $Enums.ComplaintStatus
    images?: JsonNullableFilter<"Complaint">
    societyId?: IntFilter<"Complaint"> | number
    reportedById?: IntFilter<"Complaint"> | number
    assignedToId?: IntNullableFilter<"Complaint"> | number | null
    timeline?: JsonNullableFilter<"Complaint">
    createdAt?: DateTimeFilter<"Complaint"> | Date | string
    updatedAt?: DateTimeFilter<"Complaint"> | Date | string
  }

  export type VisitorUpsertWithWhereUniqueWithoutSocietyInput = {
    where: VisitorWhereUniqueInput
    update: XOR<VisitorUpdateWithoutSocietyInput, VisitorUncheckedUpdateWithoutSocietyInput>
    create: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput>
  }

  export type VisitorUpdateWithWhereUniqueWithoutSocietyInput = {
    where: VisitorWhereUniqueInput
    data: XOR<VisitorUpdateWithoutSocietyInput, VisitorUncheckedUpdateWithoutSocietyInput>
  }

  export type VisitorUpdateManyWithWhereWithoutSocietyInput = {
    where: VisitorScalarWhereInput
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyWithoutSocietyInput>
  }

  export type VisitorScalarWhereInput = {
    AND?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
    OR?: VisitorScalarWhereInput[]
    NOT?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
    id?: IntFilter<"Visitor"> | number
    name?: StringFilter<"Visitor"> | string
    phone?: StringFilter<"Visitor"> | string
    vehicleNo?: StringNullableFilter<"Visitor"> | string | null
    purpose?: StringFilter<"Visitor"> | string
    photo?: StringNullableFilter<"Visitor"> | string | null
    status?: EnumVisitorStatusFilter<"Visitor"> | $Enums.VisitorStatus
    entryTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    exitTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    societyId?: IntFilter<"Visitor"> | number
    visitingUnitId?: IntFilter<"Visitor"> | number
    idType?: StringNullableFilter<"Visitor"> | string | null
    idNumber?: StringNullableFilter<"Visitor"> | string | null
    createdAt?: DateTimeFilter<"Visitor"> | Date | string
    updatedAt?: DateTimeFilter<"Visitor"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutSocietyInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutSocietyInput, TransactionUncheckedUpdateWithoutSocietyInput>
    create: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutSocietyInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutSocietyInput, TransactionUncheckedUpdateWithoutSocietyInput>
  }

  export type TransactionUpdateManyWithWhereWithoutSocietyInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutSocietyInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    category?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    status?: StringFilter<"Transaction"> | string
    societyId?: IntFilter<"Transaction"> | number
    invoiceNo?: StringNullableFilter<"Transaction"> | string | null
    paidTo?: StringNullableFilter<"Transaction"> | string | null
    receivedFrom?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type NoticeUpsertWithWhereUniqueWithoutSocietyInput = {
    where: NoticeWhereUniqueInput
    update: XOR<NoticeUpdateWithoutSocietyInput, NoticeUncheckedUpdateWithoutSocietyInput>
    create: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput>
  }

  export type NoticeUpdateWithWhereUniqueWithoutSocietyInput = {
    where: NoticeWhereUniqueInput
    data: XOR<NoticeUpdateWithoutSocietyInput, NoticeUncheckedUpdateWithoutSocietyInput>
  }

  export type NoticeUpdateManyWithWhereWithoutSocietyInput = {
    where: NoticeScalarWhereInput
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyWithoutSocietyInput>
  }

  export type NoticeScalarWhereInput = {
    AND?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
    OR?: NoticeScalarWhereInput[]
    NOT?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
    id?: IntFilter<"Notice"> | number
    title?: StringFilter<"Notice"> | string
    content?: StringFilter<"Notice"> | string
    audience?: StringFilter<"Notice"> | string
    societyId?: IntFilter<"Notice"> | number
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notice"> | Date | string | null
  }

  export type VendorUpsertWithWhereUniqueWithoutSocietyInput = {
    where: VendorWhereUniqueInput
    update: XOR<VendorUpdateWithoutSocietyInput, VendorUncheckedUpdateWithoutSocietyInput>
    create: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput>
  }

  export type VendorUpdateWithWhereUniqueWithoutSocietyInput = {
    where: VendorWhereUniqueInput
    data: XOR<VendorUpdateWithoutSocietyInput, VendorUncheckedUpdateWithoutSocietyInput>
  }

  export type VendorUpdateManyWithWhereWithoutSocietyInput = {
    where: VendorScalarWhereInput
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyWithoutSocietyInput>
  }

  export type VendorScalarWhereInput = {
    AND?: VendorScalarWhereInput | VendorScalarWhereInput[]
    OR?: VendorScalarWhereInput[]
    NOT?: VendorScalarWhereInput | VendorScalarWhereInput[]
    id?: IntFilter<"Vendor"> | number
    name?: StringFilter<"Vendor"> | string
    serviceType?: StringFilter<"Vendor"> | string
    contact?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    active?: BoolFilter<"Vendor"> | boolean
    societyId?: IntFilter<"Vendor"> | number
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
  }

  export type AmenityUpsertWithWhereUniqueWithoutSocietyInput = {
    where: AmenityWhereUniqueInput
    update: XOR<AmenityUpdateWithoutSocietyInput, AmenityUncheckedUpdateWithoutSocietyInput>
    create: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput>
  }

  export type AmenityUpdateWithWhereUniqueWithoutSocietyInput = {
    where: AmenityWhereUniqueInput
    data: XOR<AmenityUpdateWithoutSocietyInput, AmenityUncheckedUpdateWithoutSocietyInput>
  }

  export type AmenityUpdateManyWithWhereWithoutSocietyInput = {
    where: AmenityScalarWhereInput
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyWithoutSocietyInput>
  }

  export type AmenityScalarWhereInput = {
    AND?: AmenityScalarWhereInput | AmenityScalarWhereInput[]
    OR?: AmenityScalarWhereInput[]
    NOT?: AmenityScalarWhereInput | AmenityScalarWhereInput[]
    id?: IntFilter<"Amenity"> | number
    name?: StringFilter<"Amenity"> | string
    description?: StringNullableFilter<"Amenity"> | string | null
    chargesPerHour?: FloatFilter<"Amenity"> | number
    societyId?: IntFilter<"Amenity"> | number
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
  }

  export type ParkingSlotUpsertWithWhereUniqueWithoutSocietyInput = {
    where: ParkingSlotWhereUniqueInput
    update: XOR<ParkingSlotUpdateWithoutSocietyInput, ParkingSlotUncheckedUpdateWithoutSocietyInput>
    create: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput>
  }

  export type ParkingSlotUpdateWithWhereUniqueWithoutSocietyInput = {
    where: ParkingSlotWhereUniqueInput
    data: XOR<ParkingSlotUpdateWithoutSocietyInput, ParkingSlotUncheckedUpdateWithoutSocietyInput>
  }

  export type ParkingSlotUpdateManyWithWhereWithoutSocietyInput = {
    where: ParkingSlotScalarWhereInput
    data: XOR<ParkingSlotUpdateManyMutationInput, ParkingSlotUncheckedUpdateManyWithoutSocietyInput>
  }

  export type ParkingSlotScalarWhereInput = {
    AND?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
    OR?: ParkingSlotScalarWhereInput[]
    NOT?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
    id?: IntFilter<"ParkingSlot"> | number
    number?: StringFilter<"ParkingSlot"> | string
    type?: StringFilter<"ParkingSlot"> | string
    status?: StringFilter<"ParkingSlot"> | string
    societyId?: IntFilter<"ParkingSlot"> | number
    allocatedToUnitId?: IntNullableFilter<"ParkingSlot"> | number | null
    vehicleNumber?: StringNullableFilter<"ParkingSlot"> | string | null
    createdAt?: DateTimeFilter<"ParkingSlot"> | Date | string
  }

  export type SocietyCreateWithoutUsersInput = {
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutUsersInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutUsersInput, SocietyUncheckedCreateWithoutUsersInput>
  }

  export type UnitCreateWithoutOwnerInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutOwnerInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutOwnerInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput>
  }

  export type UnitCreateManyOwnerInputEnvelope = {
    data: UnitCreateManyOwnerInput | UnitCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type UnitCreateWithoutTenantInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutTenantInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    ownerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutTenantInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput>
  }

  export type UnitCreateManyTenantInputEnvelope = {
    data: UnitCreateManyTenantInput | UnitCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCreateWithoutReportedByInput = {
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutComplaintsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedComplaintsInput
    comments?: ComplaintCommentCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintUncheckedCreateWithoutReportedByInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintCreateOrConnectWithoutReportedByInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput>
  }

  export type ComplaintCreateManyReportedByInputEnvelope = {
    data: ComplaintCreateManyReportedByInput | ComplaintCreateManyReportedByInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCreateWithoutAssignedToInput = {
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutComplaintsInput
    reportedBy: UserCreateNestedOneWithoutReportedComplaintsInput
    comments?: ComplaintCommentCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintUncheckedCreateWithoutAssignedToInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    reportedById: number
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintCreateOrConnectWithoutAssignedToInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput>
  }

  export type ComplaintCreateManyAssignedToInputEnvelope = {
    data: ComplaintCreateManyAssignedToInput | ComplaintCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type AmenityBookingCreateWithoutUserInput = {
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
    amenity: AmenityCreateNestedOneWithoutBookingsInput
  }

  export type AmenityBookingUncheckedCreateWithoutUserInput = {
    id?: number
    amenityId: number
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
  }

  export type AmenityBookingCreateOrConnectWithoutUserInput = {
    where: AmenityBookingWhereUniqueInput
    create: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput>
  }

  export type AmenityBookingCreateManyUserInputEnvelope = {
    data: AmenityBookingCreateManyUserInput | AmenityBookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCommentCreateWithoutUserInput = {
    message: string
    createdAt?: Date | string
    complaint: ComplaintCreateNestedOneWithoutCommentsInput
  }

  export type ComplaintCommentUncheckedCreateWithoutUserInput = {
    id?: number
    complaintId: number
    message: string
    createdAt?: Date | string
  }

  export type ComplaintCommentCreateOrConnectWithoutUserInput = {
    where: ComplaintCommentWhereUniqueInput
    create: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput>
  }

  export type ComplaintCommentCreateManyUserInputEnvelope = {
    data: ComplaintCommentCreateManyUserInput | ComplaintCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SocietyUpsertWithoutUsersInput = {
    update: XOR<SocietyUpdateWithoutUsersInput, SocietyUncheckedUpdateWithoutUsersInput>
    create: XOR<SocietyCreateWithoutUsersInput, SocietyUncheckedCreateWithoutUsersInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutUsersInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutUsersInput, SocietyUncheckedUpdateWithoutUsersInput>
  }

  export type SocietyUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UnitUpsertWithWhereUniqueWithoutOwnerInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutOwnerInput, UnitUncheckedUpdateWithoutOwnerInput>
    create: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutOwnerInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutOwnerInput, UnitUncheckedUpdateWithoutOwnerInput>
  }

  export type UnitUpdateManyWithWhereWithoutOwnerInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutOwnerInput>
  }

  export type UnitUpsertWithWhereUniqueWithoutTenantInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutTenantInput, UnitUncheckedUpdateWithoutTenantInput>
    create: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutTenantInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutTenantInput, UnitUncheckedUpdateWithoutTenantInput>
  }

  export type UnitUpdateManyWithWhereWithoutTenantInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutTenantInput>
  }

  export type ComplaintUpsertWithWhereUniqueWithoutReportedByInput = {
    where: ComplaintWhereUniqueInput
    update: XOR<ComplaintUpdateWithoutReportedByInput, ComplaintUncheckedUpdateWithoutReportedByInput>
    create: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput>
  }

  export type ComplaintUpdateWithWhereUniqueWithoutReportedByInput = {
    where: ComplaintWhereUniqueInput
    data: XOR<ComplaintUpdateWithoutReportedByInput, ComplaintUncheckedUpdateWithoutReportedByInput>
  }

  export type ComplaintUpdateManyWithWhereWithoutReportedByInput = {
    where: ComplaintScalarWhereInput
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyWithoutReportedByInput>
  }

  export type ComplaintUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: ComplaintWhereUniqueInput
    update: XOR<ComplaintUpdateWithoutAssignedToInput, ComplaintUncheckedUpdateWithoutAssignedToInput>
    create: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput>
  }

  export type ComplaintUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: ComplaintWhereUniqueInput
    data: XOR<ComplaintUpdateWithoutAssignedToInput, ComplaintUncheckedUpdateWithoutAssignedToInput>
  }

  export type ComplaintUpdateManyWithWhereWithoutAssignedToInput = {
    where: ComplaintScalarWhereInput
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type AmenityBookingUpsertWithWhereUniqueWithoutUserInput = {
    where: AmenityBookingWhereUniqueInput
    update: XOR<AmenityBookingUpdateWithoutUserInput, AmenityBookingUncheckedUpdateWithoutUserInput>
    create: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput>
  }

  export type AmenityBookingUpdateWithWhereUniqueWithoutUserInput = {
    where: AmenityBookingWhereUniqueInput
    data: XOR<AmenityBookingUpdateWithoutUserInput, AmenityBookingUncheckedUpdateWithoutUserInput>
  }

  export type AmenityBookingUpdateManyWithWhereWithoutUserInput = {
    where: AmenityBookingScalarWhereInput
    data: XOR<AmenityBookingUpdateManyMutationInput, AmenityBookingUncheckedUpdateManyWithoutUserInput>
  }

  export type AmenityBookingScalarWhereInput = {
    AND?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
    OR?: AmenityBookingScalarWhereInput[]
    NOT?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
    id?: IntFilter<"AmenityBooking"> | number
    amenityId?: IntFilter<"AmenityBooking"> | number
    userId?: IntFilter<"AmenityBooking"> | number
    startTime?: DateTimeFilter<"AmenityBooking"> | Date | string
    endTime?: DateTimeFilter<"AmenityBooking"> | Date | string
    status?: StringFilter<"AmenityBooking"> | string
    amountPaid?: FloatFilter<"AmenityBooking"> | number
    createdAt?: DateTimeFilter<"AmenityBooking"> | Date | string
  }

  export type ComplaintCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: ComplaintCommentWhereUniqueInput
    update: XOR<ComplaintCommentUpdateWithoutUserInput, ComplaintCommentUncheckedUpdateWithoutUserInput>
    create: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput>
  }

  export type ComplaintCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: ComplaintCommentWhereUniqueInput
    data: XOR<ComplaintCommentUpdateWithoutUserInput, ComplaintCommentUncheckedUpdateWithoutUserInput>
  }

  export type ComplaintCommentUpdateManyWithWhereWithoutUserInput = {
    where: ComplaintCommentScalarWhereInput
    data: XOR<ComplaintCommentUpdateManyMutationInput, ComplaintCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type ComplaintCommentScalarWhereInput = {
    AND?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
    OR?: ComplaintCommentScalarWhereInput[]
    NOT?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
    id?: IntFilter<"ComplaintComment"> | number
    complaintId?: IntFilter<"ComplaintComment"> | number
    userId?: IntFilter<"ComplaintComment"> | number
    message?: StringFilter<"ComplaintComment"> | string
    createdAt?: DateTimeFilter<"ComplaintComment"> | Date | string
  }

  export type SocietyCreateWithoutUnitsInput = {
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutUnitsInput = {
    id?: number
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutUnitsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutUnitsInput, SocietyUncheckedCreateWithoutUnitsInput>
  }

  export type UserCreateWithoutOwnedUnitsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutUsersInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedUnitsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedUnitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedUnitsInput, UserUncheckedCreateWithoutOwnedUnitsInput>
  }

  export type UserCreateWithoutRentedUnitsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRentedUnitsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRentedUnitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRentedUnitsInput, UserUncheckedCreateWithoutRentedUnitsInput>
  }

  export type VisitorCreateWithoutUnitInput = {
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateWithoutUnitInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    societyId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorCreateOrConnectWithoutUnitInput = {
    where: VisitorWhereUniqueInput
    create: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput>
  }

  export type VisitorCreateManyUnitInputEnvelope = {
    data: VisitorCreateManyUnitInput | VisitorCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ParkingSlotCreateWithoutUnitInput = {
    number: string
    type: string
    status: string
    vehicleNumber?: string | null
    createdAt?: Date | string
    society: SocietyCreateNestedOneWithoutParkingSlotsInput
  }

  export type ParkingSlotUncheckedCreateWithoutUnitInput = {
    id?: number
    number: string
    type: string
    status: string
    societyId: number
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type ParkingSlotCreateOrConnectWithoutUnitInput = {
    where: ParkingSlotWhereUniqueInput
    create: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput>
  }

  export type ParkingSlotCreateManyUnitInputEnvelope = {
    data: ParkingSlotCreateManyUnitInput | ParkingSlotCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type SocietyUpsertWithoutUnitsInput = {
    update: XOR<SocietyUpdateWithoutUnitsInput, SocietyUncheckedUpdateWithoutUnitsInput>
    create: XOR<SocietyCreateWithoutUnitsInput, SocietyUncheckedCreateWithoutUnitsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutUnitsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutUnitsInput, SocietyUncheckedUpdateWithoutUnitsInput>
  }

  export type SocietyUpdateWithoutUnitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UserUpsertWithoutOwnedUnitsInput = {
    update: XOR<UserUpdateWithoutOwnedUnitsInput, UserUncheckedUpdateWithoutOwnedUnitsInput>
    create: XOR<UserCreateWithoutOwnedUnitsInput, UserUncheckedCreateWithoutOwnedUnitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedUnitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedUnitsInput, UserUncheckedUpdateWithoutOwnedUnitsInput>
  }

  export type UserUpdateWithoutOwnedUnitsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutUsersNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutRentedUnitsInput = {
    update: XOR<UserUpdateWithoutRentedUnitsInput, UserUncheckedUpdateWithoutRentedUnitsInput>
    create: XOR<UserCreateWithoutRentedUnitsInput, UserUncheckedCreateWithoutRentedUnitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRentedUnitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRentedUnitsInput, UserUncheckedUpdateWithoutRentedUnitsInput>
  }

  export type UserUpdateWithoutRentedUnitsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRentedUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VisitorUpsertWithWhereUniqueWithoutUnitInput = {
    where: VisitorWhereUniqueInput
    update: XOR<VisitorUpdateWithoutUnitInput, VisitorUncheckedUpdateWithoutUnitInput>
    create: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput>
  }

  export type VisitorUpdateWithWhereUniqueWithoutUnitInput = {
    where: VisitorWhereUniqueInput
    data: XOR<VisitorUpdateWithoutUnitInput, VisitorUncheckedUpdateWithoutUnitInput>
  }

  export type VisitorUpdateManyWithWhereWithoutUnitInput = {
    where: VisitorScalarWhereInput
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyWithoutUnitInput>
  }

  export type ParkingSlotUpsertWithWhereUniqueWithoutUnitInput = {
    where: ParkingSlotWhereUniqueInput
    update: XOR<ParkingSlotUpdateWithoutUnitInput, ParkingSlotUncheckedUpdateWithoutUnitInput>
    create: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput>
  }

  export type ParkingSlotUpdateWithWhereUniqueWithoutUnitInput = {
    where: ParkingSlotWhereUniqueInput
    data: XOR<ParkingSlotUpdateWithoutUnitInput, ParkingSlotUncheckedUpdateWithoutUnitInput>
  }

  export type ParkingSlotUpdateManyWithWhereWithoutUnitInput = {
    where: ParkingSlotScalarWhereInput
    data: XOR<ParkingSlotUpdateManyMutationInput, ParkingSlotUncheckedUpdateManyWithoutUnitInput>
  }

  export type SocietyCreateWithoutParkingSlotsInput = {
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutParkingSlotsInput = {
    id?: number
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutParkingSlotsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutParkingSlotsInput, SocietyUncheckedCreateWithoutParkingSlotsInput>
  }

  export type UnitCreateWithoutParkingSlotsInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutParkingSlotsInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutParkingSlotsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutParkingSlotsInput, UnitUncheckedCreateWithoutParkingSlotsInput>
  }

  export type SocietyUpsertWithoutParkingSlotsInput = {
    update: XOR<SocietyUpdateWithoutParkingSlotsInput, SocietyUncheckedUpdateWithoutParkingSlotsInput>
    create: XOR<SocietyCreateWithoutParkingSlotsInput, SocietyUncheckedCreateWithoutParkingSlotsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutParkingSlotsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutParkingSlotsInput, SocietyUncheckedUpdateWithoutParkingSlotsInput>
  }

  export type SocietyUpdateWithoutParkingSlotsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutParkingSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UnitUpsertWithoutParkingSlotsInput = {
    update: XOR<UnitUpdateWithoutParkingSlotsInput, UnitUncheckedUpdateWithoutParkingSlotsInput>
    create: XOR<UnitCreateWithoutParkingSlotsInput, UnitUncheckedCreateWithoutParkingSlotsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutParkingSlotsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutParkingSlotsInput, UnitUncheckedUpdateWithoutParkingSlotsInput>
  }

  export type UnitUpdateWithoutParkingSlotsInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutParkingSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type SocietyCreateWithoutComplaintsInput = {
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutComplaintsInput = {
    id?: number
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutComplaintsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutComplaintsInput, SocietyUncheckedCreateWithoutComplaintsInput>
  }

  export type UserCreateWithoutReportedComplaintsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportedComplaintsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportedComplaintsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportedComplaintsInput, UserUncheckedCreateWithoutReportedComplaintsInput>
  }

  export type UserCreateWithoutAssignedComplaintsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedComplaintsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedComplaintsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedComplaintsInput, UserUncheckedCreateWithoutAssignedComplaintsInput>
  }

  export type ComplaintCommentCreateWithoutComplaintInput = {
    message: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type ComplaintCommentUncheckedCreateWithoutComplaintInput = {
    id?: number
    userId: number
    message: string
    createdAt?: Date | string
  }

  export type ComplaintCommentCreateOrConnectWithoutComplaintInput = {
    where: ComplaintCommentWhereUniqueInput
    create: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput>
  }

  export type ComplaintCommentCreateManyComplaintInputEnvelope = {
    data: ComplaintCommentCreateManyComplaintInput | ComplaintCommentCreateManyComplaintInput[]
    skipDuplicates?: boolean
  }

  export type SocietyUpsertWithoutComplaintsInput = {
    update: XOR<SocietyUpdateWithoutComplaintsInput, SocietyUncheckedUpdateWithoutComplaintsInput>
    create: XOR<SocietyCreateWithoutComplaintsInput, SocietyUncheckedCreateWithoutComplaintsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutComplaintsInput, SocietyUncheckedUpdateWithoutComplaintsInput>
  }

  export type SocietyUpdateWithoutComplaintsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UserUpsertWithoutReportedComplaintsInput = {
    update: XOR<UserUpdateWithoutReportedComplaintsInput, UserUncheckedUpdateWithoutReportedComplaintsInput>
    create: XOR<UserCreateWithoutReportedComplaintsInput, UserUncheckedCreateWithoutReportedComplaintsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportedComplaintsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportedComplaintsInput, UserUncheckedUpdateWithoutReportedComplaintsInput>
  }

  export type UserUpdateWithoutReportedComplaintsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportedComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutAssignedComplaintsInput = {
    update: XOR<UserUpdateWithoutAssignedComplaintsInput, UserUncheckedUpdateWithoutAssignedComplaintsInput>
    create: XOR<UserCreateWithoutAssignedComplaintsInput, UserUncheckedCreateWithoutAssignedComplaintsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedComplaintsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedComplaintsInput, UserUncheckedUpdateWithoutAssignedComplaintsInput>
  }

  export type UserUpdateWithoutAssignedComplaintsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ComplaintCommentUpsertWithWhereUniqueWithoutComplaintInput = {
    where: ComplaintCommentWhereUniqueInput
    update: XOR<ComplaintCommentUpdateWithoutComplaintInput, ComplaintCommentUncheckedUpdateWithoutComplaintInput>
    create: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput>
  }

  export type ComplaintCommentUpdateWithWhereUniqueWithoutComplaintInput = {
    where: ComplaintCommentWhereUniqueInput
    data: XOR<ComplaintCommentUpdateWithoutComplaintInput, ComplaintCommentUncheckedUpdateWithoutComplaintInput>
  }

  export type ComplaintCommentUpdateManyWithWhereWithoutComplaintInput = {
    where: ComplaintCommentScalarWhereInput
    data: XOR<ComplaintCommentUpdateManyMutationInput, ComplaintCommentUncheckedUpdateManyWithoutComplaintInput>
  }

  export type ComplaintCreateWithoutCommentsInput = {
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutComplaintsInput
    reportedBy: UserCreateNestedOneWithoutReportedComplaintsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedComplaintsInput
  }

  export type ComplaintUncheckedCreateWithoutCommentsInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    reportedById: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintCreateOrConnectWithoutCommentsInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutCommentsInput, ComplaintUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type ComplaintUpsertWithoutCommentsInput = {
    update: XOR<ComplaintUpdateWithoutCommentsInput, ComplaintUncheckedUpdateWithoutCommentsInput>
    create: XOR<ComplaintCreateWithoutCommentsInput, ComplaintUncheckedCreateWithoutCommentsInput>
    where?: ComplaintWhereInput
  }

  export type ComplaintUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ComplaintWhereInput
    data: XOR<ComplaintUpdateWithoutCommentsInput, ComplaintUncheckedUpdateWithoutCommentsInput>
  }

  export type ComplaintUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutComplaintsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutReportedComplaintsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedComplaintsNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SocietyCreateWithoutVisitorsInput = {
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutVisitorsInput = {
    id?: number
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutVisitorsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutVisitorsInput, SocietyUncheckedCreateWithoutVisitorsInput>
  }

  export type UnitCreateWithoutVisitorsInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutVisitorsInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutVisitorsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutVisitorsInput, UnitUncheckedCreateWithoutVisitorsInput>
  }

  export type SocietyUpsertWithoutVisitorsInput = {
    update: XOR<SocietyUpdateWithoutVisitorsInput, SocietyUncheckedUpdateWithoutVisitorsInput>
    create: XOR<SocietyCreateWithoutVisitorsInput, SocietyUncheckedCreateWithoutVisitorsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutVisitorsInput, SocietyUncheckedUpdateWithoutVisitorsInput>
  }

  export type SocietyUpdateWithoutVisitorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutVisitorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UnitUpsertWithoutVisitorsInput = {
    update: XOR<UnitUpdateWithoutVisitorsInput, UnitUncheckedUpdateWithoutVisitorsInput>
    create: XOR<UnitCreateWithoutVisitorsInput, UnitUncheckedCreateWithoutVisitorsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutVisitorsInput, UnitUncheckedUpdateWithoutVisitorsInput>
  }

  export type UnitUpdateWithoutVisitorsInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutVisitorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type SocietyCreateWithoutTransactionsInput = {
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutTransactionsInput = {
    id?: number
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutTransactionsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutTransactionsInput, SocietyUncheckedCreateWithoutTransactionsInput>
  }

  export type SocietyUpsertWithoutTransactionsInput = {
    update: XOR<SocietyUpdateWithoutTransactionsInput, SocietyUncheckedUpdateWithoutTransactionsInput>
    create: XOR<SocietyCreateWithoutTransactionsInput, SocietyUncheckedCreateWithoutTransactionsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutTransactionsInput, SocietyUncheckedUpdateWithoutTransactionsInput>
  }

  export type SocietyUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyCreateWithoutVendorsInput = {
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutVendorsInput = {
    id?: number
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutVendorsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutVendorsInput, SocietyUncheckedCreateWithoutVendorsInput>
  }

  export type SocietyUpsertWithoutVendorsInput = {
    update: XOR<SocietyUpdateWithoutVendorsInput, SocietyUncheckedUpdateWithoutVendorsInput>
    create: XOR<SocietyCreateWithoutVendorsInput, SocietyUncheckedCreateWithoutVendorsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutVendorsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutVendorsInput, SocietyUncheckedUpdateWithoutVendorsInput>
  }

  export type SocietyUpdateWithoutVendorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutVendorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyCreateWithoutNoticesInput = {
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutNoticesInput = {
    id?: number
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutNoticesInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutNoticesInput, SocietyUncheckedCreateWithoutNoticesInput>
  }

  export type SocietyUpsertWithoutNoticesInput = {
    update: XOR<SocietyUpdateWithoutNoticesInput, SocietyUncheckedUpdateWithoutNoticesInput>
    create: XOR<SocietyCreateWithoutNoticesInput, SocietyUncheckedCreateWithoutNoticesInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutNoticesInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutNoticesInput, SocietyUncheckedUpdateWithoutNoticesInput>
  }

  export type SocietyUpdateWithoutNoticesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutNoticesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyCreateWithoutAmenitiesInput = {
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutAmenitiesInput = {
    id?: number
    name: string
    address?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutAmenitiesInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutAmenitiesInput, SocietyUncheckedCreateWithoutAmenitiesInput>
  }

  export type AmenityBookingCreateWithoutAmenityInput = {
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
  }

  export type AmenityBookingUncheckedCreateWithoutAmenityInput = {
    id?: number
    userId: number
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
  }

  export type AmenityBookingCreateOrConnectWithoutAmenityInput = {
    where: AmenityBookingWhereUniqueInput
    create: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput>
  }

  export type AmenityBookingCreateManyAmenityInputEnvelope = {
    data: AmenityBookingCreateManyAmenityInput | AmenityBookingCreateManyAmenityInput[]
    skipDuplicates?: boolean
  }

  export type SocietyUpsertWithoutAmenitiesInput = {
    update: XOR<SocietyUpdateWithoutAmenitiesInput, SocietyUncheckedUpdateWithoutAmenitiesInput>
    create: XOR<SocietyCreateWithoutAmenitiesInput, SocietyUncheckedCreateWithoutAmenitiesInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutAmenitiesInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutAmenitiesInput, SocietyUncheckedUpdateWithoutAmenitiesInput>
  }

  export type SocietyUpdateWithoutAmenitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutAmenitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type AmenityBookingUpsertWithWhereUniqueWithoutAmenityInput = {
    where: AmenityBookingWhereUniqueInput
    update: XOR<AmenityBookingUpdateWithoutAmenityInput, AmenityBookingUncheckedUpdateWithoutAmenityInput>
    create: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput>
  }

  export type AmenityBookingUpdateWithWhereUniqueWithoutAmenityInput = {
    where: AmenityBookingWhereUniqueInput
    data: XOR<AmenityBookingUpdateWithoutAmenityInput, AmenityBookingUncheckedUpdateWithoutAmenityInput>
  }

  export type AmenityBookingUpdateManyWithWhereWithoutAmenityInput = {
    where: AmenityBookingScalarWhereInput
    data: XOR<AmenityBookingUpdateManyMutationInput, AmenityBookingUncheckedUpdateManyWithoutAmenityInput>
  }

  export type AmenityCreateWithoutBookingsInput = {
    name: string
    description?: string | null
    chargesPerHour?: number
    createdAt?: Date | string
    society: SocietyCreateNestedOneWithoutAmenitiesInput
  }

  export type AmenityUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    description?: string | null
    chargesPerHour?: number
    societyId: number
    createdAt?: Date | string
  }

  export type AmenityCreateOrConnectWithoutBookingsInput = {
    where: AmenityWhereUniqueInput
    create: XOR<AmenityCreateWithoutBookingsInput, AmenityUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutBookingsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type AmenityUpsertWithoutBookingsInput = {
    update: XOR<AmenityUpdateWithoutBookingsInput, AmenityUncheckedUpdateWithoutBookingsInput>
    create: XOR<AmenityCreateWithoutBookingsInput, AmenityUncheckedCreateWithoutBookingsInput>
    where?: AmenityWhereInput
  }

  export type AmenityUpdateToOneWithWhereWithoutBookingsInput = {
    where?: AmenityWhereInput
    data: XOR<AmenityUpdateWithoutBookingsInput, AmenityUncheckedUpdateWithoutBookingsInput>
  }

  export type AmenityUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutAmenitiesNestedInput
  }

  export type AmenityUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManySocietyInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitCreateManySocietyInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintCreateManySocietyInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    reportedById: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorCreateManySocietyInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    visitingUnitId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManySocietyInput = {
    id?: number
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoticeCreateManySocietyInput = {
    id?: number
    title: string
    content: string
    audience: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type VendorCreateManySocietyInput = {
    id?: number
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    active?: boolean
    createdAt?: Date | string
  }

  export type AmenityCreateManySocietyInput = {
    id?: number
    name: string
    description?: string | null
    chargesPerHour?: number
    createdAt?: Date | string
  }

  export type ParkingSlotCreateManySocietyInput = {
    id?: number
    number: string
    type: string
    status: string
    allocatedToUnitId?: number | null
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type UserUpdateWithoutSocietyInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpdateWithoutSocietyInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUpdateWithoutSocietyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: UserUpdateOneRequiredWithoutReportedComplaintsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedComplaintsNestedInput
    comments?: ComplaintCommentUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    reportedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ComplaintCommentUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    reportedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUpdateWithoutSocietyInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitingUnitId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitingUnitId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutSocietyInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeUpdateWithoutSocietyInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoticeUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoticeUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VendorUpdateWithoutSocietyInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityUpdateWithoutSocietyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: AmenityBookingUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: AmenityBookingUncheckedUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotUpdateWithoutSocietyInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneWithoutParkingSlotsNestedInput
  }

  export type ParkingSlotUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    allocatedToUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    allocatedToUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateManyOwnerInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitCreateManyTenantInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    ownerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintCreateManyReportedByInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintCreateManyAssignedToInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    reportedById: number
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenityBookingCreateManyUserInput = {
    id?: number
    amenityId: number
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
  }

  export type ComplaintCommentCreateManyUserInput = {
    id?: number
    complaintId: number
    message: string
    createdAt?: Date | string
  }

  export type UnitUpdateWithoutOwnerInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpdateWithoutTenantInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUpdateWithoutReportedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutComplaintsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedComplaintsNestedInput
    comments?: ComplaintCommentUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutReportedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ComplaintCommentUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateManyWithoutReportedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUpdateWithoutAssignedToInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutComplaintsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutReportedComplaintsNestedInput
    comments?: ComplaintCommentUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ComplaintCommentUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateManyWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingUpdateWithoutUserInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenity?: AmenityUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type AmenityBookingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentUpdateWithoutUserInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint?: ComplaintUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ComplaintCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaintId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaintId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorCreateManyUnitInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    societyId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParkingSlotCreateManyUnitInput = {
    id?: number
    number: string
    type: string
    status: string
    societyId: number
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type VisitorUpdateWithoutUnitInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotUpdateWithoutUnitInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutParkingSlotsNestedInput
  }

  export type ParkingSlotUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentCreateManyComplaintInput = {
    id?: number
    userId: number
    message: string
    createdAt?: Date | string
  }

  export type ComplaintCommentUpdateWithoutComplaintInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ComplaintCommentUncheckedUpdateWithoutComplaintInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentUncheckedUpdateManyWithoutComplaintInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingCreateManyAmenityInput = {
    id?: number
    userId: number
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
  }

  export type AmenityBookingUpdateWithoutAmenityInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type AmenityBookingUncheckedUpdateWithoutAmenityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingUncheckedUpdateManyWithoutAmenityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}