
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Society
 * 
 */
export type Society = $Result.DefaultSelection<Prisma.$SocietyPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model ParkingSlot
 * 
 */
export type ParkingSlot = $Result.DefaultSelection<Prisma.$ParkingSlotPayload>
/**
 * Model Complaint
 * 
 */
export type Complaint = $Result.DefaultSelection<Prisma.$ComplaintPayload>
/**
 * Model ComplaintComment
 * 
 */
export type ComplaintComment = $Result.DefaultSelection<Prisma.$ComplaintCommentPayload>
/**
 * Model Visitor
 * 
 */
export type Visitor = $Result.DefaultSelection<Prisma.$VisitorPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model VendorPayout
 * 
 */
export type VendorPayout = $Result.DefaultSelection<Prisma.$VendorPayoutPayload>
/**
 * Model ServiceCategory
 * 
 */
export type ServiceCategory = $Result.DefaultSelection<Prisma.$ServiceCategoryPayload>
/**
 * Model ServiceVariant
 * 
 */
export type ServiceVariant = $Result.DefaultSelection<Prisma.$ServiceVariantPayload>
/**
 * Model ServiceInquiry
 * 
 */
export type ServiceInquiry = $Result.DefaultSelection<Prisma.$ServiceInquiryPayload>
/**
 * Model EmergencyLog
 * 
 */
export type EmergencyLog = $Result.DefaultSelection<Prisma.$EmergencyLogPayload>
/**
 * Model EmergencyBarcode
 * 
 */
export type EmergencyBarcode = $Result.DefaultSelection<Prisma.$EmergencyBarcodePayload>
/**
 * Model Notice
 * 
 */
export type Notice = $Result.DefaultSelection<Prisma.$NoticePayload>
/**
 * Model Amenity
 * 
 */
export type Amenity = $Result.DefaultSelection<Prisma.$AmenityPayload>
/**
 * Model AmenityBooking
 * 
 */
export type AmenityBooking = $Result.DefaultSelection<Prisma.$AmenityBookingPayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>
/**
 * Model BillingPlan
 * 
 */
export type BillingPlan = $Result.DefaultSelection<Prisma.$BillingPlanPayload>
/**
 * Model PlatformInvoice
 * 
 */
export type PlatformInvoice = $Result.DefaultSelection<Prisma.$PlatformInvoicePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  RESIDENT: 'RESIDENT',
  GUARD: 'GUARD',
  VENDOR: 'VENDOR',
  ACCOUNTANT: 'ACCOUNTANT',
  INDIVIDUAL: 'INDIVIDUAL',
  COMMUNITY_MANAGER: 'COMMUNITY_MANAGER',
  COMMITTEE: 'COMMITTEE'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ComplaintStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type ComplaintStatus = (typeof ComplaintStatus)[keyof typeof ComplaintStatus]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const VisitorStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  CHECKED_IN: 'CHECKED_IN',
  CHECKED_OUT: 'CHECKED_OUT',
  REJECTED: 'REJECTED'
};

export type VisitorStatus = (typeof VisitorStatus)[keyof typeof VisitorStatus]


export const TransactionType: {
  INCOME: 'INCOME',
  EXPENSE: 'EXPENSE'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const PaymentMethod: {
  CASH: 'CASH',
  ONLINE: 'ONLINE',
  UPI: 'UPI',
  CHEQUE: 'CHEQUE'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const SocietyStatus: {
  ACTIVE: 'ACTIVE',
  PENDING: 'PENDING',
  INACTIVE: 'INACTIVE'
};

export type SocietyStatus = (typeof SocietyStatus)[keyof typeof SocietyStatus]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  PENDING: 'PENDING'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const VendorStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  PENDING: 'PENDING'
};

export type VendorStatus = (typeof VendorStatus)[keyof typeof VendorStatus]


export const SubscriptionPlan: {
  BASIC: 'BASIC',
  PROFESSIONAL: 'PROFESSIONAL',
  ENTERPRISE: 'ENTERPRISE'
};

export type SubscriptionPlan = (typeof SubscriptionPlan)[keyof typeof SubscriptionPlan]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ComplaintStatus = $Enums.ComplaintStatus

export const ComplaintStatus: typeof $Enums.ComplaintStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type VisitorStatus = $Enums.VisitorStatus

export const VisitorStatus: typeof $Enums.VisitorStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type SocietyStatus = $Enums.SocietyStatus

export const SocietyStatus: typeof $Enums.SocietyStatus

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type VendorStatus = $Enums.VendorStatus

export const VendorStatus: typeof $Enums.VendorStatus

export type SubscriptionPlan = $Enums.SubscriptionPlan

export const SubscriptionPlan: typeof $Enums.SubscriptionPlan

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Societies
 * const societies = await prisma.society.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Societies
   * const societies = await prisma.society.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.society`: Exposes CRUD operations for the **Society** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Societies
    * const societies = await prisma.society.findMany()
    * ```
    */
  get society(): Prisma.SocietyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parkingSlot`: Exposes CRUD operations for the **ParkingSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParkingSlots
    * const parkingSlots = await prisma.parkingSlot.findMany()
    * ```
    */
  get parkingSlot(): Prisma.ParkingSlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complaint`: Exposes CRUD operations for the **Complaint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Complaints
    * const complaints = await prisma.complaint.findMany()
    * ```
    */
  get complaint(): Prisma.ComplaintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complaintComment`: Exposes CRUD operations for the **ComplaintComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplaintComments
    * const complaintComments = await prisma.complaintComment.findMany()
    * ```
    */
  get complaintComment(): Prisma.ComplaintCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visitor`: Exposes CRUD operations for the **Visitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visitors
    * const visitors = await prisma.visitor.findMany()
    * ```
    */
  get visitor(): Prisma.VisitorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorPayout`: Exposes CRUD operations for the **VendorPayout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorPayouts
    * const vendorPayouts = await prisma.vendorPayout.findMany()
    * ```
    */
  get vendorPayout(): Prisma.VendorPayoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceCategory`: Exposes CRUD operations for the **ServiceCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCategories
    * const serviceCategories = await prisma.serviceCategory.findMany()
    * ```
    */
  get serviceCategory(): Prisma.ServiceCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceVariant`: Exposes CRUD operations for the **ServiceVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceVariants
    * const serviceVariants = await prisma.serviceVariant.findMany()
    * ```
    */
  get serviceVariant(): Prisma.ServiceVariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceInquiry`: Exposes CRUD operations for the **ServiceInquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceInquiries
    * const serviceInquiries = await prisma.serviceInquiry.findMany()
    * ```
    */
  get serviceInquiry(): Prisma.ServiceInquiryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emergencyLog`: Exposes CRUD operations for the **EmergencyLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmergencyLogs
    * const emergencyLogs = await prisma.emergencyLog.findMany()
    * ```
    */
  get emergencyLog(): Prisma.EmergencyLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emergencyBarcode`: Exposes CRUD operations for the **EmergencyBarcode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmergencyBarcodes
    * const emergencyBarcodes = await prisma.emergencyBarcode.findMany()
    * ```
    */
  get emergencyBarcode(): Prisma.EmergencyBarcodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notice`: Exposes CRUD operations for the **Notice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notices
    * const notices = await prisma.notice.findMany()
    * ```
    */
  get notice(): Prisma.NoticeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amenity`: Exposes CRUD operations for the **Amenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amenities
    * const amenities = await prisma.amenity.findMany()
    * ```
    */
  get amenity(): Prisma.AmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amenityBooking`: Exposes CRUD operations for the **AmenityBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AmenityBookings
    * const amenityBookings = await prisma.amenityBooking.findMany()
    * ```
    */
  get amenityBooking(): Prisma.AmenityBookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingPlan`: Exposes CRUD operations for the **BillingPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingPlans
    * const billingPlans = await prisma.billingPlan.findMany()
    * ```
    */
  get billingPlan(): Prisma.BillingPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.platformInvoice`: Exposes CRUD operations for the **PlatformInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlatformInvoices
    * const platformInvoices = await prisma.platformInvoice.findMany()
    * ```
    */
  get platformInvoice(): Prisma.PlatformInvoiceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Society: 'Society',
    User: 'User',
    Unit: 'Unit',
    ParkingSlot: 'ParkingSlot',
    Complaint: 'Complaint',
    ComplaintComment: 'ComplaintComment',
    Visitor: 'Visitor',
    Transaction: 'Transaction',
    Vendor: 'Vendor',
    VendorPayout: 'VendorPayout',
    ServiceCategory: 'ServiceCategory',
    ServiceVariant: 'ServiceVariant',
    ServiceInquiry: 'ServiceInquiry',
    EmergencyLog: 'EmergencyLog',
    EmergencyBarcode: 'EmergencyBarcode',
    Notice: 'Notice',
    Amenity: 'Amenity',
    AmenityBooking: 'AmenityBooking',
    SystemSetting: 'SystemSetting',
    BillingPlan: 'BillingPlan',
    PlatformInvoice: 'PlatformInvoice'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "society" | "user" | "unit" | "parkingSlot" | "complaint" | "complaintComment" | "visitor" | "transaction" | "vendor" | "vendorPayout" | "serviceCategory" | "serviceVariant" | "serviceInquiry" | "emergencyLog" | "emergencyBarcode" | "notice" | "amenity" | "amenityBooking" | "systemSetting" | "billingPlan" | "platformInvoice"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Society: {
        payload: Prisma.$SocietyPayload<ExtArgs>
        fields: Prisma.SocietyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocietyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocietyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          findFirst: {
            args: Prisma.SocietyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocietyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          findMany: {
            args: Prisma.SocietyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>[]
          }
          create: {
            args: Prisma.SocietyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          createMany: {
            args: Prisma.SocietyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SocietyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          update: {
            args: Prisma.SocietyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          deleteMany: {
            args: Prisma.SocietyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocietyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SocietyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocietyPayload>
          }
          aggregate: {
            args: Prisma.SocietyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSociety>
          }
          groupBy: {
            args: Prisma.SocietyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocietyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocietyCountArgs<ExtArgs>
            result: $Utils.Optional<SocietyCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      ParkingSlot: {
        payload: Prisma.$ParkingSlotPayload<ExtArgs>
        fields: Prisma.ParkingSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParkingSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParkingSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          findFirst: {
            args: Prisma.ParkingSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParkingSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          findMany: {
            args: Prisma.ParkingSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>[]
          }
          create: {
            args: Prisma.ParkingSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          createMany: {
            args: Prisma.ParkingSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ParkingSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          update: {
            args: Prisma.ParkingSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          deleteMany: {
            args: Prisma.ParkingSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParkingSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParkingSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          aggregate: {
            args: Prisma.ParkingSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParkingSlot>
          }
          groupBy: {
            args: Prisma.ParkingSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParkingSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParkingSlotCountArgs<ExtArgs>
            result: $Utils.Optional<ParkingSlotCountAggregateOutputType> | number
          }
        }
      }
      Complaint: {
        payload: Prisma.$ComplaintPayload<ExtArgs>
        fields: Prisma.ComplaintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          findFirst: {
            args: Prisma.ComplaintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          findMany: {
            args: Prisma.ComplaintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>[]
          }
          create: {
            args: Prisma.ComplaintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          createMany: {
            args: Prisma.ComplaintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComplaintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          update: {
            args: Prisma.ComplaintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          deleteMany: {
            args: Prisma.ComplaintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplaintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          aggregate: {
            args: Prisma.ComplaintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaint>
          }
          groupBy: {
            args: Prisma.ComplaintGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintCountAggregateOutputType> | number
          }
        }
      }
      ComplaintComment: {
        payload: Prisma.$ComplaintCommentPayload<ExtArgs>
        fields: Prisma.ComplaintCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          findFirst: {
            args: Prisma.ComplaintCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          findMany: {
            args: Prisma.ComplaintCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>[]
          }
          create: {
            args: Prisma.ComplaintCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          createMany: {
            args: Prisma.ComplaintCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComplaintCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          update: {
            args: Prisma.ComplaintCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          deleteMany: {
            args: Prisma.ComplaintCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplaintCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintCommentPayload>
          }
          aggregate: {
            args: Prisma.ComplaintCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaintComment>
          }
          groupBy: {
            args: Prisma.ComplaintCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintCommentCountAggregateOutputType> | number
          }
        }
      }
      Visitor: {
        payload: Prisma.$VisitorPayload<ExtArgs>
        fields: Prisma.VisitorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          findFirst: {
            args: Prisma.VisitorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          findMany: {
            args: Prisma.VisitorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>[]
          }
          create: {
            args: Prisma.VisitorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          createMany: {
            args: Prisma.VisitorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VisitorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          update: {
            args: Prisma.VisitorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          deleteMany: {
            args: Prisma.VisitorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          aggregate: {
            args: Prisma.VisitorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitor>
          }
          groupBy: {
            args: Prisma.VisitorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitorCountArgs<ExtArgs>
            result: $Utils.Optional<VisitorCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      VendorPayout: {
        payload: Prisma.$VendorPayoutPayload<ExtArgs>
        fields: Prisma.VendorPayoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorPayoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorPayoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload>
          }
          findFirst: {
            args: Prisma.VendorPayoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorPayoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload>
          }
          findMany: {
            args: Prisma.VendorPayoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload>[]
          }
          create: {
            args: Prisma.VendorPayoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload>
          }
          createMany: {
            args: Prisma.VendorPayoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VendorPayoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload>
          }
          update: {
            args: Prisma.VendorPayoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload>
          }
          deleteMany: {
            args: Prisma.VendorPayoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorPayoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorPayoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayoutPayload>
          }
          aggregate: {
            args: Prisma.VendorPayoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorPayout>
          }
          groupBy: {
            args: Prisma.VendorPayoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorPayoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorPayoutCountArgs<ExtArgs>
            result: $Utils.Optional<VendorPayoutCountAggregateOutputType> | number
          }
        }
      }
      ServiceCategory: {
        payload: Prisma.$ServiceCategoryPayload<ExtArgs>
        fields: Prisma.ServiceCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findFirst: {
            args: Prisma.ServiceCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findMany: {
            args: Prisma.ServiceCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          create: {
            args: Prisma.ServiceCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          createMany: {
            args: Prisma.ServiceCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          update: {
            args: Prisma.ServiceCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ServiceCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          aggregate: {
            args: Prisma.ServiceCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceCategory>
          }
          groupBy: {
            args: Prisma.ServiceCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryCountAggregateOutputType> | number
          }
        }
      }
      ServiceVariant: {
        payload: Prisma.$ServiceVariantPayload<ExtArgs>
        fields: Prisma.ServiceVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>
          }
          findFirst: {
            args: Prisma.ServiceVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>
          }
          findMany: {
            args: Prisma.ServiceVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>[]
          }
          create: {
            args: Prisma.ServiceVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>
          }
          createMany: {
            args: Prisma.ServiceVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>
          }
          update: {
            args: Prisma.ServiceVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>
          }
          deleteMany: {
            args: Prisma.ServiceVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>
          }
          aggregate: {
            args: Prisma.ServiceVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceVariant>
          }
          groupBy: {
            args: Prisma.ServiceVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceVariantCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceVariantCountAggregateOutputType> | number
          }
        }
      }
      ServiceInquiry: {
        payload: Prisma.$ServiceInquiryPayload<ExtArgs>
        fields: Prisma.ServiceInquiryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceInquiryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceInquiryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload>
          }
          findFirst: {
            args: Prisma.ServiceInquiryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceInquiryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload>
          }
          findMany: {
            args: Prisma.ServiceInquiryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload>[]
          }
          create: {
            args: Prisma.ServiceInquiryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload>
          }
          createMany: {
            args: Prisma.ServiceInquiryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceInquiryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload>
          }
          update: {
            args: Prisma.ServiceInquiryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload>
          }
          deleteMany: {
            args: Prisma.ServiceInquiryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceInquiryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceInquiryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInquiryPayload>
          }
          aggregate: {
            args: Prisma.ServiceInquiryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceInquiry>
          }
          groupBy: {
            args: Prisma.ServiceInquiryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceInquiryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceInquiryCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceInquiryCountAggregateOutputType> | number
          }
        }
      }
      EmergencyLog: {
        payload: Prisma.$EmergencyLogPayload<ExtArgs>
        fields: Prisma.EmergencyLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmergencyLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmergencyLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload>
          }
          findFirst: {
            args: Prisma.EmergencyLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmergencyLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload>
          }
          findMany: {
            args: Prisma.EmergencyLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload>[]
          }
          create: {
            args: Prisma.EmergencyLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload>
          }
          createMany: {
            args: Prisma.EmergencyLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmergencyLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload>
          }
          update: {
            args: Prisma.EmergencyLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload>
          }
          deleteMany: {
            args: Prisma.EmergencyLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmergencyLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmergencyLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyLogPayload>
          }
          aggregate: {
            args: Prisma.EmergencyLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmergencyLog>
          }
          groupBy: {
            args: Prisma.EmergencyLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmergencyLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmergencyLogCountArgs<ExtArgs>
            result: $Utils.Optional<EmergencyLogCountAggregateOutputType> | number
          }
        }
      }
      EmergencyBarcode: {
        payload: Prisma.$EmergencyBarcodePayload<ExtArgs>
        fields: Prisma.EmergencyBarcodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmergencyBarcodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmergencyBarcodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload>
          }
          findFirst: {
            args: Prisma.EmergencyBarcodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmergencyBarcodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload>
          }
          findMany: {
            args: Prisma.EmergencyBarcodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload>[]
          }
          create: {
            args: Prisma.EmergencyBarcodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload>
          }
          createMany: {
            args: Prisma.EmergencyBarcodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmergencyBarcodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload>
          }
          update: {
            args: Prisma.EmergencyBarcodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload>
          }
          deleteMany: {
            args: Prisma.EmergencyBarcodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmergencyBarcodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmergencyBarcodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyBarcodePayload>
          }
          aggregate: {
            args: Prisma.EmergencyBarcodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmergencyBarcode>
          }
          groupBy: {
            args: Prisma.EmergencyBarcodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmergencyBarcodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmergencyBarcodeCountArgs<ExtArgs>
            result: $Utils.Optional<EmergencyBarcodeCountAggregateOutputType> | number
          }
        }
      }
      Notice: {
        payload: Prisma.$NoticePayload<ExtArgs>
        fields: Prisma.NoticeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoticeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoticeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          findFirst: {
            args: Prisma.NoticeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoticeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          findMany: {
            args: Prisma.NoticeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>[]
          }
          create: {
            args: Prisma.NoticeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          createMany: {
            args: Prisma.NoticeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NoticeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          update: {
            args: Prisma.NoticeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          deleteMany: {
            args: Prisma.NoticeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoticeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoticeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          aggregate: {
            args: Prisma.NoticeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotice>
          }
          groupBy: {
            args: Prisma.NoticeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoticeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoticeCountArgs<ExtArgs>
            result: $Utils.Optional<NoticeCountAggregateOutputType> | number
          }
        }
      }
      Amenity: {
        payload: Prisma.$AmenityPayload<ExtArgs>
        fields: Prisma.AmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findFirst: {
            args: Prisma.AmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findMany: {
            args: Prisma.AmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          create: {
            args: Prisma.AmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          createMany: {
            args: Prisma.AmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          update: {
            args: Prisma.AmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          deleteMany: {
            args: Prisma.AmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          aggregate: {
            args: Prisma.AmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmenity>
          }
          groupBy: {
            args: Prisma.AmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmenityCountArgs<ExtArgs>
            result: $Utils.Optional<AmenityCountAggregateOutputType> | number
          }
        }
      }
      AmenityBooking: {
        payload: Prisma.$AmenityBookingPayload<ExtArgs>
        fields: Prisma.AmenityBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmenityBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmenityBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          findFirst: {
            args: Prisma.AmenityBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmenityBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          findMany: {
            args: Prisma.AmenityBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>[]
          }
          create: {
            args: Prisma.AmenityBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          createMany: {
            args: Prisma.AmenityBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AmenityBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          update: {
            args: Prisma.AmenityBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          deleteMany: {
            args: Prisma.AmenityBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmenityBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AmenityBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityBookingPayload>
          }
          aggregate: {
            args: Prisma.AmenityBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmenityBooking>
          }
          groupBy: {
            args: Prisma.AmenityBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmenityBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmenityBookingCountArgs<ExtArgs>
            result: $Utils.Optional<AmenityBookingCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
      BillingPlan: {
        payload: Prisma.$BillingPlanPayload<ExtArgs>
        fields: Prisma.BillingPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          findFirst: {
            args: Prisma.BillingPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          findMany: {
            args: Prisma.BillingPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>[]
          }
          create: {
            args: Prisma.BillingPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          createMany: {
            args: Prisma.BillingPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BillingPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          update: {
            args: Prisma.BillingPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          deleteMany: {
            args: Prisma.BillingPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BillingPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          aggregate: {
            args: Prisma.BillingPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingPlan>
          }
          groupBy: {
            args: Prisma.BillingPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingPlanCountArgs<ExtArgs>
            result: $Utils.Optional<BillingPlanCountAggregateOutputType> | number
          }
        }
      }
      PlatformInvoice: {
        payload: Prisma.$PlatformInvoicePayload<ExtArgs>
        fields: Prisma.PlatformInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload>
          }
          findFirst: {
            args: Prisma.PlatformInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload>
          }
          findMany: {
            args: Prisma.PlatformInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload>[]
          }
          create: {
            args: Prisma.PlatformInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload>
          }
          createMany: {
            args: Prisma.PlatformInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlatformInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload>
          }
          update: {
            args: Prisma.PlatformInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload>
          }
          deleteMany: {
            args: Prisma.PlatformInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlatformInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformInvoicePayload>
          }
          aggregate: {
            args: Prisma.PlatformInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatformInvoice>
          }
          groupBy: {
            args: Prisma.PlatformInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformInvoiceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    society?: SocietyOmit
    user?: UserOmit
    unit?: UnitOmit
    parkingSlot?: ParkingSlotOmit
    complaint?: ComplaintOmit
    complaintComment?: ComplaintCommentOmit
    visitor?: VisitorOmit
    transaction?: TransactionOmit
    vendor?: VendorOmit
    vendorPayout?: VendorPayoutOmit
    serviceCategory?: ServiceCategoryOmit
    serviceVariant?: ServiceVariantOmit
    serviceInquiry?: ServiceInquiryOmit
    emergencyLog?: EmergencyLogOmit
    emergencyBarcode?: EmergencyBarcodeOmit
    notice?: NoticeOmit
    amenity?: AmenityOmit
    amenityBooking?: AmenityBookingOmit
    systemSetting?: SystemSettingOmit
    billingPlan?: BillingPlanOmit
    platformInvoice?: PlatformInvoiceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SocietyCountOutputType
   */

  export type SocietyCountOutputType = {
    users: number
    units: number
    complaints: number
    visitors: number
    transactions: number
    notices: number
    vendors: number
    amenities: number
    parkingSlots: number
    platformInvoices: number
  }

  export type SocietyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SocietyCountOutputTypeCountUsersArgs
    units?: boolean | SocietyCountOutputTypeCountUnitsArgs
    complaints?: boolean | SocietyCountOutputTypeCountComplaintsArgs
    visitors?: boolean | SocietyCountOutputTypeCountVisitorsArgs
    transactions?: boolean | SocietyCountOutputTypeCountTransactionsArgs
    notices?: boolean | SocietyCountOutputTypeCountNoticesArgs
    vendors?: boolean | SocietyCountOutputTypeCountVendorsArgs
    amenities?: boolean | SocietyCountOutputTypeCountAmenitiesArgs
    parkingSlots?: boolean | SocietyCountOutputTypeCountParkingSlotsArgs
    platformInvoices?: boolean | SocietyCountOutputTypeCountPlatformInvoicesArgs
  }

  // Custom InputTypes
  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocietyCountOutputType
     */
    select?: SocietyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountNoticesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoticeWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountAmenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountParkingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingSlotWhereInput
  }

  /**
   * SocietyCountOutputType without action
   */
  export type SocietyCountOutputTypeCountPlatformInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformInvoiceWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ownedUnits: number
    rentedUnits: number
    reportedComplaints: number
    assignedComplaints: number
    bookings: number
    comments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedUnits?: boolean | UserCountOutputTypeCountOwnedUnitsArgs
    rentedUnits?: boolean | UserCountOutputTypeCountRentedUnitsArgs
    reportedComplaints?: boolean | UserCountOutputTypeCountReportedComplaintsArgs
    assignedComplaints?: boolean | UserCountOutputTypeCountAssignedComplaintsArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRentedUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportedComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityBookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintCommentWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    visitors: number
    parkingSlots: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visitors?: boolean | UnitCountOutputTypeCountVisitorsArgs
    parkingSlots?: boolean | UnitCountOutputTypeCountParkingSlotsArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountParkingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingSlotWhereInput
  }


  /**
   * Count Type ComplaintCountOutputType
   */

  export type ComplaintCountOutputType = {
    comments: number
  }

  export type ComplaintCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | ComplaintCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ComplaintCountOutputType without action
   */
  export type ComplaintCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintCountOutputType
     */
    select?: ComplaintCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComplaintCountOutputType without action
   */
  export type ComplaintCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintCommentWhereInput
  }


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    payouts: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payouts?: boolean | VendorCountOutputTypeCountPayoutsArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountPayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorPayoutWhereInput
  }


  /**
   * Count Type ServiceCategoryCountOutputType
   */

  export type ServiceCategoryCountOutputType = {
    variants: number
  }

  export type ServiceCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | ServiceCategoryCountOutputTypeCountVariantsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryCountOutputType
     */
    select?: ServiceCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceVariantWhereInput
  }


  /**
   * Count Type AmenityCountOutputType
   */

  export type AmenityCountOutputType = {
    bookings: number
  }

  export type AmenityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | AmenityCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityCountOutputType
     */
    select?: AmenityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityBookingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Society
   */

  export type AggregateSociety = {
    _count: SocietyCountAggregateOutputType | null
    _avg: SocietyAvgAggregateOutputType | null
    _sum: SocietySumAggregateOutputType | null
    _min: SocietyMinAggregateOutputType | null
    _max: SocietyMaxAggregateOutputType | null
  }

  export type SocietyAvgAggregateOutputType = {
    id: number | null
    expectedUnits: number | null
  }

  export type SocietySumAggregateOutputType = {
    id: number | null
    expectedUnits: number | null
  }

  export type SocietyMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    pincode: string | null
    code: string | null
    status: $Enums.SocietyStatus | null
    subscriptionPlan: $Enums.SubscriptionPlan | null
    expectedUnits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocietyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    pincode: string | null
    code: string | null
    status: $Enums.SocietyStatus | null
    subscriptionPlan: $Enums.SubscriptionPlan | null
    expectedUnits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocietyCountAggregateOutputType = {
    id: number
    name: number
    address: number
    city: number
    state: number
    pincode: number
    code: number
    status: number
    subscriptionPlan: number
    expectedUnits: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocietyAvgAggregateInputType = {
    id?: true
    expectedUnits?: true
  }

  export type SocietySumAggregateInputType = {
    id?: true
    expectedUnits?: true
  }

  export type SocietyMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    pincode?: true
    code?: true
    status?: true
    subscriptionPlan?: true
    expectedUnits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocietyMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    pincode?: true
    code?: true
    status?: true
    subscriptionPlan?: true
    expectedUnits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocietyCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    pincode?: true
    code?: true
    status?: true
    subscriptionPlan?: true
    expectedUnits?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocietyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Society to aggregate.
     */
    where?: SocietyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Societies to fetch.
     */
    orderBy?: SocietyOrderByWithRelationInput | SocietyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocietyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Societies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Societies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Societies
    **/
    _count?: true | SocietyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SocietyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SocietySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocietyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocietyMaxAggregateInputType
  }

  export type GetSocietyAggregateType<T extends SocietyAggregateArgs> = {
        [P in keyof T & keyof AggregateSociety]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSociety[P]>
      : GetScalarType<T[P], AggregateSociety[P]>
  }




  export type SocietyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocietyWhereInput
    orderBy?: SocietyOrderByWithAggregationInput | SocietyOrderByWithAggregationInput[]
    by: SocietyScalarFieldEnum[] | SocietyScalarFieldEnum
    having?: SocietyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocietyCountAggregateInputType | true
    _avg?: SocietyAvgAggregateInputType
    _sum?: SocietySumAggregateInputType
    _min?: SocietyMinAggregateInputType
    _max?: SocietyMaxAggregateInputType
  }

  export type SocietyGroupByOutputType = {
    id: number
    name: string
    address: string | null
    city: string | null
    state: string | null
    pincode: string | null
    code: string
    status: $Enums.SocietyStatus
    subscriptionPlan: $Enums.SubscriptionPlan
    expectedUnits: number
    createdAt: Date
    updatedAt: Date
    _count: SocietyCountAggregateOutputType | null
    _avg: SocietyAvgAggregateOutputType | null
    _sum: SocietySumAggregateOutputType | null
    _min: SocietyMinAggregateOutputType | null
    _max: SocietyMaxAggregateOutputType | null
  }

  type GetSocietyGroupByPayload<T extends SocietyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocietyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocietyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocietyGroupByOutputType[P]>
            : GetScalarType<T[P], SocietyGroupByOutputType[P]>
        }
      >
    >


  export type SocietySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    code?: boolean
    status?: boolean
    subscriptionPlan?: boolean
    expectedUnits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Society$usersArgs<ExtArgs>
    units?: boolean | Society$unitsArgs<ExtArgs>
    complaints?: boolean | Society$complaintsArgs<ExtArgs>
    visitors?: boolean | Society$visitorsArgs<ExtArgs>
    transactions?: boolean | Society$transactionsArgs<ExtArgs>
    notices?: boolean | Society$noticesArgs<ExtArgs>
    vendors?: boolean | Society$vendorsArgs<ExtArgs>
    amenities?: boolean | Society$amenitiesArgs<ExtArgs>
    parkingSlots?: boolean | Society$parkingSlotsArgs<ExtArgs>
    platformInvoices?: boolean | Society$platformInvoicesArgs<ExtArgs>
    _count?: boolean | SocietyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["society"]>



  export type SocietySelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    code?: boolean
    status?: boolean
    subscriptionPlan?: boolean
    expectedUnits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocietyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "city" | "state" | "pincode" | "code" | "status" | "subscriptionPlan" | "expectedUnits" | "createdAt" | "updatedAt", ExtArgs["result"]["society"]>
  export type SocietyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Society$usersArgs<ExtArgs>
    units?: boolean | Society$unitsArgs<ExtArgs>
    complaints?: boolean | Society$complaintsArgs<ExtArgs>
    visitors?: boolean | Society$visitorsArgs<ExtArgs>
    transactions?: boolean | Society$transactionsArgs<ExtArgs>
    notices?: boolean | Society$noticesArgs<ExtArgs>
    vendors?: boolean | Society$vendorsArgs<ExtArgs>
    amenities?: boolean | Society$amenitiesArgs<ExtArgs>
    parkingSlots?: boolean | Society$parkingSlotsArgs<ExtArgs>
    platformInvoices?: boolean | Society$platformInvoicesArgs<ExtArgs>
    _count?: boolean | SocietyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SocietyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Society"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      units: Prisma.$UnitPayload<ExtArgs>[]
      complaints: Prisma.$ComplaintPayload<ExtArgs>[]
      visitors: Prisma.$VisitorPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      notices: Prisma.$NoticePayload<ExtArgs>[]
      vendors: Prisma.$VendorPayload<ExtArgs>[]
      amenities: Prisma.$AmenityPayload<ExtArgs>[]
      parkingSlots: Prisma.$ParkingSlotPayload<ExtArgs>[]
      platformInvoices: Prisma.$PlatformInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string | null
      city: string | null
      state: string | null
      pincode: string | null
      code: string
      status: $Enums.SocietyStatus
      subscriptionPlan: $Enums.SubscriptionPlan
      expectedUnits: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["society"]>
    composites: {}
  }

  type SocietyGetPayload<S extends boolean | null | undefined | SocietyDefaultArgs> = $Result.GetResult<Prisma.$SocietyPayload, S>

  type SocietyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocietyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocietyCountAggregateInputType | true
    }

  export interface SocietyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Society'], meta: { name: 'Society' } }
    /**
     * Find zero or one Society that matches the filter.
     * @param {SocietyFindUniqueArgs} args - Arguments to find a Society
     * @example
     * // Get one Society
     * const society = await prisma.society.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocietyFindUniqueArgs>(args: SelectSubset<T, SocietyFindUniqueArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Society that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocietyFindUniqueOrThrowArgs} args - Arguments to find a Society
     * @example
     * // Get one Society
     * const society = await prisma.society.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocietyFindUniqueOrThrowArgs>(args: SelectSubset<T, SocietyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Society that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyFindFirstArgs} args - Arguments to find a Society
     * @example
     * // Get one Society
     * const society = await prisma.society.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocietyFindFirstArgs>(args?: SelectSubset<T, SocietyFindFirstArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Society that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyFindFirstOrThrowArgs} args - Arguments to find a Society
     * @example
     * // Get one Society
     * const society = await prisma.society.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocietyFindFirstOrThrowArgs>(args?: SelectSubset<T, SocietyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Societies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Societies
     * const societies = await prisma.society.findMany()
     * 
     * // Get first 10 Societies
     * const societies = await prisma.society.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const societyWithIdOnly = await prisma.society.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocietyFindManyArgs>(args?: SelectSubset<T, SocietyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Society.
     * @param {SocietyCreateArgs} args - Arguments to create a Society.
     * @example
     * // Create one Society
     * const Society = await prisma.society.create({
     *   data: {
     *     // ... data to create a Society
     *   }
     * })
     * 
     */
    create<T extends SocietyCreateArgs>(args: SelectSubset<T, SocietyCreateArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Societies.
     * @param {SocietyCreateManyArgs} args - Arguments to create many Societies.
     * @example
     * // Create many Societies
     * const society = await prisma.society.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocietyCreateManyArgs>(args?: SelectSubset<T, SocietyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Society.
     * @param {SocietyDeleteArgs} args - Arguments to delete one Society.
     * @example
     * // Delete one Society
     * const Society = await prisma.society.delete({
     *   where: {
     *     // ... filter to delete one Society
     *   }
     * })
     * 
     */
    delete<T extends SocietyDeleteArgs>(args: SelectSubset<T, SocietyDeleteArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Society.
     * @param {SocietyUpdateArgs} args - Arguments to update one Society.
     * @example
     * // Update one Society
     * const society = await prisma.society.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocietyUpdateArgs>(args: SelectSubset<T, SocietyUpdateArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Societies.
     * @param {SocietyDeleteManyArgs} args - Arguments to filter Societies to delete.
     * @example
     * // Delete a few Societies
     * const { count } = await prisma.society.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocietyDeleteManyArgs>(args?: SelectSubset<T, SocietyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Societies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Societies
     * const society = await prisma.society.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocietyUpdateManyArgs>(args: SelectSubset<T, SocietyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Society.
     * @param {SocietyUpsertArgs} args - Arguments to update or create a Society.
     * @example
     * // Update or create a Society
     * const society = await prisma.society.upsert({
     *   create: {
     *     // ... data to create a Society
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Society we want to update
     *   }
     * })
     */
    upsert<T extends SocietyUpsertArgs>(args: SelectSubset<T, SocietyUpsertArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Societies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyCountArgs} args - Arguments to filter Societies to count.
     * @example
     * // Count the number of Societies
     * const count = await prisma.society.count({
     *   where: {
     *     // ... the filter for the Societies we want to count
     *   }
     * })
    **/
    count<T extends SocietyCountArgs>(
      args?: Subset<T, SocietyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocietyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Society.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocietyAggregateArgs>(args: Subset<T, SocietyAggregateArgs>): Prisma.PrismaPromise<GetSocietyAggregateType<T>>

    /**
     * Group by Society.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocietyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocietyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocietyGroupByArgs['orderBy'] }
        : { orderBy?: SocietyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocietyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocietyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Society model
   */
  readonly fields: SocietyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Society.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocietyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Society$usersArgs<ExtArgs> = {}>(args?: Subset<T, Society$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    units<T extends Society$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Society$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    complaints<T extends Society$complaintsArgs<ExtArgs> = {}>(args?: Subset<T, Society$complaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visitors<T extends Society$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, Society$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Society$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Society$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notices<T extends Society$noticesArgs<ExtArgs> = {}>(args?: Subset<T, Society$noticesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendors<T extends Society$vendorsArgs<ExtArgs> = {}>(args?: Subset<T, Society$vendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    amenities<T extends Society$amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Society$amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parkingSlots<T extends Society$parkingSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Society$parkingSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    platformInvoices<T extends Society$platformInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Society$platformInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Society model
   */
  interface SocietyFieldRefs {
    readonly id: FieldRef<"Society", 'Int'>
    readonly name: FieldRef<"Society", 'String'>
    readonly address: FieldRef<"Society", 'String'>
    readonly city: FieldRef<"Society", 'String'>
    readonly state: FieldRef<"Society", 'String'>
    readonly pincode: FieldRef<"Society", 'String'>
    readonly code: FieldRef<"Society", 'String'>
    readonly status: FieldRef<"Society", 'SocietyStatus'>
    readonly subscriptionPlan: FieldRef<"Society", 'SubscriptionPlan'>
    readonly expectedUnits: FieldRef<"Society", 'Int'>
    readonly createdAt: FieldRef<"Society", 'DateTime'>
    readonly updatedAt: FieldRef<"Society", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Society findUnique
   */
  export type SocietyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter, which Society to fetch.
     */
    where: SocietyWhereUniqueInput
  }

  /**
   * Society findUniqueOrThrow
   */
  export type SocietyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter, which Society to fetch.
     */
    where: SocietyWhereUniqueInput
  }

  /**
   * Society findFirst
   */
  export type SocietyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter, which Society to fetch.
     */
    where?: SocietyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Societies to fetch.
     */
    orderBy?: SocietyOrderByWithRelationInput | SocietyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Societies.
     */
    cursor?: SocietyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Societies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Societies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Societies.
     */
    distinct?: SocietyScalarFieldEnum | SocietyScalarFieldEnum[]
  }

  /**
   * Society findFirstOrThrow
   */
  export type SocietyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter, which Society to fetch.
     */
    where?: SocietyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Societies to fetch.
     */
    orderBy?: SocietyOrderByWithRelationInput | SocietyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Societies.
     */
    cursor?: SocietyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Societies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Societies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Societies.
     */
    distinct?: SocietyScalarFieldEnum | SocietyScalarFieldEnum[]
  }

  /**
   * Society findMany
   */
  export type SocietyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter, which Societies to fetch.
     */
    where?: SocietyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Societies to fetch.
     */
    orderBy?: SocietyOrderByWithRelationInput | SocietyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Societies.
     */
    cursor?: SocietyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Societies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Societies.
     */
    skip?: number
    distinct?: SocietyScalarFieldEnum | SocietyScalarFieldEnum[]
  }

  /**
   * Society create
   */
  export type SocietyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * The data needed to create a Society.
     */
    data: XOR<SocietyCreateInput, SocietyUncheckedCreateInput>
  }

  /**
   * Society createMany
   */
  export type SocietyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Societies.
     */
    data: SocietyCreateManyInput | SocietyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Society update
   */
  export type SocietyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * The data needed to update a Society.
     */
    data: XOR<SocietyUpdateInput, SocietyUncheckedUpdateInput>
    /**
     * Choose, which Society to update.
     */
    where: SocietyWhereUniqueInput
  }

  /**
   * Society updateMany
   */
  export type SocietyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Societies.
     */
    data: XOR<SocietyUpdateManyMutationInput, SocietyUncheckedUpdateManyInput>
    /**
     * Filter which Societies to update
     */
    where?: SocietyWhereInput
    /**
     * Limit how many Societies to update.
     */
    limit?: number
  }

  /**
   * Society upsert
   */
  export type SocietyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * The filter to search for the Society to update in case it exists.
     */
    where: SocietyWhereUniqueInput
    /**
     * In case the Society found by the `where` argument doesn't exist, create a new Society with this data.
     */
    create: XOR<SocietyCreateInput, SocietyUncheckedCreateInput>
    /**
     * In case the Society was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocietyUpdateInput, SocietyUncheckedUpdateInput>
  }

  /**
   * Society delete
   */
  export type SocietyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    /**
     * Filter which Society to delete.
     */
    where: SocietyWhereUniqueInput
  }

  /**
   * Society deleteMany
   */
  export type SocietyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Societies to delete
     */
    where?: SocietyWhereInput
    /**
     * Limit how many Societies to delete.
     */
    limit?: number
  }

  /**
   * Society.users
   */
  export type Society$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Society.units
   */
  export type Society$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Society.complaints
   */
  export type Society$complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    cursor?: ComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Society.visitors
   */
  export type Society$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    cursor?: VisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Society.transactions
   */
  export type Society$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Society.notices
   */
  export type Society$noticesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    where?: NoticeWhereInput
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    cursor?: NoticeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Society.vendors
   */
  export type Society$vendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    cursor?: VendorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Society.amenities
   */
  export type Society$amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    where?: AmenityWhereInput
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    cursor?: AmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Society.parkingSlots
   */
  export type Society$parkingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    where?: ParkingSlotWhereInput
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    cursor?: ParkingSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * Society.platformInvoices
   */
  export type Society$platformInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    where?: PlatformInvoiceWhereInput
    orderBy?: PlatformInvoiceOrderByWithRelationInput | PlatformInvoiceOrderByWithRelationInput[]
    cursor?: PlatformInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlatformInvoiceScalarFieldEnum | PlatformInvoiceScalarFieldEnum[]
  }

  /**
   * Society without action
   */
  export type SocietyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    role: $Enums.Role | null
    status: $Enums.UserStatus | null
    profileImg: string | null
    societyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    role: $Enums.Role | null
    status: $Enums.UserStatus | null
    profileImg: string | null
    societyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    phone: number
    role: number
    status: number
    profileImg: number
    societyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    role?: true
    status?: true
    profileImg?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    role?: true
    status?: true
    profileImg?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    role?: true
    status?: true
    profileImg?: true
    societyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string
    phone: string | null
    role: $Enums.Role
    status: $Enums.UserStatus
    profileImg: string | null
    societyId: number | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    status?: boolean
    profileImg?: boolean
    societyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | User$societyArgs<ExtArgs>
    ownedUnits?: boolean | User$ownedUnitsArgs<ExtArgs>
    rentedUnits?: boolean | User$rentedUnitsArgs<ExtArgs>
    reportedComplaints?: boolean | User$reportedComplaintsArgs<ExtArgs>
    assignedComplaints?: boolean | User$assignedComplaintsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    status?: boolean
    profileImg?: boolean
    societyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "phone" | "role" | "status" | "profileImg" | "societyId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | User$societyArgs<ExtArgs>
    ownedUnits?: boolean | User$ownedUnitsArgs<ExtArgs>
    rentedUnits?: boolean | User$rentedUnitsArgs<ExtArgs>
    reportedComplaints?: boolean | User$reportedComplaintsArgs<ExtArgs>
    assignedComplaints?: boolean | User$assignedComplaintsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs> | null
      ownedUnits: Prisma.$UnitPayload<ExtArgs>[]
      rentedUnits: Prisma.$UnitPayload<ExtArgs>[]
      reportedComplaints: Prisma.$ComplaintPayload<ExtArgs>[]
      assignedComplaints: Prisma.$ComplaintPayload<ExtArgs>[]
      bookings: Prisma.$AmenityBookingPayload<ExtArgs>[]
      comments: Prisma.$ComplaintCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string
      phone: string | null
      role: $Enums.Role
      status: $Enums.UserStatus
      profileImg: string | null
      societyId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends User$societyArgs<ExtArgs> = {}>(args?: Subset<T, User$societyArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ownedUnits<T extends User$ownedUnitsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedUnitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rentedUnits<T extends User$rentedUnitsArgs<ExtArgs> = {}>(args?: Subset<T, User$rentedUnitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportedComplaints<T extends User$reportedComplaintsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportedComplaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedComplaints<T extends User$assignedComplaintsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedComplaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly profileImg: FieldRef<"User", 'String'>
    readonly societyId: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.society
   */
  export type User$societyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    where?: SocietyWhereInput
  }

  /**
   * User.ownedUnits
   */
  export type User$ownedUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * User.rentedUnits
   */
  export type User$rentedUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * User.reportedComplaints
   */
  export type User$reportedComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    cursor?: ComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * User.assignedComplaints
   */
  export type User$assignedComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    cursor?: ComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    where?: AmenityBookingWhereInput
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    cursor?: AmenityBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmenityBookingScalarFieldEnum | AmenityBookingScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    where?: ComplaintCommentWhereInput
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    cursor?: ComplaintCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintCommentScalarFieldEnum | ComplaintCommentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    id: number | null
    floor: number | null
    areaSqFt: number | null
    societyId: number | null
    ownerId: number | null
    tenantId: number | null
  }

  export type UnitSumAggregateOutputType = {
    id: number | null
    floor: number | null
    areaSqFt: number | null
    societyId: number | null
    ownerId: number | null
    tenantId: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: number | null
    block: string | null
    number: string | null
    floor: number | null
    type: string | null
    areaSqFt: number | null
    societyId: number | null
    ownerId: number | null
    tenantId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    id: number | null
    block: string | null
    number: string | null
    floor: number | null
    type: string | null
    areaSqFt: number | null
    societyId: number | null
    ownerId: number | null
    tenantId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    block: number
    number: number
    floor: number
    type: number
    areaSqFt: number
    societyId: number
    ownerId: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    id?: true
    floor?: true
    areaSqFt?: true
    societyId?: true
    ownerId?: true
    tenantId?: true
  }

  export type UnitSumAggregateInputType = {
    id?: true
    floor?: true
    areaSqFt?: true
    societyId?: true
    ownerId?: true
    tenantId?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    block?: true
    number?: true
    floor?: true
    type?: true
    areaSqFt?: true
    societyId?: true
    ownerId?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    block?: true
    number?: true
    floor?: true
    type?: true
    areaSqFt?: true
    societyId?: true
    ownerId?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    block?: true
    number?: true
    floor?: true
    type?: true
    areaSqFt?: true
    societyId?: true
    ownerId?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    ownerId: number | null
    tenantId: number | null
    createdAt: Date
    updatedAt: Date
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    block?: boolean
    number?: boolean
    floor?: boolean
    type?: boolean
    areaSqFt?: boolean
    societyId?: boolean
    ownerId?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    owner?: boolean | Unit$ownerArgs<ExtArgs>
    tenant?: boolean | Unit$tenantArgs<ExtArgs>
    visitors?: boolean | Unit$visitorsArgs<ExtArgs>
    parkingSlots?: boolean | Unit$parkingSlotsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>



  export type UnitSelectScalar = {
    id?: boolean
    block?: boolean
    number?: boolean
    floor?: boolean
    type?: boolean
    areaSqFt?: boolean
    societyId?: boolean
    ownerId?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "block" | "number" | "floor" | "type" | "areaSqFt" | "societyId" | "ownerId" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    owner?: boolean | Unit$ownerArgs<ExtArgs>
    tenant?: boolean | Unit$tenantArgs<ExtArgs>
    visitors?: boolean | Unit$visitorsArgs<ExtArgs>
    parkingSlots?: boolean | Unit$parkingSlotsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs> | null
      tenant: Prisma.$UserPayload<ExtArgs> | null
      visitors: Prisma.$VisitorPayload<ExtArgs>[]
      parkingSlots: Prisma.$ParkingSlotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      block: string
      number: string
      floor: number
      type: string
      areaSqFt: number
      societyId: number
      ownerId: number | null
      tenantId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends Unit$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Unit$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenant<T extends Unit$tenantArgs<ExtArgs> = {}>(args?: Subset<T, Unit$tenantArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    visitors<T extends Unit$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parkingSlots<T extends Unit$parkingSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$parkingSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'Int'>
    readonly block: FieldRef<"Unit", 'String'>
    readonly number: FieldRef<"Unit", 'String'>
    readonly floor: FieldRef<"Unit", 'Int'>
    readonly type: FieldRef<"Unit", 'String'>
    readonly areaSqFt: FieldRef<"Unit", 'Float'>
    readonly societyId: FieldRef<"Unit", 'Int'>
    readonly ownerId: FieldRef<"Unit", 'Int'>
    readonly tenantId: FieldRef<"Unit", 'Int'>
    readonly createdAt: FieldRef<"Unit", 'DateTime'>
    readonly updatedAt: FieldRef<"Unit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.owner
   */
  export type Unit$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Unit.tenant
   */
  export type Unit$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Unit.visitors
   */
  export type Unit$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    cursor?: VisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Unit.parkingSlots
   */
  export type Unit$parkingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    where?: ParkingSlotWhereInput
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    cursor?: ParkingSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model ParkingSlot
   */

  export type AggregateParkingSlot = {
    _count: ParkingSlotCountAggregateOutputType | null
    _avg: ParkingSlotAvgAggregateOutputType | null
    _sum: ParkingSlotSumAggregateOutputType | null
    _min: ParkingSlotMinAggregateOutputType | null
    _max: ParkingSlotMaxAggregateOutputType | null
  }

  export type ParkingSlotAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
    allocatedToUnitId: number | null
  }

  export type ParkingSlotSumAggregateOutputType = {
    id: number | null
    societyId: number | null
    allocatedToUnitId: number | null
  }

  export type ParkingSlotMinAggregateOutputType = {
    id: number | null
    number: string | null
    type: string | null
    status: string | null
    societyId: number | null
    allocatedToUnitId: number | null
    vehicleNumber: string | null
    createdAt: Date | null
  }

  export type ParkingSlotMaxAggregateOutputType = {
    id: number | null
    number: string | null
    type: string | null
    status: string | null
    societyId: number | null
    allocatedToUnitId: number | null
    vehicleNumber: string | null
    createdAt: Date | null
  }

  export type ParkingSlotCountAggregateOutputType = {
    id: number
    number: number
    type: number
    status: number
    societyId: number
    allocatedToUnitId: number
    vehicleNumber: number
    createdAt: number
    _all: number
  }


  export type ParkingSlotAvgAggregateInputType = {
    id?: true
    societyId?: true
    allocatedToUnitId?: true
  }

  export type ParkingSlotSumAggregateInputType = {
    id?: true
    societyId?: true
    allocatedToUnitId?: true
  }

  export type ParkingSlotMinAggregateInputType = {
    id?: true
    number?: true
    type?: true
    status?: true
    societyId?: true
    allocatedToUnitId?: true
    vehicleNumber?: true
    createdAt?: true
  }

  export type ParkingSlotMaxAggregateInputType = {
    id?: true
    number?: true
    type?: true
    status?: true
    societyId?: true
    allocatedToUnitId?: true
    vehicleNumber?: true
    createdAt?: true
  }

  export type ParkingSlotCountAggregateInputType = {
    id?: true
    number?: true
    type?: true
    status?: true
    societyId?: true
    allocatedToUnitId?: true
    vehicleNumber?: true
    createdAt?: true
    _all?: true
  }

  export type ParkingSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParkingSlot to aggregate.
     */
    where?: ParkingSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingSlots to fetch.
     */
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParkingSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParkingSlots
    **/
    _count?: true | ParkingSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParkingSlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParkingSlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParkingSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParkingSlotMaxAggregateInputType
  }

  export type GetParkingSlotAggregateType<T extends ParkingSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateParkingSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParkingSlot[P]>
      : GetScalarType<T[P], AggregateParkingSlot[P]>
  }




  export type ParkingSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingSlotWhereInput
    orderBy?: ParkingSlotOrderByWithAggregationInput | ParkingSlotOrderByWithAggregationInput[]
    by: ParkingSlotScalarFieldEnum[] | ParkingSlotScalarFieldEnum
    having?: ParkingSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParkingSlotCountAggregateInputType | true
    _avg?: ParkingSlotAvgAggregateInputType
    _sum?: ParkingSlotSumAggregateInputType
    _min?: ParkingSlotMinAggregateInputType
    _max?: ParkingSlotMaxAggregateInputType
  }

  export type ParkingSlotGroupByOutputType = {
    id: number
    number: string
    type: string
    status: string
    societyId: number
    allocatedToUnitId: number | null
    vehicleNumber: string | null
    createdAt: Date
    _count: ParkingSlotCountAggregateOutputType | null
    _avg: ParkingSlotAvgAggregateOutputType | null
    _sum: ParkingSlotSumAggregateOutputType | null
    _min: ParkingSlotMinAggregateOutputType | null
    _max: ParkingSlotMaxAggregateOutputType | null
  }

  type GetParkingSlotGroupByPayload<T extends ParkingSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParkingSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParkingSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParkingSlotGroupByOutputType[P]>
            : GetScalarType<T[P], ParkingSlotGroupByOutputType[P]>
        }
      >
    >


  export type ParkingSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    type?: boolean
    status?: boolean
    societyId?: boolean
    allocatedToUnitId?: boolean
    vehicleNumber?: boolean
    createdAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    unit?: boolean | ParkingSlot$unitArgs<ExtArgs>
  }, ExtArgs["result"]["parkingSlot"]>



  export type ParkingSlotSelectScalar = {
    id?: boolean
    number?: boolean
    type?: boolean
    status?: boolean
    societyId?: boolean
    allocatedToUnitId?: boolean
    vehicleNumber?: boolean
    createdAt?: boolean
  }

  export type ParkingSlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "type" | "status" | "societyId" | "allocatedToUnitId" | "vehicleNumber" | "createdAt", ExtArgs["result"]["parkingSlot"]>
  export type ParkingSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    unit?: boolean | ParkingSlot$unitArgs<ExtArgs>
  }

  export type $ParkingSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParkingSlot"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: string
      type: string
      status: string
      societyId: number
      allocatedToUnitId: number | null
      vehicleNumber: string | null
      createdAt: Date
    }, ExtArgs["result"]["parkingSlot"]>
    composites: {}
  }

  type ParkingSlotGetPayload<S extends boolean | null | undefined | ParkingSlotDefaultArgs> = $Result.GetResult<Prisma.$ParkingSlotPayload, S>

  type ParkingSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParkingSlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParkingSlotCountAggregateInputType | true
    }

  export interface ParkingSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParkingSlot'], meta: { name: 'ParkingSlot' } }
    /**
     * Find zero or one ParkingSlot that matches the filter.
     * @param {ParkingSlotFindUniqueArgs} args - Arguments to find a ParkingSlot
     * @example
     * // Get one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParkingSlotFindUniqueArgs>(args: SelectSubset<T, ParkingSlotFindUniqueArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParkingSlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParkingSlotFindUniqueOrThrowArgs} args - Arguments to find a ParkingSlot
     * @example
     * // Get one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParkingSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, ParkingSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParkingSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotFindFirstArgs} args - Arguments to find a ParkingSlot
     * @example
     * // Get one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParkingSlotFindFirstArgs>(args?: SelectSubset<T, ParkingSlotFindFirstArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParkingSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotFindFirstOrThrowArgs} args - Arguments to find a ParkingSlot
     * @example
     * // Get one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParkingSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, ParkingSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParkingSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParkingSlots
     * const parkingSlots = await prisma.parkingSlot.findMany()
     * 
     * // Get first 10 ParkingSlots
     * const parkingSlots = await prisma.parkingSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parkingSlotWithIdOnly = await prisma.parkingSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParkingSlotFindManyArgs>(args?: SelectSubset<T, ParkingSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParkingSlot.
     * @param {ParkingSlotCreateArgs} args - Arguments to create a ParkingSlot.
     * @example
     * // Create one ParkingSlot
     * const ParkingSlot = await prisma.parkingSlot.create({
     *   data: {
     *     // ... data to create a ParkingSlot
     *   }
     * })
     * 
     */
    create<T extends ParkingSlotCreateArgs>(args: SelectSubset<T, ParkingSlotCreateArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParkingSlots.
     * @param {ParkingSlotCreateManyArgs} args - Arguments to create many ParkingSlots.
     * @example
     * // Create many ParkingSlots
     * const parkingSlot = await prisma.parkingSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParkingSlotCreateManyArgs>(args?: SelectSubset<T, ParkingSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ParkingSlot.
     * @param {ParkingSlotDeleteArgs} args - Arguments to delete one ParkingSlot.
     * @example
     * // Delete one ParkingSlot
     * const ParkingSlot = await prisma.parkingSlot.delete({
     *   where: {
     *     // ... filter to delete one ParkingSlot
     *   }
     * })
     * 
     */
    delete<T extends ParkingSlotDeleteArgs>(args: SelectSubset<T, ParkingSlotDeleteArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParkingSlot.
     * @param {ParkingSlotUpdateArgs} args - Arguments to update one ParkingSlot.
     * @example
     * // Update one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParkingSlotUpdateArgs>(args: SelectSubset<T, ParkingSlotUpdateArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParkingSlots.
     * @param {ParkingSlotDeleteManyArgs} args - Arguments to filter ParkingSlots to delete.
     * @example
     * // Delete a few ParkingSlots
     * const { count } = await prisma.parkingSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParkingSlotDeleteManyArgs>(args?: SelectSubset<T, ParkingSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParkingSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParkingSlots
     * const parkingSlot = await prisma.parkingSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParkingSlotUpdateManyArgs>(args: SelectSubset<T, ParkingSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ParkingSlot.
     * @param {ParkingSlotUpsertArgs} args - Arguments to update or create a ParkingSlot.
     * @example
     * // Update or create a ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.upsert({
     *   create: {
     *     // ... data to create a ParkingSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParkingSlot we want to update
     *   }
     * })
     */
    upsert<T extends ParkingSlotUpsertArgs>(args: SelectSubset<T, ParkingSlotUpsertArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParkingSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotCountArgs} args - Arguments to filter ParkingSlots to count.
     * @example
     * // Count the number of ParkingSlots
     * const count = await prisma.parkingSlot.count({
     *   where: {
     *     // ... the filter for the ParkingSlots we want to count
     *   }
     * })
    **/
    count<T extends ParkingSlotCountArgs>(
      args?: Subset<T, ParkingSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParkingSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParkingSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParkingSlotAggregateArgs>(args: Subset<T, ParkingSlotAggregateArgs>): Prisma.PrismaPromise<GetParkingSlotAggregateType<T>>

    /**
     * Group by ParkingSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParkingSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParkingSlotGroupByArgs['orderBy'] }
        : { orderBy?: ParkingSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParkingSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParkingSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParkingSlot model
   */
  readonly fields: ParkingSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParkingSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParkingSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends ParkingSlot$unitArgs<ExtArgs> = {}>(args?: Subset<T, ParkingSlot$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParkingSlot model
   */
  interface ParkingSlotFieldRefs {
    readonly id: FieldRef<"ParkingSlot", 'Int'>
    readonly number: FieldRef<"ParkingSlot", 'String'>
    readonly type: FieldRef<"ParkingSlot", 'String'>
    readonly status: FieldRef<"ParkingSlot", 'String'>
    readonly societyId: FieldRef<"ParkingSlot", 'Int'>
    readonly allocatedToUnitId: FieldRef<"ParkingSlot", 'Int'>
    readonly vehicleNumber: FieldRef<"ParkingSlot", 'String'>
    readonly createdAt: FieldRef<"ParkingSlot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParkingSlot findUnique
   */
  export type ParkingSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlot to fetch.
     */
    where: ParkingSlotWhereUniqueInput
  }

  /**
   * ParkingSlot findUniqueOrThrow
   */
  export type ParkingSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlot to fetch.
     */
    where: ParkingSlotWhereUniqueInput
  }

  /**
   * ParkingSlot findFirst
   */
  export type ParkingSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlot to fetch.
     */
    where?: ParkingSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingSlots to fetch.
     */
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParkingSlots.
     */
    cursor?: ParkingSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParkingSlots.
     */
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * ParkingSlot findFirstOrThrow
   */
  export type ParkingSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlot to fetch.
     */
    where?: ParkingSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingSlots to fetch.
     */
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParkingSlots.
     */
    cursor?: ParkingSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParkingSlots.
     */
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * ParkingSlot findMany
   */
  export type ParkingSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlots to fetch.
     */
    where?: ParkingSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingSlots to fetch.
     */
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParkingSlots.
     */
    cursor?: ParkingSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingSlots.
     */
    skip?: number
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * ParkingSlot create
   */
  export type ParkingSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a ParkingSlot.
     */
    data: XOR<ParkingSlotCreateInput, ParkingSlotUncheckedCreateInput>
  }

  /**
   * ParkingSlot createMany
   */
  export type ParkingSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParkingSlots.
     */
    data: ParkingSlotCreateManyInput | ParkingSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParkingSlot update
   */
  export type ParkingSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a ParkingSlot.
     */
    data: XOR<ParkingSlotUpdateInput, ParkingSlotUncheckedUpdateInput>
    /**
     * Choose, which ParkingSlot to update.
     */
    where: ParkingSlotWhereUniqueInput
  }

  /**
   * ParkingSlot updateMany
   */
  export type ParkingSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParkingSlots.
     */
    data: XOR<ParkingSlotUpdateManyMutationInput, ParkingSlotUncheckedUpdateManyInput>
    /**
     * Filter which ParkingSlots to update
     */
    where?: ParkingSlotWhereInput
    /**
     * Limit how many ParkingSlots to update.
     */
    limit?: number
  }

  /**
   * ParkingSlot upsert
   */
  export type ParkingSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the ParkingSlot to update in case it exists.
     */
    where: ParkingSlotWhereUniqueInput
    /**
     * In case the ParkingSlot found by the `where` argument doesn't exist, create a new ParkingSlot with this data.
     */
    create: XOR<ParkingSlotCreateInput, ParkingSlotUncheckedCreateInput>
    /**
     * In case the ParkingSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParkingSlotUpdateInput, ParkingSlotUncheckedUpdateInput>
  }

  /**
   * ParkingSlot delete
   */
  export type ParkingSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter which ParkingSlot to delete.
     */
    where: ParkingSlotWhereUniqueInput
  }

  /**
   * ParkingSlot deleteMany
   */
  export type ParkingSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParkingSlots to delete
     */
    where?: ParkingSlotWhereInput
    /**
     * Limit how many ParkingSlots to delete.
     */
    limit?: number
  }

  /**
   * ParkingSlot.unit
   */
  export type ParkingSlot$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * ParkingSlot without action
   */
  export type ParkingSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
  }


  /**
   * Model Complaint
   */

  export type AggregateComplaint = {
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  export type ComplaintAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
    reportedById: number | null
    assignedToId: number | null
  }

  export type ComplaintSumAggregateOutputType = {
    id: number | null
    societyId: number | null
    reportedById: number | null
    assignedToId: number | null
  }

  export type ComplaintMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    category: string | null
    priority: $Enums.Priority | null
    status: $Enums.ComplaintStatus | null
    societyId: number | null
    reportedById: number | null
    assignedToId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplaintMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    category: string | null
    priority: $Enums.Priority | null
    status: $Enums.ComplaintStatus | null
    societyId: number | null
    reportedById: number | null
    assignedToId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplaintCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    priority: number
    status: number
    images: number
    societyId: number
    reportedById: number
    assignedToId: number
    timeline: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComplaintAvgAggregateInputType = {
    id?: true
    societyId?: true
    reportedById?: true
    assignedToId?: true
  }

  export type ComplaintSumAggregateInputType = {
    id?: true
    societyId?: true
    reportedById?: true
    assignedToId?: true
  }

  export type ComplaintMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    societyId?: true
    reportedById?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplaintMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    societyId?: true
    reportedById?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplaintCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    images?: true
    societyId?: true
    reportedById?: true
    assignedToId?: true
    timeline?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComplaintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaint to aggregate.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Complaints
    **/
    _count?: true | ComplaintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintMaxAggregateInputType
  }

  export type GetComplaintAggregateType<T extends ComplaintAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaint[P]>
      : GetScalarType<T[P], AggregateComplaint[P]>
  }




  export type ComplaintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithAggregationInput | ComplaintOrderByWithAggregationInput[]
    by: ComplaintScalarFieldEnum[] | ComplaintScalarFieldEnum
    having?: ComplaintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintCountAggregateInputType | true
    _avg?: ComplaintAvgAggregateInputType
    _sum?: ComplaintSumAggregateInputType
    _min?: ComplaintMinAggregateInputType
    _max?: ComplaintMaxAggregateInputType
  }

  export type ComplaintGroupByOutputType = {
    id: number
    title: string
    description: string
    category: string
    priority: $Enums.Priority
    status: $Enums.ComplaintStatus
    images: JsonValue | null
    societyId: number
    reportedById: number
    assignedToId: number | null
    timeline: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  type GetComplaintGroupByPayload<T extends ComplaintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    images?: boolean
    societyId?: boolean
    reportedById?: boolean
    assignedToId?: boolean
    timeline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Complaint$assignedToArgs<ExtArgs>
    comments?: boolean | Complaint$commentsArgs<ExtArgs>
    _count?: boolean | ComplaintCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaint"]>



  export type ComplaintSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    images?: boolean
    societyId?: boolean
    reportedById?: boolean
    assignedToId?: boolean
    timeline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComplaintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "category" | "priority" | "status" | "images" | "societyId" | "reportedById" | "assignedToId" | "timeline" | "createdAt" | "updatedAt", ExtArgs["result"]["complaint"]>
  export type ComplaintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Complaint$assignedToArgs<ExtArgs>
    comments?: boolean | Complaint$commentsArgs<ExtArgs>
    _count?: boolean | ComplaintCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ComplaintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Complaint"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      reportedBy: Prisma.$UserPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      comments: Prisma.$ComplaintCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      category: string
      priority: $Enums.Priority
      status: $Enums.ComplaintStatus
      images: Prisma.JsonValue | null
      societyId: number
      reportedById: number
      assignedToId: number | null
      timeline: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["complaint"]>
    composites: {}
  }

  type ComplaintGetPayload<S extends boolean | null | undefined | ComplaintDefaultArgs> = $Result.GetResult<Prisma.$ComplaintPayload, S>

  type ComplaintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplaintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplaintCountAggregateInputType | true
    }

  export interface ComplaintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Complaint'], meta: { name: 'Complaint' } }
    /**
     * Find zero or one Complaint that matches the filter.
     * @param {ComplaintFindUniqueArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintFindUniqueArgs>(args: SelectSubset<T, ComplaintFindUniqueArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Complaint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplaintFindUniqueOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintFindFirstArgs>(args?: SelectSubset<T, ComplaintFindFirstArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complaints
     * const complaints = await prisma.complaint.findMany()
     * 
     * // Get first 10 Complaints
     * const complaints = await prisma.complaint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintWithIdOnly = await prisma.complaint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplaintFindManyArgs>(args?: SelectSubset<T, ComplaintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Complaint.
     * @param {ComplaintCreateArgs} args - Arguments to create a Complaint.
     * @example
     * // Create one Complaint
     * const Complaint = await prisma.complaint.create({
     *   data: {
     *     // ... data to create a Complaint
     *   }
     * })
     * 
     */
    create<T extends ComplaintCreateArgs>(args: SelectSubset<T, ComplaintCreateArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Complaints.
     * @param {ComplaintCreateManyArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaint = await prisma.complaint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintCreateManyArgs>(args?: SelectSubset<T, ComplaintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Complaint.
     * @param {ComplaintDeleteArgs} args - Arguments to delete one Complaint.
     * @example
     * // Delete one Complaint
     * const Complaint = await prisma.complaint.delete({
     *   where: {
     *     // ... filter to delete one Complaint
     *   }
     * })
     * 
     */
    delete<T extends ComplaintDeleteArgs>(args: SelectSubset<T, ComplaintDeleteArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Complaint.
     * @param {ComplaintUpdateArgs} args - Arguments to update one Complaint.
     * @example
     * // Update one Complaint
     * const complaint = await prisma.complaint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintUpdateArgs>(args: SelectSubset<T, ComplaintUpdateArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Complaints.
     * @param {ComplaintDeleteManyArgs} args - Arguments to filter Complaints to delete.
     * @example
     * // Delete a few Complaints
     * const { count } = await prisma.complaint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintDeleteManyArgs>(args?: SelectSubset<T, ComplaintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complaints
     * const complaint = await prisma.complaint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintUpdateManyArgs>(args: SelectSubset<T, ComplaintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Complaint.
     * @param {ComplaintUpsertArgs} args - Arguments to update or create a Complaint.
     * @example
     * // Update or create a Complaint
     * const complaint = await prisma.complaint.upsert({
     *   create: {
     *     // ... data to create a Complaint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complaint we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintUpsertArgs>(args: SelectSubset<T, ComplaintUpsertArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCountArgs} args - Arguments to filter Complaints to count.
     * @example
     * // Count the number of Complaints
     * const count = await prisma.complaint.count({
     *   where: {
     *     // ... the filter for the Complaints we want to count
     *   }
     * })
    **/
    count<T extends ComplaintCountArgs>(
      args?: Subset<T, ComplaintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintAggregateArgs>(args: Subset<T, ComplaintAggregateArgs>): Prisma.PrismaPromise<GetComplaintAggregateType<T>>

    /**
     * Group by Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Complaint model
   */
  readonly fields: ComplaintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Complaint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reportedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends Complaint$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Complaint$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comments<T extends Complaint$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Complaint$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Complaint model
   */
  interface ComplaintFieldRefs {
    readonly id: FieldRef<"Complaint", 'Int'>
    readonly title: FieldRef<"Complaint", 'String'>
    readonly description: FieldRef<"Complaint", 'String'>
    readonly category: FieldRef<"Complaint", 'String'>
    readonly priority: FieldRef<"Complaint", 'Priority'>
    readonly status: FieldRef<"Complaint", 'ComplaintStatus'>
    readonly images: FieldRef<"Complaint", 'Json'>
    readonly societyId: FieldRef<"Complaint", 'Int'>
    readonly reportedById: FieldRef<"Complaint", 'Int'>
    readonly assignedToId: FieldRef<"Complaint", 'Int'>
    readonly timeline: FieldRef<"Complaint", 'Json'>
    readonly createdAt: FieldRef<"Complaint", 'DateTime'>
    readonly updatedAt: FieldRef<"Complaint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Complaint findUnique
   */
  export type ComplaintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint findUniqueOrThrow
   */
  export type ComplaintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint findFirst
   */
  export type ComplaintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint findFirstOrThrow
   */
  export type ComplaintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint findMany
   */
  export type ComplaintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaints to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint create
   */
  export type ComplaintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The data needed to create a Complaint.
     */
    data: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>
  }

  /**
   * Complaint createMany
   */
  export type ComplaintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Complaints.
     */
    data: ComplaintCreateManyInput | ComplaintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Complaint update
   */
  export type ComplaintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The data needed to update a Complaint.
     */
    data: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>
    /**
     * Choose, which Complaint to update.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint updateMany
   */
  export type ComplaintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Complaints.
     */
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyInput>
    /**
     * Filter which Complaints to update
     */
    where?: ComplaintWhereInput
    /**
     * Limit how many Complaints to update.
     */
    limit?: number
  }

  /**
   * Complaint upsert
   */
  export type ComplaintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The filter to search for the Complaint to update in case it exists.
     */
    where: ComplaintWhereUniqueInput
    /**
     * In case the Complaint found by the `where` argument doesn't exist, create a new Complaint with this data.
     */
    create: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>
    /**
     * In case the Complaint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>
  }

  /**
   * Complaint delete
   */
  export type ComplaintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter which Complaint to delete.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint deleteMany
   */
  export type ComplaintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaints to delete
     */
    where?: ComplaintWhereInput
    /**
     * Limit how many Complaints to delete.
     */
    limit?: number
  }

  /**
   * Complaint.assignedTo
   */
  export type Complaint$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Complaint.comments
   */
  export type Complaint$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    where?: ComplaintCommentWhereInput
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    cursor?: ComplaintCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintCommentScalarFieldEnum | ComplaintCommentScalarFieldEnum[]
  }

  /**
   * Complaint without action
   */
  export type ComplaintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
  }


  /**
   * Model ComplaintComment
   */

  export type AggregateComplaintComment = {
    _count: ComplaintCommentCountAggregateOutputType | null
    _avg: ComplaintCommentAvgAggregateOutputType | null
    _sum: ComplaintCommentSumAggregateOutputType | null
    _min: ComplaintCommentMinAggregateOutputType | null
    _max: ComplaintCommentMaxAggregateOutputType | null
  }

  export type ComplaintCommentAvgAggregateOutputType = {
    id: number | null
    complaintId: number | null
    userId: number | null
  }

  export type ComplaintCommentSumAggregateOutputType = {
    id: number | null
    complaintId: number | null
    userId: number | null
  }

  export type ComplaintCommentMinAggregateOutputType = {
    id: number | null
    complaintId: number | null
    userId: number | null
    message: string | null
    createdAt: Date | null
  }

  export type ComplaintCommentMaxAggregateOutputType = {
    id: number | null
    complaintId: number | null
    userId: number | null
    message: string | null
    createdAt: Date | null
  }

  export type ComplaintCommentCountAggregateOutputType = {
    id: number
    complaintId: number
    userId: number
    message: number
    createdAt: number
    _all: number
  }


  export type ComplaintCommentAvgAggregateInputType = {
    id?: true
    complaintId?: true
    userId?: true
  }

  export type ComplaintCommentSumAggregateInputType = {
    id?: true
    complaintId?: true
    userId?: true
  }

  export type ComplaintCommentMinAggregateInputType = {
    id?: true
    complaintId?: true
    userId?: true
    message?: true
    createdAt?: true
  }

  export type ComplaintCommentMaxAggregateInputType = {
    id?: true
    complaintId?: true
    userId?: true
    message?: true
    createdAt?: true
  }

  export type ComplaintCommentCountAggregateInputType = {
    id?: true
    complaintId?: true
    userId?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type ComplaintCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplaintComment to aggregate.
     */
    where?: ComplaintCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintComments to fetch.
     */
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplaintComments
    **/
    _count?: true | ComplaintCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintCommentMaxAggregateInputType
  }

  export type GetComplaintCommentAggregateType<T extends ComplaintCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaintComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaintComment[P]>
      : GetScalarType<T[P], AggregateComplaintComment[P]>
  }




  export type ComplaintCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintCommentWhereInput
    orderBy?: ComplaintCommentOrderByWithAggregationInput | ComplaintCommentOrderByWithAggregationInput[]
    by: ComplaintCommentScalarFieldEnum[] | ComplaintCommentScalarFieldEnum
    having?: ComplaintCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintCommentCountAggregateInputType | true
    _avg?: ComplaintCommentAvgAggregateInputType
    _sum?: ComplaintCommentSumAggregateInputType
    _min?: ComplaintCommentMinAggregateInputType
    _max?: ComplaintCommentMaxAggregateInputType
  }

  export type ComplaintCommentGroupByOutputType = {
    id: number
    complaintId: number
    userId: number
    message: string
    createdAt: Date
    _count: ComplaintCommentCountAggregateOutputType | null
    _avg: ComplaintCommentAvgAggregateOutputType | null
    _sum: ComplaintCommentSumAggregateOutputType | null
    _min: ComplaintCommentMinAggregateOutputType | null
    _max: ComplaintCommentMaxAggregateOutputType | null
  }

  type GetComplaintCommentGroupByPayload<T extends ComplaintCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintCommentGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    complaintId?: boolean
    userId?: boolean
    message?: boolean
    createdAt?: boolean
    complaint?: boolean | ComplaintDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaintComment"]>



  export type ComplaintCommentSelectScalar = {
    id?: boolean
    complaintId?: boolean
    userId?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type ComplaintCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "complaintId" | "userId" | "message" | "createdAt", ExtArgs["result"]["complaintComment"]>
  export type ComplaintCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaint?: boolean | ComplaintDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ComplaintCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplaintComment"
    objects: {
      complaint: Prisma.$ComplaintPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      complaintId: number
      userId: number
      message: string
      createdAt: Date
    }, ExtArgs["result"]["complaintComment"]>
    composites: {}
  }

  type ComplaintCommentGetPayload<S extends boolean | null | undefined | ComplaintCommentDefaultArgs> = $Result.GetResult<Prisma.$ComplaintCommentPayload, S>

  type ComplaintCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplaintCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplaintCommentCountAggregateInputType | true
    }

  export interface ComplaintCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplaintComment'], meta: { name: 'ComplaintComment' } }
    /**
     * Find zero or one ComplaintComment that matches the filter.
     * @param {ComplaintCommentFindUniqueArgs} args - Arguments to find a ComplaintComment
     * @example
     * // Get one ComplaintComment
     * const complaintComment = await prisma.complaintComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintCommentFindUniqueArgs>(args: SelectSubset<T, ComplaintCommentFindUniqueArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComplaintComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplaintCommentFindUniqueOrThrowArgs} args - Arguments to find a ComplaintComment
     * @example
     * // Get one ComplaintComment
     * const complaintComment = await prisma.complaintComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplaintComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentFindFirstArgs} args - Arguments to find a ComplaintComment
     * @example
     * // Get one ComplaintComment
     * const complaintComment = await prisma.complaintComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintCommentFindFirstArgs>(args?: SelectSubset<T, ComplaintCommentFindFirstArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplaintComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentFindFirstOrThrowArgs} args - Arguments to find a ComplaintComment
     * @example
     * // Get one ComplaintComment
     * const complaintComment = await prisma.complaintComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComplaintComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplaintComments
     * const complaintComments = await prisma.complaintComment.findMany()
     * 
     * // Get first 10 ComplaintComments
     * const complaintComments = await prisma.complaintComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintCommentWithIdOnly = await prisma.complaintComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplaintCommentFindManyArgs>(args?: SelectSubset<T, ComplaintCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComplaintComment.
     * @param {ComplaintCommentCreateArgs} args - Arguments to create a ComplaintComment.
     * @example
     * // Create one ComplaintComment
     * const ComplaintComment = await prisma.complaintComment.create({
     *   data: {
     *     // ... data to create a ComplaintComment
     *   }
     * })
     * 
     */
    create<T extends ComplaintCommentCreateArgs>(args: SelectSubset<T, ComplaintCommentCreateArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComplaintComments.
     * @param {ComplaintCommentCreateManyArgs} args - Arguments to create many ComplaintComments.
     * @example
     * // Create many ComplaintComments
     * const complaintComment = await prisma.complaintComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintCommentCreateManyArgs>(args?: SelectSubset<T, ComplaintCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ComplaintComment.
     * @param {ComplaintCommentDeleteArgs} args - Arguments to delete one ComplaintComment.
     * @example
     * // Delete one ComplaintComment
     * const ComplaintComment = await prisma.complaintComment.delete({
     *   where: {
     *     // ... filter to delete one ComplaintComment
     *   }
     * })
     * 
     */
    delete<T extends ComplaintCommentDeleteArgs>(args: SelectSubset<T, ComplaintCommentDeleteArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComplaintComment.
     * @param {ComplaintCommentUpdateArgs} args - Arguments to update one ComplaintComment.
     * @example
     * // Update one ComplaintComment
     * const complaintComment = await prisma.complaintComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintCommentUpdateArgs>(args: SelectSubset<T, ComplaintCommentUpdateArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComplaintComments.
     * @param {ComplaintCommentDeleteManyArgs} args - Arguments to filter ComplaintComments to delete.
     * @example
     * // Delete a few ComplaintComments
     * const { count } = await prisma.complaintComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintCommentDeleteManyArgs>(args?: SelectSubset<T, ComplaintCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplaintComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplaintComments
     * const complaintComment = await prisma.complaintComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintCommentUpdateManyArgs>(args: SelectSubset<T, ComplaintCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComplaintComment.
     * @param {ComplaintCommentUpsertArgs} args - Arguments to update or create a ComplaintComment.
     * @example
     * // Update or create a ComplaintComment
     * const complaintComment = await prisma.complaintComment.upsert({
     *   create: {
     *     // ... data to create a ComplaintComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplaintComment we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintCommentUpsertArgs>(args: SelectSubset<T, ComplaintCommentUpsertArgs<ExtArgs>>): Prisma__ComplaintCommentClient<$Result.GetResult<Prisma.$ComplaintCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComplaintComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentCountArgs} args - Arguments to filter ComplaintComments to count.
     * @example
     * // Count the number of ComplaintComments
     * const count = await prisma.complaintComment.count({
     *   where: {
     *     // ... the filter for the ComplaintComments we want to count
     *   }
     * })
    **/
    count<T extends ComplaintCommentCountArgs>(
      args?: Subset<T, ComplaintCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplaintComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintCommentAggregateArgs>(args: Subset<T, ComplaintCommentAggregateArgs>): Prisma.PrismaPromise<GetComplaintCommentAggregateType<T>>

    /**
     * Group by ComplaintComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintCommentGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplaintComment model
   */
  readonly fields: ComplaintCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplaintComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    complaint<T extends ComplaintDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComplaintDefaultArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplaintComment model
   */
  interface ComplaintCommentFieldRefs {
    readonly id: FieldRef<"ComplaintComment", 'Int'>
    readonly complaintId: FieldRef<"ComplaintComment", 'Int'>
    readonly userId: FieldRef<"ComplaintComment", 'Int'>
    readonly message: FieldRef<"ComplaintComment", 'String'>
    readonly createdAt: FieldRef<"ComplaintComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplaintComment findUnique
   */
  export type ComplaintCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintComment to fetch.
     */
    where: ComplaintCommentWhereUniqueInput
  }

  /**
   * ComplaintComment findUniqueOrThrow
   */
  export type ComplaintCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintComment to fetch.
     */
    where: ComplaintCommentWhereUniqueInput
  }

  /**
   * ComplaintComment findFirst
   */
  export type ComplaintCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintComment to fetch.
     */
    where?: ComplaintCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintComments to fetch.
     */
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplaintComments.
     */
    cursor?: ComplaintCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplaintComments.
     */
    distinct?: ComplaintCommentScalarFieldEnum | ComplaintCommentScalarFieldEnum[]
  }

  /**
   * ComplaintComment findFirstOrThrow
   */
  export type ComplaintCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintComment to fetch.
     */
    where?: ComplaintCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintComments to fetch.
     */
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplaintComments.
     */
    cursor?: ComplaintCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplaintComments.
     */
    distinct?: ComplaintCommentScalarFieldEnum | ComplaintCommentScalarFieldEnum[]
  }

  /**
   * ComplaintComment findMany
   */
  export type ComplaintCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintComments to fetch.
     */
    where?: ComplaintCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintComments to fetch.
     */
    orderBy?: ComplaintCommentOrderByWithRelationInput | ComplaintCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplaintComments.
     */
    cursor?: ComplaintCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintComments.
     */
    skip?: number
    distinct?: ComplaintCommentScalarFieldEnum | ComplaintCommentScalarFieldEnum[]
  }

  /**
   * ComplaintComment create
   */
  export type ComplaintCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ComplaintComment.
     */
    data: XOR<ComplaintCommentCreateInput, ComplaintCommentUncheckedCreateInput>
  }

  /**
   * ComplaintComment createMany
   */
  export type ComplaintCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplaintComments.
     */
    data: ComplaintCommentCreateManyInput | ComplaintCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplaintComment update
   */
  export type ComplaintCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ComplaintComment.
     */
    data: XOR<ComplaintCommentUpdateInput, ComplaintCommentUncheckedUpdateInput>
    /**
     * Choose, which ComplaintComment to update.
     */
    where: ComplaintCommentWhereUniqueInput
  }

  /**
   * ComplaintComment updateMany
   */
  export type ComplaintCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplaintComments.
     */
    data: XOR<ComplaintCommentUpdateManyMutationInput, ComplaintCommentUncheckedUpdateManyInput>
    /**
     * Filter which ComplaintComments to update
     */
    where?: ComplaintCommentWhereInput
    /**
     * Limit how many ComplaintComments to update.
     */
    limit?: number
  }

  /**
   * ComplaintComment upsert
   */
  export type ComplaintCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ComplaintComment to update in case it exists.
     */
    where: ComplaintCommentWhereUniqueInput
    /**
     * In case the ComplaintComment found by the `where` argument doesn't exist, create a new ComplaintComment with this data.
     */
    create: XOR<ComplaintCommentCreateInput, ComplaintCommentUncheckedCreateInput>
    /**
     * In case the ComplaintComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintCommentUpdateInput, ComplaintCommentUncheckedUpdateInput>
  }

  /**
   * ComplaintComment delete
   */
  export type ComplaintCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
    /**
     * Filter which ComplaintComment to delete.
     */
    where: ComplaintCommentWhereUniqueInput
  }

  /**
   * ComplaintComment deleteMany
   */
  export type ComplaintCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplaintComments to delete
     */
    where?: ComplaintCommentWhereInput
    /**
     * Limit how many ComplaintComments to delete.
     */
    limit?: number
  }

  /**
   * ComplaintComment without action
   */
  export type ComplaintCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintComment
     */
    select?: ComplaintCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintComment
     */
    omit?: ComplaintCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintCommentInclude<ExtArgs> | null
  }


  /**
   * Model Visitor
   */

  export type AggregateVisitor = {
    _count: VisitorCountAggregateOutputType | null
    _avg: VisitorAvgAggregateOutputType | null
    _sum: VisitorSumAggregateOutputType | null
    _min: VisitorMinAggregateOutputType | null
    _max: VisitorMaxAggregateOutputType | null
  }

  export type VisitorAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
    visitingUnitId: number | null
  }

  export type VisitorSumAggregateOutputType = {
    id: number | null
    societyId: number | null
    visitingUnitId: number | null
  }

  export type VisitorMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    vehicleNo: string | null
    purpose: string | null
    photo: string | null
    status: $Enums.VisitorStatus | null
    entryTime: Date | null
    exitTime: Date | null
    societyId: number | null
    visitingUnitId: number | null
    idType: string | null
    idNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    vehicleNo: string | null
    purpose: string | null
    photo: string | null
    status: $Enums.VisitorStatus | null
    entryTime: Date | null
    exitTime: Date | null
    societyId: number | null
    visitingUnitId: number | null
    idType: string | null
    idNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitorCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    vehicleNo: number
    purpose: number
    photo: number
    status: number
    entryTime: number
    exitTime: number
    societyId: number
    visitingUnitId: number
    idType: number
    idNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VisitorAvgAggregateInputType = {
    id?: true
    societyId?: true
    visitingUnitId?: true
  }

  export type VisitorSumAggregateInputType = {
    id?: true
    societyId?: true
    visitingUnitId?: true
  }

  export type VisitorMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    vehicleNo?: true
    purpose?: true
    photo?: true
    status?: true
    entryTime?: true
    exitTime?: true
    societyId?: true
    visitingUnitId?: true
    idType?: true
    idNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitorMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    vehicleNo?: true
    purpose?: true
    photo?: true
    status?: true
    entryTime?: true
    exitTime?: true
    societyId?: true
    visitingUnitId?: true
    idType?: true
    idNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitorCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    vehicleNo?: true
    purpose?: true
    photo?: true
    status?: true
    entryTime?: true
    exitTime?: true
    societyId?: true
    visitingUnitId?: true
    idType?: true
    idNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VisitorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visitor to aggregate.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Visitors
    **/
    _count?: true | VisitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitorMaxAggregateInputType
  }

  export type GetVisitorAggregateType<T extends VisitorAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitor[P]>
      : GetScalarType<T[P], AggregateVisitor[P]>
  }




  export type VisitorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithAggregationInput | VisitorOrderByWithAggregationInput[]
    by: VisitorScalarFieldEnum[] | VisitorScalarFieldEnum
    having?: VisitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitorCountAggregateInputType | true
    _avg?: VisitorAvgAggregateInputType
    _sum?: VisitorSumAggregateInputType
    _min?: VisitorMinAggregateInputType
    _max?: VisitorMaxAggregateInputType
  }

  export type VisitorGroupByOutputType = {
    id: number
    name: string
    phone: string
    vehicleNo: string | null
    purpose: string
    photo: string | null
    status: $Enums.VisitorStatus
    entryTime: Date | null
    exitTime: Date | null
    societyId: number
    visitingUnitId: number
    idType: string | null
    idNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: VisitorCountAggregateOutputType | null
    _avg: VisitorAvgAggregateOutputType | null
    _sum: VisitorSumAggregateOutputType | null
    _min: VisitorMinAggregateOutputType | null
    _max: VisitorMaxAggregateOutputType | null
  }

  type GetVisitorGroupByPayload<T extends VisitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitorGroupByOutputType[P]>
            : GetScalarType<T[P], VisitorGroupByOutputType[P]>
        }
      >
    >


  export type VisitorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    vehicleNo?: boolean
    purpose?: boolean
    photo?: boolean
    status?: boolean
    entryTime?: boolean
    exitTime?: boolean
    societyId?: boolean
    visitingUnitId?: boolean
    idType?: boolean
    idNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitor"]>



  export type VisitorSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    vehicleNo?: boolean
    purpose?: boolean
    photo?: boolean
    status?: boolean
    entryTime?: boolean
    exitTime?: boolean
    societyId?: boolean
    visitingUnitId?: boolean
    idType?: boolean
    idNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VisitorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "vehicleNo" | "purpose" | "photo" | "status" | "entryTime" | "exitTime" | "societyId" | "visitingUnitId" | "idType" | "idNumber" | "createdAt" | "updatedAt", ExtArgs["result"]["visitor"]>
  export type VisitorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $VisitorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Visitor"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string
      vehicleNo: string | null
      purpose: string
      photo: string | null
      status: $Enums.VisitorStatus
      entryTime: Date | null
      exitTime: Date | null
      societyId: number
      visitingUnitId: number
      idType: string | null
      idNumber: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["visitor"]>
    composites: {}
  }

  type VisitorGetPayload<S extends boolean | null | undefined | VisitorDefaultArgs> = $Result.GetResult<Prisma.$VisitorPayload, S>

  type VisitorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisitorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisitorCountAggregateInputType | true
    }

  export interface VisitorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Visitor'], meta: { name: 'Visitor' } }
    /**
     * Find zero or one Visitor that matches the filter.
     * @param {VisitorFindUniqueArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitorFindUniqueArgs>(args: SelectSubset<T, VisitorFindUniqueArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Visitor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisitorFindUniqueOrThrowArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitorFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindFirstArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitorFindFirstArgs>(args?: SelectSubset<T, VisitorFindFirstArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visitor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindFirstOrThrowArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitorFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Visitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visitors
     * const visitors = await prisma.visitor.findMany()
     * 
     * // Get first 10 Visitors
     * const visitors = await prisma.visitor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitorWithIdOnly = await prisma.visitor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitorFindManyArgs>(args?: SelectSubset<T, VisitorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Visitor.
     * @param {VisitorCreateArgs} args - Arguments to create a Visitor.
     * @example
     * // Create one Visitor
     * const Visitor = await prisma.visitor.create({
     *   data: {
     *     // ... data to create a Visitor
     *   }
     * })
     * 
     */
    create<T extends VisitorCreateArgs>(args: SelectSubset<T, VisitorCreateArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Visitors.
     * @param {VisitorCreateManyArgs} args - Arguments to create many Visitors.
     * @example
     * // Create many Visitors
     * const visitor = await prisma.visitor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitorCreateManyArgs>(args?: SelectSubset<T, VisitorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Visitor.
     * @param {VisitorDeleteArgs} args - Arguments to delete one Visitor.
     * @example
     * // Delete one Visitor
     * const Visitor = await prisma.visitor.delete({
     *   where: {
     *     // ... filter to delete one Visitor
     *   }
     * })
     * 
     */
    delete<T extends VisitorDeleteArgs>(args: SelectSubset<T, VisitorDeleteArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Visitor.
     * @param {VisitorUpdateArgs} args - Arguments to update one Visitor.
     * @example
     * // Update one Visitor
     * const visitor = await prisma.visitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitorUpdateArgs>(args: SelectSubset<T, VisitorUpdateArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Visitors.
     * @param {VisitorDeleteManyArgs} args - Arguments to filter Visitors to delete.
     * @example
     * // Delete a few Visitors
     * const { count } = await prisma.visitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitorDeleteManyArgs>(args?: SelectSubset<T, VisitorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visitors
     * const visitor = await prisma.visitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitorUpdateManyArgs>(args: SelectSubset<T, VisitorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Visitor.
     * @param {VisitorUpsertArgs} args - Arguments to update or create a Visitor.
     * @example
     * // Update or create a Visitor
     * const visitor = await prisma.visitor.upsert({
     *   create: {
     *     // ... data to create a Visitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visitor we want to update
     *   }
     * })
     */
    upsert<T extends VisitorUpsertArgs>(args: SelectSubset<T, VisitorUpsertArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorCountArgs} args - Arguments to filter Visitors to count.
     * @example
     * // Count the number of Visitors
     * const count = await prisma.visitor.count({
     *   where: {
     *     // ... the filter for the Visitors we want to count
     *   }
     * })
    **/
    count<T extends VisitorCountArgs>(
      args?: Subset<T, VisitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitorAggregateArgs>(args: Subset<T, VisitorAggregateArgs>): Prisma.PrismaPromise<GetVisitorAggregateType<T>>

    /**
     * Group by Visitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitorGroupByArgs['orderBy'] }
        : { orderBy?: VisitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Visitor model
   */
  readonly fields: VisitorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Visitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Visitor model
   */
  interface VisitorFieldRefs {
    readonly id: FieldRef<"Visitor", 'Int'>
    readonly name: FieldRef<"Visitor", 'String'>
    readonly phone: FieldRef<"Visitor", 'String'>
    readonly vehicleNo: FieldRef<"Visitor", 'String'>
    readonly purpose: FieldRef<"Visitor", 'String'>
    readonly photo: FieldRef<"Visitor", 'String'>
    readonly status: FieldRef<"Visitor", 'VisitorStatus'>
    readonly entryTime: FieldRef<"Visitor", 'DateTime'>
    readonly exitTime: FieldRef<"Visitor", 'DateTime'>
    readonly societyId: FieldRef<"Visitor", 'Int'>
    readonly visitingUnitId: FieldRef<"Visitor", 'Int'>
    readonly idType: FieldRef<"Visitor", 'String'>
    readonly idNumber: FieldRef<"Visitor", 'String'>
    readonly createdAt: FieldRef<"Visitor", 'DateTime'>
    readonly updatedAt: FieldRef<"Visitor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Visitor findUnique
   */
  export type VisitorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor findUniqueOrThrow
   */
  export type VisitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor findFirst
   */
  export type VisitorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visitors.
     */
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor findFirstOrThrow
   */
  export type VisitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visitors.
     */
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor findMany
   */
  export type VisitorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter, which Visitors to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor create
   */
  export type VisitorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * The data needed to create a Visitor.
     */
    data: XOR<VisitorCreateInput, VisitorUncheckedCreateInput>
  }

  /**
   * Visitor createMany
   */
  export type VisitorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Visitors.
     */
    data: VisitorCreateManyInput | VisitorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Visitor update
   */
  export type VisitorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * The data needed to update a Visitor.
     */
    data: XOR<VisitorUpdateInput, VisitorUncheckedUpdateInput>
    /**
     * Choose, which Visitor to update.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor updateMany
   */
  export type VisitorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Visitors.
     */
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyInput>
    /**
     * Filter which Visitors to update
     */
    where?: VisitorWhereInput
    /**
     * Limit how many Visitors to update.
     */
    limit?: number
  }

  /**
   * Visitor upsert
   */
  export type VisitorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * The filter to search for the Visitor to update in case it exists.
     */
    where: VisitorWhereUniqueInput
    /**
     * In case the Visitor found by the `where` argument doesn't exist, create a new Visitor with this data.
     */
    create: XOR<VisitorCreateInput, VisitorUncheckedCreateInput>
    /**
     * In case the Visitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitorUpdateInput, VisitorUncheckedUpdateInput>
  }

  /**
   * Visitor delete
   */
  export type VisitorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
    /**
     * Filter which Visitor to delete.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor deleteMany
   */
  export type VisitorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visitors to delete
     */
    where?: VisitorWhereInput
    /**
     * Limit how many Visitors to delete.
     */
    limit?: number
  }

  /**
   * Visitor without action
   */
  export type VisitorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    societyId: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    amount: number | null
    societyId: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    type: $Enums.TransactionType | null
    category: string | null
    amount: number | null
    date: Date | null
    description: string | null
    paymentMethod: $Enums.PaymentMethod | null
    status: string | null
    societyId: number | null
    invoiceNo: string | null
    paidTo: string | null
    receivedFrom: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    type: $Enums.TransactionType | null
    category: string | null
    amount: number | null
    date: Date | null
    description: string | null
    paymentMethod: $Enums.PaymentMethod | null
    status: string | null
    societyId: number | null
    invoiceNo: string | null
    paidTo: string | null
    receivedFrom: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    type: number
    category: number
    amount: number
    date: number
    description: number
    paymentMethod: number
    status: number
    societyId: number
    invoiceNo: number
    paidTo: number
    receivedFrom: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    amount?: true
    societyId?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    amount?: true
    societyId?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    type?: true
    category?: true
    amount?: true
    date?: true
    description?: true
    paymentMethod?: true
    status?: true
    societyId?: true
    invoiceNo?: true
    paidTo?: true
    receivedFrom?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    type?: true
    category?: true
    amount?: true
    date?: true
    description?: true
    paymentMethod?: true
    status?: true
    societyId?: true
    invoiceNo?: true
    paidTo?: true
    receivedFrom?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    type?: true
    category?: true
    amount?: true
    date?: true
    description?: true
    paymentMethod?: true
    status?: true
    societyId?: true
    invoiceNo?: true
    paidTo?: true
    receivedFrom?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date
    description: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    societyId: number
    invoiceNo: string | null
    paidTo: string | null
    receivedFrom: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    paymentMethod?: boolean
    status?: boolean
    societyId?: boolean
    invoiceNo?: boolean
    paidTo?: boolean
    receivedFrom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>



  export type TransactionSelectScalar = {
    id?: boolean
    type?: boolean
    category?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    paymentMethod?: boolean
    status?: boolean
    societyId?: boolean
    invoiceNo?: boolean
    paidTo?: boolean
    receivedFrom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "category" | "amount" | "date" | "description" | "paymentMethod" | "status" | "societyId" | "invoiceNo" | "paidTo" | "receivedFrom" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.TransactionType
      category: string
      amount: number
      date: Date
      description: string | null
      paymentMethod: $Enums.PaymentMethod
      status: string
      societyId: number
      invoiceNo: string | null
      paidTo: string | null
      receivedFrom: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly category: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly date: FieldRef<"Transaction", 'DateTime'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly paymentMethod: FieldRef<"Transaction", 'PaymentMethod'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly societyId: FieldRef<"Transaction", 'Int'>
    readonly invoiceNo: FieldRef<"Transaction", 'String'>
    readonly paidTo: FieldRef<"Transaction", 'String'>
    readonly receivedFrom: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type VendorSumAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: number | null
    name: string | null
    serviceType: string | null
    contact: string | null
    email: string | null
    address: string | null
    status: $Enums.VendorStatus | null
    societyId: number | null
    createdAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    serviceType: string | null
    contact: string | null
    email: string | null
    address: string | null
    status: $Enums.VendorStatus | null
    societyId: number | null
    createdAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    name: number
    serviceType: number
    contact: number
    email: number
    address: number
    status: number
    societyId: number
    createdAt: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type VendorSumAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    name?: true
    serviceType?: true
    contact?: true
    email?: true
    address?: true
    status?: true
    societyId?: true
    createdAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    name?: true
    serviceType?: true
    contact?: true
    email?: true
    address?: true
    status?: true
    societyId?: true
    createdAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    name?: true
    serviceType?: true
    contact?: true
    email?: true
    address?: true
    status?: true
    societyId?: true
    createdAt?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: number
    name: string
    serviceType: string
    contact: string
    email: string | null
    address: string | null
    status: $Enums.VendorStatus
    societyId: number | null
    createdAt: Date
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    serviceType?: boolean
    contact?: boolean
    email?: boolean
    address?: boolean
    status?: boolean
    societyId?: boolean
    createdAt?: boolean
    society?: boolean | Vendor$societyArgs<ExtArgs>
    payouts?: boolean | Vendor$payoutsArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>



  export type VendorSelectScalar = {
    id?: boolean
    name?: boolean
    serviceType?: boolean
    contact?: boolean
    email?: boolean
    address?: boolean
    status?: boolean
    societyId?: boolean
    createdAt?: boolean
  }

  export type VendorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "serviceType" | "contact" | "email" | "address" | "status" | "societyId" | "createdAt", ExtArgs["result"]["vendor"]>
  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | Vendor$societyArgs<ExtArgs>
    payouts?: boolean | Vendor$payoutsArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs> | null
      payouts: Prisma.$VendorPayoutPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      serviceType: string
      contact: string
      email: string | null
      address: string | null
      status: $Enums.VendorStatus
      societyId: number | null
      createdAt: Date
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends Vendor$societyArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$societyArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payouts<T extends Vendor$payoutsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$payoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'Int'>
    readonly name: FieldRef<"Vendor", 'String'>
    readonly serviceType: FieldRef<"Vendor", 'String'>
    readonly contact: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly address: FieldRef<"Vendor", 'String'>
    readonly status: FieldRef<"Vendor", 'VendorStatus'>
    readonly societyId: FieldRef<"Vendor", 'Int'>
    readonly createdAt: FieldRef<"Vendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to delete.
     */
    limit?: number
  }

  /**
   * Vendor.society
   */
  export type Vendor$societyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Society
     */
    select?: SocietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Society
     */
    omit?: SocietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocietyInclude<ExtArgs> | null
    where?: SocietyWhereInput
  }

  /**
   * Vendor.payouts
   */
  export type Vendor$payoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    where?: VendorPayoutWhereInput
    orderBy?: VendorPayoutOrderByWithRelationInput | VendorPayoutOrderByWithRelationInput[]
    cursor?: VendorPayoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorPayoutScalarFieldEnum | VendorPayoutScalarFieldEnum[]
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model VendorPayout
   */

  export type AggregateVendorPayout = {
    _count: VendorPayoutCountAggregateOutputType | null
    _avg: VendorPayoutAvgAggregateOutputType | null
    _sum: VendorPayoutSumAggregateOutputType | null
    _min: VendorPayoutMinAggregateOutputType | null
    _max: VendorPayoutMaxAggregateOutputType | null
  }

  export type VendorPayoutAvgAggregateOutputType = {
    id: number | null
    vendorId: number | null
    societyId: number | null
    dealValue: number | null
    commissionPercent: number | null
    payableAmount: number | null
  }

  export type VendorPayoutSumAggregateOutputType = {
    id: number | null
    vendorId: number | null
    societyId: number | null
    dealValue: number | null
    commissionPercent: number | null
    payableAmount: number | null
  }

  export type VendorPayoutMinAggregateOutputType = {
    id: number | null
    vendorId: number | null
    vendorName: string | null
    societyId: number | null
    societyName: string | null
    dealValue: number | null
    commissionPercent: number | null
    payableAmount: number | null
    status: string | null
    remarks: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorPayoutMaxAggregateOutputType = {
    id: number | null
    vendorId: number | null
    vendorName: string | null
    societyId: number | null
    societyName: string | null
    dealValue: number | null
    commissionPercent: number | null
    payableAmount: number | null
    status: string | null
    remarks: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorPayoutCountAggregateOutputType = {
    id: number
    vendorId: number
    vendorName: number
    societyId: number
    societyName: number
    dealValue: number
    commissionPercent: number
    payableAmount: number
    status: number
    remarks: number
    date: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorPayoutAvgAggregateInputType = {
    id?: true
    vendorId?: true
    societyId?: true
    dealValue?: true
    commissionPercent?: true
    payableAmount?: true
  }

  export type VendorPayoutSumAggregateInputType = {
    id?: true
    vendorId?: true
    societyId?: true
    dealValue?: true
    commissionPercent?: true
    payableAmount?: true
  }

  export type VendorPayoutMinAggregateInputType = {
    id?: true
    vendorId?: true
    vendorName?: true
    societyId?: true
    societyName?: true
    dealValue?: true
    commissionPercent?: true
    payableAmount?: true
    status?: true
    remarks?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorPayoutMaxAggregateInputType = {
    id?: true
    vendorId?: true
    vendorName?: true
    societyId?: true
    societyName?: true
    dealValue?: true
    commissionPercent?: true
    payableAmount?: true
    status?: true
    remarks?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorPayoutCountAggregateInputType = {
    id?: true
    vendorId?: true
    vendorName?: true
    societyId?: true
    societyName?: true
    dealValue?: true
    commissionPercent?: true
    payableAmount?: true
    status?: true
    remarks?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorPayoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorPayout to aggregate.
     */
    where?: VendorPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorPayouts to fetch.
     */
    orderBy?: VendorPayoutOrderByWithRelationInput | VendorPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorPayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorPayouts
    **/
    _count?: true | VendorPayoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorPayoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorPayoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorPayoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorPayoutMaxAggregateInputType
  }

  export type GetVendorPayoutAggregateType<T extends VendorPayoutAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorPayout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorPayout[P]>
      : GetScalarType<T[P], AggregateVendorPayout[P]>
  }




  export type VendorPayoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorPayoutWhereInput
    orderBy?: VendorPayoutOrderByWithAggregationInput | VendorPayoutOrderByWithAggregationInput[]
    by: VendorPayoutScalarFieldEnum[] | VendorPayoutScalarFieldEnum
    having?: VendorPayoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorPayoutCountAggregateInputType | true
    _avg?: VendorPayoutAvgAggregateInputType
    _sum?: VendorPayoutSumAggregateInputType
    _min?: VendorPayoutMinAggregateInputType
    _max?: VendorPayoutMaxAggregateInputType
  }

  export type VendorPayoutGroupByOutputType = {
    id: number
    vendorId: number
    vendorName: string
    societyId: number | null
    societyName: string | null
    dealValue: number
    commissionPercent: number
    payableAmount: number
    status: string
    remarks: string | null
    date: Date
    createdAt: Date
    updatedAt: Date
    _count: VendorPayoutCountAggregateOutputType | null
    _avg: VendorPayoutAvgAggregateOutputType | null
    _sum: VendorPayoutSumAggregateOutputType | null
    _min: VendorPayoutMinAggregateOutputType | null
    _max: VendorPayoutMaxAggregateOutputType | null
  }

  type GetVendorPayoutGroupByPayload<T extends VendorPayoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorPayoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorPayoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorPayoutGroupByOutputType[P]>
            : GetScalarType<T[P], VendorPayoutGroupByOutputType[P]>
        }
      >
    >


  export type VendorPayoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    vendorName?: boolean
    societyId?: boolean
    societyName?: boolean
    dealValue?: boolean
    commissionPercent?: boolean
    payableAmount?: boolean
    status?: boolean
    remarks?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorPayout"]>



  export type VendorPayoutSelectScalar = {
    id?: boolean
    vendorId?: boolean
    vendorName?: boolean
    societyId?: boolean
    societyName?: boolean
    dealValue?: boolean
    commissionPercent?: boolean
    payableAmount?: boolean
    status?: boolean
    remarks?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorPayoutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendorId" | "vendorName" | "societyId" | "societyName" | "dealValue" | "commissionPercent" | "payableAmount" | "status" | "remarks" | "date" | "createdAt" | "updatedAt", ExtArgs["result"]["vendorPayout"]>
  export type VendorPayoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $VendorPayoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorPayout"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      vendorId: number
      vendorName: string
      societyId: number | null
      societyName: string | null
      dealValue: number
      commissionPercent: number
      payableAmount: number
      status: string
      remarks: string | null
      date: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendorPayout"]>
    composites: {}
  }

  type VendorPayoutGetPayload<S extends boolean | null | undefined | VendorPayoutDefaultArgs> = $Result.GetResult<Prisma.$VendorPayoutPayload, S>

  type VendorPayoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorPayoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorPayoutCountAggregateInputType | true
    }

  export interface VendorPayoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorPayout'], meta: { name: 'VendorPayout' } }
    /**
     * Find zero or one VendorPayout that matches the filter.
     * @param {VendorPayoutFindUniqueArgs} args - Arguments to find a VendorPayout
     * @example
     * // Get one VendorPayout
     * const vendorPayout = await prisma.vendorPayout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorPayoutFindUniqueArgs>(args: SelectSubset<T, VendorPayoutFindUniqueArgs<ExtArgs>>): Prisma__VendorPayoutClient<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorPayout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorPayoutFindUniqueOrThrowArgs} args - Arguments to find a VendorPayout
     * @example
     * // Get one VendorPayout
     * const vendorPayout = await prisma.vendorPayout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorPayoutFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorPayoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorPayoutClient<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorPayout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPayoutFindFirstArgs} args - Arguments to find a VendorPayout
     * @example
     * // Get one VendorPayout
     * const vendorPayout = await prisma.vendorPayout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorPayoutFindFirstArgs>(args?: SelectSubset<T, VendorPayoutFindFirstArgs<ExtArgs>>): Prisma__VendorPayoutClient<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorPayout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPayoutFindFirstOrThrowArgs} args - Arguments to find a VendorPayout
     * @example
     * // Get one VendorPayout
     * const vendorPayout = await prisma.vendorPayout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorPayoutFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorPayoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorPayoutClient<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorPayouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPayoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorPayouts
     * const vendorPayouts = await prisma.vendorPayout.findMany()
     * 
     * // Get first 10 VendorPayouts
     * const vendorPayouts = await prisma.vendorPayout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorPayoutWithIdOnly = await prisma.vendorPayout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorPayoutFindManyArgs>(args?: SelectSubset<T, VendorPayoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorPayout.
     * @param {VendorPayoutCreateArgs} args - Arguments to create a VendorPayout.
     * @example
     * // Create one VendorPayout
     * const VendorPayout = await prisma.vendorPayout.create({
     *   data: {
     *     // ... data to create a VendorPayout
     *   }
     * })
     * 
     */
    create<T extends VendorPayoutCreateArgs>(args: SelectSubset<T, VendorPayoutCreateArgs<ExtArgs>>): Prisma__VendorPayoutClient<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorPayouts.
     * @param {VendorPayoutCreateManyArgs} args - Arguments to create many VendorPayouts.
     * @example
     * // Create many VendorPayouts
     * const vendorPayout = await prisma.vendorPayout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorPayoutCreateManyArgs>(args?: SelectSubset<T, VendorPayoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VendorPayout.
     * @param {VendorPayoutDeleteArgs} args - Arguments to delete one VendorPayout.
     * @example
     * // Delete one VendorPayout
     * const VendorPayout = await prisma.vendorPayout.delete({
     *   where: {
     *     // ... filter to delete one VendorPayout
     *   }
     * })
     * 
     */
    delete<T extends VendorPayoutDeleteArgs>(args: SelectSubset<T, VendorPayoutDeleteArgs<ExtArgs>>): Prisma__VendorPayoutClient<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorPayout.
     * @param {VendorPayoutUpdateArgs} args - Arguments to update one VendorPayout.
     * @example
     * // Update one VendorPayout
     * const vendorPayout = await prisma.vendorPayout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorPayoutUpdateArgs>(args: SelectSubset<T, VendorPayoutUpdateArgs<ExtArgs>>): Prisma__VendorPayoutClient<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorPayouts.
     * @param {VendorPayoutDeleteManyArgs} args - Arguments to filter VendorPayouts to delete.
     * @example
     * // Delete a few VendorPayouts
     * const { count } = await prisma.vendorPayout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorPayoutDeleteManyArgs>(args?: SelectSubset<T, VendorPayoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorPayouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPayoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorPayouts
     * const vendorPayout = await prisma.vendorPayout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorPayoutUpdateManyArgs>(args: SelectSubset<T, VendorPayoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VendorPayout.
     * @param {VendorPayoutUpsertArgs} args - Arguments to update or create a VendorPayout.
     * @example
     * // Update or create a VendorPayout
     * const vendorPayout = await prisma.vendorPayout.upsert({
     *   create: {
     *     // ... data to create a VendorPayout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorPayout we want to update
     *   }
     * })
     */
    upsert<T extends VendorPayoutUpsertArgs>(args: SelectSubset<T, VendorPayoutUpsertArgs<ExtArgs>>): Prisma__VendorPayoutClient<$Result.GetResult<Prisma.$VendorPayoutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorPayouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPayoutCountArgs} args - Arguments to filter VendorPayouts to count.
     * @example
     * // Count the number of VendorPayouts
     * const count = await prisma.vendorPayout.count({
     *   where: {
     *     // ... the filter for the VendorPayouts we want to count
     *   }
     * })
    **/
    count<T extends VendorPayoutCountArgs>(
      args?: Subset<T, VendorPayoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorPayoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorPayout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPayoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorPayoutAggregateArgs>(args: Subset<T, VendorPayoutAggregateArgs>): Prisma.PrismaPromise<GetVendorPayoutAggregateType<T>>

    /**
     * Group by VendorPayout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPayoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorPayoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorPayoutGroupByArgs['orderBy'] }
        : { orderBy?: VendorPayoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorPayoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorPayoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorPayout model
   */
  readonly fields: VendorPayoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorPayout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorPayoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorPayout model
   */
  interface VendorPayoutFieldRefs {
    readonly id: FieldRef<"VendorPayout", 'Int'>
    readonly vendorId: FieldRef<"VendorPayout", 'Int'>
    readonly vendorName: FieldRef<"VendorPayout", 'String'>
    readonly societyId: FieldRef<"VendorPayout", 'Int'>
    readonly societyName: FieldRef<"VendorPayout", 'String'>
    readonly dealValue: FieldRef<"VendorPayout", 'Float'>
    readonly commissionPercent: FieldRef<"VendorPayout", 'Float'>
    readonly payableAmount: FieldRef<"VendorPayout", 'Float'>
    readonly status: FieldRef<"VendorPayout", 'String'>
    readonly remarks: FieldRef<"VendorPayout", 'String'>
    readonly date: FieldRef<"VendorPayout", 'DateTime'>
    readonly createdAt: FieldRef<"VendorPayout", 'DateTime'>
    readonly updatedAt: FieldRef<"VendorPayout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorPayout findUnique
   */
  export type VendorPayoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * Filter, which VendorPayout to fetch.
     */
    where: VendorPayoutWhereUniqueInput
  }

  /**
   * VendorPayout findUniqueOrThrow
   */
  export type VendorPayoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * Filter, which VendorPayout to fetch.
     */
    where: VendorPayoutWhereUniqueInput
  }

  /**
   * VendorPayout findFirst
   */
  export type VendorPayoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * Filter, which VendorPayout to fetch.
     */
    where?: VendorPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorPayouts to fetch.
     */
    orderBy?: VendorPayoutOrderByWithRelationInput | VendorPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorPayouts.
     */
    cursor?: VendorPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorPayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorPayouts.
     */
    distinct?: VendorPayoutScalarFieldEnum | VendorPayoutScalarFieldEnum[]
  }

  /**
   * VendorPayout findFirstOrThrow
   */
  export type VendorPayoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * Filter, which VendorPayout to fetch.
     */
    where?: VendorPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorPayouts to fetch.
     */
    orderBy?: VendorPayoutOrderByWithRelationInput | VendorPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorPayouts.
     */
    cursor?: VendorPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorPayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorPayouts.
     */
    distinct?: VendorPayoutScalarFieldEnum | VendorPayoutScalarFieldEnum[]
  }

  /**
   * VendorPayout findMany
   */
  export type VendorPayoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * Filter, which VendorPayouts to fetch.
     */
    where?: VendorPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorPayouts to fetch.
     */
    orderBy?: VendorPayoutOrderByWithRelationInput | VendorPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorPayouts.
     */
    cursor?: VendorPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorPayouts.
     */
    skip?: number
    distinct?: VendorPayoutScalarFieldEnum | VendorPayoutScalarFieldEnum[]
  }

  /**
   * VendorPayout create
   */
  export type VendorPayoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorPayout.
     */
    data: XOR<VendorPayoutCreateInput, VendorPayoutUncheckedCreateInput>
  }

  /**
   * VendorPayout createMany
   */
  export type VendorPayoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorPayouts.
     */
    data: VendorPayoutCreateManyInput | VendorPayoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorPayout update
   */
  export type VendorPayoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorPayout.
     */
    data: XOR<VendorPayoutUpdateInput, VendorPayoutUncheckedUpdateInput>
    /**
     * Choose, which VendorPayout to update.
     */
    where: VendorPayoutWhereUniqueInput
  }

  /**
   * VendorPayout updateMany
   */
  export type VendorPayoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorPayouts.
     */
    data: XOR<VendorPayoutUpdateManyMutationInput, VendorPayoutUncheckedUpdateManyInput>
    /**
     * Filter which VendorPayouts to update
     */
    where?: VendorPayoutWhereInput
    /**
     * Limit how many VendorPayouts to update.
     */
    limit?: number
  }

  /**
   * VendorPayout upsert
   */
  export type VendorPayoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorPayout to update in case it exists.
     */
    where: VendorPayoutWhereUniqueInput
    /**
     * In case the VendorPayout found by the `where` argument doesn't exist, create a new VendorPayout with this data.
     */
    create: XOR<VendorPayoutCreateInput, VendorPayoutUncheckedCreateInput>
    /**
     * In case the VendorPayout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorPayoutUpdateInput, VendorPayoutUncheckedUpdateInput>
  }

  /**
   * VendorPayout delete
   */
  export type VendorPayoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
    /**
     * Filter which VendorPayout to delete.
     */
    where: VendorPayoutWhereUniqueInput
  }

  /**
   * VendorPayout deleteMany
   */
  export type VendorPayoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorPayouts to delete
     */
    where?: VendorPayoutWhereInput
    /**
     * Limit how many VendorPayouts to delete.
     */
    limit?: number
  }

  /**
   * VendorPayout without action
   */
  export type VendorPayoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayout
     */
    select?: VendorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayout
     */
    omit?: VendorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPayoutInclude<ExtArgs> | null
  }


  /**
   * Model ServiceCategory
   */

  export type AggregateServiceCategory = {
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  export type ServiceCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
  }

  export type ServiceCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
  }

  export type ServiceCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    icon: number
    color: number
    _all: number
  }


  export type ServiceCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    color?: true
  }

  export type ServiceCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    color?: true
  }

  export type ServiceCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    _all?: true
  }

  export type ServiceCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategory to aggregate.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceCategories
    **/
    _count?: true | ServiceCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type GetServiceCategoryAggregateType<T extends ServiceCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCategory[P]>
      : GetScalarType<T[P], AggregateServiceCategory[P]>
  }




  export type ServiceCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCategoryWhereInput
    orderBy?: ServiceCategoryOrderByWithAggregationInput | ServiceCategoryOrderByWithAggregationInput[]
    by: ServiceCategoryScalarFieldEnum[] | ServiceCategoryScalarFieldEnum
    having?: ServiceCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCategoryCountAggregateInputType | true
    _min?: ServiceCategoryMinAggregateInputType
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type ServiceCategoryGroupByOutputType = {
    id: string
    name: string
    description: string
    icon: string
    color: string
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  type GetServiceCategoryGroupByPayload<T extends ServiceCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ServiceCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    variants?: boolean | ServiceCategory$variantsArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCategory"]>



  export type ServiceCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
  }

  export type ServiceCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "icon" | "color", ExtArgs["result"]["serviceCategory"]>
  export type ServiceCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | ServiceCategory$variantsArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServiceCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceCategory"
    objects: {
      variants: Prisma.$ServiceVariantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      icon: string
      color: string
    }, ExtArgs["result"]["serviceCategory"]>
    composites: {}
  }

  type ServiceCategoryGetPayload<S extends boolean | null | undefined | ServiceCategoryDefaultArgs> = $Result.GetResult<Prisma.$ServiceCategoryPayload, S>

  type ServiceCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCategoryCountAggregateInputType | true
    }

  export interface ServiceCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceCategory'], meta: { name: 'ServiceCategory' } }
    /**
     * Find zero or one ServiceCategory that matches the filter.
     * @param {ServiceCategoryFindUniqueArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceCategoryFindUniqueArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceCategoryFindUniqueOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceCategoryFindFirstArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany()
     * 
     * // Get first 10 ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceCategoryFindManyArgs>(args?: SelectSubset<T, ServiceCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceCategory.
     * @param {ServiceCategoryCreateArgs} args - Arguments to create a ServiceCategory.
     * @example
     * // Create one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.create({
     *   data: {
     *     // ... data to create a ServiceCategory
     *   }
     * })
     * 
     */
    create<T extends ServiceCategoryCreateArgs>(args: SelectSubset<T, ServiceCategoryCreateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceCategories.
     * @param {ServiceCategoryCreateManyArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCategoryCreateManyArgs>(args?: SelectSubset<T, ServiceCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceCategory.
     * @param {ServiceCategoryDeleteArgs} args - Arguments to delete one ServiceCategory.
     * @example
     * // Delete one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.delete({
     *   where: {
     *     // ... filter to delete one ServiceCategory
     *   }
     * })
     * 
     */
    delete<T extends ServiceCategoryDeleteArgs>(args: SelectSubset<T, ServiceCategoryDeleteArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceCategory.
     * @param {ServiceCategoryUpdateArgs} args - Arguments to update one ServiceCategory.
     * @example
     * // Update one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceCategoryUpdateArgs>(args: SelectSubset<T, ServiceCategoryUpdateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceCategories.
     * @param {ServiceCategoryDeleteManyArgs} args - Arguments to filter ServiceCategories to delete.
     * @example
     * // Delete a few ServiceCategories
     * const { count } = await prisma.serviceCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceCategoryDeleteManyArgs>(args?: SelectSubset<T, ServiceCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceCategoryUpdateManyArgs>(args: SelectSubset<T, ServiceCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceCategory.
     * @param {ServiceCategoryUpsertArgs} args - Arguments to update or create a ServiceCategory.
     * @example
     * // Update or create a ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.upsert({
     *   create: {
     *     // ... data to create a ServiceCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCategory we want to update
     *   }
     * })
     */
    upsert<T extends ServiceCategoryUpsertArgs>(args: SelectSubset<T, ServiceCategoryUpsertArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryCountArgs} args - Arguments to filter ServiceCategories to count.
     * @example
     * // Count the number of ServiceCategories
     * const count = await prisma.serviceCategory.count({
     *   where: {
     *     // ... the filter for the ServiceCategories we want to count
     *   }
     * })
    **/
    count<T extends ServiceCategoryCountArgs>(
      args?: Subset<T, ServiceCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCategoryAggregateArgs>(args: Subset<T, ServiceCategoryAggregateArgs>): Prisma.PrismaPromise<GetServiceCategoryAggregateType<T>>

    /**
     * Group by ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ServiceCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceCategory model
   */
  readonly fields: ServiceCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variants<T extends ServiceCategory$variantsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategory$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceCategory model
   */
  interface ServiceCategoryFieldRefs {
    readonly id: FieldRef<"ServiceCategory", 'String'>
    readonly name: FieldRef<"ServiceCategory", 'String'>
    readonly description: FieldRef<"ServiceCategory", 'String'>
    readonly icon: FieldRef<"ServiceCategory", 'String'>
    readonly color: FieldRef<"ServiceCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceCategory findUnique
   */
  export type ServiceCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findUniqueOrThrow
   */
  export type ServiceCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findFirst
   */
  export type ServiceCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findFirstOrThrow
   */
  export type ServiceCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findMany
   */
  export type ServiceCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategories to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory create
   */
  export type ServiceCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceCategory.
     */
    data: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
  }

  /**
   * ServiceCategory createMany
   */
  export type ServiceCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceCategories.
     */
    data: ServiceCategoryCreateManyInput | ServiceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCategory update
   */
  export type ServiceCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceCategory.
     */
    data: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
    /**
     * Choose, which ServiceCategory to update.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory updateMany
   */
  export type ServiceCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceCategories.
     */
    data: XOR<ServiceCategoryUpdateManyMutationInput, ServiceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategories to update
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to update.
     */
    limit?: number
  }

  /**
   * ServiceCategory upsert
   */
  export type ServiceCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceCategory to update in case it exists.
     */
    where: ServiceCategoryWhereUniqueInput
    /**
     * In case the ServiceCategory found by the `where` argument doesn't exist, create a new ServiceCategory with this data.
     */
    create: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
    /**
     * In case the ServiceCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
  }

  /**
   * ServiceCategory delete
   */
  export type ServiceCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter which ServiceCategory to delete.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory deleteMany
   */
  export type ServiceCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategories to delete
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to delete.
     */
    limit?: number
  }

  /**
   * ServiceCategory.variants
   */
  export type ServiceCategory$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    where?: ServiceVariantWhereInput
    orderBy?: ServiceVariantOrderByWithRelationInput | ServiceVariantOrderByWithRelationInput[]
    cursor?: ServiceVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceVariantScalarFieldEnum | ServiceVariantScalarFieldEnum[]
  }

  /**
   * ServiceCategory without action
   */
  export type ServiceCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ServiceVariant
   */

  export type AggregateServiceVariant = {
    _count: ServiceVariantCountAggregateOutputType | null
    _min: ServiceVariantMinAggregateOutputType | null
    _max: ServiceVariantMaxAggregateOutputType | null
  }

  export type ServiceVariantMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: string | null
    description: string | null
    categoryId: string | null
  }

  export type ServiceVariantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: string | null
    description: string | null
    categoryId: string | null
  }

  export type ServiceVariantCountAggregateOutputType = {
    id: number
    name: number
    price: number
    description: number
    categoryId: number
    _all: number
  }


  export type ServiceVariantMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    description?: true
    categoryId?: true
  }

  export type ServiceVariantMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    description?: true
    categoryId?: true
  }

  export type ServiceVariantCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    description?: true
    categoryId?: true
    _all?: true
  }

  export type ServiceVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceVariant to aggregate.
     */
    where?: ServiceVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceVariants to fetch.
     */
    orderBy?: ServiceVariantOrderByWithRelationInput | ServiceVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceVariants
    **/
    _count?: true | ServiceVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceVariantMaxAggregateInputType
  }

  export type GetServiceVariantAggregateType<T extends ServiceVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceVariant[P]>
      : GetScalarType<T[P], AggregateServiceVariant[P]>
  }




  export type ServiceVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceVariantWhereInput
    orderBy?: ServiceVariantOrderByWithAggregationInput | ServiceVariantOrderByWithAggregationInput[]
    by: ServiceVariantScalarFieldEnum[] | ServiceVariantScalarFieldEnum
    having?: ServiceVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceVariantCountAggregateInputType | true
    _min?: ServiceVariantMinAggregateInputType
    _max?: ServiceVariantMaxAggregateInputType
  }

  export type ServiceVariantGroupByOutputType = {
    id: string
    name: string
    price: string
    description: string | null
    categoryId: string
    _count: ServiceVariantCountAggregateOutputType | null
    _min: ServiceVariantMinAggregateOutputType | null
    _max: ServiceVariantMaxAggregateOutputType | null
  }

  type GetServiceVariantGroupByPayload<T extends ServiceVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceVariantGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceVariantGroupByOutputType[P]>
        }
      >
    >


  export type ServiceVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    categoryId?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceVariant"]>



  export type ServiceVariantSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    categoryId?: boolean
  }

  export type ServiceVariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "description" | "categoryId", ExtArgs["result"]["serviceVariant"]>
  export type ServiceVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }

  export type $ServiceVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceVariant"
    objects: {
      category: Prisma.$ServiceCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: string
      description: string | null
      categoryId: string
    }, ExtArgs["result"]["serviceVariant"]>
    composites: {}
  }

  type ServiceVariantGetPayload<S extends boolean | null | undefined | ServiceVariantDefaultArgs> = $Result.GetResult<Prisma.$ServiceVariantPayload, S>

  type ServiceVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceVariantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceVariantCountAggregateInputType | true
    }

  export interface ServiceVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceVariant'], meta: { name: 'ServiceVariant' } }
    /**
     * Find zero or one ServiceVariant that matches the filter.
     * @param {ServiceVariantFindUniqueArgs} args - Arguments to find a ServiceVariant
     * @example
     * // Get one ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceVariantFindUniqueArgs>(args: SelectSubset<T, ServiceVariantFindUniqueArgs<ExtArgs>>): Prisma__ServiceVariantClient<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceVariantFindUniqueOrThrowArgs} args - Arguments to find a ServiceVariant
     * @example
     * // Get one ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceVariantClient<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantFindFirstArgs} args - Arguments to find a ServiceVariant
     * @example
     * // Get one ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceVariantFindFirstArgs>(args?: SelectSubset<T, ServiceVariantFindFirstArgs<ExtArgs>>): Prisma__ServiceVariantClient<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantFindFirstOrThrowArgs} args - Arguments to find a ServiceVariant
     * @example
     * // Get one ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceVariantClient<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceVariants
     * const serviceVariants = await prisma.serviceVariant.findMany()
     * 
     * // Get first 10 ServiceVariants
     * const serviceVariants = await prisma.serviceVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceVariantWithIdOnly = await prisma.serviceVariant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceVariantFindManyArgs>(args?: SelectSubset<T, ServiceVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceVariant.
     * @param {ServiceVariantCreateArgs} args - Arguments to create a ServiceVariant.
     * @example
     * // Create one ServiceVariant
     * const ServiceVariant = await prisma.serviceVariant.create({
     *   data: {
     *     // ... data to create a ServiceVariant
     *   }
     * })
     * 
     */
    create<T extends ServiceVariantCreateArgs>(args: SelectSubset<T, ServiceVariantCreateArgs<ExtArgs>>): Prisma__ServiceVariantClient<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceVariants.
     * @param {ServiceVariantCreateManyArgs} args - Arguments to create many ServiceVariants.
     * @example
     * // Create many ServiceVariants
     * const serviceVariant = await prisma.serviceVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceVariantCreateManyArgs>(args?: SelectSubset<T, ServiceVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceVariant.
     * @param {ServiceVariantDeleteArgs} args - Arguments to delete one ServiceVariant.
     * @example
     * // Delete one ServiceVariant
     * const ServiceVariant = await prisma.serviceVariant.delete({
     *   where: {
     *     // ... filter to delete one ServiceVariant
     *   }
     * })
     * 
     */
    delete<T extends ServiceVariantDeleteArgs>(args: SelectSubset<T, ServiceVariantDeleteArgs<ExtArgs>>): Prisma__ServiceVariantClient<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceVariant.
     * @param {ServiceVariantUpdateArgs} args - Arguments to update one ServiceVariant.
     * @example
     * // Update one ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceVariantUpdateArgs>(args: SelectSubset<T, ServiceVariantUpdateArgs<ExtArgs>>): Prisma__ServiceVariantClient<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceVariants.
     * @param {ServiceVariantDeleteManyArgs} args - Arguments to filter ServiceVariants to delete.
     * @example
     * // Delete a few ServiceVariants
     * const { count } = await prisma.serviceVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceVariantDeleteManyArgs>(args?: SelectSubset<T, ServiceVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceVariants
     * const serviceVariant = await prisma.serviceVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceVariantUpdateManyArgs>(args: SelectSubset<T, ServiceVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceVariant.
     * @param {ServiceVariantUpsertArgs} args - Arguments to update or create a ServiceVariant.
     * @example
     * // Update or create a ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.upsert({
     *   create: {
     *     // ... data to create a ServiceVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceVariant we want to update
     *   }
     * })
     */
    upsert<T extends ServiceVariantUpsertArgs>(args: SelectSubset<T, ServiceVariantUpsertArgs<ExtArgs>>): Prisma__ServiceVariantClient<$Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantCountArgs} args - Arguments to filter ServiceVariants to count.
     * @example
     * // Count the number of ServiceVariants
     * const count = await prisma.serviceVariant.count({
     *   where: {
     *     // ... the filter for the ServiceVariants we want to count
     *   }
     * })
    **/
    count<T extends ServiceVariantCountArgs>(
      args?: Subset<T, ServiceVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceVariantAggregateArgs>(args: Subset<T, ServiceVariantAggregateArgs>): Prisma.PrismaPromise<GetServiceVariantAggregateType<T>>

    /**
     * Group by ServiceVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceVariantGroupByArgs['orderBy'] }
        : { orderBy?: ServiceVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceVariant model
   */
  readonly fields: ServiceVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends ServiceCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategoryDefaultArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceVariant model
   */
  interface ServiceVariantFieldRefs {
    readonly id: FieldRef<"ServiceVariant", 'String'>
    readonly name: FieldRef<"ServiceVariant", 'String'>
    readonly price: FieldRef<"ServiceVariant", 'String'>
    readonly description: FieldRef<"ServiceVariant", 'String'>
    readonly categoryId: FieldRef<"ServiceVariant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceVariant findUnique
   */
  export type ServiceVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * Filter, which ServiceVariant to fetch.
     */
    where: ServiceVariantWhereUniqueInput
  }

  /**
   * ServiceVariant findUniqueOrThrow
   */
  export type ServiceVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * Filter, which ServiceVariant to fetch.
     */
    where: ServiceVariantWhereUniqueInput
  }

  /**
   * ServiceVariant findFirst
   */
  export type ServiceVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * Filter, which ServiceVariant to fetch.
     */
    where?: ServiceVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceVariants to fetch.
     */
    orderBy?: ServiceVariantOrderByWithRelationInput | ServiceVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceVariants.
     */
    cursor?: ServiceVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceVariants.
     */
    distinct?: ServiceVariantScalarFieldEnum | ServiceVariantScalarFieldEnum[]
  }

  /**
   * ServiceVariant findFirstOrThrow
   */
  export type ServiceVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * Filter, which ServiceVariant to fetch.
     */
    where?: ServiceVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceVariants to fetch.
     */
    orderBy?: ServiceVariantOrderByWithRelationInput | ServiceVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceVariants.
     */
    cursor?: ServiceVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceVariants.
     */
    distinct?: ServiceVariantScalarFieldEnum | ServiceVariantScalarFieldEnum[]
  }

  /**
   * ServiceVariant findMany
   */
  export type ServiceVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * Filter, which ServiceVariants to fetch.
     */
    where?: ServiceVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceVariants to fetch.
     */
    orderBy?: ServiceVariantOrderByWithRelationInput | ServiceVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceVariants.
     */
    cursor?: ServiceVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceVariants.
     */
    skip?: number
    distinct?: ServiceVariantScalarFieldEnum | ServiceVariantScalarFieldEnum[]
  }

  /**
   * ServiceVariant create
   */
  export type ServiceVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceVariant.
     */
    data: XOR<ServiceVariantCreateInput, ServiceVariantUncheckedCreateInput>
  }

  /**
   * ServiceVariant createMany
   */
  export type ServiceVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceVariants.
     */
    data: ServiceVariantCreateManyInput | ServiceVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceVariant update
   */
  export type ServiceVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceVariant.
     */
    data: XOR<ServiceVariantUpdateInput, ServiceVariantUncheckedUpdateInput>
    /**
     * Choose, which ServiceVariant to update.
     */
    where: ServiceVariantWhereUniqueInput
  }

  /**
   * ServiceVariant updateMany
   */
  export type ServiceVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceVariants.
     */
    data: XOR<ServiceVariantUpdateManyMutationInput, ServiceVariantUncheckedUpdateManyInput>
    /**
     * Filter which ServiceVariants to update
     */
    where?: ServiceVariantWhereInput
    /**
     * Limit how many ServiceVariants to update.
     */
    limit?: number
  }

  /**
   * ServiceVariant upsert
   */
  export type ServiceVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceVariant to update in case it exists.
     */
    where: ServiceVariantWhereUniqueInput
    /**
     * In case the ServiceVariant found by the `where` argument doesn't exist, create a new ServiceVariant with this data.
     */
    create: XOR<ServiceVariantCreateInput, ServiceVariantUncheckedCreateInput>
    /**
     * In case the ServiceVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceVariantUpdateInput, ServiceVariantUncheckedUpdateInput>
  }

  /**
   * ServiceVariant delete
   */
  export type ServiceVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
    /**
     * Filter which ServiceVariant to delete.
     */
    where: ServiceVariantWhereUniqueInput
  }

  /**
   * ServiceVariant deleteMany
   */
  export type ServiceVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceVariants to delete
     */
    where?: ServiceVariantWhereInput
    /**
     * Limit how many ServiceVariants to delete.
     */
    limit?: number
  }

  /**
   * ServiceVariant without action
   */
  export type ServiceVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceVariant
     */
    omit?: ServiceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null
  }


  /**
   * Model ServiceInquiry
   */

  export type AggregateServiceInquiry = {
    _count: ServiceInquiryCountAggregateOutputType | null
    _avg: ServiceInquiryAvgAggregateOutputType | null
    _sum: ServiceInquirySumAggregateOutputType | null
    _min: ServiceInquiryMinAggregateOutputType | null
    _max: ServiceInquiryMaxAggregateOutputType | null
  }

  export type ServiceInquiryAvgAggregateOutputType = {
    societyId: number | null
  }

  export type ServiceInquirySumAggregateOutputType = {
    societyId: number | null
  }

  export type ServiceInquiryMinAggregateOutputType = {
    id: string | null
    residentName: string | null
    unit: string | null
    serviceName: string | null
    serviceId: string | null
    status: string | null
    vendorName: string | null
    vendorId: string | null
    source: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
    societyId: number | null
  }

  export type ServiceInquiryMaxAggregateOutputType = {
    id: string | null
    residentName: string | null
    unit: string | null
    serviceName: string | null
    serviceId: string | null
    status: string | null
    vendorName: string | null
    vendorId: string | null
    source: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
    societyId: number | null
  }

  export type ServiceInquiryCountAggregateOutputType = {
    id: number
    residentName: number
    unit: number
    serviceName: number
    serviceId: number
    status: number
    vendorName: number
    vendorId: number
    source: number
    type: number
    createdAt: number
    updatedAt: number
    societyId: number
    _all: number
  }


  export type ServiceInquiryAvgAggregateInputType = {
    societyId?: true
  }

  export type ServiceInquirySumAggregateInputType = {
    societyId?: true
  }

  export type ServiceInquiryMinAggregateInputType = {
    id?: true
    residentName?: true
    unit?: true
    serviceName?: true
    serviceId?: true
    status?: true
    vendorName?: true
    vendorId?: true
    source?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    societyId?: true
  }

  export type ServiceInquiryMaxAggregateInputType = {
    id?: true
    residentName?: true
    unit?: true
    serviceName?: true
    serviceId?: true
    status?: true
    vendorName?: true
    vendorId?: true
    source?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    societyId?: true
  }

  export type ServiceInquiryCountAggregateInputType = {
    id?: true
    residentName?: true
    unit?: true
    serviceName?: true
    serviceId?: true
    status?: true
    vendorName?: true
    vendorId?: true
    source?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    societyId?: true
    _all?: true
  }

  export type ServiceInquiryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceInquiry to aggregate.
     */
    where?: ServiceInquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInquiries to fetch.
     */
    orderBy?: ServiceInquiryOrderByWithRelationInput | ServiceInquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceInquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceInquiries
    **/
    _count?: true | ServiceInquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceInquiryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceInquirySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceInquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceInquiryMaxAggregateInputType
  }

  export type GetServiceInquiryAggregateType<T extends ServiceInquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceInquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceInquiry[P]>
      : GetScalarType<T[P], AggregateServiceInquiry[P]>
  }




  export type ServiceInquiryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceInquiryWhereInput
    orderBy?: ServiceInquiryOrderByWithAggregationInput | ServiceInquiryOrderByWithAggregationInput[]
    by: ServiceInquiryScalarFieldEnum[] | ServiceInquiryScalarFieldEnum
    having?: ServiceInquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceInquiryCountAggregateInputType | true
    _avg?: ServiceInquiryAvgAggregateInputType
    _sum?: ServiceInquirySumAggregateInputType
    _min?: ServiceInquiryMinAggregateInputType
    _max?: ServiceInquiryMaxAggregateInputType
  }

  export type ServiceInquiryGroupByOutputType = {
    id: string
    residentName: string
    unit: string
    serviceName: string
    serviceId: string
    status: string
    vendorName: string | null
    vendorId: string | null
    source: string | null
    type: string | null
    createdAt: Date
    updatedAt: Date
    societyId: number | null
    _count: ServiceInquiryCountAggregateOutputType | null
    _avg: ServiceInquiryAvgAggregateOutputType | null
    _sum: ServiceInquirySumAggregateOutputType | null
    _min: ServiceInquiryMinAggregateOutputType | null
    _max: ServiceInquiryMaxAggregateOutputType | null
  }

  type GetServiceInquiryGroupByPayload<T extends ServiceInquiryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceInquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceInquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceInquiryGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceInquiryGroupByOutputType[P]>
        }
      >
    >


  export type ServiceInquirySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    residentName?: boolean
    unit?: boolean
    serviceName?: boolean
    serviceId?: boolean
    status?: boolean
    vendorName?: boolean
    vendorId?: boolean
    source?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    societyId?: boolean
  }, ExtArgs["result"]["serviceInquiry"]>



  export type ServiceInquirySelectScalar = {
    id?: boolean
    residentName?: boolean
    unit?: boolean
    serviceName?: boolean
    serviceId?: boolean
    status?: boolean
    vendorName?: boolean
    vendorId?: boolean
    source?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    societyId?: boolean
  }

  export type ServiceInquiryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "residentName" | "unit" | "serviceName" | "serviceId" | "status" | "vendorName" | "vendorId" | "source" | "type" | "createdAt" | "updatedAt" | "societyId", ExtArgs["result"]["serviceInquiry"]>

  export type $ServiceInquiryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceInquiry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      residentName: string
      unit: string
      serviceName: string
      serviceId: string
      status: string
      vendorName: string | null
      vendorId: string | null
      source: string | null
      type: string | null
      createdAt: Date
      updatedAt: Date
      societyId: number | null
    }, ExtArgs["result"]["serviceInquiry"]>
    composites: {}
  }

  type ServiceInquiryGetPayload<S extends boolean | null | undefined | ServiceInquiryDefaultArgs> = $Result.GetResult<Prisma.$ServiceInquiryPayload, S>

  type ServiceInquiryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceInquiryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceInquiryCountAggregateInputType | true
    }

  export interface ServiceInquiryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceInquiry'], meta: { name: 'ServiceInquiry' } }
    /**
     * Find zero or one ServiceInquiry that matches the filter.
     * @param {ServiceInquiryFindUniqueArgs} args - Arguments to find a ServiceInquiry
     * @example
     * // Get one ServiceInquiry
     * const serviceInquiry = await prisma.serviceInquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceInquiryFindUniqueArgs>(args: SelectSubset<T, ServiceInquiryFindUniqueArgs<ExtArgs>>): Prisma__ServiceInquiryClient<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceInquiry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceInquiryFindUniqueOrThrowArgs} args - Arguments to find a ServiceInquiry
     * @example
     * // Get one ServiceInquiry
     * const serviceInquiry = await prisma.serviceInquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceInquiryFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceInquiryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceInquiryClient<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceInquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInquiryFindFirstArgs} args - Arguments to find a ServiceInquiry
     * @example
     * // Get one ServiceInquiry
     * const serviceInquiry = await prisma.serviceInquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceInquiryFindFirstArgs>(args?: SelectSubset<T, ServiceInquiryFindFirstArgs<ExtArgs>>): Prisma__ServiceInquiryClient<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceInquiry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInquiryFindFirstOrThrowArgs} args - Arguments to find a ServiceInquiry
     * @example
     * // Get one ServiceInquiry
     * const serviceInquiry = await prisma.serviceInquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceInquiryFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceInquiryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceInquiryClient<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceInquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInquiryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceInquiries
     * const serviceInquiries = await prisma.serviceInquiry.findMany()
     * 
     * // Get first 10 ServiceInquiries
     * const serviceInquiries = await prisma.serviceInquiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceInquiryWithIdOnly = await prisma.serviceInquiry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceInquiryFindManyArgs>(args?: SelectSubset<T, ServiceInquiryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceInquiry.
     * @param {ServiceInquiryCreateArgs} args - Arguments to create a ServiceInquiry.
     * @example
     * // Create one ServiceInquiry
     * const ServiceInquiry = await prisma.serviceInquiry.create({
     *   data: {
     *     // ... data to create a ServiceInquiry
     *   }
     * })
     * 
     */
    create<T extends ServiceInquiryCreateArgs>(args: SelectSubset<T, ServiceInquiryCreateArgs<ExtArgs>>): Prisma__ServiceInquiryClient<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceInquiries.
     * @param {ServiceInquiryCreateManyArgs} args - Arguments to create many ServiceInquiries.
     * @example
     * // Create many ServiceInquiries
     * const serviceInquiry = await prisma.serviceInquiry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceInquiryCreateManyArgs>(args?: SelectSubset<T, ServiceInquiryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceInquiry.
     * @param {ServiceInquiryDeleteArgs} args - Arguments to delete one ServiceInquiry.
     * @example
     * // Delete one ServiceInquiry
     * const ServiceInquiry = await prisma.serviceInquiry.delete({
     *   where: {
     *     // ... filter to delete one ServiceInquiry
     *   }
     * })
     * 
     */
    delete<T extends ServiceInquiryDeleteArgs>(args: SelectSubset<T, ServiceInquiryDeleteArgs<ExtArgs>>): Prisma__ServiceInquiryClient<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceInquiry.
     * @param {ServiceInquiryUpdateArgs} args - Arguments to update one ServiceInquiry.
     * @example
     * // Update one ServiceInquiry
     * const serviceInquiry = await prisma.serviceInquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceInquiryUpdateArgs>(args: SelectSubset<T, ServiceInquiryUpdateArgs<ExtArgs>>): Prisma__ServiceInquiryClient<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceInquiries.
     * @param {ServiceInquiryDeleteManyArgs} args - Arguments to filter ServiceInquiries to delete.
     * @example
     * // Delete a few ServiceInquiries
     * const { count } = await prisma.serviceInquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceInquiryDeleteManyArgs>(args?: SelectSubset<T, ServiceInquiryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceInquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceInquiries
     * const serviceInquiry = await prisma.serviceInquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceInquiryUpdateManyArgs>(args: SelectSubset<T, ServiceInquiryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceInquiry.
     * @param {ServiceInquiryUpsertArgs} args - Arguments to update or create a ServiceInquiry.
     * @example
     * // Update or create a ServiceInquiry
     * const serviceInquiry = await prisma.serviceInquiry.upsert({
     *   create: {
     *     // ... data to create a ServiceInquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceInquiry we want to update
     *   }
     * })
     */
    upsert<T extends ServiceInquiryUpsertArgs>(args: SelectSubset<T, ServiceInquiryUpsertArgs<ExtArgs>>): Prisma__ServiceInquiryClient<$Result.GetResult<Prisma.$ServiceInquiryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceInquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInquiryCountArgs} args - Arguments to filter ServiceInquiries to count.
     * @example
     * // Count the number of ServiceInquiries
     * const count = await prisma.serviceInquiry.count({
     *   where: {
     *     // ... the filter for the ServiceInquiries we want to count
     *   }
     * })
    **/
    count<T extends ServiceInquiryCountArgs>(
      args?: Subset<T, ServiceInquiryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceInquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceInquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceInquiryAggregateArgs>(args: Subset<T, ServiceInquiryAggregateArgs>): Prisma.PrismaPromise<GetServiceInquiryAggregateType<T>>

    /**
     * Group by ServiceInquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceInquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceInquiryGroupByArgs['orderBy'] }
        : { orderBy?: ServiceInquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceInquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceInquiryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceInquiry model
   */
  readonly fields: ServiceInquiryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceInquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceInquiryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceInquiry model
   */
  interface ServiceInquiryFieldRefs {
    readonly id: FieldRef<"ServiceInquiry", 'String'>
    readonly residentName: FieldRef<"ServiceInquiry", 'String'>
    readonly unit: FieldRef<"ServiceInquiry", 'String'>
    readonly serviceName: FieldRef<"ServiceInquiry", 'String'>
    readonly serviceId: FieldRef<"ServiceInquiry", 'String'>
    readonly status: FieldRef<"ServiceInquiry", 'String'>
    readonly vendorName: FieldRef<"ServiceInquiry", 'String'>
    readonly vendorId: FieldRef<"ServiceInquiry", 'String'>
    readonly source: FieldRef<"ServiceInquiry", 'String'>
    readonly type: FieldRef<"ServiceInquiry", 'String'>
    readonly createdAt: FieldRef<"ServiceInquiry", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceInquiry", 'DateTime'>
    readonly societyId: FieldRef<"ServiceInquiry", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ServiceInquiry findUnique
   */
  export type ServiceInquiryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Filter, which ServiceInquiry to fetch.
     */
    where: ServiceInquiryWhereUniqueInput
  }

  /**
   * ServiceInquiry findUniqueOrThrow
   */
  export type ServiceInquiryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Filter, which ServiceInquiry to fetch.
     */
    where: ServiceInquiryWhereUniqueInput
  }

  /**
   * ServiceInquiry findFirst
   */
  export type ServiceInquiryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Filter, which ServiceInquiry to fetch.
     */
    where?: ServiceInquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInquiries to fetch.
     */
    orderBy?: ServiceInquiryOrderByWithRelationInput | ServiceInquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceInquiries.
     */
    cursor?: ServiceInquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceInquiries.
     */
    distinct?: ServiceInquiryScalarFieldEnum | ServiceInquiryScalarFieldEnum[]
  }

  /**
   * ServiceInquiry findFirstOrThrow
   */
  export type ServiceInquiryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Filter, which ServiceInquiry to fetch.
     */
    where?: ServiceInquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInquiries to fetch.
     */
    orderBy?: ServiceInquiryOrderByWithRelationInput | ServiceInquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceInquiries.
     */
    cursor?: ServiceInquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceInquiries.
     */
    distinct?: ServiceInquiryScalarFieldEnum | ServiceInquiryScalarFieldEnum[]
  }

  /**
   * ServiceInquiry findMany
   */
  export type ServiceInquiryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Filter, which ServiceInquiries to fetch.
     */
    where?: ServiceInquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInquiries to fetch.
     */
    orderBy?: ServiceInquiryOrderByWithRelationInput | ServiceInquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceInquiries.
     */
    cursor?: ServiceInquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInquiries.
     */
    skip?: number
    distinct?: ServiceInquiryScalarFieldEnum | ServiceInquiryScalarFieldEnum[]
  }

  /**
   * ServiceInquiry create
   */
  export type ServiceInquiryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * The data needed to create a ServiceInquiry.
     */
    data: XOR<ServiceInquiryCreateInput, ServiceInquiryUncheckedCreateInput>
  }

  /**
   * ServiceInquiry createMany
   */
  export type ServiceInquiryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceInquiries.
     */
    data: ServiceInquiryCreateManyInput | ServiceInquiryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceInquiry update
   */
  export type ServiceInquiryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * The data needed to update a ServiceInquiry.
     */
    data: XOR<ServiceInquiryUpdateInput, ServiceInquiryUncheckedUpdateInput>
    /**
     * Choose, which ServiceInquiry to update.
     */
    where: ServiceInquiryWhereUniqueInput
  }

  /**
   * ServiceInquiry updateMany
   */
  export type ServiceInquiryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceInquiries.
     */
    data: XOR<ServiceInquiryUpdateManyMutationInput, ServiceInquiryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceInquiries to update
     */
    where?: ServiceInquiryWhereInput
    /**
     * Limit how many ServiceInquiries to update.
     */
    limit?: number
  }

  /**
   * ServiceInquiry upsert
   */
  export type ServiceInquiryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * The filter to search for the ServiceInquiry to update in case it exists.
     */
    where: ServiceInquiryWhereUniqueInput
    /**
     * In case the ServiceInquiry found by the `where` argument doesn't exist, create a new ServiceInquiry with this data.
     */
    create: XOR<ServiceInquiryCreateInput, ServiceInquiryUncheckedCreateInput>
    /**
     * In case the ServiceInquiry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceInquiryUpdateInput, ServiceInquiryUncheckedUpdateInput>
  }

  /**
   * ServiceInquiry delete
   */
  export type ServiceInquiryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
    /**
     * Filter which ServiceInquiry to delete.
     */
    where: ServiceInquiryWhereUniqueInput
  }

  /**
   * ServiceInquiry deleteMany
   */
  export type ServiceInquiryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceInquiries to delete
     */
    where?: ServiceInquiryWhereInput
    /**
     * Limit how many ServiceInquiries to delete.
     */
    limit?: number
  }

  /**
   * ServiceInquiry without action
   */
  export type ServiceInquiryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInquiry
     */
    select?: ServiceInquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInquiry
     */
    omit?: ServiceInquiryOmit<ExtArgs> | null
  }


  /**
   * Model EmergencyLog
   */

  export type AggregateEmergencyLog = {
    _count: EmergencyLogCountAggregateOutputType | null
    _avg: EmergencyLogAvgAggregateOutputType | null
    _sum: EmergencyLogSumAggregateOutputType | null
    _min: EmergencyLogMinAggregateOutputType | null
    _max: EmergencyLogMaxAggregateOutputType | null
  }

  export type EmergencyLogAvgAggregateOutputType = {
    societyId: number | null
  }

  export type EmergencyLogSumAggregateOutputType = {
    societyId: number | null
  }

  export type EmergencyLogMinAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    visitorName: string | null
    visitorPhone: string | null
    residentName: string | null
    unit: string | null
    isEmergency: boolean | null
    reason: string | null
    barcodeId: string | null
    societyId: number | null
  }

  export type EmergencyLogMaxAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    visitorName: string | null
    visitorPhone: string | null
    residentName: string | null
    unit: string | null
    isEmergency: boolean | null
    reason: string | null
    barcodeId: string | null
    societyId: number | null
  }

  export type EmergencyLogCountAggregateOutputType = {
    id: number
    timestamp: number
    visitorName: number
    visitorPhone: number
    residentName: number
    unit: number
    isEmergency: number
    reason: number
    barcodeId: number
    societyId: number
    _all: number
  }


  export type EmergencyLogAvgAggregateInputType = {
    societyId?: true
  }

  export type EmergencyLogSumAggregateInputType = {
    societyId?: true
  }

  export type EmergencyLogMinAggregateInputType = {
    id?: true
    timestamp?: true
    visitorName?: true
    visitorPhone?: true
    residentName?: true
    unit?: true
    isEmergency?: true
    reason?: true
    barcodeId?: true
    societyId?: true
  }

  export type EmergencyLogMaxAggregateInputType = {
    id?: true
    timestamp?: true
    visitorName?: true
    visitorPhone?: true
    residentName?: true
    unit?: true
    isEmergency?: true
    reason?: true
    barcodeId?: true
    societyId?: true
  }

  export type EmergencyLogCountAggregateInputType = {
    id?: true
    timestamp?: true
    visitorName?: true
    visitorPhone?: true
    residentName?: true
    unit?: true
    isEmergency?: true
    reason?: true
    barcodeId?: true
    societyId?: true
    _all?: true
  }

  export type EmergencyLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyLog to aggregate.
     */
    where?: EmergencyLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyLogs to fetch.
     */
    orderBy?: EmergencyLogOrderByWithRelationInput | EmergencyLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmergencyLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmergencyLogs
    **/
    _count?: true | EmergencyLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmergencyLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmergencyLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmergencyLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmergencyLogMaxAggregateInputType
  }

  export type GetEmergencyLogAggregateType<T extends EmergencyLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEmergencyLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmergencyLog[P]>
      : GetScalarType<T[P], AggregateEmergencyLog[P]>
  }




  export type EmergencyLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyLogWhereInput
    orderBy?: EmergencyLogOrderByWithAggregationInput | EmergencyLogOrderByWithAggregationInput[]
    by: EmergencyLogScalarFieldEnum[] | EmergencyLogScalarFieldEnum
    having?: EmergencyLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmergencyLogCountAggregateInputType | true
    _avg?: EmergencyLogAvgAggregateInputType
    _sum?: EmergencyLogSumAggregateInputType
    _min?: EmergencyLogMinAggregateInputType
    _max?: EmergencyLogMaxAggregateInputType
  }

  export type EmergencyLogGroupByOutputType = {
    id: string
    timestamp: Date
    visitorName: string
    visitorPhone: string
    residentName: string
    unit: string
    isEmergency: boolean
    reason: string | null
    barcodeId: string
    societyId: number | null
    _count: EmergencyLogCountAggregateOutputType | null
    _avg: EmergencyLogAvgAggregateOutputType | null
    _sum: EmergencyLogSumAggregateOutputType | null
    _min: EmergencyLogMinAggregateOutputType | null
    _max: EmergencyLogMaxAggregateOutputType | null
  }

  type GetEmergencyLogGroupByPayload<T extends EmergencyLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmergencyLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmergencyLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmergencyLogGroupByOutputType[P]>
            : GetScalarType<T[P], EmergencyLogGroupByOutputType[P]>
        }
      >
    >


  export type EmergencyLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    visitorName?: boolean
    visitorPhone?: boolean
    residentName?: boolean
    unit?: boolean
    isEmergency?: boolean
    reason?: boolean
    barcodeId?: boolean
    societyId?: boolean
  }, ExtArgs["result"]["emergencyLog"]>



  export type EmergencyLogSelectScalar = {
    id?: boolean
    timestamp?: boolean
    visitorName?: boolean
    visitorPhone?: boolean
    residentName?: boolean
    unit?: boolean
    isEmergency?: boolean
    reason?: boolean
    barcodeId?: boolean
    societyId?: boolean
  }

  export type EmergencyLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "visitorName" | "visitorPhone" | "residentName" | "unit" | "isEmergency" | "reason" | "barcodeId" | "societyId", ExtArgs["result"]["emergencyLog"]>

  export type $EmergencyLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmergencyLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: Date
      visitorName: string
      visitorPhone: string
      residentName: string
      unit: string
      isEmergency: boolean
      reason: string | null
      barcodeId: string
      societyId: number | null
    }, ExtArgs["result"]["emergencyLog"]>
    composites: {}
  }

  type EmergencyLogGetPayload<S extends boolean | null | undefined | EmergencyLogDefaultArgs> = $Result.GetResult<Prisma.$EmergencyLogPayload, S>

  type EmergencyLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmergencyLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmergencyLogCountAggregateInputType | true
    }

  export interface EmergencyLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmergencyLog'], meta: { name: 'EmergencyLog' } }
    /**
     * Find zero or one EmergencyLog that matches the filter.
     * @param {EmergencyLogFindUniqueArgs} args - Arguments to find a EmergencyLog
     * @example
     * // Get one EmergencyLog
     * const emergencyLog = await prisma.emergencyLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmergencyLogFindUniqueArgs>(args: SelectSubset<T, EmergencyLogFindUniqueArgs<ExtArgs>>): Prisma__EmergencyLogClient<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmergencyLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmergencyLogFindUniqueOrThrowArgs} args - Arguments to find a EmergencyLog
     * @example
     * // Get one EmergencyLog
     * const emergencyLog = await prisma.emergencyLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmergencyLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EmergencyLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmergencyLogClient<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyLogFindFirstArgs} args - Arguments to find a EmergencyLog
     * @example
     * // Get one EmergencyLog
     * const emergencyLog = await prisma.emergencyLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmergencyLogFindFirstArgs>(args?: SelectSubset<T, EmergencyLogFindFirstArgs<ExtArgs>>): Prisma__EmergencyLogClient<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyLogFindFirstOrThrowArgs} args - Arguments to find a EmergencyLog
     * @example
     * // Get one EmergencyLog
     * const emergencyLog = await prisma.emergencyLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmergencyLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EmergencyLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmergencyLogClient<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmergencyLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmergencyLogs
     * const emergencyLogs = await prisma.emergencyLog.findMany()
     * 
     * // Get first 10 EmergencyLogs
     * const emergencyLogs = await prisma.emergencyLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emergencyLogWithIdOnly = await prisma.emergencyLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmergencyLogFindManyArgs>(args?: SelectSubset<T, EmergencyLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmergencyLog.
     * @param {EmergencyLogCreateArgs} args - Arguments to create a EmergencyLog.
     * @example
     * // Create one EmergencyLog
     * const EmergencyLog = await prisma.emergencyLog.create({
     *   data: {
     *     // ... data to create a EmergencyLog
     *   }
     * })
     * 
     */
    create<T extends EmergencyLogCreateArgs>(args: SelectSubset<T, EmergencyLogCreateArgs<ExtArgs>>): Prisma__EmergencyLogClient<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmergencyLogs.
     * @param {EmergencyLogCreateManyArgs} args - Arguments to create many EmergencyLogs.
     * @example
     * // Create many EmergencyLogs
     * const emergencyLog = await prisma.emergencyLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmergencyLogCreateManyArgs>(args?: SelectSubset<T, EmergencyLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmergencyLog.
     * @param {EmergencyLogDeleteArgs} args - Arguments to delete one EmergencyLog.
     * @example
     * // Delete one EmergencyLog
     * const EmergencyLog = await prisma.emergencyLog.delete({
     *   where: {
     *     // ... filter to delete one EmergencyLog
     *   }
     * })
     * 
     */
    delete<T extends EmergencyLogDeleteArgs>(args: SelectSubset<T, EmergencyLogDeleteArgs<ExtArgs>>): Prisma__EmergencyLogClient<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmergencyLog.
     * @param {EmergencyLogUpdateArgs} args - Arguments to update one EmergencyLog.
     * @example
     * // Update one EmergencyLog
     * const emergencyLog = await prisma.emergencyLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmergencyLogUpdateArgs>(args: SelectSubset<T, EmergencyLogUpdateArgs<ExtArgs>>): Prisma__EmergencyLogClient<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmergencyLogs.
     * @param {EmergencyLogDeleteManyArgs} args - Arguments to filter EmergencyLogs to delete.
     * @example
     * // Delete a few EmergencyLogs
     * const { count } = await prisma.emergencyLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmergencyLogDeleteManyArgs>(args?: SelectSubset<T, EmergencyLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmergencyLogs
     * const emergencyLog = await prisma.emergencyLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmergencyLogUpdateManyArgs>(args: SelectSubset<T, EmergencyLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmergencyLog.
     * @param {EmergencyLogUpsertArgs} args - Arguments to update or create a EmergencyLog.
     * @example
     * // Update or create a EmergencyLog
     * const emergencyLog = await prisma.emergencyLog.upsert({
     *   create: {
     *     // ... data to create a EmergencyLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmergencyLog we want to update
     *   }
     * })
     */
    upsert<T extends EmergencyLogUpsertArgs>(args: SelectSubset<T, EmergencyLogUpsertArgs<ExtArgs>>): Prisma__EmergencyLogClient<$Result.GetResult<Prisma.$EmergencyLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmergencyLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyLogCountArgs} args - Arguments to filter EmergencyLogs to count.
     * @example
     * // Count the number of EmergencyLogs
     * const count = await prisma.emergencyLog.count({
     *   where: {
     *     // ... the filter for the EmergencyLogs we want to count
     *   }
     * })
    **/
    count<T extends EmergencyLogCountArgs>(
      args?: Subset<T, EmergencyLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmergencyLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmergencyLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmergencyLogAggregateArgs>(args: Subset<T, EmergencyLogAggregateArgs>): Prisma.PrismaPromise<GetEmergencyLogAggregateType<T>>

    /**
     * Group by EmergencyLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmergencyLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmergencyLogGroupByArgs['orderBy'] }
        : { orderBy?: EmergencyLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmergencyLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmergencyLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmergencyLog model
   */
  readonly fields: EmergencyLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmergencyLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmergencyLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmergencyLog model
   */
  interface EmergencyLogFieldRefs {
    readonly id: FieldRef<"EmergencyLog", 'String'>
    readonly timestamp: FieldRef<"EmergencyLog", 'DateTime'>
    readonly visitorName: FieldRef<"EmergencyLog", 'String'>
    readonly visitorPhone: FieldRef<"EmergencyLog", 'String'>
    readonly residentName: FieldRef<"EmergencyLog", 'String'>
    readonly unit: FieldRef<"EmergencyLog", 'String'>
    readonly isEmergency: FieldRef<"EmergencyLog", 'Boolean'>
    readonly reason: FieldRef<"EmergencyLog", 'String'>
    readonly barcodeId: FieldRef<"EmergencyLog", 'String'>
    readonly societyId: FieldRef<"EmergencyLog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EmergencyLog findUnique
   */
  export type EmergencyLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyLog to fetch.
     */
    where: EmergencyLogWhereUniqueInput
  }

  /**
   * EmergencyLog findUniqueOrThrow
   */
  export type EmergencyLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyLog to fetch.
     */
    where: EmergencyLogWhereUniqueInput
  }

  /**
   * EmergencyLog findFirst
   */
  export type EmergencyLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyLog to fetch.
     */
    where?: EmergencyLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyLogs to fetch.
     */
    orderBy?: EmergencyLogOrderByWithRelationInput | EmergencyLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyLogs.
     */
    cursor?: EmergencyLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyLogs.
     */
    distinct?: EmergencyLogScalarFieldEnum | EmergencyLogScalarFieldEnum[]
  }

  /**
   * EmergencyLog findFirstOrThrow
   */
  export type EmergencyLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyLog to fetch.
     */
    where?: EmergencyLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyLogs to fetch.
     */
    orderBy?: EmergencyLogOrderByWithRelationInput | EmergencyLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyLogs.
     */
    cursor?: EmergencyLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyLogs.
     */
    distinct?: EmergencyLogScalarFieldEnum | EmergencyLogScalarFieldEnum[]
  }

  /**
   * EmergencyLog findMany
   */
  export type EmergencyLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyLogs to fetch.
     */
    where?: EmergencyLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyLogs to fetch.
     */
    orderBy?: EmergencyLogOrderByWithRelationInput | EmergencyLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmergencyLogs.
     */
    cursor?: EmergencyLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyLogs.
     */
    skip?: number
    distinct?: EmergencyLogScalarFieldEnum | EmergencyLogScalarFieldEnum[]
  }

  /**
   * EmergencyLog create
   */
  export type EmergencyLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * The data needed to create a EmergencyLog.
     */
    data: XOR<EmergencyLogCreateInput, EmergencyLogUncheckedCreateInput>
  }

  /**
   * EmergencyLog createMany
   */
  export type EmergencyLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmergencyLogs.
     */
    data: EmergencyLogCreateManyInput | EmergencyLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmergencyLog update
   */
  export type EmergencyLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * The data needed to update a EmergencyLog.
     */
    data: XOR<EmergencyLogUpdateInput, EmergencyLogUncheckedUpdateInput>
    /**
     * Choose, which EmergencyLog to update.
     */
    where: EmergencyLogWhereUniqueInput
  }

  /**
   * EmergencyLog updateMany
   */
  export type EmergencyLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmergencyLogs.
     */
    data: XOR<EmergencyLogUpdateManyMutationInput, EmergencyLogUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyLogs to update
     */
    where?: EmergencyLogWhereInput
    /**
     * Limit how many EmergencyLogs to update.
     */
    limit?: number
  }

  /**
   * EmergencyLog upsert
   */
  export type EmergencyLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * The filter to search for the EmergencyLog to update in case it exists.
     */
    where: EmergencyLogWhereUniqueInput
    /**
     * In case the EmergencyLog found by the `where` argument doesn't exist, create a new EmergencyLog with this data.
     */
    create: XOR<EmergencyLogCreateInput, EmergencyLogUncheckedCreateInput>
    /**
     * In case the EmergencyLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmergencyLogUpdateInput, EmergencyLogUncheckedUpdateInput>
  }

  /**
   * EmergencyLog delete
   */
  export type EmergencyLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
    /**
     * Filter which EmergencyLog to delete.
     */
    where: EmergencyLogWhereUniqueInput
  }

  /**
   * EmergencyLog deleteMany
   */
  export type EmergencyLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyLogs to delete
     */
    where?: EmergencyLogWhereInput
    /**
     * Limit how many EmergencyLogs to delete.
     */
    limit?: number
  }

  /**
   * EmergencyLog without action
   */
  export type EmergencyLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyLog
     */
    select?: EmergencyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyLog
     */
    omit?: EmergencyLogOmit<ExtArgs> | null
  }


  /**
   * Model EmergencyBarcode
   */

  export type AggregateEmergencyBarcode = {
    _count: EmergencyBarcodeCountAggregateOutputType | null
    _avg: EmergencyBarcodeAvgAggregateOutputType | null
    _sum: EmergencyBarcodeSumAggregateOutputType | null
    _min: EmergencyBarcodeMinAggregateOutputType | null
    _max: EmergencyBarcodeMaxAggregateOutputType | null
  }

  export type EmergencyBarcodeAvgAggregateOutputType = {
    societyId: number | null
  }

  export type EmergencyBarcodeSumAggregateOutputType = {
    societyId: number | null
  }

  export type EmergencyBarcodeMinAggregateOutputType = {
    id: string | null
    residentName: string | null
    unit: string | null
    phone: string | null
    status: string | null
    qrCodeUrl: string | null
    createdAt: Date | null
    societyId: number | null
  }

  export type EmergencyBarcodeMaxAggregateOutputType = {
    id: string | null
    residentName: string | null
    unit: string | null
    phone: string | null
    status: string | null
    qrCodeUrl: string | null
    createdAt: Date | null
    societyId: number | null
  }

  export type EmergencyBarcodeCountAggregateOutputType = {
    id: number
    residentName: number
    unit: number
    phone: number
    status: number
    qrCodeUrl: number
    createdAt: number
    societyId: number
    _all: number
  }


  export type EmergencyBarcodeAvgAggregateInputType = {
    societyId?: true
  }

  export type EmergencyBarcodeSumAggregateInputType = {
    societyId?: true
  }

  export type EmergencyBarcodeMinAggregateInputType = {
    id?: true
    residentName?: true
    unit?: true
    phone?: true
    status?: true
    qrCodeUrl?: true
    createdAt?: true
    societyId?: true
  }

  export type EmergencyBarcodeMaxAggregateInputType = {
    id?: true
    residentName?: true
    unit?: true
    phone?: true
    status?: true
    qrCodeUrl?: true
    createdAt?: true
    societyId?: true
  }

  export type EmergencyBarcodeCountAggregateInputType = {
    id?: true
    residentName?: true
    unit?: true
    phone?: true
    status?: true
    qrCodeUrl?: true
    createdAt?: true
    societyId?: true
    _all?: true
  }

  export type EmergencyBarcodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyBarcode to aggregate.
     */
    where?: EmergencyBarcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyBarcodes to fetch.
     */
    orderBy?: EmergencyBarcodeOrderByWithRelationInput | EmergencyBarcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmergencyBarcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyBarcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyBarcodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmergencyBarcodes
    **/
    _count?: true | EmergencyBarcodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmergencyBarcodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmergencyBarcodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmergencyBarcodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmergencyBarcodeMaxAggregateInputType
  }

  export type GetEmergencyBarcodeAggregateType<T extends EmergencyBarcodeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmergencyBarcode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmergencyBarcode[P]>
      : GetScalarType<T[P], AggregateEmergencyBarcode[P]>
  }




  export type EmergencyBarcodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyBarcodeWhereInput
    orderBy?: EmergencyBarcodeOrderByWithAggregationInput | EmergencyBarcodeOrderByWithAggregationInput[]
    by: EmergencyBarcodeScalarFieldEnum[] | EmergencyBarcodeScalarFieldEnum
    having?: EmergencyBarcodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmergencyBarcodeCountAggregateInputType | true
    _avg?: EmergencyBarcodeAvgAggregateInputType
    _sum?: EmergencyBarcodeSumAggregateInputType
    _min?: EmergencyBarcodeMinAggregateInputType
    _max?: EmergencyBarcodeMaxAggregateInputType
  }

  export type EmergencyBarcodeGroupByOutputType = {
    id: string
    residentName: string
    unit: string
    phone: string
    status: string
    qrCodeUrl: string
    createdAt: Date
    societyId: number | null
    _count: EmergencyBarcodeCountAggregateOutputType | null
    _avg: EmergencyBarcodeAvgAggregateOutputType | null
    _sum: EmergencyBarcodeSumAggregateOutputType | null
    _min: EmergencyBarcodeMinAggregateOutputType | null
    _max: EmergencyBarcodeMaxAggregateOutputType | null
  }

  type GetEmergencyBarcodeGroupByPayload<T extends EmergencyBarcodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmergencyBarcodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmergencyBarcodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmergencyBarcodeGroupByOutputType[P]>
            : GetScalarType<T[P], EmergencyBarcodeGroupByOutputType[P]>
        }
      >
    >


  export type EmergencyBarcodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    residentName?: boolean
    unit?: boolean
    phone?: boolean
    status?: boolean
    qrCodeUrl?: boolean
    createdAt?: boolean
    societyId?: boolean
  }, ExtArgs["result"]["emergencyBarcode"]>



  export type EmergencyBarcodeSelectScalar = {
    id?: boolean
    residentName?: boolean
    unit?: boolean
    phone?: boolean
    status?: boolean
    qrCodeUrl?: boolean
    createdAt?: boolean
    societyId?: boolean
  }

  export type EmergencyBarcodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "residentName" | "unit" | "phone" | "status" | "qrCodeUrl" | "createdAt" | "societyId", ExtArgs["result"]["emergencyBarcode"]>

  export type $EmergencyBarcodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmergencyBarcode"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      residentName: string
      unit: string
      phone: string
      status: string
      qrCodeUrl: string
      createdAt: Date
      societyId: number | null
    }, ExtArgs["result"]["emergencyBarcode"]>
    composites: {}
  }

  type EmergencyBarcodeGetPayload<S extends boolean | null | undefined | EmergencyBarcodeDefaultArgs> = $Result.GetResult<Prisma.$EmergencyBarcodePayload, S>

  type EmergencyBarcodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmergencyBarcodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmergencyBarcodeCountAggregateInputType | true
    }

  export interface EmergencyBarcodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmergencyBarcode'], meta: { name: 'EmergencyBarcode' } }
    /**
     * Find zero or one EmergencyBarcode that matches the filter.
     * @param {EmergencyBarcodeFindUniqueArgs} args - Arguments to find a EmergencyBarcode
     * @example
     * // Get one EmergencyBarcode
     * const emergencyBarcode = await prisma.emergencyBarcode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmergencyBarcodeFindUniqueArgs>(args: SelectSubset<T, EmergencyBarcodeFindUniqueArgs<ExtArgs>>): Prisma__EmergencyBarcodeClient<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmergencyBarcode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmergencyBarcodeFindUniqueOrThrowArgs} args - Arguments to find a EmergencyBarcode
     * @example
     * // Get one EmergencyBarcode
     * const emergencyBarcode = await prisma.emergencyBarcode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmergencyBarcodeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmergencyBarcodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmergencyBarcodeClient<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyBarcode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyBarcodeFindFirstArgs} args - Arguments to find a EmergencyBarcode
     * @example
     * // Get one EmergencyBarcode
     * const emergencyBarcode = await prisma.emergencyBarcode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmergencyBarcodeFindFirstArgs>(args?: SelectSubset<T, EmergencyBarcodeFindFirstArgs<ExtArgs>>): Prisma__EmergencyBarcodeClient<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyBarcode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyBarcodeFindFirstOrThrowArgs} args - Arguments to find a EmergencyBarcode
     * @example
     * // Get one EmergencyBarcode
     * const emergencyBarcode = await prisma.emergencyBarcode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmergencyBarcodeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmergencyBarcodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmergencyBarcodeClient<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmergencyBarcodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyBarcodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmergencyBarcodes
     * const emergencyBarcodes = await prisma.emergencyBarcode.findMany()
     * 
     * // Get first 10 EmergencyBarcodes
     * const emergencyBarcodes = await prisma.emergencyBarcode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emergencyBarcodeWithIdOnly = await prisma.emergencyBarcode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmergencyBarcodeFindManyArgs>(args?: SelectSubset<T, EmergencyBarcodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmergencyBarcode.
     * @param {EmergencyBarcodeCreateArgs} args - Arguments to create a EmergencyBarcode.
     * @example
     * // Create one EmergencyBarcode
     * const EmergencyBarcode = await prisma.emergencyBarcode.create({
     *   data: {
     *     // ... data to create a EmergencyBarcode
     *   }
     * })
     * 
     */
    create<T extends EmergencyBarcodeCreateArgs>(args: SelectSubset<T, EmergencyBarcodeCreateArgs<ExtArgs>>): Prisma__EmergencyBarcodeClient<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmergencyBarcodes.
     * @param {EmergencyBarcodeCreateManyArgs} args - Arguments to create many EmergencyBarcodes.
     * @example
     * // Create many EmergencyBarcodes
     * const emergencyBarcode = await prisma.emergencyBarcode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmergencyBarcodeCreateManyArgs>(args?: SelectSubset<T, EmergencyBarcodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmergencyBarcode.
     * @param {EmergencyBarcodeDeleteArgs} args - Arguments to delete one EmergencyBarcode.
     * @example
     * // Delete one EmergencyBarcode
     * const EmergencyBarcode = await prisma.emergencyBarcode.delete({
     *   where: {
     *     // ... filter to delete one EmergencyBarcode
     *   }
     * })
     * 
     */
    delete<T extends EmergencyBarcodeDeleteArgs>(args: SelectSubset<T, EmergencyBarcodeDeleteArgs<ExtArgs>>): Prisma__EmergencyBarcodeClient<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmergencyBarcode.
     * @param {EmergencyBarcodeUpdateArgs} args - Arguments to update one EmergencyBarcode.
     * @example
     * // Update one EmergencyBarcode
     * const emergencyBarcode = await prisma.emergencyBarcode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmergencyBarcodeUpdateArgs>(args: SelectSubset<T, EmergencyBarcodeUpdateArgs<ExtArgs>>): Prisma__EmergencyBarcodeClient<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmergencyBarcodes.
     * @param {EmergencyBarcodeDeleteManyArgs} args - Arguments to filter EmergencyBarcodes to delete.
     * @example
     * // Delete a few EmergencyBarcodes
     * const { count } = await prisma.emergencyBarcode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmergencyBarcodeDeleteManyArgs>(args?: SelectSubset<T, EmergencyBarcodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyBarcodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyBarcodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmergencyBarcodes
     * const emergencyBarcode = await prisma.emergencyBarcode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmergencyBarcodeUpdateManyArgs>(args: SelectSubset<T, EmergencyBarcodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmergencyBarcode.
     * @param {EmergencyBarcodeUpsertArgs} args - Arguments to update or create a EmergencyBarcode.
     * @example
     * // Update or create a EmergencyBarcode
     * const emergencyBarcode = await prisma.emergencyBarcode.upsert({
     *   create: {
     *     // ... data to create a EmergencyBarcode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmergencyBarcode we want to update
     *   }
     * })
     */
    upsert<T extends EmergencyBarcodeUpsertArgs>(args: SelectSubset<T, EmergencyBarcodeUpsertArgs<ExtArgs>>): Prisma__EmergencyBarcodeClient<$Result.GetResult<Prisma.$EmergencyBarcodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmergencyBarcodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyBarcodeCountArgs} args - Arguments to filter EmergencyBarcodes to count.
     * @example
     * // Count the number of EmergencyBarcodes
     * const count = await prisma.emergencyBarcode.count({
     *   where: {
     *     // ... the filter for the EmergencyBarcodes we want to count
     *   }
     * })
    **/
    count<T extends EmergencyBarcodeCountArgs>(
      args?: Subset<T, EmergencyBarcodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmergencyBarcodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmergencyBarcode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyBarcodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmergencyBarcodeAggregateArgs>(args: Subset<T, EmergencyBarcodeAggregateArgs>): Prisma.PrismaPromise<GetEmergencyBarcodeAggregateType<T>>

    /**
     * Group by EmergencyBarcode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyBarcodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmergencyBarcodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmergencyBarcodeGroupByArgs['orderBy'] }
        : { orderBy?: EmergencyBarcodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmergencyBarcodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmergencyBarcodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmergencyBarcode model
   */
  readonly fields: EmergencyBarcodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmergencyBarcode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmergencyBarcodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmergencyBarcode model
   */
  interface EmergencyBarcodeFieldRefs {
    readonly id: FieldRef<"EmergencyBarcode", 'String'>
    readonly residentName: FieldRef<"EmergencyBarcode", 'String'>
    readonly unit: FieldRef<"EmergencyBarcode", 'String'>
    readonly phone: FieldRef<"EmergencyBarcode", 'String'>
    readonly status: FieldRef<"EmergencyBarcode", 'String'>
    readonly qrCodeUrl: FieldRef<"EmergencyBarcode", 'String'>
    readonly createdAt: FieldRef<"EmergencyBarcode", 'DateTime'>
    readonly societyId: FieldRef<"EmergencyBarcode", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EmergencyBarcode findUnique
   */
  export type EmergencyBarcodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyBarcode to fetch.
     */
    where: EmergencyBarcodeWhereUniqueInput
  }

  /**
   * EmergencyBarcode findUniqueOrThrow
   */
  export type EmergencyBarcodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyBarcode to fetch.
     */
    where: EmergencyBarcodeWhereUniqueInput
  }

  /**
   * EmergencyBarcode findFirst
   */
  export type EmergencyBarcodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyBarcode to fetch.
     */
    where?: EmergencyBarcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyBarcodes to fetch.
     */
    orderBy?: EmergencyBarcodeOrderByWithRelationInput | EmergencyBarcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyBarcodes.
     */
    cursor?: EmergencyBarcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyBarcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyBarcodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyBarcodes.
     */
    distinct?: EmergencyBarcodeScalarFieldEnum | EmergencyBarcodeScalarFieldEnum[]
  }

  /**
   * EmergencyBarcode findFirstOrThrow
   */
  export type EmergencyBarcodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyBarcode to fetch.
     */
    where?: EmergencyBarcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyBarcodes to fetch.
     */
    orderBy?: EmergencyBarcodeOrderByWithRelationInput | EmergencyBarcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyBarcodes.
     */
    cursor?: EmergencyBarcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyBarcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyBarcodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyBarcodes.
     */
    distinct?: EmergencyBarcodeScalarFieldEnum | EmergencyBarcodeScalarFieldEnum[]
  }

  /**
   * EmergencyBarcode findMany
   */
  export type EmergencyBarcodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * Filter, which EmergencyBarcodes to fetch.
     */
    where?: EmergencyBarcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyBarcodes to fetch.
     */
    orderBy?: EmergencyBarcodeOrderByWithRelationInput | EmergencyBarcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmergencyBarcodes.
     */
    cursor?: EmergencyBarcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyBarcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyBarcodes.
     */
    skip?: number
    distinct?: EmergencyBarcodeScalarFieldEnum | EmergencyBarcodeScalarFieldEnum[]
  }

  /**
   * EmergencyBarcode create
   */
  export type EmergencyBarcodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * The data needed to create a EmergencyBarcode.
     */
    data: XOR<EmergencyBarcodeCreateInput, EmergencyBarcodeUncheckedCreateInput>
  }

  /**
   * EmergencyBarcode createMany
   */
  export type EmergencyBarcodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmergencyBarcodes.
     */
    data: EmergencyBarcodeCreateManyInput | EmergencyBarcodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmergencyBarcode update
   */
  export type EmergencyBarcodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * The data needed to update a EmergencyBarcode.
     */
    data: XOR<EmergencyBarcodeUpdateInput, EmergencyBarcodeUncheckedUpdateInput>
    /**
     * Choose, which EmergencyBarcode to update.
     */
    where: EmergencyBarcodeWhereUniqueInput
  }

  /**
   * EmergencyBarcode updateMany
   */
  export type EmergencyBarcodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmergencyBarcodes.
     */
    data: XOR<EmergencyBarcodeUpdateManyMutationInput, EmergencyBarcodeUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyBarcodes to update
     */
    where?: EmergencyBarcodeWhereInput
    /**
     * Limit how many EmergencyBarcodes to update.
     */
    limit?: number
  }

  /**
   * EmergencyBarcode upsert
   */
  export type EmergencyBarcodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * The filter to search for the EmergencyBarcode to update in case it exists.
     */
    where: EmergencyBarcodeWhereUniqueInput
    /**
     * In case the EmergencyBarcode found by the `where` argument doesn't exist, create a new EmergencyBarcode with this data.
     */
    create: XOR<EmergencyBarcodeCreateInput, EmergencyBarcodeUncheckedCreateInput>
    /**
     * In case the EmergencyBarcode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmergencyBarcodeUpdateInput, EmergencyBarcodeUncheckedUpdateInput>
  }

  /**
   * EmergencyBarcode delete
   */
  export type EmergencyBarcodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
    /**
     * Filter which EmergencyBarcode to delete.
     */
    where: EmergencyBarcodeWhereUniqueInput
  }

  /**
   * EmergencyBarcode deleteMany
   */
  export type EmergencyBarcodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyBarcodes to delete
     */
    where?: EmergencyBarcodeWhereInput
    /**
     * Limit how many EmergencyBarcodes to delete.
     */
    limit?: number
  }

  /**
   * EmergencyBarcode without action
   */
  export type EmergencyBarcodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyBarcode
     */
    select?: EmergencyBarcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyBarcode
     */
    omit?: EmergencyBarcodeOmit<ExtArgs> | null
  }


  /**
   * Model Notice
   */

  export type AggregateNotice = {
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  export type NoticeAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type NoticeSumAggregateOutputType = {
    id: number | null
    societyId: number | null
  }

  export type NoticeMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    audience: string | null
    societyId: number | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type NoticeMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    audience: string | null
    societyId: number | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type NoticeCountAggregateOutputType = {
    id: number
    title: number
    content: number
    audience: number
    societyId: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type NoticeAvgAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type NoticeSumAggregateInputType = {
    id?: true
    societyId?: true
  }

  export type NoticeMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    audience?: true
    societyId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type NoticeMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    audience?: true
    societyId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type NoticeCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    audience?: true
    societyId?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type NoticeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notice to aggregate.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notices
    **/
    _count?: true | NoticeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoticeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoticeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoticeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoticeMaxAggregateInputType
  }

  export type GetNoticeAggregateType<T extends NoticeAggregateArgs> = {
        [P in keyof T & keyof AggregateNotice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotice[P]>
      : GetScalarType<T[P], AggregateNotice[P]>
  }




  export type NoticeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoticeWhereInput
    orderBy?: NoticeOrderByWithAggregationInput | NoticeOrderByWithAggregationInput[]
    by: NoticeScalarFieldEnum[] | NoticeScalarFieldEnum
    having?: NoticeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoticeCountAggregateInputType | true
    _avg?: NoticeAvgAggregateInputType
    _sum?: NoticeSumAggregateInputType
    _min?: NoticeMinAggregateInputType
    _max?: NoticeMaxAggregateInputType
  }

  export type NoticeGroupByOutputType = {
    id: number
    title: string
    content: string
    audience: string
    societyId: number
    createdAt: Date
    expiresAt: Date | null
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  type GetNoticeGroupByPayload<T extends NoticeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoticeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoticeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoticeGroupByOutputType[P]>
            : GetScalarType<T[P], NoticeGroupByOutputType[P]>
        }
      >
    >


  export type NoticeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    audience?: boolean
    societyId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notice"]>



  export type NoticeSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    audience?: boolean
    societyId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type NoticeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "audience" | "societyId" | "createdAt" | "expiresAt", ExtArgs["result"]["notice"]>
  export type NoticeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $NoticePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notice"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      audience: string
      societyId: number
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["notice"]>
    composites: {}
  }

  type NoticeGetPayload<S extends boolean | null | undefined | NoticeDefaultArgs> = $Result.GetResult<Prisma.$NoticePayload, S>

  type NoticeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoticeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoticeCountAggregateInputType | true
    }

  export interface NoticeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notice'], meta: { name: 'Notice' } }
    /**
     * Find zero or one Notice that matches the filter.
     * @param {NoticeFindUniqueArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoticeFindUniqueArgs>(args: SelectSubset<T, NoticeFindUniqueArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoticeFindUniqueOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoticeFindUniqueOrThrowArgs>(args: SelectSubset<T, NoticeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoticeFindFirstArgs>(args?: SelectSubset<T, NoticeFindFirstArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoticeFindFirstOrThrowArgs>(args?: SelectSubset<T, NoticeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notices
     * const notices = await prisma.notice.findMany()
     * 
     * // Get first 10 Notices
     * const notices = await prisma.notice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noticeWithIdOnly = await prisma.notice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoticeFindManyArgs>(args?: SelectSubset<T, NoticeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notice.
     * @param {NoticeCreateArgs} args - Arguments to create a Notice.
     * @example
     * // Create one Notice
     * const Notice = await prisma.notice.create({
     *   data: {
     *     // ... data to create a Notice
     *   }
     * })
     * 
     */
    create<T extends NoticeCreateArgs>(args: SelectSubset<T, NoticeCreateArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notices.
     * @param {NoticeCreateManyArgs} args - Arguments to create many Notices.
     * @example
     * // Create many Notices
     * const notice = await prisma.notice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoticeCreateManyArgs>(args?: SelectSubset<T, NoticeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notice.
     * @param {NoticeDeleteArgs} args - Arguments to delete one Notice.
     * @example
     * // Delete one Notice
     * const Notice = await prisma.notice.delete({
     *   where: {
     *     // ... filter to delete one Notice
     *   }
     * })
     * 
     */
    delete<T extends NoticeDeleteArgs>(args: SelectSubset<T, NoticeDeleteArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notice.
     * @param {NoticeUpdateArgs} args - Arguments to update one Notice.
     * @example
     * // Update one Notice
     * const notice = await prisma.notice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoticeUpdateArgs>(args: SelectSubset<T, NoticeUpdateArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notices.
     * @param {NoticeDeleteManyArgs} args - Arguments to filter Notices to delete.
     * @example
     * // Delete a few Notices
     * const { count } = await prisma.notice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoticeDeleteManyArgs>(args?: SelectSubset<T, NoticeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notices
     * const notice = await prisma.notice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoticeUpdateManyArgs>(args: SelectSubset<T, NoticeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notice.
     * @param {NoticeUpsertArgs} args - Arguments to update or create a Notice.
     * @example
     * // Update or create a Notice
     * const notice = await prisma.notice.upsert({
     *   create: {
     *     // ... data to create a Notice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notice we want to update
     *   }
     * })
     */
    upsert<T extends NoticeUpsertArgs>(args: SelectSubset<T, NoticeUpsertArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeCountArgs} args - Arguments to filter Notices to count.
     * @example
     * // Count the number of Notices
     * const count = await prisma.notice.count({
     *   where: {
     *     // ... the filter for the Notices we want to count
     *   }
     * })
    **/
    count<T extends NoticeCountArgs>(
      args?: Subset<T, NoticeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoticeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoticeAggregateArgs>(args: Subset<T, NoticeAggregateArgs>): Prisma.PrismaPromise<GetNoticeAggregateType<T>>

    /**
     * Group by Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoticeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoticeGroupByArgs['orderBy'] }
        : { orderBy?: NoticeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoticeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoticeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notice model
   */
  readonly fields: NoticeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoticeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notice model
   */
  interface NoticeFieldRefs {
    readonly id: FieldRef<"Notice", 'Int'>
    readonly title: FieldRef<"Notice", 'String'>
    readonly content: FieldRef<"Notice", 'String'>
    readonly audience: FieldRef<"Notice", 'String'>
    readonly societyId: FieldRef<"Notice", 'Int'>
    readonly createdAt: FieldRef<"Notice", 'DateTime'>
    readonly expiresAt: FieldRef<"Notice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notice findUnique
   */
  export type NoticeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice findUniqueOrThrow
   */
  export type NoticeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice findFirst
   */
  export type NoticeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     */
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice findFirstOrThrow
   */
  export type NoticeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     */
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice findMany
   */
  export type NoticeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notices to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice create
   */
  export type NoticeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The data needed to create a Notice.
     */
    data: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
  }

  /**
   * Notice createMany
   */
  export type NoticeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notices.
     */
    data: NoticeCreateManyInput | NoticeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notice update
   */
  export type NoticeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The data needed to update a Notice.
     */
    data: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
    /**
     * Choose, which Notice to update.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice updateMany
   */
  export type NoticeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notices.
     */
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyInput>
    /**
     * Filter which Notices to update
     */
    where?: NoticeWhereInput
    /**
     * Limit how many Notices to update.
     */
    limit?: number
  }

  /**
   * Notice upsert
   */
  export type NoticeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The filter to search for the Notice to update in case it exists.
     */
    where: NoticeWhereUniqueInput
    /**
     * In case the Notice found by the `where` argument doesn't exist, create a new Notice with this data.
     */
    create: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
    /**
     * In case the Notice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
  }

  /**
   * Notice delete
   */
  export type NoticeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter which Notice to delete.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice deleteMany
   */
  export type NoticeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notices to delete
     */
    where?: NoticeWhereInput
    /**
     * Limit how many Notices to delete.
     */
    limit?: number
  }

  /**
   * Notice without action
   */
  export type NoticeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
  }


  /**
   * Model Amenity
   */

  export type AggregateAmenity = {
    _count: AmenityCountAggregateOutputType | null
    _avg: AmenityAvgAggregateOutputType | null
    _sum: AmenitySumAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  export type AmenityAvgAggregateOutputType = {
    id: number | null
    chargesPerHour: number | null
    societyId: number | null
  }

  export type AmenitySumAggregateOutputType = {
    id: number | null
    chargesPerHour: number | null
    societyId: number | null
  }

  export type AmenityMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    chargesPerHour: number | null
    societyId: number | null
    createdAt: Date | null
  }

  export type AmenityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    chargesPerHour: number | null
    societyId: number | null
    createdAt: Date | null
  }

  export type AmenityCountAggregateOutputType = {
    id: number
    name: number
    description: number
    chargesPerHour: number
    societyId: number
    createdAt: number
    _all: number
  }


  export type AmenityAvgAggregateInputType = {
    id?: true
    chargesPerHour?: true
    societyId?: true
  }

  export type AmenitySumAggregateInputType = {
    id?: true
    chargesPerHour?: true
    societyId?: true
  }

  export type AmenityMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    chargesPerHour?: true
    societyId?: true
    createdAt?: true
  }

  export type AmenityMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    chargesPerHour?: true
    societyId?: true
    createdAt?: true
  }

  export type AmenityCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    chargesPerHour?: true
    societyId?: true
    createdAt?: true
    _all?: true
  }

  export type AmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenity to aggregate.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Amenities
    **/
    _count?: true | AmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmenityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmenitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenityMaxAggregateInputType
  }

  export type GetAmenityAggregateType<T extends AmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenity[P]>
      : GetScalarType<T[P], AggregateAmenity[P]>
  }




  export type AmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityWhereInput
    orderBy?: AmenityOrderByWithAggregationInput | AmenityOrderByWithAggregationInput[]
    by: AmenityScalarFieldEnum[] | AmenityScalarFieldEnum
    having?: AmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenityCountAggregateInputType | true
    _avg?: AmenityAvgAggregateInputType
    _sum?: AmenitySumAggregateInputType
    _min?: AmenityMinAggregateInputType
    _max?: AmenityMaxAggregateInputType
  }

  export type AmenityGroupByOutputType = {
    id: number
    name: string
    description: string | null
    chargesPerHour: number
    societyId: number
    createdAt: Date
    _count: AmenityCountAggregateOutputType | null
    _avg: AmenityAvgAggregateOutputType | null
    _sum: AmenitySumAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  type GetAmenityGroupByPayload<T extends AmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenityGroupByOutputType[P]>
            : GetScalarType<T[P], AmenityGroupByOutputType[P]>
        }
      >
    >


  export type AmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    chargesPerHour?: boolean
    societyId?: boolean
    createdAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    bookings?: boolean | Amenity$bookingsArgs<ExtArgs>
    _count?: boolean | AmenityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amenity"]>



  export type AmenitySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    chargesPerHour?: boolean
    societyId?: boolean
    createdAt?: boolean
  }

  export type AmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "chargesPerHour" | "societyId" | "createdAt", ExtArgs["result"]["amenity"]>
  export type AmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
    bookings?: boolean | Amenity$bookingsArgs<ExtArgs>
    _count?: boolean | AmenityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Amenity"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
      bookings: Prisma.$AmenityBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      chargesPerHour: number
      societyId: number
      createdAt: Date
    }, ExtArgs["result"]["amenity"]>
    composites: {}
  }

  type AmenityGetPayload<S extends boolean | null | undefined | AmenityDefaultArgs> = $Result.GetResult<Prisma.$AmenityPayload, S>

  type AmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmenityCountAggregateInputType | true
    }

  export interface AmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Amenity'], meta: { name: 'Amenity' } }
    /**
     * Find zero or one Amenity that matches the filter.
     * @param {AmenityFindUniqueArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmenityFindUniqueArgs>(args: SelectSubset<T, AmenityFindUniqueArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Amenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmenityFindUniqueOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, AmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmenityFindFirstArgs>(args?: SelectSubset<T, AmenityFindFirstArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, AmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amenities
     * const amenities = await prisma.amenity.findMany()
     * 
     * // Get first 10 Amenities
     * const amenities = await prisma.amenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amenityWithIdOnly = await prisma.amenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmenityFindManyArgs>(args?: SelectSubset<T, AmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Amenity.
     * @param {AmenityCreateArgs} args - Arguments to create a Amenity.
     * @example
     * // Create one Amenity
     * const Amenity = await prisma.amenity.create({
     *   data: {
     *     // ... data to create a Amenity
     *   }
     * })
     * 
     */
    create<T extends AmenityCreateArgs>(args: SelectSubset<T, AmenityCreateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Amenities.
     * @param {AmenityCreateManyArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenity = await prisma.amenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmenityCreateManyArgs>(args?: SelectSubset<T, AmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Amenity.
     * @param {AmenityDeleteArgs} args - Arguments to delete one Amenity.
     * @example
     * // Delete one Amenity
     * const Amenity = await prisma.amenity.delete({
     *   where: {
     *     // ... filter to delete one Amenity
     *   }
     * })
     * 
     */
    delete<T extends AmenityDeleteArgs>(args: SelectSubset<T, AmenityDeleteArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Amenity.
     * @param {AmenityUpdateArgs} args - Arguments to update one Amenity.
     * @example
     * // Update one Amenity
     * const amenity = await prisma.amenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmenityUpdateArgs>(args: SelectSubset<T, AmenityUpdateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Amenities.
     * @param {AmenityDeleteManyArgs} args - Arguments to filter Amenities to delete.
     * @example
     * // Delete a few Amenities
     * const { count } = await prisma.amenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmenityDeleteManyArgs>(args?: SelectSubset<T, AmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amenities
     * const amenity = await prisma.amenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmenityUpdateManyArgs>(args: SelectSubset<T, AmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Amenity.
     * @param {AmenityUpsertArgs} args - Arguments to update or create a Amenity.
     * @example
     * // Update or create a Amenity
     * const amenity = await prisma.amenity.upsert({
     *   create: {
     *     // ... data to create a Amenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amenity we want to update
     *   }
     * })
     */
    upsert<T extends AmenityUpsertArgs>(args: SelectSubset<T, AmenityUpsertArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityCountArgs} args - Arguments to filter Amenities to count.
     * @example
     * // Count the number of Amenities
     * const count = await prisma.amenity.count({
     *   where: {
     *     // ... the filter for the Amenities we want to count
     *   }
     * })
    **/
    count<T extends AmenityCountArgs>(
      args?: Subset<T, AmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenityAggregateArgs>(args: Subset<T, AmenityAggregateArgs>): Prisma.PrismaPromise<GetAmenityAggregateType<T>>

    /**
     * Group by Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmenityGroupByArgs['orderBy'] }
        : { orderBy?: AmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Amenity model
   */
  readonly fields: AmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Amenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookings<T extends Amenity$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Amenity$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Amenity model
   */
  interface AmenityFieldRefs {
    readonly id: FieldRef<"Amenity", 'Int'>
    readonly name: FieldRef<"Amenity", 'String'>
    readonly description: FieldRef<"Amenity", 'String'>
    readonly chargesPerHour: FieldRef<"Amenity", 'Float'>
    readonly societyId: FieldRef<"Amenity", 'Int'>
    readonly createdAt: FieldRef<"Amenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Amenity findUnique
   */
  export type AmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findUniqueOrThrow
   */
  export type AmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findFirst
   */
  export type AmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findFirstOrThrow
   */
  export type AmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findMany
   */
  export type AmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity create
   */
  export type AmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a Amenity.
     */
    data: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
  }

  /**
   * Amenity createMany
   */
  export type AmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Amenities.
     */
    data: AmenityCreateManyInput | AmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenity update
   */
  export type AmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a Amenity.
     */
    data: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
    /**
     * Choose, which Amenity to update.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity updateMany
   */
  export type AmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenity upsert
   */
  export type AmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the Amenity to update in case it exists.
     */
    where: AmenityWhereUniqueInput
    /**
     * In case the Amenity found by the `where` argument doesn't exist, create a new Amenity with this data.
     */
    create: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
    /**
     * In case the Amenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
  }

  /**
   * Amenity delete
   */
  export type AmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter which Amenity to delete.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity deleteMany
   */
  export type AmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to delete
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to delete.
     */
    limit?: number
  }

  /**
   * Amenity.bookings
   */
  export type Amenity$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    where?: AmenityBookingWhereInput
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    cursor?: AmenityBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmenityBookingScalarFieldEnum | AmenityBookingScalarFieldEnum[]
  }

  /**
   * Amenity without action
   */
  export type AmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
  }


  /**
   * Model AmenityBooking
   */

  export type AggregateAmenityBooking = {
    _count: AmenityBookingCountAggregateOutputType | null
    _avg: AmenityBookingAvgAggregateOutputType | null
    _sum: AmenityBookingSumAggregateOutputType | null
    _min: AmenityBookingMinAggregateOutputType | null
    _max: AmenityBookingMaxAggregateOutputType | null
  }

  export type AmenityBookingAvgAggregateOutputType = {
    id: number | null
    amenityId: number | null
    userId: number | null
    amountPaid: number | null
  }

  export type AmenityBookingSumAggregateOutputType = {
    id: number | null
    amenityId: number | null
    userId: number | null
    amountPaid: number | null
  }

  export type AmenityBookingMinAggregateOutputType = {
    id: number | null
    amenityId: number | null
    userId: number | null
    startTime: Date | null
    endTime: Date | null
    status: string | null
    amountPaid: number | null
    createdAt: Date | null
  }

  export type AmenityBookingMaxAggregateOutputType = {
    id: number | null
    amenityId: number | null
    userId: number | null
    startTime: Date | null
    endTime: Date | null
    status: string | null
    amountPaid: number | null
    createdAt: Date | null
  }

  export type AmenityBookingCountAggregateOutputType = {
    id: number
    amenityId: number
    userId: number
    startTime: number
    endTime: number
    status: number
    amountPaid: number
    createdAt: number
    _all: number
  }


  export type AmenityBookingAvgAggregateInputType = {
    id?: true
    amenityId?: true
    userId?: true
    amountPaid?: true
  }

  export type AmenityBookingSumAggregateInputType = {
    id?: true
    amenityId?: true
    userId?: true
    amountPaid?: true
  }

  export type AmenityBookingMinAggregateInputType = {
    id?: true
    amenityId?: true
    userId?: true
    startTime?: true
    endTime?: true
    status?: true
    amountPaid?: true
    createdAt?: true
  }

  export type AmenityBookingMaxAggregateInputType = {
    id?: true
    amenityId?: true
    userId?: true
    startTime?: true
    endTime?: true
    status?: true
    amountPaid?: true
    createdAt?: true
  }

  export type AmenityBookingCountAggregateInputType = {
    id?: true
    amenityId?: true
    userId?: true
    startTime?: true
    endTime?: true
    status?: true
    amountPaid?: true
    createdAt?: true
    _all?: true
  }

  export type AmenityBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmenityBooking to aggregate.
     */
    where?: AmenityBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmenityBookings to fetch.
     */
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmenityBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmenityBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmenityBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AmenityBookings
    **/
    _count?: true | AmenityBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmenityBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmenityBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenityBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenityBookingMaxAggregateInputType
  }

  export type GetAmenityBookingAggregateType<T extends AmenityBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenityBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenityBooking[P]>
      : GetScalarType<T[P], AggregateAmenityBooking[P]>
  }




  export type AmenityBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityBookingWhereInput
    orderBy?: AmenityBookingOrderByWithAggregationInput | AmenityBookingOrderByWithAggregationInput[]
    by: AmenityBookingScalarFieldEnum[] | AmenityBookingScalarFieldEnum
    having?: AmenityBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenityBookingCountAggregateInputType | true
    _avg?: AmenityBookingAvgAggregateInputType
    _sum?: AmenityBookingSumAggregateInputType
    _min?: AmenityBookingMinAggregateInputType
    _max?: AmenityBookingMaxAggregateInputType
  }

  export type AmenityBookingGroupByOutputType = {
    id: number
    amenityId: number
    userId: number
    startTime: Date
    endTime: Date
    status: string
    amountPaid: number
    createdAt: Date
    _count: AmenityBookingCountAggregateOutputType | null
    _avg: AmenityBookingAvgAggregateOutputType | null
    _sum: AmenityBookingSumAggregateOutputType | null
    _min: AmenityBookingMinAggregateOutputType | null
    _max: AmenityBookingMaxAggregateOutputType | null
  }

  type GetAmenityBookingGroupByPayload<T extends AmenityBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenityBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenityBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenityBookingGroupByOutputType[P]>
            : GetScalarType<T[P], AmenityBookingGroupByOutputType[P]>
        }
      >
    >


  export type AmenityBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amenityId?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    amountPaid?: boolean
    createdAt?: boolean
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amenityBooking"]>



  export type AmenityBookingSelectScalar = {
    id?: boolean
    amenityId?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    amountPaid?: boolean
    createdAt?: boolean
  }

  export type AmenityBookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amenityId" | "userId" | "startTime" | "endTime" | "status" | "amountPaid" | "createdAt", ExtArgs["result"]["amenityBooking"]>
  export type AmenityBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AmenityBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AmenityBooking"
    objects: {
      amenity: Prisma.$AmenityPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amenityId: number
      userId: number
      startTime: Date
      endTime: Date
      status: string
      amountPaid: number
      createdAt: Date
    }, ExtArgs["result"]["amenityBooking"]>
    composites: {}
  }

  type AmenityBookingGetPayload<S extends boolean | null | undefined | AmenityBookingDefaultArgs> = $Result.GetResult<Prisma.$AmenityBookingPayload, S>

  type AmenityBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmenityBookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmenityBookingCountAggregateInputType | true
    }

  export interface AmenityBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AmenityBooking'], meta: { name: 'AmenityBooking' } }
    /**
     * Find zero or one AmenityBooking that matches the filter.
     * @param {AmenityBookingFindUniqueArgs} args - Arguments to find a AmenityBooking
     * @example
     * // Get one AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmenityBookingFindUniqueArgs>(args: SelectSubset<T, AmenityBookingFindUniqueArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AmenityBooking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmenityBookingFindUniqueOrThrowArgs} args - Arguments to find a AmenityBooking
     * @example
     * // Get one AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmenityBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, AmenityBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmenityBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingFindFirstArgs} args - Arguments to find a AmenityBooking
     * @example
     * // Get one AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmenityBookingFindFirstArgs>(args?: SelectSubset<T, AmenityBookingFindFirstArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmenityBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingFindFirstOrThrowArgs} args - Arguments to find a AmenityBooking
     * @example
     * // Get one AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmenityBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, AmenityBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AmenityBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AmenityBookings
     * const amenityBookings = await prisma.amenityBooking.findMany()
     * 
     * // Get first 10 AmenityBookings
     * const amenityBookings = await prisma.amenityBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amenityBookingWithIdOnly = await prisma.amenityBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmenityBookingFindManyArgs>(args?: SelectSubset<T, AmenityBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AmenityBooking.
     * @param {AmenityBookingCreateArgs} args - Arguments to create a AmenityBooking.
     * @example
     * // Create one AmenityBooking
     * const AmenityBooking = await prisma.amenityBooking.create({
     *   data: {
     *     // ... data to create a AmenityBooking
     *   }
     * })
     * 
     */
    create<T extends AmenityBookingCreateArgs>(args: SelectSubset<T, AmenityBookingCreateArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AmenityBookings.
     * @param {AmenityBookingCreateManyArgs} args - Arguments to create many AmenityBookings.
     * @example
     * // Create many AmenityBookings
     * const amenityBooking = await prisma.amenityBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmenityBookingCreateManyArgs>(args?: SelectSubset<T, AmenityBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AmenityBooking.
     * @param {AmenityBookingDeleteArgs} args - Arguments to delete one AmenityBooking.
     * @example
     * // Delete one AmenityBooking
     * const AmenityBooking = await prisma.amenityBooking.delete({
     *   where: {
     *     // ... filter to delete one AmenityBooking
     *   }
     * })
     * 
     */
    delete<T extends AmenityBookingDeleteArgs>(args: SelectSubset<T, AmenityBookingDeleteArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AmenityBooking.
     * @param {AmenityBookingUpdateArgs} args - Arguments to update one AmenityBooking.
     * @example
     * // Update one AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmenityBookingUpdateArgs>(args: SelectSubset<T, AmenityBookingUpdateArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AmenityBookings.
     * @param {AmenityBookingDeleteManyArgs} args - Arguments to filter AmenityBookings to delete.
     * @example
     * // Delete a few AmenityBookings
     * const { count } = await prisma.amenityBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmenityBookingDeleteManyArgs>(args?: SelectSubset<T, AmenityBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmenityBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AmenityBookings
     * const amenityBooking = await prisma.amenityBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmenityBookingUpdateManyArgs>(args: SelectSubset<T, AmenityBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AmenityBooking.
     * @param {AmenityBookingUpsertArgs} args - Arguments to update or create a AmenityBooking.
     * @example
     * // Update or create a AmenityBooking
     * const amenityBooking = await prisma.amenityBooking.upsert({
     *   create: {
     *     // ... data to create a AmenityBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AmenityBooking we want to update
     *   }
     * })
     */
    upsert<T extends AmenityBookingUpsertArgs>(args: SelectSubset<T, AmenityBookingUpsertArgs<ExtArgs>>): Prisma__AmenityBookingClient<$Result.GetResult<Prisma.$AmenityBookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AmenityBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingCountArgs} args - Arguments to filter AmenityBookings to count.
     * @example
     * // Count the number of AmenityBookings
     * const count = await prisma.amenityBooking.count({
     *   where: {
     *     // ... the filter for the AmenityBookings we want to count
     *   }
     * })
    **/
    count<T extends AmenityBookingCountArgs>(
      args?: Subset<T, AmenityBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenityBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AmenityBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenityBookingAggregateArgs>(args: Subset<T, AmenityBookingAggregateArgs>): Prisma.PrismaPromise<GetAmenityBookingAggregateType<T>>

    /**
     * Group by AmenityBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmenityBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmenityBookingGroupByArgs['orderBy'] }
        : { orderBy?: AmenityBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmenityBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenityBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AmenityBooking model
   */
  readonly fields: AmenityBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AmenityBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmenityBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    amenity<T extends AmenityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AmenityDefaultArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AmenityBooking model
   */
  interface AmenityBookingFieldRefs {
    readonly id: FieldRef<"AmenityBooking", 'Int'>
    readonly amenityId: FieldRef<"AmenityBooking", 'Int'>
    readonly userId: FieldRef<"AmenityBooking", 'Int'>
    readonly startTime: FieldRef<"AmenityBooking", 'DateTime'>
    readonly endTime: FieldRef<"AmenityBooking", 'DateTime'>
    readonly status: FieldRef<"AmenityBooking", 'String'>
    readonly amountPaid: FieldRef<"AmenityBooking", 'Float'>
    readonly createdAt: FieldRef<"AmenityBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AmenityBooking findUnique
   */
  export type AmenityBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter, which AmenityBooking to fetch.
     */
    where: AmenityBookingWhereUniqueInput
  }

  /**
   * AmenityBooking findUniqueOrThrow
   */
  export type AmenityBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter, which AmenityBooking to fetch.
     */
    where: AmenityBookingWhereUniqueInput
  }

  /**
   * AmenityBooking findFirst
   */
  export type AmenityBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter, which AmenityBooking to fetch.
     */
    where?: AmenityBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmenityBookings to fetch.
     */
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmenityBookings.
     */
    cursor?: AmenityBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmenityBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmenityBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmenityBookings.
     */
    distinct?: AmenityBookingScalarFieldEnum | AmenityBookingScalarFieldEnum[]
  }

  /**
   * AmenityBooking findFirstOrThrow
   */
  export type AmenityBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter, which AmenityBooking to fetch.
     */
    where?: AmenityBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmenityBookings to fetch.
     */
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmenityBookings.
     */
    cursor?: AmenityBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmenityBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmenityBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmenityBookings.
     */
    distinct?: AmenityBookingScalarFieldEnum | AmenityBookingScalarFieldEnum[]
  }

  /**
   * AmenityBooking findMany
   */
  export type AmenityBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter, which AmenityBookings to fetch.
     */
    where?: AmenityBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmenityBookings to fetch.
     */
    orderBy?: AmenityBookingOrderByWithRelationInput | AmenityBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AmenityBookings.
     */
    cursor?: AmenityBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmenityBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmenityBookings.
     */
    skip?: number
    distinct?: AmenityBookingScalarFieldEnum | AmenityBookingScalarFieldEnum[]
  }

  /**
   * AmenityBooking create
   */
  export type AmenityBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a AmenityBooking.
     */
    data: XOR<AmenityBookingCreateInput, AmenityBookingUncheckedCreateInput>
  }

  /**
   * AmenityBooking createMany
   */
  export type AmenityBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AmenityBookings.
     */
    data: AmenityBookingCreateManyInput | AmenityBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AmenityBooking update
   */
  export type AmenityBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a AmenityBooking.
     */
    data: XOR<AmenityBookingUpdateInput, AmenityBookingUncheckedUpdateInput>
    /**
     * Choose, which AmenityBooking to update.
     */
    where: AmenityBookingWhereUniqueInput
  }

  /**
   * AmenityBooking updateMany
   */
  export type AmenityBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AmenityBookings.
     */
    data: XOR<AmenityBookingUpdateManyMutationInput, AmenityBookingUncheckedUpdateManyInput>
    /**
     * Filter which AmenityBookings to update
     */
    where?: AmenityBookingWhereInput
    /**
     * Limit how many AmenityBookings to update.
     */
    limit?: number
  }

  /**
   * AmenityBooking upsert
   */
  export type AmenityBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the AmenityBooking to update in case it exists.
     */
    where: AmenityBookingWhereUniqueInput
    /**
     * In case the AmenityBooking found by the `where` argument doesn't exist, create a new AmenityBooking with this data.
     */
    create: XOR<AmenityBookingCreateInput, AmenityBookingUncheckedCreateInput>
    /**
     * In case the AmenityBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmenityBookingUpdateInput, AmenityBookingUncheckedUpdateInput>
  }

  /**
   * AmenityBooking delete
   */
  export type AmenityBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
    /**
     * Filter which AmenityBooking to delete.
     */
    where: AmenityBookingWhereUniqueInput
  }

  /**
   * AmenityBooking deleteMany
   */
  export type AmenityBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmenityBookings to delete
     */
    where?: AmenityBookingWhereInput
    /**
     * Limit how many AmenityBookings to delete.
     */
    limit?: number
  }

  /**
   * AmenityBooking without action
   */
  export type AmenityBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityBooking
     */
    select?: AmenityBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmenityBooking
     */
    omit?: AmenityBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityBookingInclude<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _avg: SystemSettingAvgAggregateOutputType | null
    _sum: SystemSettingSumAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingAvgAggregateOutputType = {
    id: number | null
  }

  export type SystemSettingSumAggregateOutputType = {
    id: number | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    _all: number
  }


  export type SystemSettingAvgAggregateInputType = {
    id?: true
  }

  export type SystemSettingSumAggregateInputType = {
    id?: true
  }

  export type SystemSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _avg?: SystemSettingAvgAggregateInputType
    _sum?: SystemSettingSumAggregateInputType
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: number
    key: string
    value: string
    _count: SystemSettingCountAggregateOutputType | null
    _avg: SystemSettingAvgAggregateOutputType | null
    _sum: SystemSettingSumAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["systemSetting"]>



  export type SystemSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
  }

  export type SystemSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value", ExtArgs["result"]["systemSetting"]>

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: string
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'Int'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
  }


  /**
   * Model BillingPlan
   */

  export type AggregateBillingPlan = {
    _count: BillingPlanCountAggregateOutputType | null
    _avg: BillingPlanAvgAggregateOutputType | null
    _sum: BillingPlanSumAggregateOutputType | null
    _min: BillingPlanMinAggregateOutputType | null
    _max: BillingPlanMaxAggregateOutputType | null
  }

  export type BillingPlanAvgAggregateOutputType = {
    id: number | null
  }

  export type BillingPlanSumAggregateOutputType = {
    id: number | null
  }

  export type BillingPlanMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    price: string | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingPlanMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    price: string | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingPlanCountAggregateOutputType = {
    id: number
    name: number
    type: number
    price: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillingPlanAvgAggregateInputType = {
    id?: true
  }

  export type BillingPlanSumAggregateInputType = {
    id?: true
  }

  export type BillingPlanMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    price?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingPlanMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    price?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingPlanCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    price?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillingPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingPlan to aggregate.
     */
    where?: BillingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPlans to fetch.
     */
    orderBy?: BillingPlanOrderByWithRelationInput | BillingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingPlans
    **/
    _count?: true | BillingPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingPlanMaxAggregateInputType
  }

  export type GetBillingPlanAggregateType<T extends BillingPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingPlan[P]>
      : GetScalarType<T[P], AggregateBillingPlan[P]>
  }




  export type BillingPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingPlanWhereInput
    orderBy?: BillingPlanOrderByWithAggregationInput | BillingPlanOrderByWithAggregationInput[]
    by: BillingPlanScalarFieldEnum[] | BillingPlanScalarFieldEnum
    having?: BillingPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingPlanCountAggregateInputType | true
    _avg?: BillingPlanAvgAggregateInputType
    _sum?: BillingPlanSumAggregateInputType
    _min?: BillingPlanMinAggregateInputType
    _max?: BillingPlanMaxAggregateInputType
  }

  export type BillingPlanGroupByOutputType = {
    id: number
    name: string
    type: string
    price: string
    description: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: BillingPlanCountAggregateOutputType | null
    _avg: BillingPlanAvgAggregateOutputType | null
    _sum: BillingPlanSumAggregateOutputType | null
    _min: BillingPlanMinAggregateOutputType | null
    _max: BillingPlanMaxAggregateOutputType | null
  }

  type GetBillingPlanGroupByPayload<T extends BillingPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingPlanGroupByOutputType[P]>
            : GetScalarType<T[P], BillingPlanGroupByOutputType[P]>
        }
      >
    >


  export type BillingPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    price?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["billingPlan"]>



  export type BillingPlanSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    price?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillingPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "price" | "description" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["billingPlan"]>

  export type $BillingPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingPlan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      price: string
      description: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["billingPlan"]>
    composites: {}
  }

  type BillingPlanGetPayload<S extends boolean | null | undefined | BillingPlanDefaultArgs> = $Result.GetResult<Prisma.$BillingPlanPayload, S>

  type BillingPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingPlanCountAggregateInputType | true
    }

  export interface BillingPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingPlan'], meta: { name: 'BillingPlan' } }
    /**
     * Find zero or one BillingPlan that matches the filter.
     * @param {BillingPlanFindUniqueArgs} args - Arguments to find a BillingPlan
     * @example
     * // Get one BillingPlan
     * const billingPlan = await prisma.billingPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingPlanFindUniqueArgs>(args: SelectSubset<T, BillingPlanFindUniqueArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingPlanFindUniqueOrThrowArgs} args - Arguments to find a BillingPlan
     * @example
     * // Get one BillingPlan
     * const billingPlan = await prisma.billingPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanFindFirstArgs} args - Arguments to find a BillingPlan
     * @example
     * // Get one BillingPlan
     * const billingPlan = await prisma.billingPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingPlanFindFirstArgs>(args?: SelectSubset<T, BillingPlanFindFirstArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanFindFirstOrThrowArgs} args - Arguments to find a BillingPlan
     * @example
     * // Get one BillingPlan
     * const billingPlan = await prisma.billingPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingPlans
     * const billingPlans = await prisma.billingPlan.findMany()
     * 
     * // Get first 10 BillingPlans
     * const billingPlans = await prisma.billingPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingPlanWithIdOnly = await prisma.billingPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingPlanFindManyArgs>(args?: SelectSubset<T, BillingPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingPlan.
     * @param {BillingPlanCreateArgs} args - Arguments to create a BillingPlan.
     * @example
     * // Create one BillingPlan
     * const BillingPlan = await prisma.billingPlan.create({
     *   data: {
     *     // ... data to create a BillingPlan
     *   }
     * })
     * 
     */
    create<T extends BillingPlanCreateArgs>(args: SelectSubset<T, BillingPlanCreateArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingPlans.
     * @param {BillingPlanCreateManyArgs} args - Arguments to create many BillingPlans.
     * @example
     * // Create many BillingPlans
     * const billingPlan = await prisma.billingPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingPlanCreateManyArgs>(args?: SelectSubset<T, BillingPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BillingPlan.
     * @param {BillingPlanDeleteArgs} args - Arguments to delete one BillingPlan.
     * @example
     * // Delete one BillingPlan
     * const BillingPlan = await prisma.billingPlan.delete({
     *   where: {
     *     // ... filter to delete one BillingPlan
     *   }
     * })
     * 
     */
    delete<T extends BillingPlanDeleteArgs>(args: SelectSubset<T, BillingPlanDeleteArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingPlan.
     * @param {BillingPlanUpdateArgs} args - Arguments to update one BillingPlan.
     * @example
     * // Update one BillingPlan
     * const billingPlan = await prisma.billingPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingPlanUpdateArgs>(args: SelectSubset<T, BillingPlanUpdateArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingPlans.
     * @param {BillingPlanDeleteManyArgs} args - Arguments to filter BillingPlans to delete.
     * @example
     * // Delete a few BillingPlans
     * const { count } = await prisma.billingPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingPlanDeleteManyArgs>(args?: SelectSubset<T, BillingPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingPlans
     * const billingPlan = await prisma.billingPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingPlanUpdateManyArgs>(args: SelectSubset<T, BillingPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BillingPlan.
     * @param {BillingPlanUpsertArgs} args - Arguments to update or create a BillingPlan.
     * @example
     * // Update or create a BillingPlan
     * const billingPlan = await prisma.billingPlan.upsert({
     *   create: {
     *     // ... data to create a BillingPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingPlan we want to update
     *   }
     * })
     */
    upsert<T extends BillingPlanUpsertArgs>(args: SelectSubset<T, BillingPlanUpsertArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanCountArgs} args - Arguments to filter BillingPlans to count.
     * @example
     * // Count the number of BillingPlans
     * const count = await prisma.billingPlan.count({
     *   where: {
     *     // ... the filter for the BillingPlans we want to count
     *   }
     * })
    **/
    count<T extends BillingPlanCountArgs>(
      args?: Subset<T, BillingPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingPlanAggregateArgs>(args: Subset<T, BillingPlanAggregateArgs>): Prisma.PrismaPromise<GetBillingPlanAggregateType<T>>

    /**
     * Group by BillingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingPlanGroupByArgs['orderBy'] }
        : { orderBy?: BillingPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingPlan model
   */
  readonly fields: BillingPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingPlan model
   */
  interface BillingPlanFieldRefs {
    readonly id: FieldRef<"BillingPlan", 'Int'>
    readonly name: FieldRef<"BillingPlan", 'String'>
    readonly type: FieldRef<"BillingPlan", 'String'>
    readonly price: FieldRef<"BillingPlan", 'String'>
    readonly description: FieldRef<"BillingPlan", 'String'>
    readonly status: FieldRef<"BillingPlan", 'String'>
    readonly createdAt: FieldRef<"BillingPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"BillingPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillingPlan findUnique
   */
  export type BillingPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Filter, which BillingPlan to fetch.
     */
    where: BillingPlanWhereUniqueInput
  }

  /**
   * BillingPlan findUniqueOrThrow
   */
  export type BillingPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Filter, which BillingPlan to fetch.
     */
    where: BillingPlanWhereUniqueInput
  }

  /**
   * BillingPlan findFirst
   */
  export type BillingPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Filter, which BillingPlan to fetch.
     */
    where?: BillingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPlans to fetch.
     */
    orderBy?: BillingPlanOrderByWithRelationInput | BillingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingPlans.
     */
    cursor?: BillingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingPlans.
     */
    distinct?: BillingPlanScalarFieldEnum | BillingPlanScalarFieldEnum[]
  }

  /**
   * BillingPlan findFirstOrThrow
   */
  export type BillingPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Filter, which BillingPlan to fetch.
     */
    where?: BillingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPlans to fetch.
     */
    orderBy?: BillingPlanOrderByWithRelationInput | BillingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingPlans.
     */
    cursor?: BillingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingPlans.
     */
    distinct?: BillingPlanScalarFieldEnum | BillingPlanScalarFieldEnum[]
  }

  /**
   * BillingPlan findMany
   */
  export type BillingPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Filter, which BillingPlans to fetch.
     */
    where?: BillingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPlans to fetch.
     */
    orderBy?: BillingPlanOrderByWithRelationInput | BillingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingPlans.
     */
    cursor?: BillingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPlans.
     */
    skip?: number
    distinct?: BillingPlanScalarFieldEnum | BillingPlanScalarFieldEnum[]
  }

  /**
   * BillingPlan create
   */
  export type BillingPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * The data needed to create a BillingPlan.
     */
    data: XOR<BillingPlanCreateInput, BillingPlanUncheckedCreateInput>
  }

  /**
   * BillingPlan createMany
   */
  export type BillingPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingPlans.
     */
    data: BillingPlanCreateManyInput | BillingPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingPlan update
   */
  export type BillingPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * The data needed to update a BillingPlan.
     */
    data: XOR<BillingPlanUpdateInput, BillingPlanUncheckedUpdateInput>
    /**
     * Choose, which BillingPlan to update.
     */
    where: BillingPlanWhereUniqueInput
  }

  /**
   * BillingPlan updateMany
   */
  export type BillingPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingPlans.
     */
    data: XOR<BillingPlanUpdateManyMutationInput, BillingPlanUncheckedUpdateManyInput>
    /**
     * Filter which BillingPlans to update
     */
    where?: BillingPlanWhereInput
    /**
     * Limit how many BillingPlans to update.
     */
    limit?: number
  }

  /**
   * BillingPlan upsert
   */
  export type BillingPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * The filter to search for the BillingPlan to update in case it exists.
     */
    where: BillingPlanWhereUniqueInput
    /**
     * In case the BillingPlan found by the `where` argument doesn't exist, create a new BillingPlan with this data.
     */
    create: XOR<BillingPlanCreateInput, BillingPlanUncheckedCreateInput>
    /**
     * In case the BillingPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingPlanUpdateInput, BillingPlanUncheckedUpdateInput>
  }

  /**
   * BillingPlan delete
   */
  export type BillingPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Filter which BillingPlan to delete.
     */
    where: BillingPlanWhereUniqueInput
  }

  /**
   * BillingPlan deleteMany
   */
  export type BillingPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingPlans to delete
     */
    where?: BillingPlanWhereInput
    /**
     * Limit how many BillingPlans to delete.
     */
    limit?: number
  }

  /**
   * BillingPlan without action
   */
  export type BillingPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
  }


  /**
   * Model PlatformInvoice
   */

  export type AggregatePlatformInvoice = {
    _count: PlatformInvoiceCountAggregateOutputType | null
    _avg: PlatformInvoiceAvgAggregateOutputType | null
    _sum: PlatformInvoiceSumAggregateOutputType | null
    _min: PlatformInvoiceMinAggregateOutputType | null
    _max: PlatformInvoiceMaxAggregateOutputType | null
  }

  export type PlatformInvoiceAvgAggregateOutputType = {
    id: number | null
    societyId: number | null
    amount: number | null
  }

  export type PlatformInvoiceSumAggregateOutputType = {
    id: number | null
    societyId: number | null
    amount: number | null
  }

  export type PlatformInvoiceMinAggregateOutputType = {
    id: number | null
    invoiceNo: string | null
    societyId: number | null
    amount: number | null
    status: string | null
    issueDate: Date | null
    dueDate: Date | null
    paidDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformInvoiceMaxAggregateOutputType = {
    id: number | null
    invoiceNo: string | null
    societyId: number | null
    amount: number | null
    status: string | null
    issueDate: Date | null
    dueDate: Date | null
    paidDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformInvoiceCountAggregateOutputType = {
    id: number
    invoiceNo: number
    societyId: number
    amount: number
    status: number
    issueDate: number
    dueDate: number
    paidDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlatformInvoiceAvgAggregateInputType = {
    id?: true
    societyId?: true
    amount?: true
  }

  export type PlatformInvoiceSumAggregateInputType = {
    id?: true
    societyId?: true
    amount?: true
  }

  export type PlatformInvoiceMinAggregateInputType = {
    id?: true
    invoiceNo?: true
    societyId?: true
    amount?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformInvoiceMaxAggregateInputType = {
    id?: true
    invoiceNo?: true
    societyId?: true
    amount?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformInvoiceCountAggregateInputType = {
    id?: true
    invoiceNo?: true
    societyId?: true
    amount?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlatformInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformInvoice to aggregate.
     */
    where?: PlatformInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformInvoices to fetch.
     */
    orderBy?: PlatformInvoiceOrderByWithRelationInput | PlatformInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlatformInvoices
    **/
    _count?: true | PlatformInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlatformInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlatformInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformInvoiceMaxAggregateInputType
  }

  export type GetPlatformInvoiceAggregateType<T extends PlatformInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatformInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatformInvoice[P]>
      : GetScalarType<T[P], AggregatePlatformInvoice[P]>
  }




  export type PlatformInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformInvoiceWhereInput
    orderBy?: PlatformInvoiceOrderByWithAggregationInput | PlatformInvoiceOrderByWithAggregationInput[]
    by: PlatformInvoiceScalarFieldEnum[] | PlatformInvoiceScalarFieldEnum
    having?: PlatformInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformInvoiceCountAggregateInputType | true
    _avg?: PlatformInvoiceAvgAggregateInputType
    _sum?: PlatformInvoiceSumAggregateInputType
    _min?: PlatformInvoiceMinAggregateInputType
    _max?: PlatformInvoiceMaxAggregateInputType
  }

  export type PlatformInvoiceGroupByOutputType = {
    id: number
    invoiceNo: string
    societyId: number
    amount: number
    status: string
    issueDate: Date
    dueDate: Date
    paidDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PlatformInvoiceCountAggregateOutputType | null
    _avg: PlatformInvoiceAvgAggregateOutputType | null
    _sum: PlatformInvoiceSumAggregateOutputType | null
    _min: PlatformInvoiceMinAggregateOutputType | null
    _max: PlatformInvoiceMaxAggregateOutputType | null
  }

  type GetPlatformInvoiceGroupByPayload<T extends PlatformInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type PlatformInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNo?: boolean
    societyId?: boolean
    amount?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformInvoice"]>



  export type PlatformInvoiceSelectScalar = {
    id?: boolean
    invoiceNo?: boolean
    societyId?: boolean
    amount?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlatformInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNo" | "societyId" | "amount" | "status" | "issueDate" | "dueDate" | "paidDate" | "createdAt" | "updatedAt", ExtArgs["result"]["platformInvoice"]>
  export type PlatformInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    society?: boolean | SocietyDefaultArgs<ExtArgs>
  }

  export type $PlatformInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlatformInvoice"
    objects: {
      society: Prisma.$SocietyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceNo: string
      societyId: number
      amount: number
      status: string
      issueDate: Date
      dueDate: Date
      paidDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["platformInvoice"]>
    composites: {}
  }

  type PlatformInvoiceGetPayload<S extends boolean | null | undefined | PlatformInvoiceDefaultArgs> = $Result.GetResult<Prisma.$PlatformInvoicePayload, S>

  type PlatformInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlatformInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlatformInvoiceCountAggregateInputType | true
    }

  export interface PlatformInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlatformInvoice'], meta: { name: 'PlatformInvoice' } }
    /**
     * Find zero or one PlatformInvoice that matches the filter.
     * @param {PlatformInvoiceFindUniqueArgs} args - Arguments to find a PlatformInvoice
     * @example
     * // Get one PlatformInvoice
     * const platformInvoice = await prisma.platformInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformInvoiceFindUniqueArgs>(args: SelectSubset<T, PlatformInvoiceFindUniqueArgs<ExtArgs>>): Prisma__PlatformInvoiceClient<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlatformInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlatformInvoiceFindUniqueOrThrowArgs} args - Arguments to find a PlatformInvoice
     * @example
     * // Get one PlatformInvoice
     * const platformInvoice = await prisma.platformInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformInvoiceClient<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformInvoiceFindFirstArgs} args - Arguments to find a PlatformInvoice
     * @example
     * // Get one PlatformInvoice
     * const platformInvoice = await prisma.platformInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformInvoiceFindFirstArgs>(args?: SelectSubset<T, PlatformInvoiceFindFirstArgs<ExtArgs>>): Prisma__PlatformInvoiceClient<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformInvoiceFindFirstOrThrowArgs} args - Arguments to find a PlatformInvoice
     * @example
     * // Get one PlatformInvoice
     * const platformInvoice = await prisma.platformInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformInvoiceClient<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlatformInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlatformInvoices
     * const platformInvoices = await prisma.platformInvoice.findMany()
     * 
     * // Get first 10 PlatformInvoices
     * const platformInvoices = await prisma.platformInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformInvoiceWithIdOnly = await prisma.platformInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformInvoiceFindManyArgs>(args?: SelectSubset<T, PlatformInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlatformInvoice.
     * @param {PlatformInvoiceCreateArgs} args - Arguments to create a PlatformInvoice.
     * @example
     * // Create one PlatformInvoice
     * const PlatformInvoice = await prisma.platformInvoice.create({
     *   data: {
     *     // ... data to create a PlatformInvoice
     *   }
     * })
     * 
     */
    create<T extends PlatformInvoiceCreateArgs>(args: SelectSubset<T, PlatformInvoiceCreateArgs<ExtArgs>>): Prisma__PlatformInvoiceClient<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlatformInvoices.
     * @param {PlatformInvoiceCreateManyArgs} args - Arguments to create many PlatformInvoices.
     * @example
     * // Create many PlatformInvoices
     * const platformInvoice = await prisma.platformInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformInvoiceCreateManyArgs>(args?: SelectSubset<T, PlatformInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlatformInvoice.
     * @param {PlatformInvoiceDeleteArgs} args - Arguments to delete one PlatformInvoice.
     * @example
     * // Delete one PlatformInvoice
     * const PlatformInvoice = await prisma.platformInvoice.delete({
     *   where: {
     *     // ... filter to delete one PlatformInvoice
     *   }
     * })
     * 
     */
    delete<T extends PlatformInvoiceDeleteArgs>(args: SelectSubset<T, PlatformInvoiceDeleteArgs<ExtArgs>>): Prisma__PlatformInvoiceClient<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlatformInvoice.
     * @param {PlatformInvoiceUpdateArgs} args - Arguments to update one PlatformInvoice.
     * @example
     * // Update one PlatformInvoice
     * const platformInvoice = await prisma.platformInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformInvoiceUpdateArgs>(args: SelectSubset<T, PlatformInvoiceUpdateArgs<ExtArgs>>): Prisma__PlatformInvoiceClient<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlatformInvoices.
     * @param {PlatformInvoiceDeleteManyArgs} args - Arguments to filter PlatformInvoices to delete.
     * @example
     * // Delete a few PlatformInvoices
     * const { count } = await prisma.platformInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformInvoiceDeleteManyArgs>(args?: SelectSubset<T, PlatformInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlatformInvoices
     * const platformInvoice = await prisma.platformInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformInvoiceUpdateManyArgs>(args: SelectSubset<T, PlatformInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlatformInvoice.
     * @param {PlatformInvoiceUpsertArgs} args - Arguments to update or create a PlatformInvoice.
     * @example
     * // Update or create a PlatformInvoice
     * const platformInvoice = await prisma.platformInvoice.upsert({
     *   create: {
     *     // ... data to create a PlatformInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlatformInvoice we want to update
     *   }
     * })
     */
    upsert<T extends PlatformInvoiceUpsertArgs>(args: SelectSubset<T, PlatformInvoiceUpsertArgs<ExtArgs>>): Prisma__PlatformInvoiceClient<$Result.GetResult<Prisma.$PlatformInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlatformInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformInvoiceCountArgs} args - Arguments to filter PlatformInvoices to count.
     * @example
     * // Count the number of PlatformInvoices
     * const count = await prisma.platformInvoice.count({
     *   where: {
     *     // ... the filter for the PlatformInvoices we want to count
     *   }
     * })
    **/
    count<T extends PlatformInvoiceCountArgs>(
      args?: Subset<T, PlatformInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlatformInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformInvoiceAggregateArgs>(args: Subset<T, PlatformInvoiceAggregateArgs>): Prisma.PrismaPromise<GetPlatformInvoiceAggregateType<T>>

    /**
     * Group by PlatformInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: PlatformInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlatformInvoice model
   */
  readonly fields: PlatformInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlatformInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    society<T extends SocietyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocietyDefaultArgs<ExtArgs>>): Prisma__SocietyClient<$Result.GetResult<Prisma.$SocietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlatformInvoice model
   */
  interface PlatformInvoiceFieldRefs {
    readonly id: FieldRef<"PlatformInvoice", 'Int'>
    readonly invoiceNo: FieldRef<"PlatformInvoice", 'String'>
    readonly societyId: FieldRef<"PlatformInvoice", 'Int'>
    readonly amount: FieldRef<"PlatformInvoice", 'Float'>
    readonly status: FieldRef<"PlatformInvoice", 'String'>
    readonly issueDate: FieldRef<"PlatformInvoice", 'DateTime'>
    readonly dueDate: FieldRef<"PlatformInvoice", 'DateTime'>
    readonly paidDate: FieldRef<"PlatformInvoice", 'DateTime'>
    readonly createdAt: FieldRef<"PlatformInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"PlatformInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlatformInvoice findUnique
   */
  export type PlatformInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PlatformInvoice to fetch.
     */
    where: PlatformInvoiceWhereUniqueInput
  }

  /**
   * PlatformInvoice findUniqueOrThrow
   */
  export type PlatformInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PlatformInvoice to fetch.
     */
    where: PlatformInvoiceWhereUniqueInput
  }

  /**
   * PlatformInvoice findFirst
   */
  export type PlatformInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PlatformInvoice to fetch.
     */
    where?: PlatformInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformInvoices to fetch.
     */
    orderBy?: PlatformInvoiceOrderByWithRelationInput | PlatformInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformInvoices.
     */
    cursor?: PlatformInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformInvoices.
     */
    distinct?: PlatformInvoiceScalarFieldEnum | PlatformInvoiceScalarFieldEnum[]
  }

  /**
   * PlatformInvoice findFirstOrThrow
   */
  export type PlatformInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PlatformInvoice to fetch.
     */
    where?: PlatformInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformInvoices to fetch.
     */
    orderBy?: PlatformInvoiceOrderByWithRelationInput | PlatformInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformInvoices.
     */
    cursor?: PlatformInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformInvoices.
     */
    distinct?: PlatformInvoiceScalarFieldEnum | PlatformInvoiceScalarFieldEnum[]
  }

  /**
   * PlatformInvoice findMany
   */
  export type PlatformInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PlatformInvoices to fetch.
     */
    where?: PlatformInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformInvoices to fetch.
     */
    orderBy?: PlatformInvoiceOrderByWithRelationInput | PlatformInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlatformInvoices.
     */
    cursor?: PlatformInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformInvoices.
     */
    skip?: number
    distinct?: PlatformInvoiceScalarFieldEnum | PlatformInvoiceScalarFieldEnum[]
  }

  /**
   * PlatformInvoice create
   */
  export type PlatformInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a PlatformInvoice.
     */
    data: XOR<PlatformInvoiceCreateInput, PlatformInvoiceUncheckedCreateInput>
  }

  /**
   * PlatformInvoice createMany
   */
  export type PlatformInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlatformInvoices.
     */
    data: PlatformInvoiceCreateManyInput | PlatformInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformInvoice update
   */
  export type PlatformInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a PlatformInvoice.
     */
    data: XOR<PlatformInvoiceUpdateInput, PlatformInvoiceUncheckedUpdateInput>
    /**
     * Choose, which PlatformInvoice to update.
     */
    where: PlatformInvoiceWhereUniqueInput
  }

  /**
   * PlatformInvoice updateMany
   */
  export type PlatformInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlatformInvoices.
     */
    data: XOR<PlatformInvoiceUpdateManyMutationInput, PlatformInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which PlatformInvoices to update
     */
    where?: PlatformInvoiceWhereInput
    /**
     * Limit how many PlatformInvoices to update.
     */
    limit?: number
  }

  /**
   * PlatformInvoice upsert
   */
  export type PlatformInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the PlatformInvoice to update in case it exists.
     */
    where: PlatformInvoiceWhereUniqueInput
    /**
     * In case the PlatformInvoice found by the `where` argument doesn't exist, create a new PlatformInvoice with this data.
     */
    create: XOR<PlatformInvoiceCreateInput, PlatformInvoiceUncheckedCreateInput>
    /**
     * In case the PlatformInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformInvoiceUpdateInput, PlatformInvoiceUncheckedUpdateInput>
  }

  /**
   * PlatformInvoice delete
   */
  export type PlatformInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
    /**
     * Filter which PlatformInvoice to delete.
     */
    where: PlatformInvoiceWhereUniqueInput
  }

  /**
   * PlatformInvoice deleteMany
   */
  export type PlatformInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformInvoices to delete
     */
    where?: PlatformInvoiceWhereInput
    /**
     * Limit how many PlatformInvoices to delete.
     */
    limit?: number
  }

  /**
   * PlatformInvoice without action
   */
  export type PlatformInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformInvoice
     */
    select?: PlatformInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformInvoice
     */
    omit?: PlatformInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInvoiceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SocietyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    city: 'city',
    state: 'state',
    pincode: 'pincode',
    code: 'code',
    status: 'status',
    subscriptionPlan: 'subscriptionPlan',
    expectedUnits: 'expectedUnits',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocietyScalarFieldEnum = (typeof SocietyScalarFieldEnum)[keyof typeof SocietyScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    phone: 'phone',
    role: 'role',
    status: 'status',
    profileImg: 'profileImg',
    societyId: 'societyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    block: 'block',
    number: 'number',
    floor: 'floor',
    type: 'type',
    areaSqFt: 'areaSqFt',
    societyId: 'societyId',
    ownerId: 'ownerId',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const ParkingSlotScalarFieldEnum: {
    id: 'id',
    number: 'number',
    type: 'type',
    status: 'status',
    societyId: 'societyId',
    allocatedToUnitId: 'allocatedToUnitId',
    vehicleNumber: 'vehicleNumber',
    createdAt: 'createdAt'
  };

  export type ParkingSlotScalarFieldEnum = (typeof ParkingSlotScalarFieldEnum)[keyof typeof ParkingSlotScalarFieldEnum]


  export const ComplaintScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    priority: 'priority',
    status: 'status',
    images: 'images',
    societyId: 'societyId',
    reportedById: 'reportedById',
    assignedToId: 'assignedToId',
    timeline: 'timeline',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComplaintScalarFieldEnum = (typeof ComplaintScalarFieldEnum)[keyof typeof ComplaintScalarFieldEnum]


  export const ComplaintCommentScalarFieldEnum: {
    id: 'id',
    complaintId: 'complaintId',
    userId: 'userId',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type ComplaintCommentScalarFieldEnum = (typeof ComplaintCommentScalarFieldEnum)[keyof typeof ComplaintCommentScalarFieldEnum]


  export const VisitorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    vehicleNo: 'vehicleNo',
    purpose: 'purpose',
    photo: 'photo',
    status: 'status',
    entryTime: 'entryTime',
    exitTime: 'exitTime',
    societyId: 'societyId',
    visitingUnitId: 'visitingUnitId',
    idType: 'idType',
    idNumber: 'idNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VisitorScalarFieldEnum = (typeof VisitorScalarFieldEnum)[keyof typeof VisitorScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    category: 'category',
    amount: 'amount',
    date: 'date',
    description: 'description',
    paymentMethod: 'paymentMethod',
    status: 'status',
    societyId: 'societyId',
    invoiceNo: 'invoiceNo',
    paidTo: 'paidTo',
    receivedFrom: 'receivedFrom',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    serviceType: 'serviceType',
    contact: 'contact',
    email: 'email',
    address: 'address',
    status: 'status',
    societyId: 'societyId',
    createdAt: 'createdAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const VendorPayoutScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    vendorName: 'vendorName',
    societyId: 'societyId',
    societyName: 'societyName',
    dealValue: 'dealValue',
    commissionPercent: 'commissionPercent',
    payableAmount: 'payableAmount',
    status: 'status',
    remarks: 'remarks',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorPayoutScalarFieldEnum = (typeof VendorPayoutScalarFieldEnum)[keyof typeof VendorPayoutScalarFieldEnum]


  export const ServiceCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    icon: 'icon',
    color: 'color'
  };

  export type ServiceCategoryScalarFieldEnum = (typeof ServiceCategoryScalarFieldEnum)[keyof typeof ServiceCategoryScalarFieldEnum]


  export const ServiceVariantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    description: 'description',
    categoryId: 'categoryId'
  };

  export type ServiceVariantScalarFieldEnum = (typeof ServiceVariantScalarFieldEnum)[keyof typeof ServiceVariantScalarFieldEnum]


  export const ServiceInquiryScalarFieldEnum: {
    id: 'id',
    residentName: 'residentName',
    unit: 'unit',
    serviceName: 'serviceName',
    serviceId: 'serviceId',
    status: 'status',
    vendorName: 'vendorName',
    vendorId: 'vendorId',
    source: 'source',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    societyId: 'societyId'
  };

  export type ServiceInquiryScalarFieldEnum = (typeof ServiceInquiryScalarFieldEnum)[keyof typeof ServiceInquiryScalarFieldEnum]


  export const EmergencyLogScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    visitorName: 'visitorName',
    visitorPhone: 'visitorPhone',
    residentName: 'residentName',
    unit: 'unit',
    isEmergency: 'isEmergency',
    reason: 'reason',
    barcodeId: 'barcodeId',
    societyId: 'societyId'
  };

  export type EmergencyLogScalarFieldEnum = (typeof EmergencyLogScalarFieldEnum)[keyof typeof EmergencyLogScalarFieldEnum]


  export const EmergencyBarcodeScalarFieldEnum: {
    id: 'id',
    residentName: 'residentName',
    unit: 'unit',
    phone: 'phone',
    status: 'status',
    qrCodeUrl: 'qrCodeUrl',
    createdAt: 'createdAt',
    societyId: 'societyId'
  };

  export type EmergencyBarcodeScalarFieldEnum = (typeof EmergencyBarcodeScalarFieldEnum)[keyof typeof EmergencyBarcodeScalarFieldEnum]


  export const NoticeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    audience: 'audience',
    societyId: 'societyId',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type NoticeScalarFieldEnum = (typeof NoticeScalarFieldEnum)[keyof typeof NoticeScalarFieldEnum]


  export const AmenityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    chargesPerHour: 'chargesPerHour',
    societyId: 'societyId',
    createdAt: 'createdAt'
  };

  export type AmenityScalarFieldEnum = (typeof AmenityScalarFieldEnum)[keyof typeof AmenityScalarFieldEnum]


  export const AmenityBookingScalarFieldEnum: {
    id: 'id',
    amenityId: 'amenityId',
    userId: 'userId',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    amountPaid: 'amountPaid',
    createdAt: 'createdAt'
  };

  export type AmenityBookingScalarFieldEnum = (typeof AmenityBookingScalarFieldEnum)[keyof typeof AmenityBookingScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const BillingPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    price: 'price',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillingPlanScalarFieldEnum = (typeof BillingPlanScalarFieldEnum)[keyof typeof BillingPlanScalarFieldEnum]


  export const PlatformInvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNo: 'invoiceNo',
    societyId: 'societyId',
    amount: 'amount',
    status: 'status',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    paidDate: 'paidDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlatformInvoiceScalarFieldEnum = (typeof PlatformInvoiceScalarFieldEnum)[keyof typeof PlatformInvoiceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const SocietyOrderByRelevanceFieldEnum: {
    name: 'name',
    address: 'address',
    city: 'city',
    state: 'state',
    pincode: 'pincode',
    code: 'code'
  };

  export type SocietyOrderByRelevanceFieldEnum = (typeof SocietyOrderByRelevanceFieldEnum)[keyof typeof SocietyOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    email: 'email',
    password: 'password',
    name: 'name',
    phone: 'phone',
    profileImg: 'profileImg'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const UnitOrderByRelevanceFieldEnum: {
    block: 'block',
    number: 'number',
    type: 'type'
  };

  export type UnitOrderByRelevanceFieldEnum = (typeof UnitOrderByRelevanceFieldEnum)[keyof typeof UnitOrderByRelevanceFieldEnum]


  export const ParkingSlotOrderByRelevanceFieldEnum: {
    number: 'number',
    type: 'type',
    status: 'status',
    vehicleNumber: 'vehicleNumber'
  };

  export type ParkingSlotOrderByRelevanceFieldEnum = (typeof ParkingSlotOrderByRelevanceFieldEnum)[keyof typeof ParkingSlotOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const ComplaintOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    category: 'category'
  };

  export type ComplaintOrderByRelevanceFieldEnum = (typeof ComplaintOrderByRelevanceFieldEnum)[keyof typeof ComplaintOrderByRelevanceFieldEnum]


  export const ComplaintCommentOrderByRelevanceFieldEnum: {
    message: 'message'
  };

  export type ComplaintCommentOrderByRelevanceFieldEnum = (typeof ComplaintCommentOrderByRelevanceFieldEnum)[keyof typeof ComplaintCommentOrderByRelevanceFieldEnum]


  export const VisitorOrderByRelevanceFieldEnum: {
    name: 'name',
    phone: 'phone',
    vehicleNo: 'vehicleNo',
    purpose: 'purpose',
    photo: 'photo',
    idType: 'idType',
    idNumber: 'idNumber'
  };

  export type VisitorOrderByRelevanceFieldEnum = (typeof VisitorOrderByRelevanceFieldEnum)[keyof typeof VisitorOrderByRelevanceFieldEnum]


  export const TransactionOrderByRelevanceFieldEnum: {
    category: 'category',
    description: 'description',
    status: 'status',
    invoiceNo: 'invoiceNo',
    paidTo: 'paidTo',
    receivedFrom: 'receivedFrom'
  };

  export type TransactionOrderByRelevanceFieldEnum = (typeof TransactionOrderByRelevanceFieldEnum)[keyof typeof TransactionOrderByRelevanceFieldEnum]


  export const VendorOrderByRelevanceFieldEnum: {
    name: 'name',
    serviceType: 'serviceType',
    contact: 'contact',
    email: 'email',
    address: 'address'
  };

  export type VendorOrderByRelevanceFieldEnum = (typeof VendorOrderByRelevanceFieldEnum)[keyof typeof VendorOrderByRelevanceFieldEnum]


  export const VendorPayoutOrderByRelevanceFieldEnum: {
    vendorName: 'vendorName',
    societyName: 'societyName',
    status: 'status',
    remarks: 'remarks'
  };

  export type VendorPayoutOrderByRelevanceFieldEnum = (typeof VendorPayoutOrderByRelevanceFieldEnum)[keyof typeof VendorPayoutOrderByRelevanceFieldEnum]


  export const ServiceCategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    icon: 'icon',
    color: 'color'
  };

  export type ServiceCategoryOrderByRelevanceFieldEnum = (typeof ServiceCategoryOrderByRelevanceFieldEnum)[keyof typeof ServiceCategoryOrderByRelevanceFieldEnum]


  export const ServiceVariantOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    description: 'description',
    categoryId: 'categoryId'
  };

  export type ServiceVariantOrderByRelevanceFieldEnum = (typeof ServiceVariantOrderByRelevanceFieldEnum)[keyof typeof ServiceVariantOrderByRelevanceFieldEnum]


  export const ServiceInquiryOrderByRelevanceFieldEnum: {
    id: 'id',
    residentName: 'residentName',
    unit: 'unit',
    serviceName: 'serviceName',
    serviceId: 'serviceId',
    status: 'status',
    vendorName: 'vendorName',
    vendorId: 'vendorId',
    source: 'source',
    type: 'type'
  };

  export type ServiceInquiryOrderByRelevanceFieldEnum = (typeof ServiceInquiryOrderByRelevanceFieldEnum)[keyof typeof ServiceInquiryOrderByRelevanceFieldEnum]


  export const EmergencyLogOrderByRelevanceFieldEnum: {
    id: 'id',
    visitorName: 'visitorName',
    visitorPhone: 'visitorPhone',
    residentName: 'residentName',
    unit: 'unit',
    reason: 'reason',
    barcodeId: 'barcodeId'
  };

  export type EmergencyLogOrderByRelevanceFieldEnum = (typeof EmergencyLogOrderByRelevanceFieldEnum)[keyof typeof EmergencyLogOrderByRelevanceFieldEnum]


  export const EmergencyBarcodeOrderByRelevanceFieldEnum: {
    id: 'id',
    residentName: 'residentName',
    unit: 'unit',
    phone: 'phone',
    status: 'status',
    qrCodeUrl: 'qrCodeUrl'
  };

  export type EmergencyBarcodeOrderByRelevanceFieldEnum = (typeof EmergencyBarcodeOrderByRelevanceFieldEnum)[keyof typeof EmergencyBarcodeOrderByRelevanceFieldEnum]


  export const NoticeOrderByRelevanceFieldEnum: {
    title: 'title',
    content: 'content',
    audience: 'audience'
  };

  export type NoticeOrderByRelevanceFieldEnum = (typeof NoticeOrderByRelevanceFieldEnum)[keyof typeof NoticeOrderByRelevanceFieldEnum]


  export const AmenityOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type AmenityOrderByRelevanceFieldEnum = (typeof AmenityOrderByRelevanceFieldEnum)[keyof typeof AmenityOrderByRelevanceFieldEnum]


  export const AmenityBookingOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type AmenityBookingOrderByRelevanceFieldEnum = (typeof AmenityBookingOrderByRelevanceFieldEnum)[keyof typeof AmenityBookingOrderByRelevanceFieldEnum]


  export const SystemSettingOrderByRelevanceFieldEnum: {
    key: 'key',
    value: 'value'
  };

  export type SystemSettingOrderByRelevanceFieldEnum = (typeof SystemSettingOrderByRelevanceFieldEnum)[keyof typeof SystemSettingOrderByRelevanceFieldEnum]


  export const BillingPlanOrderByRelevanceFieldEnum: {
    name: 'name',
    type: 'type',
    price: 'price',
    description: 'description',
    status: 'status'
  };

  export type BillingPlanOrderByRelevanceFieldEnum = (typeof BillingPlanOrderByRelevanceFieldEnum)[keyof typeof BillingPlanOrderByRelevanceFieldEnum]


  export const PlatformInvoiceOrderByRelevanceFieldEnum: {
    invoiceNo: 'invoiceNo',
    status: 'status'
  };

  export type PlatformInvoiceOrderByRelevanceFieldEnum = (typeof PlatformInvoiceOrderByRelevanceFieldEnum)[keyof typeof PlatformInvoiceOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'SocietyStatus'
   */
  export type EnumSocietyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocietyStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan'
   */
  export type EnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'ComplaintStatus'
   */
  export type EnumComplaintStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintStatus'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'VisitorStatus'
   */
  export type EnumVisitorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitorStatus'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'VendorStatus'
   */
  export type EnumVendorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VendorStatus'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type SocietyWhereInput = {
    AND?: SocietyWhereInput | SocietyWhereInput[]
    OR?: SocietyWhereInput[]
    NOT?: SocietyWhereInput | SocietyWhereInput[]
    id?: IntFilter<"Society"> | number
    name?: StringFilter<"Society"> | string
    address?: StringNullableFilter<"Society"> | string | null
    city?: StringNullableFilter<"Society"> | string | null
    state?: StringNullableFilter<"Society"> | string | null
    pincode?: StringNullableFilter<"Society"> | string | null
    code?: StringFilter<"Society"> | string
    status?: EnumSocietyStatusFilter<"Society"> | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFilter<"Society"> | $Enums.SubscriptionPlan
    expectedUnits?: IntFilter<"Society"> | number
    createdAt?: DateTimeFilter<"Society"> | Date | string
    updatedAt?: DateTimeFilter<"Society"> | Date | string
    users?: UserListRelationFilter
    units?: UnitListRelationFilter
    complaints?: ComplaintListRelationFilter
    visitors?: VisitorListRelationFilter
    transactions?: TransactionListRelationFilter
    notices?: NoticeListRelationFilter
    vendors?: VendorListRelationFilter
    amenities?: AmenityListRelationFilter
    parkingSlots?: ParkingSlotListRelationFilter
    platformInvoices?: PlatformInvoiceListRelationFilter
  }

  export type SocietyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    code?: SortOrder
    status?: SortOrder
    subscriptionPlan?: SortOrder
    expectedUnits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    units?: UnitOrderByRelationAggregateInput
    complaints?: ComplaintOrderByRelationAggregateInput
    visitors?: VisitorOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    notices?: NoticeOrderByRelationAggregateInput
    vendors?: VendorOrderByRelationAggregateInput
    amenities?: AmenityOrderByRelationAggregateInput
    parkingSlots?: ParkingSlotOrderByRelationAggregateInput
    platformInvoices?: PlatformInvoiceOrderByRelationAggregateInput
    _relevance?: SocietyOrderByRelevanceInput
  }

  export type SocietyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: SocietyWhereInput | SocietyWhereInput[]
    OR?: SocietyWhereInput[]
    NOT?: SocietyWhereInput | SocietyWhereInput[]
    name?: StringFilter<"Society"> | string
    address?: StringNullableFilter<"Society"> | string | null
    city?: StringNullableFilter<"Society"> | string | null
    state?: StringNullableFilter<"Society"> | string | null
    pincode?: StringNullableFilter<"Society"> | string | null
    status?: EnumSocietyStatusFilter<"Society"> | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFilter<"Society"> | $Enums.SubscriptionPlan
    expectedUnits?: IntFilter<"Society"> | number
    createdAt?: DateTimeFilter<"Society"> | Date | string
    updatedAt?: DateTimeFilter<"Society"> | Date | string
    users?: UserListRelationFilter
    units?: UnitListRelationFilter
    complaints?: ComplaintListRelationFilter
    visitors?: VisitorListRelationFilter
    transactions?: TransactionListRelationFilter
    notices?: NoticeListRelationFilter
    vendors?: VendorListRelationFilter
    amenities?: AmenityListRelationFilter
    parkingSlots?: ParkingSlotListRelationFilter
    platformInvoices?: PlatformInvoiceListRelationFilter
  }, "id" | "code">

  export type SocietyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    code?: SortOrder
    status?: SortOrder
    subscriptionPlan?: SortOrder
    expectedUnits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SocietyCountOrderByAggregateInput
    _avg?: SocietyAvgOrderByAggregateInput
    _max?: SocietyMaxOrderByAggregateInput
    _min?: SocietyMinOrderByAggregateInput
    _sum?: SocietySumOrderByAggregateInput
  }

  export type SocietyScalarWhereWithAggregatesInput = {
    AND?: SocietyScalarWhereWithAggregatesInput | SocietyScalarWhereWithAggregatesInput[]
    OR?: SocietyScalarWhereWithAggregatesInput[]
    NOT?: SocietyScalarWhereWithAggregatesInput | SocietyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Society"> | number
    name?: StringWithAggregatesFilter<"Society"> | string
    address?: StringNullableWithAggregatesFilter<"Society"> | string | null
    city?: StringNullableWithAggregatesFilter<"Society"> | string | null
    state?: StringNullableWithAggregatesFilter<"Society"> | string | null
    pincode?: StringNullableWithAggregatesFilter<"Society"> | string | null
    code?: StringWithAggregatesFilter<"Society"> | string
    status?: EnumSocietyStatusWithAggregatesFilter<"Society"> | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanWithAggregatesFilter<"Society"> | $Enums.SubscriptionPlan
    expectedUnits?: IntWithAggregatesFilter<"Society"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Society"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Society"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    profileImg?: StringNullableFilter<"User"> | string | null
    societyId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    society?: XOR<SocietyNullableScalarRelationFilter, SocietyWhereInput> | null
    ownedUnits?: UnitListRelationFilter
    rentedUnits?: UnitListRelationFilter
    reportedComplaints?: ComplaintListRelationFilter
    assignedComplaints?: ComplaintListRelationFilter
    bookings?: AmenityBookingListRelationFilter
    comments?: ComplaintCommentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    profileImg?: SortOrderInput | SortOrder
    societyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    ownedUnits?: UnitOrderByRelationAggregateInput
    rentedUnits?: UnitOrderByRelationAggregateInput
    reportedComplaints?: ComplaintOrderByRelationAggregateInput
    assignedComplaints?: ComplaintOrderByRelationAggregateInput
    bookings?: AmenityBookingOrderByRelationAggregateInput
    comments?: ComplaintCommentOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    profileImg?: StringNullableFilter<"User"> | string | null
    societyId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    society?: XOR<SocietyNullableScalarRelationFilter, SocietyWhereInput> | null
    ownedUnits?: UnitListRelationFilter
    rentedUnits?: UnitListRelationFilter
    reportedComplaints?: ComplaintListRelationFilter
    assignedComplaints?: ComplaintListRelationFilter
    bookings?: AmenityBookingListRelationFilter
    comments?: ComplaintCommentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    profileImg?: SortOrderInput | SortOrder
    societyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    profileImg?: StringNullableWithAggregatesFilter<"User"> | string | null
    societyId?: IntNullableWithAggregatesFilter<"User"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: IntFilter<"Unit"> | number
    block?: StringFilter<"Unit"> | string
    number?: StringFilter<"Unit"> | string
    floor?: IntFilter<"Unit"> | number
    type?: StringFilter<"Unit"> | string
    areaSqFt?: FloatFilter<"Unit"> | number
    societyId?: IntFilter<"Unit"> | number
    ownerId?: IntNullableFilter<"Unit"> | number | null
    tenantId?: IntNullableFilter<"Unit"> | number | null
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tenant?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    visitors?: VisitorListRelationFilter
    parkingSlots?: ParkingSlotListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    block?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    areaSqFt?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    tenant?: UserOrderByWithRelationInput
    visitors?: VisitorOrderByRelationAggregateInput
    parkingSlots?: ParkingSlotOrderByRelationAggregateInput
    _relevance?: UnitOrderByRelevanceInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    societyId_block_number?: UnitSocietyIdBlockNumberCompoundUniqueInput
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    block?: StringFilter<"Unit"> | string
    number?: StringFilter<"Unit"> | string
    floor?: IntFilter<"Unit"> | number
    type?: StringFilter<"Unit"> | string
    areaSqFt?: FloatFilter<"Unit"> | number
    societyId?: IntFilter<"Unit"> | number
    ownerId?: IntNullableFilter<"Unit"> | number | null
    tenantId?: IntNullableFilter<"Unit"> | number | null
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tenant?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    visitors?: VisitorListRelationFilter
    parkingSlots?: ParkingSlotListRelationFilter
  }, "id" | "societyId_block_number">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    block?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    areaSqFt?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Unit"> | number
    block?: StringWithAggregatesFilter<"Unit"> | string
    number?: StringWithAggregatesFilter<"Unit"> | string
    floor?: IntWithAggregatesFilter<"Unit"> | number
    type?: StringWithAggregatesFilter<"Unit"> | string
    areaSqFt?: FloatWithAggregatesFilter<"Unit"> | number
    societyId?: IntWithAggregatesFilter<"Unit"> | number
    ownerId?: IntNullableWithAggregatesFilter<"Unit"> | number | null
    tenantId?: IntNullableWithAggregatesFilter<"Unit"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
  }

  export type ParkingSlotWhereInput = {
    AND?: ParkingSlotWhereInput | ParkingSlotWhereInput[]
    OR?: ParkingSlotWhereInput[]
    NOT?: ParkingSlotWhereInput | ParkingSlotWhereInput[]
    id?: IntFilter<"ParkingSlot"> | number
    number?: StringFilter<"ParkingSlot"> | string
    type?: StringFilter<"ParkingSlot"> | string
    status?: StringFilter<"ParkingSlot"> | string
    societyId?: IntFilter<"ParkingSlot"> | number
    allocatedToUnitId?: IntNullableFilter<"ParkingSlot"> | number | null
    vehicleNumber?: StringNullableFilter<"ParkingSlot"> | string | null
    createdAt?: DateTimeFilter<"ParkingSlot"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
  }

  export type ParkingSlotOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrderInput | SortOrder
    vehicleNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    _relevance?: ParkingSlotOrderByRelevanceInput
  }

  export type ParkingSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ParkingSlotWhereInput | ParkingSlotWhereInput[]
    OR?: ParkingSlotWhereInput[]
    NOT?: ParkingSlotWhereInput | ParkingSlotWhereInput[]
    number?: StringFilter<"ParkingSlot"> | string
    type?: StringFilter<"ParkingSlot"> | string
    status?: StringFilter<"ParkingSlot"> | string
    societyId?: IntFilter<"ParkingSlot"> | number
    allocatedToUnitId?: IntNullableFilter<"ParkingSlot"> | number | null
    vehicleNumber?: StringNullableFilter<"ParkingSlot"> | string | null
    createdAt?: DateTimeFilter<"ParkingSlot"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
  }, "id">

  export type ParkingSlotOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrderInput | SortOrder
    vehicleNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ParkingSlotCountOrderByAggregateInput
    _avg?: ParkingSlotAvgOrderByAggregateInput
    _max?: ParkingSlotMaxOrderByAggregateInput
    _min?: ParkingSlotMinOrderByAggregateInput
    _sum?: ParkingSlotSumOrderByAggregateInput
  }

  export type ParkingSlotScalarWhereWithAggregatesInput = {
    AND?: ParkingSlotScalarWhereWithAggregatesInput | ParkingSlotScalarWhereWithAggregatesInput[]
    OR?: ParkingSlotScalarWhereWithAggregatesInput[]
    NOT?: ParkingSlotScalarWhereWithAggregatesInput | ParkingSlotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ParkingSlot"> | number
    number?: StringWithAggregatesFilter<"ParkingSlot"> | string
    type?: StringWithAggregatesFilter<"ParkingSlot"> | string
    status?: StringWithAggregatesFilter<"ParkingSlot"> | string
    societyId?: IntWithAggregatesFilter<"ParkingSlot"> | number
    allocatedToUnitId?: IntNullableWithAggregatesFilter<"ParkingSlot"> | number | null
    vehicleNumber?: StringNullableWithAggregatesFilter<"ParkingSlot"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ParkingSlot"> | Date | string
  }

  export type ComplaintWhereInput = {
    AND?: ComplaintWhereInput | ComplaintWhereInput[]
    OR?: ComplaintWhereInput[]
    NOT?: ComplaintWhereInput | ComplaintWhereInput[]
    id?: IntFilter<"Complaint"> | number
    title?: StringFilter<"Complaint"> | string
    description?: StringFilter<"Complaint"> | string
    category?: StringFilter<"Complaint"> | string
    priority?: EnumPriorityFilter<"Complaint"> | $Enums.Priority
    status?: EnumComplaintStatusFilter<"Complaint"> | $Enums.ComplaintStatus
    images?: JsonNullableFilter<"Complaint">
    societyId?: IntFilter<"Complaint"> | number
    reportedById?: IntFilter<"Complaint"> | number
    assignedToId?: IntNullableFilter<"Complaint"> | number | null
    timeline?: JsonNullableFilter<"Complaint">
    createdAt?: DateTimeFilter<"Complaint"> | Date | string
    updatedAt?: DateTimeFilter<"Complaint"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    reportedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    comments?: ComplaintCommentListRelationFilter
  }

  export type ComplaintOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    images?: SortOrderInput | SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    timeline?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    reportedBy?: UserOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    comments?: ComplaintCommentOrderByRelationAggregateInput
    _relevance?: ComplaintOrderByRelevanceInput
  }

  export type ComplaintWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComplaintWhereInput | ComplaintWhereInput[]
    OR?: ComplaintWhereInput[]
    NOT?: ComplaintWhereInput | ComplaintWhereInput[]
    title?: StringFilter<"Complaint"> | string
    description?: StringFilter<"Complaint"> | string
    category?: StringFilter<"Complaint"> | string
    priority?: EnumPriorityFilter<"Complaint"> | $Enums.Priority
    status?: EnumComplaintStatusFilter<"Complaint"> | $Enums.ComplaintStatus
    images?: JsonNullableFilter<"Complaint">
    societyId?: IntFilter<"Complaint"> | number
    reportedById?: IntFilter<"Complaint"> | number
    assignedToId?: IntNullableFilter<"Complaint"> | number | null
    timeline?: JsonNullableFilter<"Complaint">
    createdAt?: DateTimeFilter<"Complaint"> | Date | string
    updatedAt?: DateTimeFilter<"Complaint"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    reportedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    comments?: ComplaintCommentListRelationFilter
  }, "id">

  export type ComplaintOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    images?: SortOrderInput | SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    timeline?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComplaintCountOrderByAggregateInput
    _avg?: ComplaintAvgOrderByAggregateInput
    _max?: ComplaintMaxOrderByAggregateInput
    _min?: ComplaintMinOrderByAggregateInput
    _sum?: ComplaintSumOrderByAggregateInput
  }

  export type ComplaintScalarWhereWithAggregatesInput = {
    AND?: ComplaintScalarWhereWithAggregatesInput | ComplaintScalarWhereWithAggregatesInput[]
    OR?: ComplaintScalarWhereWithAggregatesInput[]
    NOT?: ComplaintScalarWhereWithAggregatesInput | ComplaintScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Complaint"> | number
    title?: StringWithAggregatesFilter<"Complaint"> | string
    description?: StringWithAggregatesFilter<"Complaint"> | string
    category?: StringWithAggregatesFilter<"Complaint"> | string
    priority?: EnumPriorityWithAggregatesFilter<"Complaint"> | $Enums.Priority
    status?: EnumComplaintStatusWithAggregatesFilter<"Complaint"> | $Enums.ComplaintStatus
    images?: JsonNullableWithAggregatesFilter<"Complaint">
    societyId?: IntWithAggregatesFilter<"Complaint"> | number
    reportedById?: IntWithAggregatesFilter<"Complaint"> | number
    assignedToId?: IntNullableWithAggregatesFilter<"Complaint"> | number | null
    timeline?: JsonNullableWithAggregatesFilter<"Complaint">
    createdAt?: DateTimeWithAggregatesFilter<"Complaint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Complaint"> | Date | string
  }

  export type ComplaintCommentWhereInput = {
    AND?: ComplaintCommentWhereInput | ComplaintCommentWhereInput[]
    OR?: ComplaintCommentWhereInput[]
    NOT?: ComplaintCommentWhereInput | ComplaintCommentWhereInput[]
    id?: IntFilter<"ComplaintComment"> | number
    complaintId?: IntFilter<"ComplaintComment"> | number
    userId?: IntFilter<"ComplaintComment"> | number
    message?: StringFilter<"ComplaintComment"> | string
    createdAt?: DateTimeFilter<"ComplaintComment"> | Date | string
    complaint?: XOR<ComplaintScalarRelationFilter, ComplaintWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ComplaintCommentOrderByWithRelationInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    complaint?: ComplaintOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: ComplaintCommentOrderByRelevanceInput
  }

  export type ComplaintCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComplaintCommentWhereInput | ComplaintCommentWhereInput[]
    OR?: ComplaintCommentWhereInput[]
    NOT?: ComplaintCommentWhereInput | ComplaintCommentWhereInput[]
    complaintId?: IntFilter<"ComplaintComment"> | number
    userId?: IntFilter<"ComplaintComment"> | number
    message?: StringFilter<"ComplaintComment"> | string
    createdAt?: DateTimeFilter<"ComplaintComment"> | Date | string
    complaint?: XOR<ComplaintScalarRelationFilter, ComplaintWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ComplaintCommentOrderByWithAggregationInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: ComplaintCommentCountOrderByAggregateInput
    _avg?: ComplaintCommentAvgOrderByAggregateInput
    _max?: ComplaintCommentMaxOrderByAggregateInput
    _min?: ComplaintCommentMinOrderByAggregateInput
    _sum?: ComplaintCommentSumOrderByAggregateInput
  }

  export type ComplaintCommentScalarWhereWithAggregatesInput = {
    AND?: ComplaintCommentScalarWhereWithAggregatesInput | ComplaintCommentScalarWhereWithAggregatesInput[]
    OR?: ComplaintCommentScalarWhereWithAggregatesInput[]
    NOT?: ComplaintCommentScalarWhereWithAggregatesInput | ComplaintCommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ComplaintComment"> | number
    complaintId?: IntWithAggregatesFilter<"ComplaintComment"> | number
    userId?: IntWithAggregatesFilter<"ComplaintComment"> | number
    message?: StringWithAggregatesFilter<"ComplaintComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ComplaintComment"> | Date | string
  }

  export type VisitorWhereInput = {
    AND?: VisitorWhereInput | VisitorWhereInput[]
    OR?: VisitorWhereInput[]
    NOT?: VisitorWhereInput | VisitorWhereInput[]
    id?: IntFilter<"Visitor"> | number
    name?: StringFilter<"Visitor"> | string
    phone?: StringFilter<"Visitor"> | string
    vehicleNo?: StringNullableFilter<"Visitor"> | string | null
    purpose?: StringFilter<"Visitor"> | string
    photo?: StringNullableFilter<"Visitor"> | string | null
    status?: EnumVisitorStatusFilter<"Visitor"> | $Enums.VisitorStatus
    entryTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    exitTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    societyId?: IntFilter<"Visitor"> | number
    visitingUnitId?: IntFilter<"Visitor"> | number
    idType?: StringNullableFilter<"Visitor"> | string | null
    idNumber?: StringNullableFilter<"Visitor"> | string | null
    createdAt?: DateTimeFilter<"Visitor"> | Date | string
    updatedAt?: DateTimeFilter<"Visitor"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type VisitorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicleNo?: SortOrderInput | SortOrder
    purpose?: SortOrder
    photo?: SortOrderInput | SortOrder
    status?: SortOrder
    entryTime?: SortOrderInput | SortOrder
    exitTime?: SortOrderInput | SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
    idType?: SortOrderInput | SortOrder
    idNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    _relevance?: VisitorOrderByRelevanceInput
  }

  export type VisitorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VisitorWhereInput | VisitorWhereInput[]
    OR?: VisitorWhereInput[]
    NOT?: VisitorWhereInput | VisitorWhereInput[]
    name?: StringFilter<"Visitor"> | string
    phone?: StringFilter<"Visitor"> | string
    vehicleNo?: StringNullableFilter<"Visitor"> | string | null
    purpose?: StringFilter<"Visitor"> | string
    photo?: StringNullableFilter<"Visitor"> | string | null
    status?: EnumVisitorStatusFilter<"Visitor"> | $Enums.VisitorStatus
    entryTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    exitTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    societyId?: IntFilter<"Visitor"> | number
    visitingUnitId?: IntFilter<"Visitor"> | number
    idType?: StringNullableFilter<"Visitor"> | string | null
    idNumber?: StringNullableFilter<"Visitor"> | string | null
    createdAt?: DateTimeFilter<"Visitor"> | Date | string
    updatedAt?: DateTimeFilter<"Visitor"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "id">

  export type VisitorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicleNo?: SortOrderInput | SortOrder
    purpose?: SortOrder
    photo?: SortOrderInput | SortOrder
    status?: SortOrder
    entryTime?: SortOrderInput | SortOrder
    exitTime?: SortOrderInput | SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
    idType?: SortOrderInput | SortOrder
    idNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VisitorCountOrderByAggregateInput
    _avg?: VisitorAvgOrderByAggregateInput
    _max?: VisitorMaxOrderByAggregateInput
    _min?: VisitorMinOrderByAggregateInput
    _sum?: VisitorSumOrderByAggregateInput
  }

  export type VisitorScalarWhereWithAggregatesInput = {
    AND?: VisitorScalarWhereWithAggregatesInput | VisitorScalarWhereWithAggregatesInput[]
    OR?: VisitorScalarWhereWithAggregatesInput[]
    NOT?: VisitorScalarWhereWithAggregatesInput | VisitorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Visitor"> | number
    name?: StringWithAggregatesFilter<"Visitor"> | string
    phone?: StringWithAggregatesFilter<"Visitor"> | string
    vehicleNo?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    purpose?: StringWithAggregatesFilter<"Visitor"> | string
    photo?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    status?: EnumVisitorStatusWithAggregatesFilter<"Visitor"> | $Enums.VisitorStatus
    entryTime?: DateTimeNullableWithAggregatesFilter<"Visitor"> | Date | string | null
    exitTime?: DateTimeNullableWithAggregatesFilter<"Visitor"> | Date | string | null
    societyId?: IntWithAggregatesFilter<"Visitor"> | number
    visitingUnitId?: IntWithAggregatesFilter<"Visitor"> | number
    idType?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    idNumber?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Visitor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Visitor"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    category?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    status?: StringFilter<"Transaction"> | string
    societyId?: IntFilter<"Transaction"> | number
    invoiceNo?: StringNullableFilter<"Transaction"> | string | null
    paidTo?: StringNullableFilter<"Transaction"> | string | null
    receivedFrom?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    invoiceNo?: SortOrderInput | SortOrder
    paidTo?: SortOrderInput | SortOrder
    receivedFrom?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    _relevance?: TransactionOrderByRelevanceInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    category?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    status?: StringFilter<"Transaction"> | string
    societyId?: IntFilter<"Transaction"> | number
    invoiceNo?: StringNullableFilter<"Transaction"> | string | null
    paidTo?: StringNullableFilter<"Transaction"> | string | null
    receivedFrom?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    invoiceNo?: SortOrderInput | SortOrder
    paidTo?: SortOrderInput | SortOrder
    receivedFrom?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    category?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    date?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Transaction"> | $Enums.PaymentMethod
    status?: StringWithAggregatesFilter<"Transaction"> | string
    societyId?: IntWithAggregatesFilter<"Transaction"> | number
    invoiceNo?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    paidTo?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    receivedFrom?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: IntFilter<"Vendor"> | number
    name?: StringFilter<"Vendor"> | string
    serviceType?: StringFilter<"Vendor"> | string
    contact?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    status?: EnumVendorStatusFilter<"Vendor"> | $Enums.VendorStatus
    societyId?: IntNullableFilter<"Vendor"> | number | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    society?: XOR<SocietyNullableScalarRelationFilter, SocietyWhereInput> | null
    payouts?: VendorPayoutListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    contact?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    societyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    payouts?: VendorPayoutOrderByRelationAggregateInput
    _relevance?: VendorOrderByRelevanceInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    name?: StringFilter<"Vendor"> | string
    serviceType?: StringFilter<"Vendor"> | string
    contact?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    status?: EnumVendorStatusFilter<"Vendor"> | $Enums.VendorStatus
    societyId?: IntNullableFilter<"Vendor"> | number | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    society?: XOR<SocietyNullableScalarRelationFilter, SocietyWhereInput> | null
    payouts?: VendorPayoutListRelationFilter
  }, "id">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    contact?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    societyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vendor"> | number
    name?: StringWithAggregatesFilter<"Vendor"> | string
    serviceType?: StringWithAggregatesFilter<"Vendor"> | string
    contact?: StringWithAggregatesFilter<"Vendor"> | string
    email?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    address?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    status?: EnumVendorStatusWithAggregatesFilter<"Vendor"> | $Enums.VendorStatus
    societyId?: IntNullableWithAggregatesFilter<"Vendor"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
  }

  export type VendorPayoutWhereInput = {
    AND?: VendorPayoutWhereInput | VendorPayoutWhereInput[]
    OR?: VendorPayoutWhereInput[]
    NOT?: VendorPayoutWhereInput | VendorPayoutWhereInput[]
    id?: IntFilter<"VendorPayout"> | number
    vendorId?: IntFilter<"VendorPayout"> | number
    vendorName?: StringFilter<"VendorPayout"> | string
    societyId?: IntNullableFilter<"VendorPayout"> | number | null
    societyName?: StringNullableFilter<"VendorPayout"> | string | null
    dealValue?: FloatFilter<"VendorPayout"> | number
    commissionPercent?: FloatFilter<"VendorPayout"> | number
    payableAmount?: FloatFilter<"VendorPayout"> | number
    status?: StringFilter<"VendorPayout"> | string
    remarks?: StringNullableFilter<"VendorPayout"> | string | null
    date?: DateTimeFilter<"VendorPayout"> | Date | string
    createdAt?: DateTimeFilter<"VendorPayout"> | Date | string
    updatedAt?: DateTimeFilter<"VendorPayout"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }

  export type VendorPayoutOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    societyId?: SortOrderInput | SortOrder
    societyName?: SortOrderInput | SortOrder
    dealValue?: SortOrder
    commissionPercent?: SortOrder
    payableAmount?: SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    _relevance?: VendorPayoutOrderByRelevanceInput
  }

  export type VendorPayoutWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VendorPayoutWhereInput | VendorPayoutWhereInput[]
    OR?: VendorPayoutWhereInput[]
    NOT?: VendorPayoutWhereInput | VendorPayoutWhereInput[]
    vendorId?: IntFilter<"VendorPayout"> | number
    vendorName?: StringFilter<"VendorPayout"> | string
    societyId?: IntNullableFilter<"VendorPayout"> | number | null
    societyName?: StringNullableFilter<"VendorPayout"> | string | null
    dealValue?: FloatFilter<"VendorPayout"> | number
    commissionPercent?: FloatFilter<"VendorPayout"> | number
    payableAmount?: FloatFilter<"VendorPayout"> | number
    status?: StringFilter<"VendorPayout"> | string
    remarks?: StringNullableFilter<"VendorPayout"> | string | null
    date?: DateTimeFilter<"VendorPayout"> | Date | string
    createdAt?: DateTimeFilter<"VendorPayout"> | Date | string
    updatedAt?: DateTimeFilter<"VendorPayout"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }, "id">

  export type VendorPayoutOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    societyId?: SortOrderInput | SortOrder
    societyName?: SortOrderInput | SortOrder
    dealValue?: SortOrder
    commissionPercent?: SortOrder
    payableAmount?: SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorPayoutCountOrderByAggregateInput
    _avg?: VendorPayoutAvgOrderByAggregateInput
    _max?: VendorPayoutMaxOrderByAggregateInput
    _min?: VendorPayoutMinOrderByAggregateInput
    _sum?: VendorPayoutSumOrderByAggregateInput
  }

  export type VendorPayoutScalarWhereWithAggregatesInput = {
    AND?: VendorPayoutScalarWhereWithAggregatesInput | VendorPayoutScalarWhereWithAggregatesInput[]
    OR?: VendorPayoutScalarWhereWithAggregatesInput[]
    NOT?: VendorPayoutScalarWhereWithAggregatesInput | VendorPayoutScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VendorPayout"> | number
    vendorId?: IntWithAggregatesFilter<"VendorPayout"> | number
    vendorName?: StringWithAggregatesFilter<"VendorPayout"> | string
    societyId?: IntNullableWithAggregatesFilter<"VendorPayout"> | number | null
    societyName?: StringNullableWithAggregatesFilter<"VendorPayout"> | string | null
    dealValue?: FloatWithAggregatesFilter<"VendorPayout"> | number
    commissionPercent?: FloatWithAggregatesFilter<"VendorPayout"> | number
    payableAmount?: FloatWithAggregatesFilter<"VendorPayout"> | number
    status?: StringWithAggregatesFilter<"VendorPayout"> | string
    remarks?: StringNullableWithAggregatesFilter<"VendorPayout"> | string | null
    date?: DateTimeWithAggregatesFilter<"VendorPayout"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"VendorPayout"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VendorPayout"> | Date | string
  }

  export type ServiceCategoryWhereInput = {
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    id?: StringFilter<"ServiceCategory"> | string
    name?: StringFilter<"ServiceCategory"> | string
    description?: StringFilter<"ServiceCategory"> | string
    icon?: StringFilter<"ServiceCategory"> | string
    color?: StringFilter<"ServiceCategory"> | string
    variants?: ServiceVariantListRelationFilter
  }

  export type ServiceCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    variants?: ServiceVariantOrderByRelationAggregateInput
    _relevance?: ServiceCategoryOrderByRelevanceInput
  }

  export type ServiceCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    name?: StringFilter<"ServiceCategory"> | string
    description?: StringFilter<"ServiceCategory"> | string
    icon?: StringFilter<"ServiceCategory"> | string
    color?: StringFilter<"ServiceCategory"> | string
    variants?: ServiceVariantListRelationFilter
  }, "id">

  export type ServiceCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    _count?: ServiceCategoryCountOrderByAggregateInput
    _max?: ServiceCategoryMaxOrderByAggregateInput
    _min?: ServiceCategoryMinOrderByAggregateInput
  }

  export type ServiceCategoryScalarWhereWithAggregatesInput = {
    AND?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    OR?: ServiceCategoryScalarWhereWithAggregatesInput[]
    NOT?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceCategory"> | string
    name?: StringWithAggregatesFilter<"ServiceCategory"> | string
    description?: StringWithAggregatesFilter<"ServiceCategory"> | string
    icon?: StringWithAggregatesFilter<"ServiceCategory"> | string
    color?: StringWithAggregatesFilter<"ServiceCategory"> | string
  }

  export type ServiceVariantWhereInput = {
    AND?: ServiceVariantWhereInput | ServiceVariantWhereInput[]
    OR?: ServiceVariantWhereInput[]
    NOT?: ServiceVariantWhereInput | ServiceVariantWhereInput[]
    id?: StringFilter<"ServiceVariant"> | string
    name?: StringFilter<"ServiceVariant"> | string
    price?: StringFilter<"ServiceVariant"> | string
    description?: StringNullableFilter<"ServiceVariant"> | string | null
    categoryId?: StringFilter<"ServiceVariant"> | string
    category?: XOR<ServiceCategoryScalarRelationFilter, ServiceCategoryWhereInput>
  }

  export type ServiceVariantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    category?: ServiceCategoryOrderByWithRelationInput
    _relevance?: ServiceVariantOrderByRelevanceInput
  }

  export type ServiceVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceVariantWhereInput | ServiceVariantWhereInput[]
    OR?: ServiceVariantWhereInput[]
    NOT?: ServiceVariantWhereInput | ServiceVariantWhereInput[]
    name?: StringFilter<"ServiceVariant"> | string
    price?: StringFilter<"ServiceVariant"> | string
    description?: StringNullableFilter<"ServiceVariant"> | string | null
    categoryId?: StringFilter<"ServiceVariant"> | string
    category?: XOR<ServiceCategoryScalarRelationFilter, ServiceCategoryWhereInput>
  }, "id">

  export type ServiceVariantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    _count?: ServiceVariantCountOrderByAggregateInput
    _max?: ServiceVariantMaxOrderByAggregateInput
    _min?: ServiceVariantMinOrderByAggregateInput
  }

  export type ServiceVariantScalarWhereWithAggregatesInput = {
    AND?: ServiceVariantScalarWhereWithAggregatesInput | ServiceVariantScalarWhereWithAggregatesInput[]
    OR?: ServiceVariantScalarWhereWithAggregatesInput[]
    NOT?: ServiceVariantScalarWhereWithAggregatesInput | ServiceVariantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceVariant"> | string
    name?: StringWithAggregatesFilter<"ServiceVariant"> | string
    price?: StringWithAggregatesFilter<"ServiceVariant"> | string
    description?: StringNullableWithAggregatesFilter<"ServiceVariant"> | string | null
    categoryId?: StringWithAggregatesFilter<"ServiceVariant"> | string
  }

  export type ServiceInquiryWhereInput = {
    AND?: ServiceInquiryWhereInput | ServiceInquiryWhereInput[]
    OR?: ServiceInquiryWhereInput[]
    NOT?: ServiceInquiryWhereInput | ServiceInquiryWhereInput[]
    id?: StringFilter<"ServiceInquiry"> | string
    residentName?: StringFilter<"ServiceInquiry"> | string
    unit?: StringFilter<"ServiceInquiry"> | string
    serviceName?: StringFilter<"ServiceInquiry"> | string
    serviceId?: StringFilter<"ServiceInquiry"> | string
    status?: StringFilter<"ServiceInquiry"> | string
    vendorName?: StringNullableFilter<"ServiceInquiry"> | string | null
    vendorId?: StringNullableFilter<"ServiceInquiry"> | string | null
    source?: StringNullableFilter<"ServiceInquiry"> | string | null
    type?: StringNullableFilter<"ServiceInquiry"> | string | null
    createdAt?: DateTimeFilter<"ServiceInquiry"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceInquiry"> | Date | string
    societyId?: IntNullableFilter<"ServiceInquiry"> | number | null
  }

  export type ServiceInquiryOrderByWithRelationInput = {
    id?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    serviceName?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    vendorName?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    societyId?: SortOrderInput | SortOrder
    _relevance?: ServiceInquiryOrderByRelevanceInput
  }

  export type ServiceInquiryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceInquiryWhereInput | ServiceInquiryWhereInput[]
    OR?: ServiceInquiryWhereInput[]
    NOT?: ServiceInquiryWhereInput | ServiceInquiryWhereInput[]
    residentName?: StringFilter<"ServiceInquiry"> | string
    unit?: StringFilter<"ServiceInquiry"> | string
    serviceName?: StringFilter<"ServiceInquiry"> | string
    serviceId?: StringFilter<"ServiceInquiry"> | string
    status?: StringFilter<"ServiceInquiry"> | string
    vendorName?: StringNullableFilter<"ServiceInquiry"> | string | null
    vendorId?: StringNullableFilter<"ServiceInquiry"> | string | null
    source?: StringNullableFilter<"ServiceInquiry"> | string | null
    type?: StringNullableFilter<"ServiceInquiry"> | string | null
    createdAt?: DateTimeFilter<"ServiceInquiry"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceInquiry"> | Date | string
    societyId?: IntNullableFilter<"ServiceInquiry"> | number | null
  }, "id">

  export type ServiceInquiryOrderByWithAggregationInput = {
    id?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    serviceName?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    vendorName?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    societyId?: SortOrderInput | SortOrder
    _count?: ServiceInquiryCountOrderByAggregateInput
    _avg?: ServiceInquiryAvgOrderByAggregateInput
    _max?: ServiceInquiryMaxOrderByAggregateInput
    _min?: ServiceInquiryMinOrderByAggregateInput
    _sum?: ServiceInquirySumOrderByAggregateInput
  }

  export type ServiceInquiryScalarWhereWithAggregatesInput = {
    AND?: ServiceInquiryScalarWhereWithAggregatesInput | ServiceInquiryScalarWhereWithAggregatesInput[]
    OR?: ServiceInquiryScalarWhereWithAggregatesInput[]
    NOT?: ServiceInquiryScalarWhereWithAggregatesInput | ServiceInquiryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceInquiry"> | string
    residentName?: StringWithAggregatesFilter<"ServiceInquiry"> | string
    unit?: StringWithAggregatesFilter<"ServiceInquiry"> | string
    serviceName?: StringWithAggregatesFilter<"ServiceInquiry"> | string
    serviceId?: StringWithAggregatesFilter<"ServiceInquiry"> | string
    status?: StringWithAggregatesFilter<"ServiceInquiry"> | string
    vendorName?: StringNullableWithAggregatesFilter<"ServiceInquiry"> | string | null
    vendorId?: StringNullableWithAggregatesFilter<"ServiceInquiry"> | string | null
    source?: StringNullableWithAggregatesFilter<"ServiceInquiry"> | string | null
    type?: StringNullableWithAggregatesFilter<"ServiceInquiry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceInquiry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceInquiry"> | Date | string
    societyId?: IntNullableWithAggregatesFilter<"ServiceInquiry"> | number | null
  }

  export type EmergencyLogWhereInput = {
    AND?: EmergencyLogWhereInput | EmergencyLogWhereInput[]
    OR?: EmergencyLogWhereInput[]
    NOT?: EmergencyLogWhereInput | EmergencyLogWhereInput[]
    id?: StringFilter<"EmergencyLog"> | string
    timestamp?: DateTimeFilter<"EmergencyLog"> | Date | string
    visitorName?: StringFilter<"EmergencyLog"> | string
    visitorPhone?: StringFilter<"EmergencyLog"> | string
    residentName?: StringFilter<"EmergencyLog"> | string
    unit?: StringFilter<"EmergencyLog"> | string
    isEmergency?: BoolFilter<"EmergencyLog"> | boolean
    reason?: StringNullableFilter<"EmergencyLog"> | string | null
    barcodeId?: StringFilter<"EmergencyLog"> | string
    societyId?: IntNullableFilter<"EmergencyLog"> | number | null
  }

  export type EmergencyLogOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    visitorName?: SortOrder
    visitorPhone?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    isEmergency?: SortOrder
    reason?: SortOrderInput | SortOrder
    barcodeId?: SortOrder
    societyId?: SortOrderInput | SortOrder
    _relevance?: EmergencyLogOrderByRelevanceInput
  }

  export type EmergencyLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmergencyLogWhereInput | EmergencyLogWhereInput[]
    OR?: EmergencyLogWhereInput[]
    NOT?: EmergencyLogWhereInput | EmergencyLogWhereInput[]
    timestamp?: DateTimeFilter<"EmergencyLog"> | Date | string
    visitorName?: StringFilter<"EmergencyLog"> | string
    visitorPhone?: StringFilter<"EmergencyLog"> | string
    residentName?: StringFilter<"EmergencyLog"> | string
    unit?: StringFilter<"EmergencyLog"> | string
    isEmergency?: BoolFilter<"EmergencyLog"> | boolean
    reason?: StringNullableFilter<"EmergencyLog"> | string | null
    barcodeId?: StringFilter<"EmergencyLog"> | string
    societyId?: IntNullableFilter<"EmergencyLog"> | number | null
  }, "id">

  export type EmergencyLogOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    visitorName?: SortOrder
    visitorPhone?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    isEmergency?: SortOrder
    reason?: SortOrderInput | SortOrder
    barcodeId?: SortOrder
    societyId?: SortOrderInput | SortOrder
    _count?: EmergencyLogCountOrderByAggregateInput
    _avg?: EmergencyLogAvgOrderByAggregateInput
    _max?: EmergencyLogMaxOrderByAggregateInput
    _min?: EmergencyLogMinOrderByAggregateInput
    _sum?: EmergencyLogSumOrderByAggregateInput
  }

  export type EmergencyLogScalarWhereWithAggregatesInput = {
    AND?: EmergencyLogScalarWhereWithAggregatesInput | EmergencyLogScalarWhereWithAggregatesInput[]
    OR?: EmergencyLogScalarWhereWithAggregatesInput[]
    NOT?: EmergencyLogScalarWhereWithAggregatesInput | EmergencyLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmergencyLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"EmergencyLog"> | Date | string
    visitorName?: StringWithAggregatesFilter<"EmergencyLog"> | string
    visitorPhone?: StringWithAggregatesFilter<"EmergencyLog"> | string
    residentName?: StringWithAggregatesFilter<"EmergencyLog"> | string
    unit?: StringWithAggregatesFilter<"EmergencyLog"> | string
    isEmergency?: BoolWithAggregatesFilter<"EmergencyLog"> | boolean
    reason?: StringNullableWithAggregatesFilter<"EmergencyLog"> | string | null
    barcodeId?: StringWithAggregatesFilter<"EmergencyLog"> | string
    societyId?: IntNullableWithAggregatesFilter<"EmergencyLog"> | number | null
  }

  export type EmergencyBarcodeWhereInput = {
    AND?: EmergencyBarcodeWhereInput | EmergencyBarcodeWhereInput[]
    OR?: EmergencyBarcodeWhereInput[]
    NOT?: EmergencyBarcodeWhereInput | EmergencyBarcodeWhereInput[]
    id?: StringFilter<"EmergencyBarcode"> | string
    residentName?: StringFilter<"EmergencyBarcode"> | string
    unit?: StringFilter<"EmergencyBarcode"> | string
    phone?: StringFilter<"EmergencyBarcode"> | string
    status?: StringFilter<"EmergencyBarcode"> | string
    qrCodeUrl?: StringFilter<"EmergencyBarcode"> | string
    createdAt?: DateTimeFilter<"EmergencyBarcode"> | Date | string
    societyId?: IntNullableFilter<"EmergencyBarcode"> | number | null
  }

  export type EmergencyBarcodeOrderByWithRelationInput = {
    id?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    qrCodeUrl?: SortOrder
    createdAt?: SortOrder
    societyId?: SortOrderInput | SortOrder
    _relevance?: EmergencyBarcodeOrderByRelevanceInput
  }

  export type EmergencyBarcodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmergencyBarcodeWhereInput | EmergencyBarcodeWhereInput[]
    OR?: EmergencyBarcodeWhereInput[]
    NOT?: EmergencyBarcodeWhereInput | EmergencyBarcodeWhereInput[]
    residentName?: StringFilter<"EmergencyBarcode"> | string
    unit?: StringFilter<"EmergencyBarcode"> | string
    phone?: StringFilter<"EmergencyBarcode"> | string
    status?: StringFilter<"EmergencyBarcode"> | string
    qrCodeUrl?: StringFilter<"EmergencyBarcode"> | string
    createdAt?: DateTimeFilter<"EmergencyBarcode"> | Date | string
    societyId?: IntNullableFilter<"EmergencyBarcode"> | number | null
  }, "id">

  export type EmergencyBarcodeOrderByWithAggregationInput = {
    id?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    qrCodeUrl?: SortOrder
    createdAt?: SortOrder
    societyId?: SortOrderInput | SortOrder
    _count?: EmergencyBarcodeCountOrderByAggregateInput
    _avg?: EmergencyBarcodeAvgOrderByAggregateInput
    _max?: EmergencyBarcodeMaxOrderByAggregateInput
    _min?: EmergencyBarcodeMinOrderByAggregateInput
    _sum?: EmergencyBarcodeSumOrderByAggregateInput
  }

  export type EmergencyBarcodeScalarWhereWithAggregatesInput = {
    AND?: EmergencyBarcodeScalarWhereWithAggregatesInput | EmergencyBarcodeScalarWhereWithAggregatesInput[]
    OR?: EmergencyBarcodeScalarWhereWithAggregatesInput[]
    NOT?: EmergencyBarcodeScalarWhereWithAggregatesInput | EmergencyBarcodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmergencyBarcode"> | string
    residentName?: StringWithAggregatesFilter<"EmergencyBarcode"> | string
    unit?: StringWithAggregatesFilter<"EmergencyBarcode"> | string
    phone?: StringWithAggregatesFilter<"EmergencyBarcode"> | string
    status?: StringWithAggregatesFilter<"EmergencyBarcode"> | string
    qrCodeUrl?: StringWithAggregatesFilter<"EmergencyBarcode"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmergencyBarcode"> | Date | string
    societyId?: IntNullableWithAggregatesFilter<"EmergencyBarcode"> | number | null
  }

  export type NoticeWhereInput = {
    AND?: NoticeWhereInput | NoticeWhereInput[]
    OR?: NoticeWhereInput[]
    NOT?: NoticeWhereInput | NoticeWhereInput[]
    id?: IntFilter<"Notice"> | number
    title?: StringFilter<"Notice"> | string
    content?: StringFilter<"Notice"> | string
    audience?: StringFilter<"Notice"> | string
    societyId?: IntFilter<"Notice"> | number
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notice"> | Date | string | null
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type NoticeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    society?: SocietyOrderByWithRelationInput
    _relevance?: NoticeOrderByRelevanceInput
  }

  export type NoticeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NoticeWhereInput | NoticeWhereInput[]
    OR?: NoticeWhereInput[]
    NOT?: NoticeWhereInput | NoticeWhereInput[]
    title?: StringFilter<"Notice"> | string
    content?: StringFilter<"Notice"> | string
    audience?: StringFilter<"Notice"> | string
    societyId?: IntFilter<"Notice"> | number
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notice"> | Date | string | null
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id">

  export type NoticeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: NoticeCountOrderByAggregateInput
    _avg?: NoticeAvgOrderByAggregateInput
    _max?: NoticeMaxOrderByAggregateInput
    _min?: NoticeMinOrderByAggregateInput
    _sum?: NoticeSumOrderByAggregateInput
  }

  export type NoticeScalarWhereWithAggregatesInput = {
    AND?: NoticeScalarWhereWithAggregatesInput | NoticeScalarWhereWithAggregatesInput[]
    OR?: NoticeScalarWhereWithAggregatesInput[]
    NOT?: NoticeScalarWhereWithAggregatesInput | NoticeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notice"> | number
    title?: StringWithAggregatesFilter<"Notice"> | string
    content?: StringWithAggregatesFilter<"Notice"> | string
    audience?: StringWithAggregatesFilter<"Notice"> | string
    societyId?: IntWithAggregatesFilter<"Notice"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Notice"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Notice"> | Date | string | null
  }

  export type AmenityWhereInput = {
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    id?: IntFilter<"Amenity"> | number
    name?: StringFilter<"Amenity"> | string
    description?: StringNullableFilter<"Amenity"> | string | null
    chargesPerHour?: FloatFilter<"Amenity"> | number
    societyId?: IntFilter<"Amenity"> | number
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    bookings?: AmenityBookingListRelationFilter
  }

  export type AmenityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    chargesPerHour?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    bookings?: AmenityBookingOrderByRelationAggregateInput
    _relevance?: AmenityOrderByRelevanceInput
  }

  export type AmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    name?: StringFilter<"Amenity"> | string
    description?: StringNullableFilter<"Amenity"> | string | null
    chargesPerHour?: FloatFilter<"Amenity"> | number
    societyId?: IntFilter<"Amenity"> | number
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
    bookings?: AmenityBookingListRelationFilter
  }, "id">

  export type AmenityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    chargesPerHour?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    _count?: AmenityCountOrderByAggregateInput
    _avg?: AmenityAvgOrderByAggregateInput
    _max?: AmenityMaxOrderByAggregateInput
    _min?: AmenityMinOrderByAggregateInput
    _sum?: AmenitySumOrderByAggregateInput
  }

  export type AmenityScalarWhereWithAggregatesInput = {
    AND?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    OR?: AmenityScalarWhereWithAggregatesInput[]
    NOT?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Amenity"> | number
    name?: StringWithAggregatesFilter<"Amenity"> | string
    description?: StringNullableWithAggregatesFilter<"Amenity"> | string | null
    chargesPerHour?: FloatWithAggregatesFilter<"Amenity"> | number
    societyId?: IntWithAggregatesFilter<"Amenity"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Amenity"> | Date | string
  }

  export type AmenityBookingWhereInput = {
    AND?: AmenityBookingWhereInput | AmenityBookingWhereInput[]
    OR?: AmenityBookingWhereInput[]
    NOT?: AmenityBookingWhereInput | AmenityBookingWhereInput[]
    id?: IntFilter<"AmenityBooking"> | number
    amenityId?: IntFilter<"AmenityBooking"> | number
    userId?: IntFilter<"AmenityBooking"> | number
    startTime?: DateTimeFilter<"AmenityBooking"> | Date | string
    endTime?: DateTimeFilter<"AmenityBooking"> | Date | string
    status?: StringFilter<"AmenityBooking"> | string
    amountPaid?: FloatFilter<"AmenityBooking"> | number
    createdAt?: DateTimeFilter<"AmenityBooking"> | Date | string
    amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AmenityBookingOrderByWithRelationInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    amenity?: AmenityOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: AmenityBookingOrderByRelevanceInput
  }

  export type AmenityBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AmenityBookingWhereInput | AmenityBookingWhereInput[]
    OR?: AmenityBookingWhereInput[]
    NOT?: AmenityBookingWhereInput | AmenityBookingWhereInput[]
    amenityId?: IntFilter<"AmenityBooking"> | number
    userId?: IntFilter<"AmenityBooking"> | number
    startTime?: DateTimeFilter<"AmenityBooking"> | Date | string
    endTime?: DateTimeFilter<"AmenityBooking"> | Date | string
    status?: StringFilter<"AmenityBooking"> | string
    amountPaid?: FloatFilter<"AmenityBooking"> | number
    createdAt?: DateTimeFilter<"AmenityBooking"> | Date | string
    amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AmenityBookingOrderByWithAggregationInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    _count?: AmenityBookingCountOrderByAggregateInput
    _avg?: AmenityBookingAvgOrderByAggregateInput
    _max?: AmenityBookingMaxOrderByAggregateInput
    _min?: AmenityBookingMinOrderByAggregateInput
    _sum?: AmenityBookingSumOrderByAggregateInput
  }

  export type AmenityBookingScalarWhereWithAggregatesInput = {
    AND?: AmenityBookingScalarWhereWithAggregatesInput | AmenityBookingScalarWhereWithAggregatesInput[]
    OR?: AmenityBookingScalarWhereWithAggregatesInput[]
    NOT?: AmenityBookingScalarWhereWithAggregatesInput | AmenityBookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AmenityBooking"> | number
    amenityId?: IntWithAggregatesFilter<"AmenityBooking"> | number
    userId?: IntWithAggregatesFilter<"AmenityBooking"> | number
    startTime?: DateTimeWithAggregatesFilter<"AmenityBooking"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"AmenityBooking"> | Date | string
    status?: StringWithAggregatesFilter<"AmenityBooking"> | string
    amountPaid?: FloatWithAggregatesFilter<"AmenityBooking"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AmenityBooking"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: IntFilter<"SystemSetting"> | number
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _relevance?: SystemSettingOrderByRelevanceInput
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: StringFilter<"SystemSetting"> | string
  }, "id" | "key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _avg?: SystemSettingAvgOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
    _sum?: SystemSettingSumOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemSetting"> | number
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringWithAggregatesFilter<"SystemSetting"> | string
  }

  export type BillingPlanWhereInput = {
    AND?: BillingPlanWhereInput | BillingPlanWhereInput[]
    OR?: BillingPlanWhereInput[]
    NOT?: BillingPlanWhereInput | BillingPlanWhereInput[]
    id?: IntFilter<"BillingPlan"> | number
    name?: StringFilter<"BillingPlan"> | string
    type?: StringFilter<"BillingPlan"> | string
    price?: StringFilter<"BillingPlan"> | string
    description?: StringNullableFilter<"BillingPlan"> | string | null
    status?: StringFilter<"BillingPlan"> | string
    createdAt?: DateTimeFilter<"BillingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"BillingPlan"> | Date | string
  }

  export type BillingPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: BillingPlanOrderByRelevanceInput
  }

  export type BillingPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BillingPlanWhereInput | BillingPlanWhereInput[]
    OR?: BillingPlanWhereInput[]
    NOT?: BillingPlanWhereInput | BillingPlanWhereInput[]
    name?: StringFilter<"BillingPlan"> | string
    type?: StringFilter<"BillingPlan"> | string
    price?: StringFilter<"BillingPlan"> | string
    description?: StringNullableFilter<"BillingPlan"> | string | null
    status?: StringFilter<"BillingPlan"> | string
    createdAt?: DateTimeFilter<"BillingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"BillingPlan"> | Date | string
  }, "id">

  export type BillingPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillingPlanCountOrderByAggregateInput
    _avg?: BillingPlanAvgOrderByAggregateInput
    _max?: BillingPlanMaxOrderByAggregateInput
    _min?: BillingPlanMinOrderByAggregateInput
    _sum?: BillingPlanSumOrderByAggregateInput
  }

  export type BillingPlanScalarWhereWithAggregatesInput = {
    AND?: BillingPlanScalarWhereWithAggregatesInput | BillingPlanScalarWhereWithAggregatesInput[]
    OR?: BillingPlanScalarWhereWithAggregatesInput[]
    NOT?: BillingPlanScalarWhereWithAggregatesInput | BillingPlanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BillingPlan"> | number
    name?: StringWithAggregatesFilter<"BillingPlan"> | string
    type?: StringWithAggregatesFilter<"BillingPlan"> | string
    price?: StringWithAggregatesFilter<"BillingPlan"> | string
    description?: StringNullableWithAggregatesFilter<"BillingPlan"> | string | null
    status?: StringWithAggregatesFilter<"BillingPlan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BillingPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillingPlan"> | Date | string
  }

  export type PlatformInvoiceWhereInput = {
    AND?: PlatformInvoiceWhereInput | PlatformInvoiceWhereInput[]
    OR?: PlatformInvoiceWhereInput[]
    NOT?: PlatformInvoiceWhereInput | PlatformInvoiceWhereInput[]
    id?: IntFilter<"PlatformInvoice"> | number
    invoiceNo?: StringFilter<"PlatformInvoice"> | string
    societyId?: IntFilter<"PlatformInvoice"> | number
    amount?: FloatFilter<"PlatformInvoice"> | number
    status?: StringFilter<"PlatformInvoice"> | string
    issueDate?: DateTimeFilter<"PlatformInvoice"> | Date | string
    dueDate?: DateTimeFilter<"PlatformInvoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"PlatformInvoice"> | Date | string | null
    createdAt?: DateTimeFilter<"PlatformInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformInvoice"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }

  export type PlatformInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    societyId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    society?: SocietyOrderByWithRelationInput
    _relevance?: PlatformInvoiceOrderByRelevanceInput
  }

  export type PlatformInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    invoiceNo?: string
    AND?: PlatformInvoiceWhereInput | PlatformInvoiceWhereInput[]
    OR?: PlatformInvoiceWhereInput[]
    NOT?: PlatformInvoiceWhereInput | PlatformInvoiceWhereInput[]
    societyId?: IntFilter<"PlatformInvoice"> | number
    amount?: FloatFilter<"PlatformInvoice"> | number
    status?: StringFilter<"PlatformInvoice"> | string
    issueDate?: DateTimeFilter<"PlatformInvoice"> | Date | string
    dueDate?: DateTimeFilter<"PlatformInvoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"PlatformInvoice"> | Date | string | null
    createdAt?: DateTimeFilter<"PlatformInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformInvoice"> | Date | string
    society?: XOR<SocietyScalarRelationFilter, SocietyWhereInput>
  }, "id" | "invoiceNo">

  export type PlatformInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    societyId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlatformInvoiceCountOrderByAggregateInput
    _avg?: PlatformInvoiceAvgOrderByAggregateInput
    _max?: PlatformInvoiceMaxOrderByAggregateInput
    _min?: PlatformInvoiceMinOrderByAggregateInput
    _sum?: PlatformInvoiceSumOrderByAggregateInput
  }

  export type PlatformInvoiceScalarWhereWithAggregatesInput = {
    AND?: PlatformInvoiceScalarWhereWithAggregatesInput | PlatformInvoiceScalarWhereWithAggregatesInput[]
    OR?: PlatformInvoiceScalarWhereWithAggregatesInput[]
    NOT?: PlatformInvoiceScalarWhereWithAggregatesInput | PlatformInvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlatformInvoice"> | number
    invoiceNo?: StringWithAggregatesFilter<"PlatformInvoice"> | string
    societyId?: IntWithAggregatesFilter<"PlatformInvoice"> | number
    amount?: FloatWithAggregatesFilter<"PlatformInvoice"> | number
    status?: StringWithAggregatesFilter<"PlatformInvoice"> | string
    issueDate?: DateTimeWithAggregatesFilter<"PlatformInvoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"PlatformInvoice"> | Date | string
    paidDate?: DateTimeNullableWithAggregatesFilter<"PlatformInvoice"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlatformInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlatformInvoice"> | Date | string
  }

  export type SocietyCreateInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyCreateManyInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocietyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocietyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitUpdateManyMutationInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotCreateInput = {
    number: string
    type: string
    status: string
    vehicleNumber?: string | null
    createdAt?: Date | string
    society: SocietyCreateNestedOneWithoutParkingSlotsInput
    unit?: UnitCreateNestedOneWithoutParkingSlotsInput
  }

  export type ParkingSlotUncheckedCreateInput = {
    id?: number
    number: string
    type: string
    status: string
    societyId: number
    allocatedToUnitId?: number | null
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type ParkingSlotUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutParkingSlotsNestedInput
    unit?: UnitUpdateOneWithoutParkingSlotsNestedInput
  }

  export type ParkingSlotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    allocatedToUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotCreateManyInput = {
    id?: number
    number: string
    type: string
    status: string
    societyId: number
    allocatedToUnitId?: number | null
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type ParkingSlotUpdateManyMutationInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    allocatedToUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCreateInput = {
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutComplaintsInput
    reportedBy: UserCreateNestedOneWithoutReportedComplaintsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedComplaintsInput
    comments?: ComplaintCommentCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    reportedById: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutComplaintsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutReportedComplaintsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedComplaintsNestedInput
    comments?: ComplaintCommentUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ComplaintCommentUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintCreateManyInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    reportedById: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentCreateInput = {
    message: string
    createdAt?: Date | string
    complaint: ComplaintCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type ComplaintCommentUncheckedCreateInput = {
    id?: number
    complaintId: number
    userId: number
    message: string
    createdAt?: Date | string
  }

  export type ComplaintCommentUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint?: ComplaintUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ComplaintCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaintId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentCreateManyInput = {
    id?: number
    complaintId: number
    userId: number
    message: string
    createdAt?: Date | string
  }

  export type ComplaintCommentUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaintId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorCreateInput = {
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutVisitorsInput
    unit: UnitCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    societyId: number
    visitingUnitId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutVisitorsNestedInput
    unit?: UnitUpdateOneRequiredWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    visitingUnitId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorCreateManyInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    societyId: number
    visitingUnitId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    visitingUnitId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    societyId: number
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: number
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    societyId: number
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateInput = {
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    status?: $Enums.VendorStatus
    createdAt?: Date | string
    society?: SocietyCreateNestedOneWithoutVendorsInput
    payouts?: VendorPayoutCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: number
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    status?: $Enums.VendorStatus
    societyId?: number | null
    createdAt?: Date | string
    payouts?: VendorPayoutUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutVendorsNestedInput
    payouts?: VendorPayoutUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payouts?: VendorPayoutUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    id?: number
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    status?: $Enums.VendorStatus
    societyId?: number | null
    createdAt?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPayoutCreateInput = {
    vendorName: string
    societyId?: number | null
    societyName?: string | null
    dealValue: number
    commissionPercent: number
    payableAmount: number
    status?: string
    remarks?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPayoutsInput
  }

  export type VendorPayoutUncheckedCreateInput = {
    id?: number
    vendorId: number
    vendorName: string
    societyId?: number | null
    societyName?: string | null
    dealValue: number
    commissionPercent: number
    payableAmount: number
    status?: string
    remarks?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorPayoutUpdateInput = {
    vendorName?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    societyName?: NullableStringFieldUpdateOperationsInput | string | null
    dealValue?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    payableAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPayoutsNestedInput
  }

  export type VendorPayoutUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    vendorName?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    societyName?: NullableStringFieldUpdateOperationsInput | string | null
    dealValue?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    payableAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPayoutCreateManyInput = {
    id?: number
    vendorId: number
    vendorName: string
    societyId?: number | null
    societyName?: string | null
    dealValue: number
    commissionPercent: number
    payableAmount: number
    status?: string
    remarks?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorPayoutUpdateManyMutationInput = {
    vendorName?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    societyName?: NullableStringFieldUpdateOperationsInput | string | null
    dealValue?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    payableAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPayoutUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    vendorName?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    societyName?: NullableStringFieldUpdateOperationsInput | string | null
    dealValue?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    payableAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryCreateInput = {
    id: string
    name: string
    description: string
    icon: string
    color: string
    variants?: ServiceVariantCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUncheckedCreateInput = {
    id: string
    name: string
    description: string
    icon: string
    color: string
    variants?: ServiceVariantUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    variants?: ServiceVariantUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    variants?: ServiceVariantUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryCreateManyInput = {
    id: string
    name: string
    description: string
    icon: string
    color: string
  }

  export type ServiceCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceVariantCreateInput = {
    id?: string
    name: string
    price: string
    description?: string | null
    category: ServiceCategoryCreateNestedOneWithoutVariantsInput
  }

  export type ServiceVariantUncheckedCreateInput = {
    id?: string
    name: string
    price: string
    description?: string | null
    categoryId: string
  }

  export type ServiceVariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: ServiceCategoryUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type ServiceVariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceVariantCreateManyInput = {
    id?: string
    name: string
    price: string
    description?: string | null
    categoryId: string
  }

  export type ServiceVariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceVariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceInquiryCreateInput = {
    id?: string
    residentName: string
    unit: string
    serviceName: string
    serviceId: string
    status?: string
    vendorName?: string | null
    vendorId?: string | null
    source?: string | null
    type?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    societyId?: number | null
  }

  export type ServiceInquiryUncheckedCreateInput = {
    id?: string
    residentName: string
    unit: string
    serviceName: string
    serviceId: string
    status?: string
    vendorName?: string | null
    vendorId?: string | null
    source?: string | null
    type?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    societyId?: number | null
  }

  export type ServiceInquiryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServiceInquiryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServiceInquiryCreateManyInput = {
    id?: string
    residentName: string
    unit: string
    serviceName: string
    serviceId: string
    status?: string
    vendorName?: string | null
    vendorId?: string | null
    source?: string | null
    type?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    societyId?: number | null
  }

  export type ServiceInquiryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServiceInquiryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmergencyLogCreateInput = {
    id?: string
    timestamp?: Date | string
    visitorName: string
    visitorPhone: string
    residentName: string
    unit: string
    isEmergency?: boolean
    reason?: string | null
    barcodeId: string
    societyId?: number | null
  }

  export type EmergencyLogUncheckedCreateInput = {
    id?: string
    timestamp?: Date | string
    visitorName: string
    visitorPhone: string
    residentName: string
    unit: string
    isEmergency?: boolean
    reason?: string | null
    barcodeId: string
    societyId?: number | null
  }

  export type EmergencyLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    visitorName?: StringFieldUpdateOperationsInput | string
    visitorPhone?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    barcodeId?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmergencyLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    visitorName?: StringFieldUpdateOperationsInput | string
    visitorPhone?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    barcodeId?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmergencyLogCreateManyInput = {
    id?: string
    timestamp?: Date | string
    visitorName: string
    visitorPhone: string
    residentName: string
    unit: string
    isEmergency?: boolean
    reason?: string | null
    barcodeId: string
    societyId?: number | null
  }

  export type EmergencyLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    visitorName?: StringFieldUpdateOperationsInput | string
    visitorPhone?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    barcodeId?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmergencyLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    visitorName?: StringFieldUpdateOperationsInput | string
    visitorPhone?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    barcodeId?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmergencyBarcodeCreateInput = {
    id: string
    residentName: string
    unit: string
    phone: string
    status?: string
    qrCodeUrl: string
    createdAt?: Date | string
    societyId?: number | null
  }

  export type EmergencyBarcodeUncheckedCreateInput = {
    id: string
    residentName: string
    unit: string
    phone: string
    status?: string
    qrCodeUrl: string
    createdAt?: Date | string
    societyId?: number | null
  }

  export type EmergencyBarcodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmergencyBarcodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmergencyBarcodeCreateManyInput = {
    id: string
    residentName: string
    unit: string
    phone: string
    status?: string
    qrCodeUrl: string
    createdAt?: Date | string
    societyId?: number | null
  }

  export type EmergencyBarcodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmergencyBarcodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentName?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NoticeCreateInput = {
    title: string
    content: string
    audience: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    society: SocietyCreateNestedOneWithoutNoticesInput
  }

  export type NoticeUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    audience: string
    societyId: number
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NoticeUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    society?: SocietyUpdateOneRequiredWithoutNoticesNestedInput
  }

  export type NoticeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoticeCreateManyInput = {
    id?: number
    title: string
    content: string
    audience: string
    societyId: number
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NoticeUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoticeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AmenityCreateInput = {
    name: string
    description?: string | null
    chargesPerHour?: number
    createdAt?: Date | string
    society: SocietyCreateNestedOneWithoutAmenitiesInput
    bookings?: AmenityBookingCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    chargesPerHour?: number
    societyId: number
    createdAt?: Date | string
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutAmenitiesNestedInput
    bookings?: AmenityBookingUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: AmenityBookingUncheckedUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    chargesPerHour?: number
    societyId: number
    createdAt?: Date | string
  }

  export type AmenityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingCreateInput = {
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
    amenity: AmenityCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
  }

  export type AmenityBookingUncheckedCreateInput = {
    id?: number
    amenityId: number
    userId: number
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
  }

  export type AmenityBookingUpdateInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenity?: AmenityUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type AmenityBookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingCreateManyInput = {
    id?: number
    amenityId: number
    userId: number
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
  }

  export type AmenityBookingUpdateManyMutationInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    key: string
    value: string
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: number
    key: string
    value: string
  }

  export type SystemSettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SystemSettingCreateManyInput = {
    id?: number
    key: string
    value: string
  }

  export type SystemSettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type BillingPlanCreateInput = {
    name: string
    type: string
    price: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingPlanUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    price: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingPlanUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPlanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPlanCreateManyInput = {
    id?: number
    name: string
    type: string
    price: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingPlanUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPlanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformInvoiceCreateInput = {
    invoiceNo: string
    amount: number
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutPlatformInvoicesInput
  }

  export type PlatformInvoiceUncheckedCreateInput = {
    id?: number
    invoiceNo: string
    societyId: number
    amount: number
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformInvoiceUpdateInput = {
    invoiceNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutPlatformInvoicesNestedInput
  }

  export type PlatformInvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformInvoiceCreateManyInput = {
    id?: number
    invoiceNo: string
    societyId: number
    amount: number
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformInvoiceUpdateManyMutationInput = {
    invoiceNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformInvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumSocietyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SocietyStatus | EnumSocietyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SocietyStatus[]
    notIn?: $Enums.SocietyStatus[]
    not?: NestedEnumSocietyStatusFilter<$PrismaModel> | $Enums.SocietyStatus
  }

  export type EnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UnitListRelationFilter = {
    every?: UnitWhereInput
    some?: UnitWhereInput
    none?: UnitWhereInput
  }

  export type ComplaintListRelationFilter = {
    every?: ComplaintWhereInput
    some?: ComplaintWhereInput
    none?: ComplaintWhereInput
  }

  export type VisitorListRelationFilter = {
    every?: VisitorWhereInput
    some?: VisitorWhereInput
    none?: VisitorWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type NoticeListRelationFilter = {
    every?: NoticeWhereInput
    some?: NoticeWhereInput
    none?: NoticeWhereInput
  }

  export type VendorListRelationFilter = {
    every?: VendorWhereInput
    some?: VendorWhereInput
    none?: VendorWhereInput
  }

  export type AmenityListRelationFilter = {
    every?: AmenityWhereInput
    some?: AmenityWhereInput
    none?: AmenityWhereInput
  }

  export type ParkingSlotListRelationFilter = {
    every?: ParkingSlotWhereInput
    some?: ParkingSlotWhereInput
    none?: ParkingSlotWhereInput
  }

  export type PlatformInvoiceListRelationFilter = {
    every?: PlatformInvoiceWhereInput
    some?: PlatformInvoiceWhereInput
    none?: PlatformInvoiceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplaintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisitorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoticeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AmenityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParkingSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlatformInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocietyOrderByRelevanceInput = {
    fields: SocietyOrderByRelevanceFieldEnum | SocietyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SocietyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    code?: SortOrder
    status?: SortOrder
    subscriptionPlan?: SortOrder
    expectedUnits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocietyAvgOrderByAggregateInput = {
    id?: SortOrder
    expectedUnits?: SortOrder
  }

  export type SocietyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    code?: SortOrder
    status?: SortOrder
    subscriptionPlan?: SortOrder
    expectedUnits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocietyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    code?: SortOrder
    status?: SortOrder
    subscriptionPlan?: SortOrder
    expectedUnits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocietySumOrderByAggregateInput = {
    id?: SortOrder
    expectedUnits?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumSocietyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocietyStatus | EnumSocietyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SocietyStatus[]
    notIn?: $Enums.SocietyStatus[]
    not?: NestedEnumSocietyStatusWithAggregatesFilter<$PrismaModel> | $Enums.SocietyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocietyStatusFilter<$PrismaModel>
    _max?: NestedEnumSocietyStatusFilter<$PrismaModel>
  }

  export type EnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[]
    notIn?: $Enums.UserStatus[]
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SocietyNullableScalarRelationFilter = {
    is?: SocietyWhereInput | null
    isNot?: SocietyWhereInput | null
  }

  export type AmenityBookingListRelationFilter = {
    every?: AmenityBookingWhereInput
    some?: AmenityBookingWhereInput
    none?: AmenityBookingWhereInput
  }

  export type ComplaintCommentListRelationFilter = {
    every?: ComplaintCommentWhereInput
    some?: ComplaintCommentWhereInput
    none?: ComplaintCommentWhereInput
  }

  export type AmenityBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplaintCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    status?: SortOrder
    profileImg?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    status?: SortOrder
    profileImg?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    status?: SortOrder
    profileImg?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[]
    notIn?: $Enums.UserStatus[]
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SocietyScalarRelationFilter = {
    is?: SocietyWhereInput
    isNot?: SocietyWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UnitOrderByRelevanceInput = {
    fields: UnitOrderByRelevanceFieldEnum | UnitOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UnitSocietyIdBlockNumberCompoundUniqueInput = {
    societyId: number
    block: string
    number: string
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    block?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    areaSqFt?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    id?: SortOrder
    floor?: SortOrder
    areaSqFt?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    block?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    areaSqFt?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    block?: SortOrder
    number?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    areaSqFt?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    id?: SortOrder
    floor?: SortOrder
    areaSqFt?: SortOrder
    societyId?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UnitNullableScalarRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type ParkingSlotOrderByRelevanceInput = {
    fields: ParkingSlotOrderByRelevanceFieldEnum | ParkingSlotOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ParkingSlotCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrder
    vehicleNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type ParkingSlotAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrder
  }

  export type ParkingSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrder
    vehicleNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type ParkingSlotMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrder
    vehicleNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type ParkingSlotSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    allocatedToUnitId?: SortOrder
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[]
    notIn?: $Enums.Priority[]
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type EnumComplaintStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[]
    notIn?: $Enums.ComplaintStatus[]
    not?: NestedEnumComplaintStatusFilter<$PrismaModel> | $Enums.ComplaintStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ComplaintOrderByRelevanceInput = {
    fields: ComplaintOrderByRelevanceFieldEnum | ComplaintOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ComplaintCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    images?: SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    timeline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplaintAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
  }

  export type ComplaintMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplaintMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplaintSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[]
    notIn?: $Enums.Priority[]
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumComplaintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[]
    notIn?: $Enums.ComplaintStatus[]
    not?: NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintStatusFilter<$PrismaModel>
    _max?: NestedEnumComplaintStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ComplaintScalarRelationFilter = {
    is?: ComplaintWhereInput
    isNot?: ComplaintWhereInput
  }

  export type ComplaintCommentOrderByRelevanceInput = {
    fields: ComplaintCommentOrderByRelevanceFieldEnum | ComplaintCommentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ComplaintCommentCountOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ComplaintCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
  }

  export type ComplaintCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ComplaintCommentMinOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ComplaintCommentSumOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    userId?: SortOrder
  }

  export type EnumVisitorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitorStatus | EnumVisitorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitorStatus[]
    notIn?: $Enums.VisitorStatus[]
    not?: NestedEnumVisitorStatusFilter<$PrismaModel> | $Enums.VisitorStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UnitScalarRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type VisitorOrderByRelevanceInput = {
    fields: VisitorOrderByRelevanceFieldEnum | VisitorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VisitorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicleNo?: SortOrder
    purpose?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    entryTime?: SortOrder
    exitTime?: SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitorAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
  }

  export type VisitorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicleNo?: SortOrder
    purpose?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    entryTime?: SortOrder
    exitTime?: SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicleNo?: SortOrder
    purpose?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    entryTime?: SortOrder
    exitTime?: SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitorSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    visitingUnitId?: SortOrder
  }

  export type EnumVisitorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitorStatus | EnumVisitorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitorStatus[]
    notIn?: $Enums.VisitorStatus[]
    not?: NestedEnumVisitorStatusWithAggregatesFilter<$PrismaModel> | $Enums.VisitorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitorStatusFilter<$PrismaModel>
    _max?: NestedEnumVisitorStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type TransactionOrderByRelevanceInput = {
    fields: TransactionOrderByRelevanceFieldEnum | TransactionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    invoiceNo?: SortOrder
    paidTo?: SortOrder
    receivedFrom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    societyId?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    invoiceNo?: SortOrder
    paidTo?: SortOrder
    receivedFrom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    invoiceNo?: SortOrder
    paidTo?: SortOrder
    receivedFrom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    societyId?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumVendorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorStatus | EnumVendorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorStatus[]
    notIn?: $Enums.VendorStatus[]
    not?: NestedEnumVendorStatusFilter<$PrismaModel> | $Enums.VendorStatus
  }

  export type VendorPayoutListRelationFilter = {
    every?: VendorPayoutWhereInput
    some?: VendorPayoutWhereInput
    none?: VendorPayoutWhereInput
  }

  export type VendorPayoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorOrderByRelevanceInput = {
    fields: VendorOrderByRelevanceFieldEnum | VendorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    address?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    address?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    address?: SortOrder
    status?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type EnumVendorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorStatus | EnumVendorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorStatus[]
    notIn?: $Enums.VendorStatus[]
    not?: NestedEnumVendorStatusWithAggregatesFilter<$PrismaModel> | $Enums.VendorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVendorStatusFilter<$PrismaModel>
    _max?: NestedEnumVendorStatusFilter<$PrismaModel>
  }

  export type VendorScalarRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type VendorPayoutOrderByRelevanceInput = {
    fields: VendorPayoutOrderByRelevanceFieldEnum | VendorPayoutOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VendorPayoutCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    societyId?: SortOrder
    societyName?: SortOrder
    dealValue?: SortOrder
    commissionPercent?: SortOrder
    payableAmount?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorPayoutAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    societyId?: SortOrder
    dealValue?: SortOrder
    commissionPercent?: SortOrder
    payableAmount?: SortOrder
  }

  export type VendorPayoutMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    societyId?: SortOrder
    societyName?: SortOrder
    dealValue?: SortOrder
    commissionPercent?: SortOrder
    payableAmount?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorPayoutMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    societyId?: SortOrder
    societyName?: SortOrder
    dealValue?: SortOrder
    commissionPercent?: SortOrder
    payableAmount?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorPayoutSumOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    societyId?: SortOrder
    dealValue?: SortOrder
    commissionPercent?: SortOrder
    payableAmount?: SortOrder
  }

  export type ServiceVariantListRelationFilter = {
    every?: ServiceVariantWhereInput
    some?: ServiceVariantWhereInput
    none?: ServiceVariantWhereInput
  }

  export type ServiceVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCategoryOrderByRelevanceInput = {
    fields: ServiceCategoryOrderByRelevanceFieldEnum | ServiceCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ServiceCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
  }

  export type ServiceCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
  }

  export type ServiceCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
  }

  export type ServiceCategoryScalarRelationFilter = {
    is?: ServiceCategoryWhereInput
    isNot?: ServiceCategoryWhereInput
  }

  export type ServiceVariantOrderByRelevanceInput = {
    fields: ServiceVariantOrderByRelevanceFieldEnum | ServiceVariantOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ServiceVariantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
  }

  export type ServiceVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
  }

  export type ServiceVariantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
  }

  export type ServiceInquiryOrderByRelevanceInput = {
    fields: ServiceInquiryOrderByRelevanceFieldEnum | ServiceInquiryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ServiceInquiryCountOrderByAggregateInput = {
    id?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    serviceName?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    vendorName?: SortOrder
    vendorId?: SortOrder
    source?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    societyId?: SortOrder
  }

  export type ServiceInquiryAvgOrderByAggregateInput = {
    societyId?: SortOrder
  }

  export type ServiceInquiryMaxOrderByAggregateInput = {
    id?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    serviceName?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    vendorName?: SortOrder
    vendorId?: SortOrder
    source?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    societyId?: SortOrder
  }

  export type ServiceInquiryMinOrderByAggregateInput = {
    id?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    serviceName?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    vendorName?: SortOrder
    vendorId?: SortOrder
    source?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    societyId?: SortOrder
  }

  export type ServiceInquirySumOrderByAggregateInput = {
    societyId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EmergencyLogOrderByRelevanceInput = {
    fields: EmergencyLogOrderByRelevanceFieldEnum | EmergencyLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmergencyLogCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    visitorName?: SortOrder
    visitorPhone?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    isEmergency?: SortOrder
    reason?: SortOrder
    barcodeId?: SortOrder
    societyId?: SortOrder
  }

  export type EmergencyLogAvgOrderByAggregateInput = {
    societyId?: SortOrder
  }

  export type EmergencyLogMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    visitorName?: SortOrder
    visitorPhone?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    isEmergency?: SortOrder
    reason?: SortOrder
    barcodeId?: SortOrder
    societyId?: SortOrder
  }

  export type EmergencyLogMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    visitorName?: SortOrder
    visitorPhone?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    isEmergency?: SortOrder
    reason?: SortOrder
    barcodeId?: SortOrder
    societyId?: SortOrder
  }

  export type EmergencyLogSumOrderByAggregateInput = {
    societyId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EmergencyBarcodeOrderByRelevanceInput = {
    fields: EmergencyBarcodeOrderByRelevanceFieldEnum | EmergencyBarcodeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmergencyBarcodeCountOrderByAggregateInput = {
    id?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    qrCodeUrl?: SortOrder
    createdAt?: SortOrder
    societyId?: SortOrder
  }

  export type EmergencyBarcodeAvgOrderByAggregateInput = {
    societyId?: SortOrder
  }

  export type EmergencyBarcodeMaxOrderByAggregateInput = {
    id?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    qrCodeUrl?: SortOrder
    createdAt?: SortOrder
    societyId?: SortOrder
  }

  export type EmergencyBarcodeMinOrderByAggregateInput = {
    id?: SortOrder
    residentName?: SortOrder
    unit?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    qrCodeUrl?: SortOrder
    createdAt?: SortOrder
    societyId?: SortOrder
  }

  export type EmergencyBarcodeSumOrderByAggregateInput = {
    societyId?: SortOrder
  }

  export type NoticeOrderByRelevanceInput = {
    fields: NoticeOrderByRelevanceFieldEnum | NoticeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NoticeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NoticeAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type NoticeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NoticeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NoticeSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
  }

  export type AmenityOrderByRelevanceInput = {
    fields: AmenityOrderByRelevanceFieldEnum | AmenityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AmenityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chargesPerHour?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenityAvgOrderByAggregateInput = {
    id?: SortOrder
    chargesPerHour?: SortOrder
    societyId?: SortOrder
  }

  export type AmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chargesPerHour?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    chargesPerHour?: SortOrder
    societyId?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenitySumOrderByAggregateInput = {
    id?: SortOrder
    chargesPerHour?: SortOrder
    societyId?: SortOrder
  }

  export type AmenityScalarRelationFilter = {
    is?: AmenityWhereInput
    isNot?: AmenityWhereInput
  }

  export type AmenityBookingOrderByRelevanceInput = {
    fields: AmenityBookingOrderByRelevanceFieldEnum | AmenityBookingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AmenityBookingCountOrderByAggregateInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenityBookingAvgOrderByAggregateInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    amountPaid?: SortOrder
  }

  export type AmenityBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenityBookingMinOrderByAggregateInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenityBookingSumOrderByAggregateInput = {
    id?: SortOrder
    amenityId?: SortOrder
    userId?: SortOrder
    amountPaid?: SortOrder
  }

  export type SystemSettingOrderByRelevanceInput = {
    fields: SystemSettingOrderByRelevanceFieldEnum | SystemSettingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SystemSettingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SystemSettingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BillingPlanOrderByRelevanceInput = {
    fields: BillingPlanOrderByRelevanceFieldEnum | BillingPlanOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BillingPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    price?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingPlanAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BillingPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    price?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    price?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingPlanSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlatformInvoiceOrderByRelevanceInput = {
    fields: PlatformInvoiceOrderByRelevanceFieldEnum | PlatformInvoiceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PlatformInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    societyId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformInvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    amount?: SortOrder
  }

  export type PlatformInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    societyId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    societyId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformInvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    societyId?: SortOrder
    amount?: SortOrder
  }

  export type UserCreateNestedManyWithoutSocietyInput = {
    create?: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput> | UserCreateWithoutSocietyInput[] | UserUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSocietyInput | UserCreateOrConnectWithoutSocietyInput[]
    createMany?: UserCreateManySocietyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UnitCreateNestedManyWithoutSocietyInput = {
    create?: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput> | UnitCreateWithoutSocietyInput[] | UnitUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutSocietyInput | UnitCreateOrConnectWithoutSocietyInput[]
    createMany?: UnitCreateManySocietyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type ComplaintCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput> | ComplaintCreateWithoutSocietyInput[] | ComplaintUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutSocietyInput | ComplaintCreateOrConnectWithoutSocietyInput[]
    createMany?: ComplaintCreateManySocietyInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type VisitorCreateNestedManyWithoutSocietyInput = {
    create?: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput> | VisitorCreateWithoutSocietyInput[] | VisitorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutSocietyInput | VisitorCreateOrConnectWithoutSocietyInput[]
    createMany?: VisitorCreateManySocietyInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutSocietyInput = {
    create?: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput> | TransactionCreateWithoutSocietyInput[] | TransactionUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSocietyInput | TransactionCreateOrConnectWithoutSocietyInput[]
    createMany?: TransactionCreateManySocietyInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type NoticeCreateNestedManyWithoutSocietyInput = {
    create?: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput> | NoticeCreateWithoutSocietyInput[] | NoticeUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutSocietyInput | NoticeCreateOrConnectWithoutSocietyInput[]
    createMany?: NoticeCreateManySocietyInputEnvelope
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
  }

  export type VendorCreateNestedManyWithoutSocietyInput = {
    create?: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput> | VendorCreateWithoutSocietyInput[] | VendorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutSocietyInput | VendorCreateOrConnectWithoutSocietyInput[]
    createMany?: VendorCreateManySocietyInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type AmenityCreateNestedManyWithoutSocietyInput = {
    create?: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput> | AmenityCreateWithoutSocietyInput[] | AmenityUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: AmenityCreateOrConnectWithoutSocietyInput | AmenityCreateOrConnectWithoutSocietyInput[]
    createMany?: AmenityCreateManySocietyInputEnvelope
    connect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
  }

  export type ParkingSlotCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput> | ParkingSlotCreateWithoutSocietyInput[] | ParkingSlotUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutSocietyInput | ParkingSlotCreateOrConnectWithoutSocietyInput[]
    createMany?: ParkingSlotCreateManySocietyInputEnvelope
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
  }

  export type PlatformInvoiceCreateNestedManyWithoutSocietyInput = {
    create?: XOR<PlatformInvoiceCreateWithoutSocietyInput, PlatformInvoiceUncheckedCreateWithoutSocietyInput> | PlatformInvoiceCreateWithoutSocietyInput[] | PlatformInvoiceUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: PlatformInvoiceCreateOrConnectWithoutSocietyInput | PlatformInvoiceCreateOrConnectWithoutSocietyInput[]
    createMany?: PlatformInvoiceCreateManySocietyInputEnvelope
    connect?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput> | UserCreateWithoutSocietyInput[] | UserUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSocietyInput | UserCreateOrConnectWithoutSocietyInput[]
    createMany?: UserCreateManySocietyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput> | UnitCreateWithoutSocietyInput[] | UnitUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutSocietyInput | UnitCreateOrConnectWithoutSocietyInput[]
    createMany?: UnitCreateManySocietyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type ComplaintUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput> | ComplaintCreateWithoutSocietyInput[] | ComplaintUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutSocietyInput | ComplaintCreateOrConnectWithoutSocietyInput[]
    createMany?: ComplaintCreateManySocietyInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type VisitorUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput> | VisitorCreateWithoutSocietyInput[] | VisitorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutSocietyInput | VisitorCreateOrConnectWithoutSocietyInput[]
    createMany?: VisitorCreateManySocietyInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput> | TransactionCreateWithoutSocietyInput[] | TransactionUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSocietyInput | TransactionCreateOrConnectWithoutSocietyInput[]
    createMany?: TransactionCreateManySocietyInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type NoticeUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput> | NoticeCreateWithoutSocietyInput[] | NoticeUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutSocietyInput | NoticeCreateOrConnectWithoutSocietyInput[]
    createMany?: NoticeCreateManySocietyInputEnvelope
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
  }

  export type VendorUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput> | VendorCreateWithoutSocietyInput[] | VendorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutSocietyInput | VendorCreateOrConnectWithoutSocietyInput[]
    createMany?: VendorCreateManySocietyInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type AmenityUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput> | AmenityCreateWithoutSocietyInput[] | AmenityUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: AmenityCreateOrConnectWithoutSocietyInput | AmenityCreateOrConnectWithoutSocietyInput[]
    createMany?: AmenityCreateManySocietyInputEnvelope
    connect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
  }

  export type ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput> | ParkingSlotCreateWithoutSocietyInput[] | ParkingSlotUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutSocietyInput | ParkingSlotCreateOrConnectWithoutSocietyInput[]
    createMany?: ParkingSlotCreateManySocietyInputEnvelope
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
  }

  export type PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput = {
    create?: XOR<PlatformInvoiceCreateWithoutSocietyInput, PlatformInvoiceUncheckedCreateWithoutSocietyInput> | PlatformInvoiceCreateWithoutSocietyInput[] | PlatformInvoiceUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: PlatformInvoiceCreateOrConnectWithoutSocietyInput | PlatformInvoiceCreateOrConnectWithoutSocietyInput[]
    createMany?: PlatformInvoiceCreateManySocietyInputEnvelope
    connect?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumSocietyStatusFieldUpdateOperationsInput = {
    set?: $Enums.SocietyStatus
  }

  export type EnumSubscriptionPlanFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPlan
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput> | UserCreateWithoutSocietyInput[] | UserUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSocietyInput | UserCreateOrConnectWithoutSocietyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSocietyInput | UserUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: UserCreateManySocietyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSocietyInput | UserUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSocietyInput | UserUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UnitUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput> | UnitCreateWithoutSocietyInput[] | UnitUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutSocietyInput | UnitCreateOrConnectWithoutSocietyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutSocietyInput | UnitUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: UnitCreateManySocietyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutSocietyInput | UnitUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutSocietyInput | UnitUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type ComplaintUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput> | ComplaintCreateWithoutSocietyInput[] | ComplaintUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutSocietyInput | ComplaintCreateOrConnectWithoutSocietyInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutSocietyInput | ComplaintUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ComplaintCreateManySocietyInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutSocietyInput | ComplaintUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutSocietyInput | ComplaintUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type VisitorUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput> | VisitorCreateWithoutSocietyInput[] | VisitorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutSocietyInput | VisitorCreateOrConnectWithoutSocietyInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutSocietyInput | VisitorUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: VisitorCreateManySocietyInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutSocietyInput | VisitorUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutSocietyInput | VisitorUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput> | TransactionCreateWithoutSocietyInput[] | TransactionUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSocietyInput | TransactionCreateOrConnectWithoutSocietyInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSocietyInput | TransactionUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: TransactionCreateManySocietyInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSocietyInput | TransactionUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSocietyInput | TransactionUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type NoticeUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput> | NoticeCreateWithoutSocietyInput[] | NoticeUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutSocietyInput | NoticeCreateOrConnectWithoutSocietyInput[]
    upsert?: NoticeUpsertWithWhereUniqueWithoutSocietyInput | NoticeUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: NoticeCreateManySocietyInputEnvelope
    set?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    disconnect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    delete?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    update?: NoticeUpdateWithWhereUniqueWithoutSocietyInput | NoticeUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: NoticeUpdateManyWithWhereWithoutSocietyInput | NoticeUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
  }

  export type VendorUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput> | VendorCreateWithoutSocietyInput[] | VendorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutSocietyInput | VendorCreateOrConnectWithoutSocietyInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutSocietyInput | VendorUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: VendorCreateManySocietyInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutSocietyInput | VendorUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutSocietyInput | VendorUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type AmenityUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput> | AmenityCreateWithoutSocietyInput[] | AmenityUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: AmenityCreateOrConnectWithoutSocietyInput | AmenityCreateOrConnectWithoutSocietyInput[]
    upsert?: AmenityUpsertWithWhereUniqueWithoutSocietyInput | AmenityUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: AmenityCreateManySocietyInputEnvelope
    set?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    disconnect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    delete?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    connect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    update?: AmenityUpdateWithWhereUniqueWithoutSocietyInput | AmenityUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: AmenityUpdateManyWithWhereWithoutSocietyInput | AmenityUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: AmenityScalarWhereInput | AmenityScalarWhereInput[]
  }

  export type ParkingSlotUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput> | ParkingSlotCreateWithoutSocietyInput[] | ParkingSlotUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutSocietyInput | ParkingSlotCreateOrConnectWithoutSocietyInput[]
    upsert?: ParkingSlotUpsertWithWhereUniqueWithoutSocietyInput | ParkingSlotUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ParkingSlotCreateManySocietyInputEnvelope
    set?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    disconnect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    delete?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    update?: ParkingSlotUpdateWithWhereUniqueWithoutSocietyInput | ParkingSlotUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ParkingSlotUpdateManyWithWhereWithoutSocietyInput | ParkingSlotUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
  }

  export type PlatformInvoiceUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<PlatformInvoiceCreateWithoutSocietyInput, PlatformInvoiceUncheckedCreateWithoutSocietyInput> | PlatformInvoiceCreateWithoutSocietyInput[] | PlatformInvoiceUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: PlatformInvoiceCreateOrConnectWithoutSocietyInput | PlatformInvoiceCreateOrConnectWithoutSocietyInput[]
    upsert?: PlatformInvoiceUpsertWithWhereUniqueWithoutSocietyInput | PlatformInvoiceUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: PlatformInvoiceCreateManySocietyInputEnvelope
    set?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
    disconnect?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
    delete?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
    connect?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
    update?: PlatformInvoiceUpdateWithWhereUniqueWithoutSocietyInput | PlatformInvoiceUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: PlatformInvoiceUpdateManyWithWhereWithoutSocietyInput | PlatformInvoiceUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: PlatformInvoiceScalarWhereInput | PlatformInvoiceScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput> | UserCreateWithoutSocietyInput[] | UserUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSocietyInput | UserCreateOrConnectWithoutSocietyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSocietyInput | UserUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: UserCreateManySocietyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSocietyInput | UserUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSocietyInput | UserUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput> | UnitCreateWithoutSocietyInput[] | UnitUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutSocietyInput | UnitCreateOrConnectWithoutSocietyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutSocietyInput | UnitUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: UnitCreateManySocietyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutSocietyInput | UnitUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutSocietyInput | UnitUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type ComplaintUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput> | ComplaintCreateWithoutSocietyInput[] | ComplaintUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutSocietyInput | ComplaintCreateOrConnectWithoutSocietyInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutSocietyInput | ComplaintUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ComplaintCreateManySocietyInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutSocietyInput | ComplaintUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutSocietyInput | ComplaintUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type VisitorUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput> | VisitorCreateWithoutSocietyInput[] | VisitorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutSocietyInput | VisitorCreateOrConnectWithoutSocietyInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutSocietyInput | VisitorUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: VisitorCreateManySocietyInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutSocietyInput | VisitorUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutSocietyInput | VisitorUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput> | TransactionCreateWithoutSocietyInput[] | TransactionUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSocietyInput | TransactionCreateOrConnectWithoutSocietyInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSocietyInput | TransactionUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: TransactionCreateManySocietyInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSocietyInput | TransactionUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSocietyInput | TransactionUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type NoticeUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput> | NoticeCreateWithoutSocietyInput[] | NoticeUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutSocietyInput | NoticeCreateOrConnectWithoutSocietyInput[]
    upsert?: NoticeUpsertWithWhereUniqueWithoutSocietyInput | NoticeUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: NoticeCreateManySocietyInputEnvelope
    set?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    disconnect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    delete?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    update?: NoticeUpdateWithWhereUniqueWithoutSocietyInput | NoticeUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: NoticeUpdateManyWithWhereWithoutSocietyInput | NoticeUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
  }

  export type VendorUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput> | VendorCreateWithoutSocietyInput[] | VendorUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutSocietyInput | VendorCreateOrConnectWithoutSocietyInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutSocietyInput | VendorUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: VendorCreateManySocietyInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutSocietyInput | VendorUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutSocietyInput | VendorUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type AmenityUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput> | AmenityCreateWithoutSocietyInput[] | AmenityUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: AmenityCreateOrConnectWithoutSocietyInput | AmenityCreateOrConnectWithoutSocietyInput[]
    upsert?: AmenityUpsertWithWhereUniqueWithoutSocietyInput | AmenityUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: AmenityCreateManySocietyInputEnvelope
    set?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    disconnect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    delete?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    connect?: AmenityWhereUniqueInput | AmenityWhereUniqueInput[]
    update?: AmenityUpdateWithWhereUniqueWithoutSocietyInput | AmenityUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: AmenityUpdateManyWithWhereWithoutSocietyInput | AmenityUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: AmenityScalarWhereInput | AmenityScalarWhereInput[]
  }

  export type ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput> | ParkingSlotCreateWithoutSocietyInput[] | ParkingSlotUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutSocietyInput | ParkingSlotCreateOrConnectWithoutSocietyInput[]
    upsert?: ParkingSlotUpsertWithWhereUniqueWithoutSocietyInput | ParkingSlotUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: ParkingSlotCreateManySocietyInputEnvelope
    set?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    disconnect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    delete?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    update?: ParkingSlotUpdateWithWhereUniqueWithoutSocietyInput | ParkingSlotUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: ParkingSlotUpdateManyWithWhereWithoutSocietyInput | ParkingSlotUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
  }

  export type PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput = {
    create?: XOR<PlatformInvoiceCreateWithoutSocietyInput, PlatformInvoiceUncheckedCreateWithoutSocietyInput> | PlatformInvoiceCreateWithoutSocietyInput[] | PlatformInvoiceUncheckedCreateWithoutSocietyInput[]
    connectOrCreate?: PlatformInvoiceCreateOrConnectWithoutSocietyInput | PlatformInvoiceCreateOrConnectWithoutSocietyInput[]
    upsert?: PlatformInvoiceUpsertWithWhereUniqueWithoutSocietyInput | PlatformInvoiceUpsertWithWhereUniqueWithoutSocietyInput[]
    createMany?: PlatformInvoiceCreateManySocietyInputEnvelope
    set?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
    disconnect?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
    delete?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
    connect?: PlatformInvoiceWhereUniqueInput | PlatformInvoiceWhereUniqueInput[]
    update?: PlatformInvoiceUpdateWithWhereUniqueWithoutSocietyInput | PlatformInvoiceUpdateWithWhereUniqueWithoutSocietyInput[]
    updateMany?: PlatformInvoiceUpdateManyWithWhereWithoutSocietyInput | PlatformInvoiceUpdateManyWithWhereWithoutSocietyInput[]
    deleteMany?: PlatformInvoiceScalarWhereInput | PlatformInvoiceScalarWhereInput[]
  }

  export type SocietyCreateNestedOneWithoutUsersInput = {
    create?: XOR<SocietyCreateWithoutUsersInput, SocietyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutUsersInput
    connect?: SocietyWhereUniqueInput
  }

  export type UnitCreateNestedManyWithoutOwnerInput = {
    create?: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput> | UnitCreateWithoutOwnerInput[] | UnitUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutOwnerInput | UnitCreateOrConnectWithoutOwnerInput[]
    createMany?: UnitCreateManyOwnerInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type UnitCreateNestedManyWithoutTenantInput = {
    create?: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput> | UnitCreateWithoutTenantInput[] | UnitUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutTenantInput | UnitCreateOrConnectWithoutTenantInput[]
    createMany?: UnitCreateManyTenantInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type ComplaintCreateNestedManyWithoutReportedByInput = {
    create?: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput> | ComplaintCreateWithoutReportedByInput[] | ComplaintUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutReportedByInput | ComplaintCreateOrConnectWithoutReportedByInput[]
    createMany?: ComplaintCreateManyReportedByInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type ComplaintCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput> | ComplaintCreateWithoutAssignedToInput[] | ComplaintUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutAssignedToInput | ComplaintCreateOrConnectWithoutAssignedToInput[]
    createMany?: ComplaintCreateManyAssignedToInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type AmenityBookingCreateNestedManyWithoutUserInput = {
    create?: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput> | AmenityBookingCreateWithoutUserInput[] | AmenityBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutUserInput | AmenityBookingCreateOrConnectWithoutUserInput[]
    createMany?: AmenityBookingCreateManyUserInputEnvelope
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
  }

  export type ComplaintCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput> | ComplaintCommentCreateWithoutUserInput[] | ComplaintCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutUserInput | ComplaintCommentCreateOrConnectWithoutUserInput[]
    createMany?: ComplaintCommentCreateManyUserInputEnvelope
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput> | UnitCreateWithoutOwnerInput[] | UnitUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutOwnerInput | UnitCreateOrConnectWithoutOwnerInput[]
    createMany?: UnitCreateManyOwnerInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput> | UnitCreateWithoutTenantInput[] | UnitUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutTenantInput | UnitCreateOrConnectWithoutTenantInput[]
    createMany?: UnitCreateManyTenantInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type ComplaintUncheckedCreateNestedManyWithoutReportedByInput = {
    create?: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput> | ComplaintCreateWithoutReportedByInput[] | ComplaintUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutReportedByInput | ComplaintCreateOrConnectWithoutReportedByInput[]
    createMany?: ComplaintCreateManyReportedByInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type ComplaintUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput> | ComplaintCreateWithoutAssignedToInput[] | ComplaintUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutAssignedToInput | ComplaintCreateOrConnectWithoutAssignedToInput[]
    createMany?: ComplaintCreateManyAssignedToInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type AmenityBookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput> | AmenityBookingCreateWithoutUserInput[] | AmenityBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutUserInput | AmenityBookingCreateOrConnectWithoutUserInput[]
    createMany?: AmenityBookingCreateManyUserInputEnvelope
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
  }

  export type ComplaintCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput> | ComplaintCommentCreateWithoutUserInput[] | ComplaintCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutUserInput | ComplaintCommentCreateOrConnectWithoutUserInput[]
    createMany?: ComplaintCommentCreateManyUserInputEnvelope
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type SocietyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<SocietyCreateWithoutUsersInput, SocietyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutUsersInput
    upsert?: SocietyUpsertWithoutUsersInput
    disconnect?: SocietyWhereInput | boolean
    delete?: SocietyWhereInput | boolean
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutUsersInput, SocietyUpdateWithoutUsersInput>, SocietyUncheckedUpdateWithoutUsersInput>
  }

  export type UnitUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput> | UnitCreateWithoutOwnerInput[] | UnitUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutOwnerInput | UnitCreateOrConnectWithoutOwnerInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutOwnerInput | UnitUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: UnitCreateManyOwnerInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutOwnerInput | UnitUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutOwnerInput | UnitUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type UnitUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput> | UnitCreateWithoutTenantInput[] | UnitUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutTenantInput | UnitCreateOrConnectWithoutTenantInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutTenantInput | UnitUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UnitCreateManyTenantInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutTenantInput | UnitUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutTenantInput | UnitUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type ComplaintUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput> | ComplaintCreateWithoutReportedByInput[] | ComplaintUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutReportedByInput | ComplaintCreateOrConnectWithoutReportedByInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutReportedByInput | ComplaintUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: ComplaintCreateManyReportedByInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutReportedByInput | ComplaintUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutReportedByInput | ComplaintUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type ComplaintUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput> | ComplaintCreateWithoutAssignedToInput[] | ComplaintUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutAssignedToInput | ComplaintCreateOrConnectWithoutAssignedToInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutAssignedToInput | ComplaintUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: ComplaintCreateManyAssignedToInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutAssignedToInput | ComplaintUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutAssignedToInput | ComplaintUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type AmenityBookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput> | AmenityBookingCreateWithoutUserInput[] | AmenityBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutUserInput | AmenityBookingCreateOrConnectWithoutUserInput[]
    upsert?: AmenityBookingUpsertWithWhereUniqueWithoutUserInput | AmenityBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AmenityBookingCreateManyUserInputEnvelope
    set?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    disconnect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    delete?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    update?: AmenityBookingUpdateWithWhereUniqueWithoutUserInput | AmenityBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AmenityBookingUpdateManyWithWhereWithoutUserInput | AmenityBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
  }

  export type ComplaintCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput> | ComplaintCommentCreateWithoutUserInput[] | ComplaintCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutUserInput | ComplaintCommentCreateOrConnectWithoutUserInput[]
    upsert?: ComplaintCommentUpsertWithWhereUniqueWithoutUserInput | ComplaintCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComplaintCommentCreateManyUserInputEnvelope
    set?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    disconnect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    delete?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    update?: ComplaintCommentUpdateWithWhereUniqueWithoutUserInput | ComplaintCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComplaintCommentUpdateManyWithWhereWithoutUserInput | ComplaintCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UnitUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput> | UnitCreateWithoutOwnerInput[] | UnitUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutOwnerInput | UnitCreateOrConnectWithoutOwnerInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutOwnerInput | UnitUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: UnitCreateManyOwnerInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutOwnerInput | UnitUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutOwnerInput | UnitUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput> | UnitCreateWithoutTenantInput[] | UnitUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutTenantInput | UnitCreateOrConnectWithoutTenantInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutTenantInput | UnitUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UnitCreateManyTenantInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutTenantInput | UnitUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutTenantInput | UnitUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type ComplaintUncheckedUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput> | ComplaintCreateWithoutReportedByInput[] | ComplaintUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutReportedByInput | ComplaintCreateOrConnectWithoutReportedByInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutReportedByInput | ComplaintUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: ComplaintCreateManyReportedByInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutReportedByInput | ComplaintUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutReportedByInput | ComplaintUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput> | ComplaintCreateWithoutAssignedToInput[] | ComplaintUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutAssignedToInput | ComplaintCreateOrConnectWithoutAssignedToInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutAssignedToInput | ComplaintUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: ComplaintCreateManyAssignedToInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutAssignedToInput | ComplaintUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutAssignedToInput | ComplaintUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type AmenityBookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput> | AmenityBookingCreateWithoutUserInput[] | AmenityBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutUserInput | AmenityBookingCreateOrConnectWithoutUserInput[]
    upsert?: AmenityBookingUpsertWithWhereUniqueWithoutUserInput | AmenityBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AmenityBookingCreateManyUserInputEnvelope
    set?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    disconnect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    delete?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    update?: AmenityBookingUpdateWithWhereUniqueWithoutUserInput | AmenityBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AmenityBookingUpdateManyWithWhereWithoutUserInput | AmenityBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
  }

  export type ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput> | ComplaintCommentCreateWithoutUserInput[] | ComplaintCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutUserInput | ComplaintCommentCreateOrConnectWithoutUserInput[]
    upsert?: ComplaintCommentUpsertWithWhereUniqueWithoutUserInput | ComplaintCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComplaintCommentCreateManyUserInputEnvelope
    set?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    disconnect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    delete?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    update?: ComplaintCommentUpdateWithWhereUniqueWithoutUserInput | ComplaintCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComplaintCommentUpdateManyWithWhereWithoutUserInput | ComplaintCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
  }

  export type SocietyCreateNestedOneWithoutUnitsInput = {
    create?: XOR<SocietyCreateWithoutUnitsInput, SocietyUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutUnitsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedUnitsInput = {
    create?: XOR<UserCreateWithoutOwnedUnitsInput, UserUncheckedCreateWithoutOwnedUnitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedUnitsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRentedUnitsInput = {
    create?: XOR<UserCreateWithoutRentedUnitsInput, UserUncheckedCreateWithoutRentedUnitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRentedUnitsInput
    connect?: UserWhereUniqueInput
  }

  export type VisitorCreateNestedManyWithoutUnitInput = {
    create?: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput> | VisitorCreateWithoutUnitInput[] | VisitorUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutUnitInput | VisitorCreateOrConnectWithoutUnitInput[]
    createMany?: VisitorCreateManyUnitInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type ParkingSlotCreateNestedManyWithoutUnitInput = {
    create?: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput> | ParkingSlotCreateWithoutUnitInput[] | ParkingSlotUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutUnitInput | ParkingSlotCreateOrConnectWithoutUnitInput[]
    createMany?: ParkingSlotCreateManyUnitInputEnvelope
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
  }

  export type VisitorUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput> | VisitorCreateWithoutUnitInput[] | VisitorUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutUnitInput | VisitorCreateOrConnectWithoutUnitInput[]
    createMany?: VisitorCreateManyUnitInputEnvelope
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
  }

  export type ParkingSlotUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput> | ParkingSlotCreateWithoutUnitInput[] | ParkingSlotUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutUnitInput | ParkingSlotCreateOrConnectWithoutUnitInput[]
    createMany?: ParkingSlotCreateManyUnitInputEnvelope
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SocietyUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<SocietyCreateWithoutUnitsInput, SocietyUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutUnitsInput
    upsert?: SocietyUpsertWithoutUnitsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutUnitsInput, SocietyUpdateWithoutUnitsInput>, SocietyUncheckedUpdateWithoutUnitsInput>
  }

  export type UserUpdateOneWithoutOwnedUnitsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedUnitsInput, UserUncheckedCreateWithoutOwnedUnitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedUnitsInput
    upsert?: UserUpsertWithoutOwnedUnitsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedUnitsInput, UserUpdateWithoutOwnedUnitsInput>, UserUncheckedUpdateWithoutOwnedUnitsInput>
  }

  export type UserUpdateOneWithoutRentedUnitsNestedInput = {
    create?: XOR<UserCreateWithoutRentedUnitsInput, UserUncheckedCreateWithoutRentedUnitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRentedUnitsInput
    upsert?: UserUpsertWithoutRentedUnitsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRentedUnitsInput, UserUpdateWithoutRentedUnitsInput>, UserUncheckedUpdateWithoutRentedUnitsInput>
  }

  export type VisitorUpdateManyWithoutUnitNestedInput = {
    create?: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput> | VisitorCreateWithoutUnitInput[] | VisitorUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutUnitInput | VisitorCreateOrConnectWithoutUnitInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutUnitInput | VisitorUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: VisitorCreateManyUnitInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutUnitInput | VisitorUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutUnitInput | VisitorUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type ParkingSlotUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput> | ParkingSlotCreateWithoutUnitInput[] | ParkingSlotUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutUnitInput | ParkingSlotCreateOrConnectWithoutUnitInput[]
    upsert?: ParkingSlotUpsertWithWhereUniqueWithoutUnitInput | ParkingSlotUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ParkingSlotCreateManyUnitInputEnvelope
    set?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    disconnect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    delete?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    update?: ParkingSlotUpdateWithWhereUniqueWithoutUnitInput | ParkingSlotUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ParkingSlotUpdateManyWithWhereWithoutUnitInput | ParkingSlotUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
  }

  export type VisitorUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput> | VisitorCreateWithoutUnitInput[] | VisitorUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: VisitorCreateOrConnectWithoutUnitInput | VisitorCreateOrConnectWithoutUnitInput[]
    upsert?: VisitorUpsertWithWhereUniqueWithoutUnitInput | VisitorUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: VisitorCreateManyUnitInputEnvelope
    set?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    disconnect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    delete?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    connect?: VisitorWhereUniqueInput | VisitorWhereUniqueInput[]
    update?: VisitorUpdateWithWhereUniqueWithoutUnitInput | VisitorUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: VisitorUpdateManyWithWhereWithoutUnitInput | VisitorUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
  }

  export type ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput> | ParkingSlotCreateWithoutUnitInput[] | ParkingSlotUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutUnitInput | ParkingSlotCreateOrConnectWithoutUnitInput[]
    upsert?: ParkingSlotUpsertWithWhereUniqueWithoutUnitInput | ParkingSlotUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ParkingSlotCreateManyUnitInputEnvelope
    set?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    disconnect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    delete?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    update?: ParkingSlotUpdateWithWhereUniqueWithoutUnitInput | ParkingSlotUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ParkingSlotUpdateManyWithWhereWithoutUnitInput | ParkingSlotUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
  }

  export type SocietyCreateNestedOneWithoutParkingSlotsInput = {
    create?: XOR<SocietyCreateWithoutParkingSlotsInput, SocietyUncheckedCreateWithoutParkingSlotsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutParkingSlotsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutParkingSlotsInput = {
    create?: XOR<UnitCreateWithoutParkingSlotsInput, UnitUncheckedCreateWithoutParkingSlotsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutParkingSlotsInput
    connect?: UnitWhereUniqueInput
  }

  export type SocietyUpdateOneRequiredWithoutParkingSlotsNestedInput = {
    create?: XOR<SocietyCreateWithoutParkingSlotsInput, SocietyUncheckedCreateWithoutParkingSlotsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutParkingSlotsInput
    upsert?: SocietyUpsertWithoutParkingSlotsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutParkingSlotsInput, SocietyUpdateWithoutParkingSlotsInput>, SocietyUncheckedUpdateWithoutParkingSlotsInput>
  }

  export type UnitUpdateOneWithoutParkingSlotsNestedInput = {
    create?: XOR<UnitCreateWithoutParkingSlotsInput, UnitUncheckedCreateWithoutParkingSlotsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutParkingSlotsInput
    upsert?: UnitUpsertWithoutParkingSlotsInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutParkingSlotsInput, UnitUpdateWithoutParkingSlotsInput>, UnitUncheckedUpdateWithoutParkingSlotsInput>
  }

  export type SocietyCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<SocietyCreateWithoutComplaintsInput, SocietyUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutComplaintsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportedComplaintsInput = {
    create?: XOR<UserCreateWithoutReportedComplaintsInput, UserUncheckedCreateWithoutReportedComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedComplaintsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedComplaintsInput = {
    create?: XOR<UserCreateWithoutAssignedComplaintsInput, UserUncheckedCreateWithoutAssignedComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedComplaintsInput
    connect?: UserWhereUniqueInput
  }

  export type ComplaintCommentCreateNestedManyWithoutComplaintInput = {
    create?: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput> | ComplaintCommentCreateWithoutComplaintInput[] | ComplaintCommentUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutComplaintInput | ComplaintCommentCreateOrConnectWithoutComplaintInput[]
    createMany?: ComplaintCommentCreateManyComplaintInputEnvelope
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
  }

  export type ComplaintCommentUncheckedCreateNestedManyWithoutComplaintInput = {
    create?: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput> | ComplaintCommentCreateWithoutComplaintInput[] | ComplaintCommentUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutComplaintInput | ComplaintCommentCreateOrConnectWithoutComplaintInput[]
    createMany?: ComplaintCommentCreateManyComplaintInputEnvelope
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type EnumComplaintStatusFieldUpdateOperationsInput = {
    set?: $Enums.ComplaintStatus
  }

  export type SocietyUpdateOneRequiredWithoutComplaintsNestedInput = {
    create?: XOR<SocietyCreateWithoutComplaintsInput, SocietyUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutComplaintsInput
    upsert?: SocietyUpsertWithoutComplaintsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutComplaintsInput, SocietyUpdateWithoutComplaintsInput>, SocietyUncheckedUpdateWithoutComplaintsInput>
  }

  export type UserUpdateOneRequiredWithoutReportedComplaintsNestedInput = {
    create?: XOR<UserCreateWithoutReportedComplaintsInput, UserUncheckedCreateWithoutReportedComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedComplaintsInput
    upsert?: UserUpsertWithoutReportedComplaintsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportedComplaintsInput, UserUpdateWithoutReportedComplaintsInput>, UserUncheckedUpdateWithoutReportedComplaintsInput>
  }

  export type UserUpdateOneWithoutAssignedComplaintsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedComplaintsInput, UserUncheckedCreateWithoutAssignedComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedComplaintsInput
    upsert?: UserUpsertWithoutAssignedComplaintsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedComplaintsInput, UserUpdateWithoutAssignedComplaintsInput>, UserUncheckedUpdateWithoutAssignedComplaintsInput>
  }

  export type ComplaintCommentUpdateManyWithoutComplaintNestedInput = {
    create?: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput> | ComplaintCommentCreateWithoutComplaintInput[] | ComplaintCommentUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutComplaintInput | ComplaintCommentCreateOrConnectWithoutComplaintInput[]
    upsert?: ComplaintCommentUpsertWithWhereUniqueWithoutComplaintInput | ComplaintCommentUpsertWithWhereUniqueWithoutComplaintInput[]
    createMany?: ComplaintCommentCreateManyComplaintInputEnvelope
    set?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    disconnect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    delete?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    update?: ComplaintCommentUpdateWithWhereUniqueWithoutComplaintInput | ComplaintCommentUpdateWithWhereUniqueWithoutComplaintInput[]
    updateMany?: ComplaintCommentUpdateManyWithWhereWithoutComplaintInput | ComplaintCommentUpdateManyWithWhereWithoutComplaintInput[]
    deleteMany?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
  }

  export type ComplaintCommentUncheckedUpdateManyWithoutComplaintNestedInput = {
    create?: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput> | ComplaintCommentCreateWithoutComplaintInput[] | ComplaintCommentUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintCommentCreateOrConnectWithoutComplaintInput | ComplaintCommentCreateOrConnectWithoutComplaintInput[]
    upsert?: ComplaintCommentUpsertWithWhereUniqueWithoutComplaintInput | ComplaintCommentUpsertWithWhereUniqueWithoutComplaintInput[]
    createMany?: ComplaintCommentCreateManyComplaintInputEnvelope
    set?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    disconnect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    delete?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    connect?: ComplaintCommentWhereUniqueInput | ComplaintCommentWhereUniqueInput[]
    update?: ComplaintCommentUpdateWithWhereUniqueWithoutComplaintInput | ComplaintCommentUpdateWithWhereUniqueWithoutComplaintInput[]
    updateMany?: ComplaintCommentUpdateManyWithWhereWithoutComplaintInput | ComplaintCommentUpdateManyWithWhereWithoutComplaintInput[]
    deleteMany?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
  }

  export type ComplaintCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ComplaintCreateWithoutCommentsInput, ComplaintUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ComplaintCreateOrConnectWithoutCommentsInput
    connect?: ComplaintWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ComplaintUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ComplaintCreateWithoutCommentsInput, ComplaintUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ComplaintCreateOrConnectWithoutCommentsInput
    upsert?: ComplaintUpsertWithoutCommentsInput
    connect?: ComplaintWhereUniqueInput
    update?: XOR<XOR<ComplaintUpdateToOneWithWhereWithoutCommentsInput, ComplaintUpdateWithoutCommentsInput>, ComplaintUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type SocietyCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<SocietyCreateWithoutVisitorsInput, SocietyUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutVisitorsInput
    connect?: SocietyWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<UnitCreateWithoutVisitorsInput, UnitUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutVisitorsInput
    connect?: UnitWhereUniqueInput
  }

  export type EnumVisitorStatusFieldUpdateOperationsInput = {
    set?: $Enums.VisitorStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type SocietyUpdateOneRequiredWithoutVisitorsNestedInput = {
    create?: XOR<SocietyCreateWithoutVisitorsInput, SocietyUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutVisitorsInput
    upsert?: SocietyUpsertWithoutVisitorsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutVisitorsInput, SocietyUpdateWithoutVisitorsInput>, SocietyUncheckedUpdateWithoutVisitorsInput>
  }

  export type UnitUpdateOneRequiredWithoutVisitorsNestedInput = {
    create?: XOR<UnitCreateWithoutVisitorsInput, UnitUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutVisitorsInput
    upsert?: UnitUpsertWithoutVisitorsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutVisitorsInput, UnitUpdateWithoutVisitorsInput>, UnitUncheckedUpdateWithoutVisitorsInput>
  }

  export type SocietyCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<SocietyCreateWithoutTransactionsInput, SocietyUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutTransactionsInput
    connect?: SocietyWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type SocietyUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<SocietyCreateWithoutTransactionsInput, SocietyUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutTransactionsInput
    upsert?: SocietyUpsertWithoutTransactionsInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutTransactionsInput, SocietyUpdateWithoutTransactionsInput>, SocietyUncheckedUpdateWithoutTransactionsInput>
  }

  export type SocietyCreateNestedOneWithoutVendorsInput = {
    create?: XOR<SocietyCreateWithoutVendorsInput, SocietyUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutVendorsInput
    connect?: SocietyWhereUniqueInput
  }

  export type VendorPayoutCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorPayoutCreateWithoutVendorInput, VendorPayoutUncheckedCreateWithoutVendorInput> | VendorPayoutCreateWithoutVendorInput[] | VendorPayoutUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorPayoutCreateOrConnectWithoutVendorInput | VendorPayoutCreateOrConnectWithoutVendorInput[]
    createMany?: VendorPayoutCreateManyVendorInputEnvelope
    connect?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
  }

  export type VendorPayoutUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorPayoutCreateWithoutVendorInput, VendorPayoutUncheckedCreateWithoutVendorInput> | VendorPayoutCreateWithoutVendorInput[] | VendorPayoutUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorPayoutCreateOrConnectWithoutVendorInput | VendorPayoutCreateOrConnectWithoutVendorInput[]
    createMany?: VendorPayoutCreateManyVendorInputEnvelope
    connect?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
  }

  export type EnumVendorStatusFieldUpdateOperationsInput = {
    set?: $Enums.VendorStatus
  }

  export type SocietyUpdateOneWithoutVendorsNestedInput = {
    create?: XOR<SocietyCreateWithoutVendorsInput, SocietyUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutVendorsInput
    upsert?: SocietyUpsertWithoutVendorsInput
    disconnect?: SocietyWhereInput | boolean
    delete?: SocietyWhereInput | boolean
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutVendorsInput, SocietyUpdateWithoutVendorsInput>, SocietyUncheckedUpdateWithoutVendorsInput>
  }

  export type VendorPayoutUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorPayoutCreateWithoutVendorInput, VendorPayoutUncheckedCreateWithoutVendorInput> | VendorPayoutCreateWithoutVendorInput[] | VendorPayoutUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorPayoutCreateOrConnectWithoutVendorInput | VendorPayoutCreateOrConnectWithoutVendorInput[]
    upsert?: VendorPayoutUpsertWithWhereUniqueWithoutVendorInput | VendorPayoutUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorPayoutCreateManyVendorInputEnvelope
    set?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
    disconnect?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
    delete?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
    connect?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
    update?: VendorPayoutUpdateWithWhereUniqueWithoutVendorInput | VendorPayoutUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorPayoutUpdateManyWithWhereWithoutVendorInput | VendorPayoutUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorPayoutScalarWhereInput | VendorPayoutScalarWhereInput[]
  }

  export type VendorPayoutUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorPayoutCreateWithoutVendorInput, VendorPayoutUncheckedCreateWithoutVendorInput> | VendorPayoutCreateWithoutVendorInput[] | VendorPayoutUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorPayoutCreateOrConnectWithoutVendorInput | VendorPayoutCreateOrConnectWithoutVendorInput[]
    upsert?: VendorPayoutUpsertWithWhereUniqueWithoutVendorInput | VendorPayoutUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorPayoutCreateManyVendorInputEnvelope
    set?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
    disconnect?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
    delete?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
    connect?: VendorPayoutWhereUniqueInput | VendorPayoutWhereUniqueInput[]
    update?: VendorPayoutUpdateWithWhereUniqueWithoutVendorInput | VendorPayoutUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorPayoutUpdateManyWithWhereWithoutVendorInput | VendorPayoutUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorPayoutScalarWhereInput | VendorPayoutScalarWhereInput[]
  }

  export type VendorCreateNestedOneWithoutPayoutsInput = {
    create?: XOR<VendorCreateWithoutPayoutsInput, VendorUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPayoutsInput
    connect?: VendorWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutPayoutsNestedInput = {
    create?: XOR<VendorCreateWithoutPayoutsInput, VendorUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPayoutsInput
    upsert?: VendorUpsertWithoutPayoutsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutPayoutsInput, VendorUpdateWithoutPayoutsInput>, VendorUncheckedUpdateWithoutPayoutsInput>
  }

  export type ServiceVariantCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceVariantCreateWithoutCategoryInput, ServiceVariantUncheckedCreateWithoutCategoryInput> | ServiceVariantCreateWithoutCategoryInput[] | ServiceVariantUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceVariantCreateOrConnectWithoutCategoryInput | ServiceVariantCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceVariantCreateManyCategoryInputEnvelope
    connect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
  }

  export type ServiceVariantUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceVariantCreateWithoutCategoryInput, ServiceVariantUncheckedCreateWithoutCategoryInput> | ServiceVariantCreateWithoutCategoryInput[] | ServiceVariantUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceVariantCreateOrConnectWithoutCategoryInput | ServiceVariantCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceVariantCreateManyCategoryInputEnvelope
    connect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
  }

  export type ServiceVariantUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceVariantCreateWithoutCategoryInput, ServiceVariantUncheckedCreateWithoutCategoryInput> | ServiceVariantCreateWithoutCategoryInput[] | ServiceVariantUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceVariantCreateOrConnectWithoutCategoryInput | ServiceVariantCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceVariantUpsertWithWhereUniqueWithoutCategoryInput | ServiceVariantUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceVariantCreateManyCategoryInputEnvelope
    set?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
    disconnect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
    delete?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
    connect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
    update?: ServiceVariantUpdateWithWhereUniqueWithoutCategoryInput | ServiceVariantUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceVariantUpdateManyWithWhereWithoutCategoryInput | ServiceVariantUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceVariantScalarWhereInput | ServiceVariantScalarWhereInput[]
  }

  export type ServiceVariantUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceVariantCreateWithoutCategoryInput, ServiceVariantUncheckedCreateWithoutCategoryInput> | ServiceVariantCreateWithoutCategoryInput[] | ServiceVariantUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceVariantCreateOrConnectWithoutCategoryInput | ServiceVariantCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceVariantUpsertWithWhereUniqueWithoutCategoryInput | ServiceVariantUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceVariantCreateManyCategoryInputEnvelope
    set?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
    disconnect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
    delete?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
    connect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[]
    update?: ServiceVariantUpdateWithWhereUniqueWithoutCategoryInput | ServiceVariantUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceVariantUpdateManyWithWhereWithoutCategoryInput | ServiceVariantUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceVariantScalarWhereInput | ServiceVariantScalarWhereInput[]
  }

  export type ServiceCategoryCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ServiceCategoryCreateWithoutVariantsInput, ServiceCategoryUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutVariantsInput
    connect?: ServiceCategoryWhereUniqueInput
  }

  export type ServiceCategoryUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<ServiceCategoryCreateWithoutVariantsInput, ServiceCategoryUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutVariantsInput
    upsert?: ServiceCategoryUpsertWithoutVariantsInput
    connect?: ServiceCategoryWhereUniqueInput
    update?: XOR<XOR<ServiceCategoryUpdateToOneWithWhereWithoutVariantsInput, ServiceCategoryUpdateWithoutVariantsInput>, ServiceCategoryUncheckedUpdateWithoutVariantsInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SocietyCreateNestedOneWithoutNoticesInput = {
    create?: XOR<SocietyCreateWithoutNoticesInput, SocietyUncheckedCreateWithoutNoticesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutNoticesInput
    connect?: SocietyWhereUniqueInput
  }

  export type SocietyUpdateOneRequiredWithoutNoticesNestedInput = {
    create?: XOR<SocietyCreateWithoutNoticesInput, SocietyUncheckedCreateWithoutNoticesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutNoticesInput
    upsert?: SocietyUpsertWithoutNoticesInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutNoticesInput, SocietyUpdateWithoutNoticesInput>, SocietyUncheckedUpdateWithoutNoticesInput>
  }

  export type SocietyCreateNestedOneWithoutAmenitiesInput = {
    create?: XOR<SocietyCreateWithoutAmenitiesInput, SocietyUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutAmenitiesInput
    connect?: SocietyWhereUniqueInput
  }

  export type AmenityBookingCreateNestedManyWithoutAmenityInput = {
    create?: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput> | AmenityBookingCreateWithoutAmenityInput[] | AmenityBookingUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutAmenityInput | AmenityBookingCreateOrConnectWithoutAmenityInput[]
    createMany?: AmenityBookingCreateManyAmenityInputEnvelope
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
  }

  export type AmenityBookingUncheckedCreateNestedManyWithoutAmenityInput = {
    create?: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput> | AmenityBookingCreateWithoutAmenityInput[] | AmenityBookingUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutAmenityInput | AmenityBookingCreateOrConnectWithoutAmenityInput[]
    createMany?: AmenityBookingCreateManyAmenityInputEnvelope
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
  }

  export type SocietyUpdateOneRequiredWithoutAmenitiesNestedInput = {
    create?: XOR<SocietyCreateWithoutAmenitiesInput, SocietyUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutAmenitiesInput
    upsert?: SocietyUpsertWithoutAmenitiesInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutAmenitiesInput, SocietyUpdateWithoutAmenitiesInput>, SocietyUncheckedUpdateWithoutAmenitiesInput>
  }

  export type AmenityBookingUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput> | AmenityBookingCreateWithoutAmenityInput[] | AmenityBookingUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutAmenityInput | AmenityBookingCreateOrConnectWithoutAmenityInput[]
    upsert?: AmenityBookingUpsertWithWhereUniqueWithoutAmenityInput | AmenityBookingUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: AmenityBookingCreateManyAmenityInputEnvelope
    set?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    disconnect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    delete?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    update?: AmenityBookingUpdateWithWhereUniqueWithoutAmenityInput | AmenityBookingUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: AmenityBookingUpdateManyWithWhereWithoutAmenityInput | AmenityBookingUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
  }

  export type AmenityBookingUncheckedUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput> | AmenityBookingCreateWithoutAmenityInput[] | AmenityBookingUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: AmenityBookingCreateOrConnectWithoutAmenityInput | AmenityBookingCreateOrConnectWithoutAmenityInput[]
    upsert?: AmenityBookingUpsertWithWhereUniqueWithoutAmenityInput | AmenityBookingUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: AmenityBookingCreateManyAmenityInputEnvelope
    set?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    disconnect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    delete?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    connect?: AmenityBookingWhereUniqueInput | AmenityBookingWhereUniqueInput[]
    update?: AmenityBookingUpdateWithWhereUniqueWithoutAmenityInput | AmenityBookingUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: AmenityBookingUpdateManyWithWhereWithoutAmenityInput | AmenityBookingUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
  }

  export type AmenityCreateNestedOneWithoutBookingsInput = {
    create?: XOR<AmenityCreateWithoutBookingsInput, AmenityUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutBookingsInput
    connect?: AmenityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type AmenityUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<AmenityCreateWithoutBookingsInput, AmenityUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutBookingsInput
    upsert?: AmenityUpsertWithoutBookingsInput
    connect?: AmenityWhereUniqueInput
    update?: XOR<XOR<AmenityUpdateToOneWithWhereWithoutBookingsInput, AmenityUpdateWithoutBookingsInput>, AmenityUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type SocietyCreateNestedOneWithoutPlatformInvoicesInput = {
    create?: XOR<SocietyCreateWithoutPlatformInvoicesInput, SocietyUncheckedCreateWithoutPlatformInvoicesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutPlatformInvoicesInput
    connect?: SocietyWhereUniqueInput
  }

  export type SocietyUpdateOneRequiredWithoutPlatformInvoicesNestedInput = {
    create?: XOR<SocietyCreateWithoutPlatformInvoicesInput, SocietyUncheckedCreateWithoutPlatformInvoicesInput>
    connectOrCreate?: SocietyCreateOrConnectWithoutPlatformInvoicesInput
    upsert?: SocietyUpsertWithoutPlatformInvoicesInput
    connect?: SocietyWhereUniqueInput
    update?: XOR<XOR<SocietyUpdateToOneWithWhereWithoutPlatformInvoicesInput, SocietyUpdateWithoutPlatformInvoicesInput>, SocietyUncheckedUpdateWithoutPlatformInvoicesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumSocietyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SocietyStatus | EnumSocietyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SocietyStatus[]
    notIn?: $Enums.SocietyStatus[]
    not?: NestedEnumSocietyStatusFilter<$PrismaModel> | $Enums.SocietyStatus
  }

  export type NestedEnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSocietyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocietyStatus | EnumSocietyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SocietyStatus[]
    notIn?: $Enums.SocietyStatus[]
    not?: NestedEnumSocietyStatusWithAggregatesFilter<$PrismaModel> | $Enums.SocietyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocietyStatusFilter<$PrismaModel>
    _max?: NestedEnumSocietyStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[]
    notIn?: $Enums.UserStatus[]
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[]
    notIn?: $Enums.UserStatus[]
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[]
    notIn?: $Enums.Priority[]
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumComplaintStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[]
    notIn?: $Enums.ComplaintStatus[]
    not?: NestedEnumComplaintStatusFilter<$PrismaModel> | $Enums.ComplaintStatus
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[]
    notIn?: $Enums.Priority[]
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[]
    notIn?: $Enums.ComplaintStatus[]
    not?: NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintStatusFilter<$PrismaModel>
    _max?: NestedEnumComplaintStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumVisitorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitorStatus | EnumVisitorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitorStatus[]
    notIn?: $Enums.VisitorStatus[]
    not?: NestedEnumVisitorStatusFilter<$PrismaModel> | $Enums.VisitorStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumVisitorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitorStatus | EnumVisitorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitorStatus[]
    notIn?: $Enums.VisitorStatus[]
    not?: NestedEnumVisitorStatusWithAggregatesFilter<$PrismaModel> | $Enums.VisitorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitorStatusFilter<$PrismaModel>
    _max?: NestedEnumVisitorStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumVendorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorStatus | EnumVendorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorStatus[]
    notIn?: $Enums.VendorStatus[]
    not?: NestedEnumVendorStatusFilter<$PrismaModel> | $Enums.VendorStatus
  }

  export type NestedEnumVendorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorStatus | EnumVendorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorStatus[]
    notIn?: $Enums.VendorStatus[]
    not?: NestedEnumVendorStatusWithAggregatesFilter<$PrismaModel> | $Enums.VendorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVendorStatusFilter<$PrismaModel>
    _max?: NestedEnumVendorStatusFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserCreateWithoutSocietyInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSocietyInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSocietyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput>
  }

  export type UserCreateManySocietyInputEnvelope = {
    data: UserCreateManySocietyInput | UserCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type UnitCreateWithoutSocietyInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutSocietyInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutSocietyInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput>
  }

  export type UnitCreateManySocietyInputEnvelope = {
    data: UnitCreateManySocietyInput | UnitCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCreateWithoutSocietyInput = {
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    reportedBy: UserCreateNestedOneWithoutReportedComplaintsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedComplaintsInput
    comments?: ComplaintCommentCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintUncheckedCreateWithoutSocietyInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    reportedById: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintCreateOrConnectWithoutSocietyInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput>
  }

  export type ComplaintCreateManySocietyInputEnvelope = {
    data: ComplaintCreateManySocietyInput | ComplaintCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type VisitorCreateWithoutSocietyInput = {
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateWithoutSocietyInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    visitingUnitId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorCreateOrConnectWithoutSocietyInput = {
    where: VisitorWhereUniqueInput
    create: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput>
  }

  export type VisitorCreateManySocietyInputEnvelope = {
    data: VisitorCreateManySocietyInput | VisitorCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutSocietyInput = {
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUncheckedCreateWithoutSocietyInput = {
    id?: number
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutSocietyInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput>
  }

  export type TransactionCreateManySocietyInputEnvelope = {
    data: TransactionCreateManySocietyInput | TransactionCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type NoticeCreateWithoutSocietyInput = {
    title: string
    content: string
    audience: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NoticeUncheckedCreateWithoutSocietyInput = {
    id?: number
    title: string
    content: string
    audience: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NoticeCreateOrConnectWithoutSocietyInput = {
    where: NoticeWhereUniqueInput
    create: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput>
  }

  export type NoticeCreateManySocietyInputEnvelope = {
    data: NoticeCreateManySocietyInput | NoticeCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type VendorCreateWithoutSocietyInput = {
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    status?: $Enums.VendorStatus
    createdAt?: Date | string
    payouts?: VendorPayoutCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutSocietyInput = {
    id?: number
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    status?: $Enums.VendorStatus
    createdAt?: Date | string
    payouts?: VendorPayoutUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutSocietyInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput>
  }

  export type VendorCreateManySocietyInputEnvelope = {
    data: VendorCreateManySocietyInput | VendorCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type AmenityCreateWithoutSocietyInput = {
    name: string
    description?: string | null
    chargesPerHour?: number
    createdAt?: Date | string
    bookings?: AmenityBookingCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUncheckedCreateWithoutSocietyInput = {
    id?: number
    name: string
    description?: string | null
    chargesPerHour?: number
    createdAt?: Date | string
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutAmenityInput
  }

  export type AmenityCreateOrConnectWithoutSocietyInput = {
    where: AmenityWhereUniqueInput
    create: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput>
  }

  export type AmenityCreateManySocietyInputEnvelope = {
    data: AmenityCreateManySocietyInput | AmenityCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type ParkingSlotCreateWithoutSocietyInput = {
    number: string
    type: string
    status: string
    vehicleNumber?: string | null
    createdAt?: Date | string
    unit?: UnitCreateNestedOneWithoutParkingSlotsInput
  }

  export type ParkingSlotUncheckedCreateWithoutSocietyInput = {
    id?: number
    number: string
    type: string
    status: string
    allocatedToUnitId?: number | null
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type ParkingSlotCreateOrConnectWithoutSocietyInput = {
    where: ParkingSlotWhereUniqueInput
    create: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput>
  }

  export type ParkingSlotCreateManySocietyInputEnvelope = {
    data: ParkingSlotCreateManySocietyInput | ParkingSlotCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type PlatformInvoiceCreateWithoutSocietyInput = {
    invoiceNo: string
    amount: number
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformInvoiceUncheckedCreateWithoutSocietyInput = {
    id?: number
    invoiceNo: string
    amount: number
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformInvoiceCreateOrConnectWithoutSocietyInput = {
    where: PlatformInvoiceWhereUniqueInput
    create: XOR<PlatformInvoiceCreateWithoutSocietyInput, PlatformInvoiceUncheckedCreateWithoutSocietyInput>
  }

  export type PlatformInvoiceCreateManySocietyInputEnvelope = {
    data: PlatformInvoiceCreateManySocietyInput | PlatformInvoiceCreateManySocietyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutSocietyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSocietyInput, UserUncheckedUpdateWithoutSocietyInput>
    create: XOR<UserCreateWithoutSocietyInput, UserUncheckedCreateWithoutSocietyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSocietyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSocietyInput, UserUncheckedUpdateWithoutSocietyInput>
  }

  export type UserUpdateManyWithWhereWithoutSocietyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSocietyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    profileImg?: StringNullableFilter<"User"> | string | null
    societyId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UnitUpsertWithWhereUniqueWithoutSocietyInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutSocietyInput, UnitUncheckedUpdateWithoutSocietyInput>
    create: XOR<UnitCreateWithoutSocietyInput, UnitUncheckedCreateWithoutSocietyInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutSocietyInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutSocietyInput, UnitUncheckedUpdateWithoutSocietyInput>
  }

  export type UnitUpdateManyWithWhereWithoutSocietyInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutSocietyInput>
  }

  export type UnitScalarWhereInput = {
    AND?: UnitScalarWhereInput | UnitScalarWhereInput[]
    OR?: UnitScalarWhereInput[]
    NOT?: UnitScalarWhereInput | UnitScalarWhereInput[]
    id?: IntFilter<"Unit"> | number
    block?: StringFilter<"Unit"> | string
    number?: StringFilter<"Unit"> | string
    floor?: IntFilter<"Unit"> | number
    type?: StringFilter<"Unit"> | string
    areaSqFt?: FloatFilter<"Unit"> | number
    societyId?: IntFilter<"Unit"> | number
    ownerId?: IntNullableFilter<"Unit"> | number | null
    tenantId?: IntNullableFilter<"Unit"> | number | null
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
  }

  export type ComplaintUpsertWithWhereUniqueWithoutSocietyInput = {
    where: ComplaintWhereUniqueInput
    update: XOR<ComplaintUpdateWithoutSocietyInput, ComplaintUncheckedUpdateWithoutSocietyInput>
    create: XOR<ComplaintCreateWithoutSocietyInput, ComplaintUncheckedCreateWithoutSocietyInput>
  }

  export type ComplaintUpdateWithWhereUniqueWithoutSocietyInput = {
    where: ComplaintWhereUniqueInput
    data: XOR<ComplaintUpdateWithoutSocietyInput, ComplaintUncheckedUpdateWithoutSocietyInput>
  }

  export type ComplaintUpdateManyWithWhereWithoutSocietyInput = {
    where: ComplaintScalarWhereInput
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyWithoutSocietyInput>
  }

  export type ComplaintScalarWhereInput = {
    AND?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
    OR?: ComplaintScalarWhereInput[]
    NOT?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
    id?: IntFilter<"Complaint"> | number
    title?: StringFilter<"Complaint"> | string
    description?: StringFilter<"Complaint"> | string
    category?: StringFilter<"Complaint"> | string
    priority?: EnumPriorityFilter<"Complaint"> | $Enums.Priority
    status?: EnumComplaintStatusFilter<"Complaint"> | $Enums.ComplaintStatus
    images?: JsonNullableFilter<"Complaint">
    societyId?: IntFilter<"Complaint"> | number
    reportedById?: IntFilter<"Complaint"> | number
    assignedToId?: IntNullableFilter<"Complaint"> | number | null
    timeline?: JsonNullableFilter<"Complaint">
    createdAt?: DateTimeFilter<"Complaint"> | Date | string
    updatedAt?: DateTimeFilter<"Complaint"> | Date | string
  }

  export type VisitorUpsertWithWhereUniqueWithoutSocietyInput = {
    where: VisitorWhereUniqueInput
    update: XOR<VisitorUpdateWithoutSocietyInput, VisitorUncheckedUpdateWithoutSocietyInput>
    create: XOR<VisitorCreateWithoutSocietyInput, VisitorUncheckedCreateWithoutSocietyInput>
  }

  export type VisitorUpdateWithWhereUniqueWithoutSocietyInput = {
    where: VisitorWhereUniqueInput
    data: XOR<VisitorUpdateWithoutSocietyInput, VisitorUncheckedUpdateWithoutSocietyInput>
  }

  export type VisitorUpdateManyWithWhereWithoutSocietyInput = {
    where: VisitorScalarWhereInput
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyWithoutSocietyInput>
  }

  export type VisitorScalarWhereInput = {
    AND?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
    OR?: VisitorScalarWhereInput[]
    NOT?: VisitorScalarWhereInput | VisitorScalarWhereInput[]
    id?: IntFilter<"Visitor"> | number
    name?: StringFilter<"Visitor"> | string
    phone?: StringFilter<"Visitor"> | string
    vehicleNo?: StringNullableFilter<"Visitor"> | string | null
    purpose?: StringFilter<"Visitor"> | string
    photo?: StringNullableFilter<"Visitor"> | string | null
    status?: EnumVisitorStatusFilter<"Visitor"> | $Enums.VisitorStatus
    entryTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    exitTime?: DateTimeNullableFilter<"Visitor"> | Date | string | null
    societyId?: IntFilter<"Visitor"> | number
    visitingUnitId?: IntFilter<"Visitor"> | number
    idType?: StringNullableFilter<"Visitor"> | string | null
    idNumber?: StringNullableFilter<"Visitor"> | string | null
    createdAt?: DateTimeFilter<"Visitor"> | Date | string
    updatedAt?: DateTimeFilter<"Visitor"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutSocietyInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutSocietyInput, TransactionUncheckedUpdateWithoutSocietyInput>
    create: XOR<TransactionCreateWithoutSocietyInput, TransactionUncheckedCreateWithoutSocietyInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutSocietyInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutSocietyInput, TransactionUncheckedUpdateWithoutSocietyInput>
  }

  export type TransactionUpdateManyWithWhereWithoutSocietyInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutSocietyInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    category?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    status?: StringFilter<"Transaction"> | string
    societyId?: IntFilter<"Transaction"> | number
    invoiceNo?: StringNullableFilter<"Transaction"> | string | null
    paidTo?: StringNullableFilter<"Transaction"> | string | null
    receivedFrom?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type NoticeUpsertWithWhereUniqueWithoutSocietyInput = {
    where: NoticeWhereUniqueInput
    update: XOR<NoticeUpdateWithoutSocietyInput, NoticeUncheckedUpdateWithoutSocietyInput>
    create: XOR<NoticeCreateWithoutSocietyInput, NoticeUncheckedCreateWithoutSocietyInput>
  }

  export type NoticeUpdateWithWhereUniqueWithoutSocietyInput = {
    where: NoticeWhereUniqueInput
    data: XOR<NoticeUpdateWithoutSocietyInput, NoticeUncheckedUpdateWithoutSocietyInput>
  }

  export type NoticeUpdateManyWithWhereWithoutSocietyInput = {
    where: NoticeScalarWhereInput
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyWithoutSocietyInput>
  }

  export type NoticeScalarWhereInput = {
    AND?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
    OR?: NoticeScalarWhereInput[]
    NOT?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
    id?: IntFilter<"Notice"> | number
    title?: StringFilter<"Notice"> | string
    content?: StringFilter<"Notice"> | string
    audience?: StringFilter<"Notice"> | string
    societyId?: IntFilter<"Notice"> | number
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notice"> | Date | string | null
  }

  export type VendorUpsertWithWhereUniqueWithoutSocietyInput = {
    where: VendorWhereUniqueInput
    update: XOR<VendorUpdateWithoutSocietyInput, VendorUncheckedUpdateWithoutSocietyInput>
    create: XOR<VendorCreateWithoutSocietyInput, VendorUncheckedCreateWithoutSocietyInput>
  }

  export type VendorUpdateWithWhereUniqueWithoutSocietyInput = {
    where: VendorWhereUniqueInput
    data: XOR<VendorUpdateWithoutSocietyInput, VendorUncheckedUpdateWithoutSocietyInput>
  }

  export type VendorUpdateManyWithWhereWithoutSocietyInput = {
    where: VendorScalarWhereInput
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyWithoutSocietyInput>
  }

  export type VendorScalarWhereInput = {
    AND?: VendorScalarWhereInput | VendorScalarWhereInput[]
    OR?: VendorScalarWhereInput[]
    NOT?: VendorScalarWhereInput | VendorScalarWhereInput[]
    id?: IntFilter<"Vendor"> | number
    name?: StringFilter<"Vendor"> | string
    serviceType?: StringFilter<"Vendor"> | string
    contact?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    status?: EnumVendorStatusFilter<"Vendor"> | $Enums.VendorStatus
    societyId?: IntNullableFilter<"Vendor"> | number | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
  }

  export type AmenityUpsertWithWhereUniqueWithoutSocietyInput = {
    where: AmenityWhereUniqueInput
    update: XOR<AmenityUpdateWithoutSocietyInput, AmenityUncheckedUpdateWithoutSocietyInput>
    create: XOR<AmenityCreateWithoutSocietyInput, AmenityUncheckedCreateWithoutSocietyInput>
  }

  export type AmenityUpdateWithWhereUniqueWithoutSocietyInput = {
    where: AmenityWhereUniqueInput
    data: XOR<AmenityUpdateWithoutSocietyInput, AmenityUncheckedUpdateWithoutSocietyInput>
  }

  export type AmenityUpdateManyWithWhereWithoutSocietyInput = {
    where: AmenityScalarWhereInput
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyWithoutSocietyInput>
  }

  export type AmenityScalarWhereInput = {
    AND?: AmenityScalarWhereInput | AmenityScalarWhereInput[]
    OR?: AmenityScalarWhereInput[]
    NOT?: AmenityScalarWhereInput | AmenityScalarWhereInput[]
    id?: IntFilter<"Amenity"> | number
    name?: StringFilter<"Amenity"> | string
    description?: StringNullableFilter<"Amenity"> | string | null
    chargesPerHour?: FloatFilter<"Amenity"> | number
    societyId?: IntFilter<"Amenity"> | number
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
  }

  export type ParkingSlotUpsertWithWhereUniqueWithoutSocietyInput = {
    where: ParkingSlotWhereUniqueInput
    update: XOR<ParkingSlotUpdateWithoutSocietyInput, ParkingSlotUncheckedUpdateWithoutSocietyInput>
    create: XOR<ParkingSlotCreateWithoutSocietyInput, ParkingSlotUncheckedCreateWithoutSocietyInput>
  }

  export type ParkingSlotUpdateWithWhereUniqueWithoutSocietyInput = {
    where: ParkingSlotWhereUniqueInput
    data: XOR<ParkingSlotUpdateWithoutSocietyInput, ParkingSlotUncheckedUpdateWithoutSocietyInput>
  }

  export type ParkingSlotUpdateManyWithWhereWithoutSocietyInput = {
    where: ParkingSlotScalarWhereInput
    data: XOR<ParkingSlotUpdateManyMutationInput, ParkingSlotUncheckedUpdateManyWithoutSocietyInput>
  }

  export type ParkingSlotScalarWhereInput = {
    AND?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
    OR?: ParkingSlotScalarWhereInput[]
    NOT?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
    id?: IntFilter<"ParkingSlot"> | number
    number?: StringFilter<"ParkingSlot"> | string
    type?: StringFilter<"ParkingSlot"> | string
    status?: StringFilter<"ParkingSlot"> | string
    societyId?: IntFilter<"ParkingSlot"> | number
    allocatedToUnitId?: IntNullableFilter<"ParkingSlot"> | number | null
    vehicleNumber?: StringNullableFilter<"ParkingSlot"> | string | null
    createdAt?: DateTimeFilter<"ParkingSlot"> | Date | string
  }

  export type PlatformInvoiceUpsertWithWhereUniqueWithoutSocietyInput = {
    where: PlatformInvoiceWhereUniqueInput
    update: XOR<PlatformInvoiceUpdateWithoutSocietyInput, PlatformInvoiceUncheckedUpdateWithoutSocietyInput>
    create: XOR<PlatformInvoiceCreateWithoutSocietyInput, PlatformInvoiceUncheckedCreateWithoutSocietyInput>
  }

  export type PlatformInvoiceUpdateWithWhereUniqueWithoutSocietyInput = {
    where: PlatformInvoiceWhereUniqueInput
    data: XOR<PlatformInvoiceUpdateWithoutSocietyInput, PlatformInvoiceUncheckedUpdateWithoutSocietyInput>
  }

  export type PlatformInvoiceUpdateManyWithWhereWithoutSocietyInput = {
    where: PlatformInvoiceScalarWhereInput
    data: XOR<PlatformInvoiceUpdateManyMutationInput, PlatformInvoiceUncheckedUpdateManyWithoutSocietyInput>
  }

  export type PlatformInvoiceScalarWhereInput = {
    AND?: PlatformInvoiceScalarWhereInput | PlatformInvoiceScalarWhereInput[]
    OR?: PlatformInvoiceScalarWhereInput[]
    NOT?: PlatformInvoiceScalarWhereInput | PlatformInvoiceScalarWhereInput[]
    id?: IntFilter<"PlatformInvoice"> | number
    invoiceNo?: StringFilter<"PlatformInvoice"> | string
    societyId?: IntFilter<"PlatformInvoice"> | number
    amount?: FloatFilter<"PlatformInvoice"> | number
    status?: StringFilter<"PlatformInvoice"> | string
    issueDate?: DateTimeFilter<"PlatformInvoice"> | Date | string
    dueDate?: DateTimeFilter<"PlatformInvoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"PlatformInvoice"> | Date | string | null
    createdAt?: DateTimeFilter<"PlatformInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformInvoice"> | Date | string
  }

  export type SocietyCreateWithoutUsersInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutUsersInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutUsersInput, SocietyUncheckedCreateWithoutUsersInput>
  }

  export type UnitCreateWithoutOwnerInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutOwnerInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutOwnerInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput>
  }

  export type UnitCreateManyOwnerInputEnvelope = {
    data: UnitCreateManyOwnerInput | UnitCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type UnitCreateWithoutTenantInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutTenantInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    ownerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutTenantInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput>
  }

  export type UnitCreateManyTenantInputEnvelope = {
    data: UnitCreateManyTenantInput | UnitCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCreateWithoutReportedByInput = {
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutComplaintsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedComplaintsInput
    comments?: ComplaintCommentCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintUncheckedCreateWithoutReportedByInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintCreateOrConnectWithoutReportedByInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput>
  }

  export type ComplaintCreateManyReportedByInputEnvelope = {
    data: ComplaintCreateManyReportedByInput | ComplaintCreateManyReportedByInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCreateWithoutAssignedToInput = {
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutComplaintsInput
    reportedBy: UserCreateNestedOneWithoutReportedComplaintsInput
    comments?: ComplaintCommentCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintUncheckedCreateWithoutAssignedToInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    reportedById: number
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintCreateOrConnectWithoutAssignedToInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput>
  }

  export type ComplaintCreateManyAssignedToInputEnvelope = {
    data: ComplaintCreateManyAssignedToInput | ComplaintCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type AmenityBookingCreateWithoutUserInput = {
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
    amenity: AmenityCreateNestedOneWithoutBookingsInput
  }

  export type AmenityBookingUncheckedCreateWithoutUserInput = {
    id?: number
    amenityId: number
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
  }

  export type AmenityBookingCreateOrConnectWithoutUserInput = {
    where: AmenityBookingWhereUniqueInput
    create: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput>
  }

  export type AmenityBookingCreateManyUserInputEnvelope = {
    data: AmenityBookingCreateManyUserInput | AmenityBookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCommentCreateWithoutUserInput = {
    message: string
    createdAt?: Date | string
    complaint: ComplaintCreateNestedOneWithoutCommentsInput
  }

  export type ComplaintCommentUncheckedCreateWithoutUserInput = {
    id?: number
    complaintId: number
    message: string
    createdAt?: Date | string
  }

  export type ComplaintCommentCreateOrConnectWithoutUserInput = {
    where: ComplaintCommentWhereUniqueInput
    create: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput>
  }

  export type ComplaintCommentCreateManyUserInputEnvelope = {
    data: ComplaintCommentCreateManyUserInput | ComplaintCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SocietyUpsertWithoutUsersInput = {
    update: XOR<SocietyUpdateWithoutUsersInput, SocietyUncheckedUpdateWithoutUsersInput>
    create: XOR<SocietyCreateWithoutUsersInput, SocietyUncheckedCreateWithoutUsersInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutUsersInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutUsersInput, SocietyUncheckedUpdateWithoutUsersInput>
  }

  export type SocietyUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UnitUpsertWithWhereUniqueWithoutOwnerInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutOwnerInput, UnitUncheckedUpdateWithoutOwnerInput>
    create: XOR<UnitCreateWithoutOwnerInput, UnitUncheckedCreateWithoutOwnerInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutOwnerInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutOwnerInput, UnitUncheckedUpdateWithoutOwnerInput>
  }

  export type UnitUpdateManyWithWhereWithoutOwnerInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutOwnerInput>
  }

  export type UnitUpsertWithWhereUniqueWithoutTenantInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutTenantInput, UnitUncheckedUpdateWithoutTenantInput>
    create: XOR<UnitCreateWithoutTenantInput, UnitUncheckedCreateWithoutTenantInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutTenantInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutTenantInput, UnitUncheckedUpdateWithoutTenantInput>
  }

  export type UnitUpdateManyWithWhereWithoutTenantInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutTenantInput>
  }

  export type ComplaintUpsertWithWhereUniqueWithoutReportedByInput = {
    where: ComplaintWhereUniqueInput
    update: XOR<ComplaintUpdateWithoutReportedByInput, ComplaintUncheckedUpdateWithoutReportedByInput>
    create: XOR<ComplaintCreateWithoutReportedByInput, ComplaintUncheckedCreateWithoutReportedByInput>
  }

  export type ComplaintUpdateWithWhereUniqueWithoutReportedByInput = {
    where: ComplaintWhereUniqueInput
    data: XOR<ComplaintUpdateWithoutReportedByInput, ComplaintUncheckedUpdateWithoutReportedByInput>
  }

  export type ComplaintUpdateManyWithWhereWithoutReportedByInput = {
    where: ComplaintScalarWhereInput
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyWithoutReportedByInput>
  }

  export type ComplaintUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: ComplaintWhereUniqueInput
    update: XOR<ComplaintUpdateWithoutAssignedToInput, ComplaintUncheckedUpdateWithoutAssignedToInput>
    create: XOR<ComplaintCreateWithoutAssignedToInput, ComplaintUncheckedCreateWithoutAssignedToInput>
  }

  export type ComplaintUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: ComplaintWhereUniqueInput
    data: XOR<ComplaintUpdateWithoutAssignedToInput, ComplaintUncheckedUpdateWithoutAssignedToInput>
  }

  export type ComplaintUpdateManyWithWhereWithoutAssignedToInput = {
    where: ComplaintScalarWhereInput
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type AmenityBookingUpsertWithWhereUniqueWithoutUserInput = {
    where: AmenityBookingWhereUniqueInput
    update: XOR<AmenityBookingUpdateWithoutUserInput, AmenityBookingUncheckedUpdateWithoutUserInput>
    create: XOR<AmenityBookingCreateWithoutUserInput, AmenityBookingUncheckedCreateWithoutUserInput>
  }

  export type AmenityBookingUpdateWithWhereUniqueWithoutUserInput = {
    where: AmenityBookingWhereUniqueInput
    data: XOR<AmenityBookingUpdateWithoutUserInput, AmenityBookingUncheckedUpdateWithoutUserInput>
  }

  export type AmenityBookingUpdateManyWithWhereWithoutUserInput = {
    where: AmenityBookingScalarWhereInput
    data: XOR<AmenityBookingUpdateManyMutationInput, AmenityBookingUncheckedUpdateManyWithoutUserInput>
  }

  export type AmenityBookingScalarWhereInput = {
    AND?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
    OR?: AmenityBookingScalarWhereInput[]
    NOT?: AmenityBookingScalarWhereInput | AmenityBookingScalarWhereInput[]
    id?: IntFilter<"AmenityBooking"> | number
    amenityId?: IntFilter<"AmenityBooking"> | number
    userId?: IntFilter<"AmenityBooking"> | number
    startTime?: DateTimeFilter<"AmenityBooking"> | Date | string
    endTime?: DateTimeFilter<"AmenityBooking"> | Date | string
    status?: StringFilter<"AmenityBooking"> | string
    amountPaid?: FloatFilter<"AmenityBooking"> | number
    createdAt?: DateTimeFilter<"AmenityBooking"> | Date | string
  }

  export type ComplaintCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: ComplaintCommentWhereUniqueInput
    update: XOR<ComplaintCommentUpdateWithoutUserInput, ComplaintCommentUncheckedUpdateWithoutUserInput>
    create: XOR<ComplaintCommentCreateWithoutUserInput, ComplaintCommentUncheckedCreateWithoutUserInput>
  }

  export type ComplaintCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: ComplaintCommentWhereUniqueInput
    data: XOR<ComplaintCommentUpdateWithoutUserInput, ComplaintCommentUncheckedUpdateWithoutUserInput>
  }

  export type ComplaintCommentUpdateManyWithWhereWithoutUserInput = {
    where: ComplaintCommentScalarWhereInput
    data: XOR<ComplaintCommentUpdateManyMutationInput, ComplaintCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type ComplaintCommentScalarWhereInput = {
    AND?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
    OR?: ComplaintCommentScalarWhereInput[]
    NOT?: ComplaintCommentScalarWhereInput | ComplaintCommentScalarWhereInput[]
    id?: IntFilter<"ComplaintComment"> | number
    complaintId?: IntFilter<"ComplaintComment"> | number
    userId?: IntFilter<"ComplaintComment"> | number
    message?: StringFilter<"ComplaintComment"> | string
    createdAt?: DateTimeFilter<"ComplaintComment"> | Date | string
  }

  export type SocietyCreateWithoutUnitsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutUnitsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutUnitsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutUnitsInput, SocietyUncheckedCreateWithoutUnitsInput>
  }

  export type UserCreateWithoutOwnedUnitsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutUsersInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedUnitsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedUnitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedUnitsInput, UserUncheckedCreateWithoutOwnedUnitsInput>
  }

  export type UserCreateWithoutRentedUnitsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRentedUnitsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRentedUnitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRentedUnitsInput, UserUncheckedCreateWithoutRentedUnitsInput>
  }

  export type VisitorCreateWithoutUnitInput = {
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutVisitorsInput
  }

  export type VisitorUncheckedCreateWithoutUnitInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    societyId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorCreateOrConnectWithoutUnitInput = {
    where: VisitorWhereUniqueInput
    create: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput>
  }

  export type VisitorCreateManyUnitInputEnvelope = {
    data: VisitorCreateManyUnitInput | VisitorCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ParkingSlotCreateWithoutUnitInput = {
    number: string
    type: string
    status: string
    vehicleNumber?: string | null
    createdAt?: Date | string
    society: SocietyCreateNestedOneWithoutParkingSlotsInput
  }

  export type ParkingSlotUncheckedCreateWithoutUnitInput = {
    id?: number
    number: string
    type: string
    status: string
    societyId: number
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type ParkingSlotCreateOrConnectWithoutUnitInput = {
    where: ParkingSlotWhereUniqueInput
    create: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput>
  }

  export type ParkingSlotCreateManyUnitInputEnvelope = {
    data: ParkingSlotCreateManyUnitInput | ParkingSlotCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type SocietyUpsertWithoutUnitsInput = {
    update: XOR<SocietyUpdateWithoutUnitsInput, SocietyUncheckedUpdateWithoutUnitsInput>
    create: XOR<SocietyCreateWithoutUnitsInput, SocietyUncheckedCreateWithoutUnitsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutUnitsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutUnitsInput, SocietyUncheckedUpdateWithoutUnitsInput>
  }

  export type SocietyUpdateWithoutUnitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UserUpsertWithoutOwnedUnitsInput = {
    update: XOR<UserUpdateWithoutOwnedUnitsInput, UserUncheckedUpdateWithoutOwnedUnitsInput>
    create: XOR<UserCreateWithoutOwnedUnitsInput, UserUncheckedCreateWithoutOwnedUnitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedUnitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedUnitsInput, UserUncheckedUpdateWithoutOwnedUnitsInput>
  }

  export type UserUpdateWithoutOwnedUnitsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutUsersNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutRentedUnitsInput = {
    update: XOR<UserUpdateWithoutRentedUnitsInput, UserUncheckedUpdateWithoutRentedUnitsInput>
    create: XOR<UserCreateWithoutRentedUnitsInput, UserUncheckedCreateWithoutRentedUnitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRentedUnitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRentedUnitsInput, UserUncheckedUpdateWithoutRentedUnitsInput>
  }

  export type UserUpdateWithoutRentedUnitsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRentedUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VisitorUpsertWithWhereUniqueWithoutUnitInput = {
    where: VisitorWhereUniqueInput
    update: XOR<VisitorUpdateWithoutUnitInput, VisitorUncheckedUpdateWithoutUnitInput>
    create: XOR<VisitorCreateWithoutUnitInput, VisitorUncheckedCreateWithoutUnitInput>
  }

  export type VisitorUpdateWithWhereUniqueWithoutUnitInput = {
    where: VisitorWhereUniqueInput
    data: XOR<VisitorUpdateWithoutUnitInput, VisitorUncheckedUpdateWithoutUnitInput>
  }

  export type VisitorUpdateManyWithWhereWithoutUnitInput = {
    where: VisitorScalarWhereInput
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyWithoutUnitInput>
  }

  export type ParkingSlotUpsertWithWhereUniqueWithoutUnitInput = {
    where: ParkingSlotWhereUniqueInput
    update: XOR<ParkingSlotUpdateWithoutUnitInput, ParkingSlotUncheckedUpdateWithoutUnitInput>
    create: XOR<ParkingSlotCreateWithoutUnitInput, ParkingSlotUncheckedCreateWithoutUnitInput>
  }

  export type ParkingSlotUpdateWithWhereUniqueWithoutUnitInput = {
    where: ParkingSlotWhereUniqueInput
    data: XOR<ParkingSlotUpdateWithoutUnitInput, ParkingSlotUncheckedUpdateWithoutUnitInput>
  }

  export type ParkingSlotUpdateManyWithWhereWithoutUnitInput = {
    where: ParkingSlotScalarWhereInput
    data: XOR<ParkingSlotUpdateManyMutationInput, ParkingSlotUncheckedUpdateManyWithoutUnitInput>
  }

  export type SocietyCreateWithoutParkingSlotsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutParkingSlotsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutParkingSlotsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutParkingSlotsInput, SocietyUncheckedCreateWithoutParkingSlotsInput>
  }

  export type UnitCreateWithoutParkingSlotsInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    visitors?: VisitorCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutParkingSlotsInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitors?: VisitorUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutParkingSlotsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutParkingSlotsInput, UnitUncheckedCreateWithoutParkingSlotsInput>
  }

  export type SocietyUpsertWithoutParkingSlotsInput = {
    update: XOR<SocietyUpdateWithoutParkingSlotsInput, SocietyUncheckedUpdateWithoutParkingSlotsInput>
    create: XOR<SocietyCreateWithoutParkingSlotsInput, SocietyUncheckedCreateWithoutParkingSlotsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutParkingSlotsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutParkingSlotsInput, SocietyUncheckedUpdateWithoutParkingSlotsInput>
  }

  export type SocietyUpdateWithoutParkingSlotsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutParkingSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UnitUpsertWithoutParkingSlotsInput = {
    update: XOR<UnitUpdateWithoutParkingSlotsInput, UnitUncheckedUpdateWithoutParkingSlotsInput>
    create: XOR<UnitCreateWithoutParkingSlotsInput, UnitUncheckedCreateWithoutParkingSlotsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutParkingSlotsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutParkingSlotsInput, UnitUncheckedUpdateWithoutParkingSlotsInput>
  }

  export type UnitUpdateWithoutParkingSlotsInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutParkingSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type SocietyCreateWithoutComplaintsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutComplaintsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutComplaintsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutComplaintsInput, SocietyUncheckedCreateWithoutComplaintsInput>
  }

  export type UserCreateWithoutReportedComplaintsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportedComplaintsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportedComplaintsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportedComplaintsInput, UserUncheckedCreateWithoutReportedComplaintsInput>
  }

  export type UserCreateWithoutAssignedComplaintsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedComplaintsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedComplaintsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedComplaintsInput, UserUncheckedCreateWithoutAssignedComplaintsInput>
  }

  export type ComplaintCommentCreateWithoutComplaintInput = {
    message: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type ComplaintCommentUncheckedCreateWithoutComplaintInput = {
    id?: number
    userId: number
    message: string
    createdAt?: Date | string
  }

  export type ComplaintCommentCreateOrConnectWithoutComplaintInput = {
    where: ComplaintCommentWhereUniqueInput
    create: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput>
  }

  export type ComplaintCommentCreateManyComplaintInputEnvelope = {
    data: ComplaintCommentCreateManyComplaintInput | ComplaintCommentCreateManyComplaintInput[]
    skipDuplicates?: boolean
  }

  export type SocietyUpsertWithoutComplaintsInput = {
    update: XOR<SocietyUpdateWithoutComplaintsInput, SocietyUncheckedUpdateWithoutComplaintsInput>
    create: XOR<SocietyCreateWithoutComplaintsInput, SocietyUncheckedCreateWithoutComplaintsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutComplaintsInput, SocietyUncheckedUpdateWithoutComplaintsInput>
  }

  export type SocietyUpdateWithoutComplaintsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UserUpsertWithoutReportedComplaintsInput = {
    update: XOR<UserUpdateWithoutReportedComplaintsInput, UserUncheckedUpdateWithoutReportedComplaintsInput>
    create: XOR<UserCreateWithoutReportedComplaintsInput, UserUncheckedCreateWithoutReportedComplaintsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportedComplaintsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportedComplaintsInput, UserUncheckedUpdateWithoutReportedComplaintsInput>
  }

  export type UserUpdateWithoutReportedComplaintsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportedComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutAssignedComplaintsInput = {
    update: XOR<UserUpdateWithoutAssignedComplaintsInput, UserUncheckedUpdateWithoutAssignedComplaintsInput>
    create: XOR<UserCreateWithoutAssignedComplaintsInput, UserUncheckedCreateWithoutAssignedComplaintsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedComplaintsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedComplaintsInput, UserUncheckedUpdateWithoutAssignedComplaintsInput>
  }

  export type UserUpdateWithoutAssignedComplaintsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ComplaintCommentUpsertWithWhereUniqueWithoutComplaintInput = {
    where: ComplaintCommentWhereUniqueInput
    update: XOR<ComplaintCommentUpdateWithoutComplaintInput, ComplaintCommentUncheckedUpdateWithoutComplaintInput>
    create: XOR<ComplaintCommentCreateWithoutComplaintInput, ComplaintCommentUncheckedCreateWithoutComplaintInput>
  }

  export type ComplaintCommentUpdateWithWhereUniqueWithoutComplaintInput = {
    where: ComplaintCommentWhereUniqueInput
    data: XOR<ComplaintCommentUpdateWithoutComplaintInput, ComplaintCommentUncheckedUpdateWithoutComplaintInput>
  }

  export type ComplaintCommentUpdateManyWithWhereWithoutComplaintInput = {
    where: ComplaintCommentScalarWhereInput
    data: XOR<ComplaintCommentUpdateManyMutationInput, ComplaintCommentUncheckedUpdateManyWithoutComplaintInput>
  }

  export type ComplaintCreateWithoutCommentsInput = {
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutComplaintsInput
    reportedBy: UserCreateNestedOneWithoutReportedComplaintsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedComplaintsInput
  }

  export type ComplaintUncheckedCreateWithoutCommentsInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    reportedById: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintCreateOrConnectWithoutCommentsInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutCommentsInput, ComplaintUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    bookings?: AmenityBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type ComplaintUpsertWithoutCommentsInput = {
    update: XOR<ComplaintUpdateWithoutCommentsInput, ComplaintUncheckedUpdateWithoutCommentsInput>
    create: XOR<ComplaintCreateWithoutCommentsInput, ComplaintUncheckedCreateWithoutCommentsInput>
    where?: ComplaintWhereInput
  }

  export type ComplaintUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ComplaintWhereInput
    data: XOR<ComplaintUpdateWithoutCommentsInput, ComplaintUncheckedUpdateWithoutCommentsInput>
  }

  export type ComplaintUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutComplaintsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutReportedComplaintsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedComplaintsNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SocietyCreateWithoutVisitorsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutVisitorsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutVisitorsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutVisitorsInput, SocietyUncheckedCreateWithoutVisitorsInput>
  }

  export type UnitCreateWithoutVisitorsInput = {
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    createdAt?: Date | string
    updatedAt?: Date | string
    society: SocietyCreateNestedOneWithoutUnitsInput
    owner?: UserCreateNestedOneWithoutOwnedUnitsInput
    tenant?: UserCreateNestedOneWithoutRentedUnitsInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutVisitorsInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutVisitorsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutVisitorsInput, UnitUncheckedCreateWithoutVisitorsInput>
  }

  export type SocietyUpsertWithoutVisitorsInput = {
    update: XOR<SocietyUpdateWithoutVisitorsInput, SocietyUncheckedUpdateWithoutVisitorsInput>
    create: XOR<SocietyCreateWithoutVisitorsInput, SocietyUncheckedCreateWithoutVisitorsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutVisitorsInput, SocietyUncheckedUpdateWithoutVisitorsInput>
  }

  export type SocietyUpdateWithoutVisitorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutVisitorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UnitUpsertWithoutVisitorsInput = {
    update: XOR<UnitUpdateWithoutVisitorsInput, UnitUncheckedUpdateWithoutVisitorsInput>
    create: XOR<UnitCreateWithoutVisitorsInput, UnitUncheckedCreateWithoutVisitorsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutVisitorsInput, UnitUncheckedUpdateWithoutVisitorsInput>
  }

  export type UnitUpdateWithoutVisitorsInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutVisitorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type SocietyCreateWithoutTransactionsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutTransactionsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutTransactionsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutTransactionsInput, SocietyUncheckedCreateWithoutTransactionsInput>
  }

  export type SocietyUpsertWithoutTransactionsInput = {
    update: XOR<SocietyUpdateWithoutTransactionsInput, SocietyUncheckedUpdateWithoutTransactionsInput>
    create: XOR<SocietyCreateWithoutTransactionsInput, SocietyUncheckedCreateWithoutTransactionsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutTransactionsInput, SocietyUncheckedUpdateWithoutTransactionsInput>
  }

  export type SocietyUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyCreateWithoutVendorsInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutVendorsInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutVendorsInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutVendorsInput, SocietyUncheckedCreateWithoutVendorsInput>
  }

  export type VendorPayoutCreateWithoutVendorInput = {
    vendorName: string
    societyId?: number | null
    societyName?: string | null
    dealValue: number
    commissionPercent: number
    payableAmount: number
    status?: string
    remarks?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorPayoutUncheckedCreateWithoutVendorInput = {
    id?: number
    vendorName: string
    societyId?: number | null
    societyName?: string | null
    dealValue: number
    commissionPercent: number
    payableAmount: number
    status?: string
    remarks?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorPayoutCreateOrConnectWithoutVendorInput = {
    where: VendorPayoutWhereUniqueInput
    create: XOR<VendorPayoutCreateWithoutVendorInput, VendorPayoutUncheckedCreateWithoutVendorInput>
  }

  export type VendorPayoutCreateManyVendorInputEnvelope = {
    data: VendorPayoutCreateManyVendorInput | VendorPayoutCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type SocietyUpsertWithoutVendorsInput = {
    update: XOR<SocietyUpdateWithoutVendorsInput, SocietyUncheckedUpdateWithoutVendorsInput>
    create: XOR<SocietyCreateWithoutVendorsInput, SocietyUncheckedCreateWithoutVendorsInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutVendorsInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutVendorsInput, SocietyUncheckedUpdateWithoutVendorsInput>
  }

  export type SocietyUpdateWithoutVendorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutVendorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type VendorPayoutUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorPayoutWhereUniqueInput
    update: XOR<VendorPayoutUpdateWithoutVendorInput, VendorPayoutUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorPayoutCreateWithoutVendorInput, VendorPayoutUncheckedCreateWithoutVendorInput>
  }

  export type VendorPayoutUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorPayoutWhereUniqueInput
    data: XOR<VendorPayoutUpdateWithoutVendorInput, VendorPayoutUncheckedUpdateWithoutVendorInput>
  }

  export type VendorPayoutUpdateManyWithWhereWithoutVendorInput = {
    where: VendorPayoutScalarWhereInput
    data: XOR<VendorPayoutUpdateManyMutationInput, VendorPayoutUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorPayoutScalarWhereInput = {
    AND?: VendorPayoutScalarWhereInput | VendorPayoutScalarWhereInput[]
    OR?: VendorPayoutScalarWhereInput[]
    NOT?: VendorPayoutScalarWhereInput | VendorPayoutScalarWhereInput[]
    id?: IntFilter<"VendorPayout"> | number
    vendorId?: IntFilter<"VendorPayout"> | number
    vendorName?: StringFilter<"VendorPayout"> | string
    societyId?: IntNullableFilter<"VendorPayout"> | number | null
    societyName?: StringNullableFilter<"VendorPayout"> | string | null
    dealValue?: FloatFilter<"VendorPayout"> | number
    commissionPercent?: FloatFilter<"VendorPayout"> | number
    payableAmount?: FloatFilter<"VendorPayout"> | number
    status?: StringFilter<"VendorPayout"> | string
    remarks?: StringNullableFilter<"VendorPayout"> | string | null
    date?: DateTimeFilter<"VendorPayout"> | Date | string
    createdAt?: DateTimeFilter<"VendorPayout"> | Date | string
    updatedAt?: DateTimeFilter<"VendorPayout"> | Date | string
  }

  export type VendorCreateWithoutPayoutsInput = {
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    status?: $Enums.VendorStatus
    createdAt?: Date | string
    society?: SocietyCreateNestedOneWithoutVendorsInput
  }

  export type VendorUncheckedCreateWithoutPayoutsInput = {
    id?: number
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    status?: $Enums.VendorStatus
    societyId?: number | null
    createdAt?: Date | string
  }

  export type VendorCreateOrConnectWithoutPayoutsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPayoutsInput, VendorUncheckedCreateWithoutPayoutsInput>
  }

  export type VendorUpsertWithoutPayoutsInput = {
    update: XOR<VendorUpdateWithoutPayoutsInput, VendorUncheckedUpdateWithoutPayoutsInput>
    create: XOR<VendorCreateWithoutPayoutsInput, VendorUncheckedCreateWithoutPayoutsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutPayoutsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutPayoutsInput, VendorUncheckedUpdateWithoutPayoutsInput>
  }

  export type VendorUpdateWithoutPayoutsInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutVendorsNestedInput
  }

  export type VendorUncheckedUpdateWithoutPayoutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceVariantCreateWithoutCategoryInput = {
    id?: string
    name: string
    price: string
    description?: string | null
  }

  export type ServiceVariantUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    price: string
    description?: string | null
  }

  export type ServiceVariantCreateOrConnectWithoutCategoryInput = {
    where: ServiceVariantWhereUniqueInput
    create: XOR<ServiceVariantCreateWithoutCategoryInput, ServiceVariantUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceVariantCreateManyCategoryInputEnvelope = {
    data: ServiceVariantCreateManyCategoryInput | ServiceVariantCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ServiceVariantUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ServiceVariantWhereUniqueInput
    update: XOR<ServiceVariantUpdateWithoutCategoryInput, ServiceVariantUncheckedUpdateWithoutCategoryInput>
    create: XOR<ServiceVariantCreateWithoutCategoryInput, ServiceVariantUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceVariantUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ServiceVariantWhereUniqueInput
    data: XOR<ServiceVariantUpdateWithoutCategoryInput, ServiceVariantUncheckedUpdateWithoutCategoryInput>
  }

  export type ServiceVariantUpdateManyWithWhereWithoutCategoryInput = {
    where: ServiceVariantScalarWhereInput
    data: XOR<ServiceVariantUpdateManyMutationInput, ServiceVariantUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ServiceVariantScalarWhereInput = {
    AND?: ServiceVariantScalarWhereInput | ServiceVariantScalarWhereInput[]
    OR?: ServiceVariantScalarWhereInput[]
    NOT?: ServiceVariantScalarWhereInput | ServiceVariantScalarWhereInput[]
    id?: StringFilter<"ServiceVariant"> | string
    name?: StringFilter<"ServiceVariant"> | string
    price?: StringFilter<"ServiceVariant"> | string
    description?: StringNullableFilter<"ServiceVariant"> | string | null
    categoryId?: StringFilter<"ServiceVariant"> | string
  }

  export type ServiceCategoryCreateWithoutVariantsInput = {
    id: string
    name: string
    description: string
    icon: string
    color: string
  }

  export type ServiceCategoryUncheckedCreateWithoutVariantsInput = {
    id: string
    name: string
    description: string
    icon: string
    color: string
  }

  export type ServiceCategoryCreateOrConnectWithoutVariantsInput = {
    where: ServiceCategoryWhereUniqueInput
    create: XOR<ServiceCategoryCreateWithoutVariantsInput, ServiceCategoryUncheckedCreateWithoutVariantsInput>
  }

  export type ServiceCategoryUpsertWithoutVariantsInput = {
    update: XOR<ServiceCategoryUpdateWithoutVariantsInput, ServiceCategoryUncheckedUpdateWithoutVariantsInput>
    create: XOR<ServiceCategoryCreateWithoutVariantsInput, ServiceCategoryUncheckedCreateWithoutVariantsInput>
    where?: ServiceCategoryWhereInput
  }

  export type ServiceCategoryUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ServiceCategoryWhereInput
    data: XOR<ServiceCategoryUpdateWithoutVariantsInput, ServiceCategoryUncheckedUpdateWithoutVariantsInput>
  }

  export type ServiceCategoryUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCategoryUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type SocietyCreateWithoutNoticesInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutNoticesInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutNoticesInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutNoticesInput, SocietyUncheckedCreateWithoutNoticesInput>
  }

  export type SocietyUpsertWithoutNoticesInput = {
    update: XOR<SocietyUpdateWithoutNoticesInput, SocietyUncheckedUpdateWithoutNoticesInput>
    create: XOR<SocietyCreateWithoutNoticesInput, SocietyUncheckedCreateWithoutNoticesInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutNoticesInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutNoticesInput, SocietyUncheckedUpdateWithoutNoticesInput>
  }

  export type SocietyUpdateWithoutNoticesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutNoticesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyCreateWithoutAmenitiesInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutAmenitiesInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
    platformInvoices?: PlatformInvoiceUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutAmenitiesInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutAmenitiesInput, SocietyUncheckedCreateWithoutAmenitiesInput>
  }

  export type AmenityBookingCreateWithoutAmenityInput = {
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
  }

  export type AmenityBookingUncheckedCreateWithoutAmenityInput = {
    id?: number
    userId: number
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
  }

  export type AmenityBookingCreateOrConnectWithoutAmenityInput = {
    where: AmenityBookingWhereUniqueInput
    create: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput>
  }

  export type AmenityBookingCreateManyAmenityInputEnvelope = {
    data: AmenityBookingCreateManyAmenityInput | AmenityBookingCreateManyAmenityInput[]
    skipDuplicates?: boolean
  }

  export type SocietyUpsertWithoutAmenitiesInput = {
    update: XOR<SocietyUpdateWithoutAmenitiesInput, SocietyUncheckedUpdateWithoutAmenitiesInput>
    create: XOR<SocietyCreateWithoutAmenitiesInput, SocietyUncheckedCreateWithoutAmenitiesInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutAmenitiesInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutAmenitiesInput, SocietyUncheckedUpdateWithoutAmenitiesInput>
  }

  export type SocietyUpdateWithoutAmenitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutAmenitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
    platformInvoices?: PlatformInvoiceUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type AmenityBookingUpsertWithWhereUniqueWithoutAmenityInput = {
    where: AmenityBookingWhereUniqueInput
    update: XOR<AmenityBookingUpdateWithoutAmenityInput, AmenityBookingUncheckedUpdateWithoutAmenityInput>
    create: XOR<AmenityBookingCreateWithoutAmenityInput, AmenityBookingUncheckedCreateWithoutAmenityInput>
  }

  export type AmenityBookingUpdateWithWhereUniqueWithoutAmenityInput = {
    where: AmenityBookingWhereUniqueInput
    data: XOR<AmenityBookingUpdateWithoutAmenityInput, AmenityBookingUncheckedUpdateWithoutAmenityInput>
  }

  export type AmenityBookingUpdateManyWithWhereWithoutAmenityInput = {
    where: AmenityBookingScalarWhereInput
    data: XOR<AmenityBookingUpdateManyMutationInput, AmenityBookingUncheckedUpdateManyWithoutAmenityInput>
  }

  export type AmenityCreateWithoutBookingsInput = {
    name: string
    description?: string | null
    chargesPerHour?: number
    createdAt?: Date | string
    society: SocietyCreateNestedOneWithoutAmenitiesInput
  }

  export type AmenityUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    description?: string | null
    chargesPerHour?: number
    societyId: number
    createdAt?: Date | string
  }

  export type AmenityCreateOrConnectWithoutBookingsInput = {
    where: AmenityWhereUniqueInput
    create: XOR<AmenityCreateWithoutBookingsInput, AmenityUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutBookingsInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    society?: SocietyCreateNestedOneWithoutUsersInput
    ownedUnits?: UnitCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintCreateNestedManyWithoutAssignedToInput
    comments?: ComplaintCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    societyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedUnits?: UnitUncheckedCreateNestedManyWithoutOwnerInput
    rentedUnits?: UnitUncheckedCreateNestedManyWithoutTenantInput
    reportedComplaints?: ComplaintUncheckedCreateNestedManyWithoutReportedByInput
    assignedComplaints?: ComplaintUncheckedCreateNestedManyWithoutAssignedToInput
    comments?: ComplaintCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type AmenityUpsertWithoutBookingsInput = {
    update: XOR<AmenityUpdateWithoutBookingsInput, AmenityUncheckedUpdateWithoutBookingsInput>
    create: XOR<AmenityCreateWithoutBookingsInput, AmenityUncheckedCreateWithoutBookingsInput>
    where?: AmenityWhereInput
  }

  export type AmenityUpdateToOneWithWhereWithoutBookingsInput = {
    where?: AmenityWhereInput
    data: XOR<AmenityUpdateWithoutBookingsInput, AmenityUncheckedUpdateWithoutBookingsInput>
  }

  export type AmenityUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutAmenitiesNestedInput
  }

  export type AmenityUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneWithoutUsersNestedInput
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SocietyCreateWithoutPlatformInvoicesInput = {
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSocietyInput
    units?: UnitCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintCreateNestedManyWithoutSocietyInput
    visitors?: VisitorCreateNestedManyWithoutSocietyInput
    transactions?: TransactionCreateNestedManyWithoutSocietyInput
    notices?: NoticeCreateNestedManyWithoutSocietyInput
    vendors?: VendorCreateNestedManyWithoutSocietyInput
    amenities?: AmenityCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutSocietyInput
  }

  export type SocietyUncheckedCreateWithoutPlatformInvoicesInput = {
    id?: number
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    code: string
    status?: $Enums.SocietyStatus
    subscriptionPlan?: $Enums.SubscriptionPlan
    expectedUnits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSocietyInput
    units?: UnitUncheckedCreateNestedManyWithoutSocietyInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutSocietyInput
    visitors?: VisitorUncheckedCreateNestedManyWithoutSocietyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSocietyInput
    notices?: NoticeUncheckedCreateNestedManyWithoutSocietyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutSocietyInput
    amenities?: AmenityUncheckedCreateNestedManyWithoutSocietyInput
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutSocietyInput
  }

  export type SocietyCreateOrConnectWithoutPlatformInvoicesInput = {
    where: SocietyWhereUniqueInput
    create: XOR<SocietyCreateWithoutPlatformInvoicesInput, SocietyUncheckedCreateWithoutPlatformInvoicesInput>
  }

  export type SocietyUpsertWithoutPlatformInvoicesInput = {
    update: XOR<SocietyUpdateWithoutPlatformInvoicesInput, SocietyUncheckedUpdateWithoutPlatformInvoicesInput>
    create: XOR<SocietyCreateWithoutPlatformInvoicesInput, SocietyUncheckedCreateWithoutPlatformInvoicesInput>
    where?: SocietyWhereInput
  }

  export type SocietyUpdateToOneWithWhereWithoutPlatformInvoicesInput = {
    where?: SocietyWhereInput
    data: XOR<SocietyUpdateWithoutPlatformInvoicesInput, SocietyUncheckedUpdateWithoutPlatformInvoicesInput>
  }

  export type SocietyUpdateWithoutPlatformInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSocietyNestedInput
    units?: UnitUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutSocietyNestedInput
  }

  export type SocietyUncheckedUpdateWithoutPlatformInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumSocietyStatusFieldUpdateOperationsInput | $Enums.SocietyStatus
    subscriptionPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    expectedUnits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSocietyNestedInput
    units?: UnitUncheckedUpdateManyWithoutSocietyNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutSocietyNestedInput
    visitors?: VisitorUncheckedUpdateManyWithoutSocietyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSocietyNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutSocietyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutSocietyNestedInput
    amenities?: AmenityUncheckedUpdateManyWithoutSocietyNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutSocietyNestedInput
  }

  export type UserCreateManySocietyInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    profileImg?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitCreateManySocietyInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    ownerId?: number | null
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintCreateManySocietyInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    reportedById: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorCreateManySocietyInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    visitingUnitId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManySocietyInput = {
    id?: number
    type: $Enums.TransactionType
    category: string
    amount: number
    date: Date | string
    description?: string | null
    paymentMethod: $Enums.PaymentMethod
    status: string
    invoiceNo?: string | null
    paidTo?: string | null
    receivedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoticeCreateManySocietyInput = {
    id?: number
    title: string
    content: string
    audience: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type VendorCreateManySocietyInput = {
    id?: number
    name: string
    serviceType: string
    contact: string
    email?: string | null
    address?: string | null
    status?: $Enums.VendorStatus
    createdAt?: Date | string
  }

  export type AmenityCreateManySocietyInput = {
    id?: number
    name: string
    description?: string | null
    chargesPerHour?: number
    createdAt?: Date | string
  }

  export type ParkingSlotCreateManySocietyInput = {
    id?: number
    number: string
    type: string
    status: string
    allocatedToUnitId?: number | null
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type PlatformInvoiceCreateManySocietyInput = {
    id?: number
    invoiceNo: string
    amount: number
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutSocietyInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedUnits?: UnitUncheckedUpdateManyWithoutOwnerNestedInput
    rentedUnits?: UnitUncheckedUpdateManyWithoutTenantNestedInput
    reportedComplaints?: ComplaintUncheckedUpdateManyWithoutReportedByNestedInput
    assignedComplaints?: ComplaintUncheckedUpdateManyWithoutAssignedToNestedInput
    bookings?: AmenityBookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: ComplaintCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    profileImg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpdateWithoutSocietyInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUpdateWithoutSocietyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: UserUpdateOneRequiredWithoutReportedComplaintsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedComplaintsNestedInput
    comments?: ComplaintCommentUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    reportedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ComplaintCommentUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    reportedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUpdateWithoutSocietyInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitingUnitId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitingUnitId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutSocietyInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    invoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeUpdateWithoutSocietyInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoticeUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoticeUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VendorUpdateWithoutSocietyInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payouts?: VendorPayoutUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payouts?: VendorPayoutUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityUpdateWithoutSocietyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: AmenityBookingUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: AmenityBookingUncheckedUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chargesPerHour?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotUpdateWithoutSocietyInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneWithoutParkingSlotsNestedInput
  }

  export type ParkingSlotUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    allocatedToUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    allocatedToUnitId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformInvoiceUpdateWithoutSocietyInput = {
    invoiceNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformInvoiceUncheckedUpdateWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformInvoiceUncheckedUpdateManyWithoutSocietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateManyOwnerInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    tenantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitCreateManyTenantInput = {
    id?: number
    block: string
    number: string
    floor: number
    type: string
    areaSqFt: number
    societyId: number
    ownerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintCreateManyReportedByInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    assignedToId?: number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintCreateManyAssignedToInput = {
    id?: number
    title: string
    description: string
    category: string
    priority?: $Enums.Priority
    status?: $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId: number
    reportedById: number
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenityBookingCreateManyUserInput = {
    id?: number
    amenityId: number
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
  }

  export type ComplaintCommentCreateManyUserInput = {
    id?: number
    complaintId: number
    message: string
    createdAt?: Date | string
  }

  export type UnitUpdateWithoutOwnerInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    tenant?: UserUpdateOneWithoutRentedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpdateWithoutTenantInput = {
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutUnitsNestedInput
    owner?: UserUpdateOneWithoutOwnedUnitsNestedInput
    visitors?: VisitorUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitors?: VisitorUncheckedUpdateManyWithoutUnitNestedInput
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    block?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    areaSqFt?: FloatFieldUpdateOperationsInput | number
    societyId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUpdateWithoutReportedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutComplaintsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedComplaintsNestedInput
    comments?: ComplaintCommentUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutReportedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ComplaintCommentUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateManyWithoutReportedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUpdateWithoutAssignedToInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutComplaintsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutReportedComplaintsNestedInput
    comments?: ComplaintCommentUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ComplaintCommentUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateManyWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: NullableJsonNullValueInput | InputJsonValue
    societyId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    timeline?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingUpdateWithoutUserInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenity?: AmenityUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type AmenityBookingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentUpdateWithoutUserInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint?: ComplaintUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ComplaintCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaintId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaintId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorCreateManyUnitInput = {
    id?: number
    name: string
    phone: string
    vehicleNo?: string | null
    purpose: string
    photo?: string | null
    status?: $Enums.VisitorStatus
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    societyId: number
    idType?: string | null
    idNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParkingSlotCreateManyUnitInput = {
    id?: number
    number: string
    type: string
    status: string
    societyId: number
    vehicleNumber?: string | null
    createdAt?: Date | string
  }

  export type VisitorUpdateWithoutUnitInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutVisitorsNestedInput
  }

  export type VisitorUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVisitorStatusFieldUpdateOperationsInput | $Enums.VisitorStatus
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    societyId?: IntFieldUpdateOperationsInput | number
    idType?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotUpdateWithoutUnitInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    society?: SocietyUpdateOneRequiredWithoutParkingSlotsNestedInput
  }

  export type ParkingSlotUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingSlotUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    societyId?: IntFieldUpdateOperationsInput | number
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentCreateManyComplaintInput = {
    id?: number
    userId: number
    message: string
    createdAt?: Date | string
  }

  export type ComplaintCommentUpdateWithoutComplaintInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ComplaintCommentUncheckedUpdateWithoutComplaintInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCommentUncheckedUpdateManyWithoutComplaintInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPayoutCreateManyVendorInput = {
    id?: number
    vendorName: string
    societyId?: number | null
    societyName?: string | null
    dealValue: number
    commissionPercent: number
    payableAmount: number
    status?: string
    remarks?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorPayoutUpdateWithoutVendorInput = {
    vendorName?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    societyName?: NullableStringFieldUpdateOperationsInput | string | null
    dealValue?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    payableAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPayoutUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorName?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    societyName?: NullableStringFieldUpdateOperationsInput | string | null
    dealValue?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    payableAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPayoutUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorName?: StringFieldUpdateOperationsInput | string
    societyId?: NullableIntFieldUpdateOperationsInput | number | null
    societyName?: NullableStringFieldUpdateOperationsInput | string | null
    dealValue?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    payableAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceVariantCreateManyCategoryInput = {
    id?: string
    name: string
    price: string
    description?: string | null
  }

  export type ServiceVariantUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceVariantUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceVariantUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AmenityBookingCreateManyAmenityInput = {
    id?: number
    userId: number
    startTime: Date | string
    endTime: Date | string
    status: string
    amountPaid?: number
    createdAt?: Date | string
  }

  export type AmenityBookingUpdateWithoutAmenityInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type AmenityBookingUncheckedUpdateWithoutAmenityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityBookingUncheckedUpdateManyWithoutAmenityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}